
#ifndef __RNA_BLENDER_CPP_H__
#define __RNA_BLENDER_CPP_H__

/* Automatically generated classes for the Data API.
 * Do not edit manually, changes will be overwritten. */

#include "RNA_blender.h"
#include "RNA_types.hh"
#include "RNA_access.hh"
#include "DNA_node_types.h"

#include <stdlib.h> /* for malloc */
#include <string>
#include <string.h> /* for memcpy */

namespace BL {

#define BOOLEAN_PROPERTY(sname, identifier) \
    inline bool sname::identifier(void) { return sname##_##identifier##_get(&ptr) ? true: false; } \
    inline void sname::identifier(bool value) { sname##_##identifier##_set(&ptr, value); }

#define BOOLEAN_ARRAY_PROPERTY(sname, size, identifier) \
    inline Array<bool, size> sname::identifier(void) \
        { Array<bool, size> ar; sname##_##identifier##_get(&ptr, ar.data); return ar; } \
    inline void sname::identifier(bool values[size]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define BOOLEAN_DYNAMIC_ARRAY_PROPERTY(sname, identifier) \
    inline DynamicArray<bool> sname::identifier(void) { \
        int arraylen[3]; \
        int len = sname##_##identifier##_get_length(&ptr, arraylen); \
        DynamicArray<bool> ar(len); \
        sname##_##identifier##_get(&ptr, ar.data); \
        return ar; } \
    inline void sname::identifier(bool values[]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define INT_PROPERTY(sname, identifier) \
    inline int sname::identifier(void) { return sname##_##identifier##_get(&ptr); } \
    inline void sname::identifier(int value) { sname##_##identifier##_set(&ptr, value); }

#define INT_ARRAY_PROPERTY(sname, size, identifier) \
    inline Array<int, size> sname::identifier(void) \
        { Array<int, size> ar; sname##_##identifier##_get(&ptr, ar.data); return ar; } \
    inline void sname::identifier(int values[size]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define INT_DYNAMIC_ARRAY_PROPERTY(sname, identifier) \
    inline DynamicArray<int> sname::identifier(void) { \
        int arraylen[3]; \
        int len = sname##_##identifier##_get_length(&ptr, arraylen); \
        DynamicArray<int> ar(len); \
        sname##_##identifier##_get(&ptr, ar.data); \
        return ar; } \
    inline void sname::identifier(int values[]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define FLOAT_PROPERTY(sname, identifier) \
    inline float sname::identifier(void) { return sname##_##identifier##_get(&ptr); } \
    inline void sname::identifier(float value) { sname##_##identifier##_set(&ptr, value); }

#define FLOAT_ARRAY_PROPERTY(sname, size, identifier) \
    inline Array<float, size> sname::identifier(void) \
        { Array<float, size> ar; sname##_##identifier##_get(&ptr, ar.data); return ar; } \
    inline void sname::identifier(float values[size]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define FLOAT_DYNAMIC_ARRAY_PROPERTY(sname, identifier) \
    inline DynamicArray<float> sname::identifier(void) { \
        int arraylen[3]; \
        int len = sname##_##identifier##_get_length(&ptr, arraylen); \
        DynamicArray<float> ar(len); \
        sname##_##identifier##_get(&ptr, ar.data); \
        return ar; } \
    inline void sname::identifier(float values[]) \
        { sname##_##identifier##_set(&ptr, values); } \

#define ENUM_PROPERTY(type, sname, identifier) \
    inline sname::type sname::identifier(void) { return (type)sname##_##identifier##_get(&ptr); } \
    inline void sname::identifier(sname::type value) { sname##_##identifier##_set(&ptr, value); }

#define STRING_PROPERTY(sname, identifier) \
    inline std::string sname::identifier(void) { \
        int len = sname##_##identifier##_length(&ptr); \
        std::string str; str.resize(len); \
        sname##_##identifier##_get(&ptr, &str[0]); return str; } \
    inline void sname::identifier(const std::string& value) { \
        sname##_##identifier##_set(&ptr, value.c_str()); } \

#define POINTER_PROPERTY(type, sname, identifier) \
    inline type sname::identifier(void) { return type(sname##_##identifier##_get(&ptr)); }

#define COLLECTION_PROPERTY_LENGTH_false(sname, identifier) \
    inline static int sname##_##identifier##_length_wrap(PointerRNA *ptr) \
    { \
        CollectionPropertyIterator iter; \
        int length = 0; \
        sname##_##identifier##_begin(&iter, ptr); \
        while (iter.valid) { \
            sname##_##identifier##_next(&iter); \
            ++length; \
        } \
        sname##_##identifier##_end(&iter); \
        return length; \
    } 
#define COLLECTION_PROPERTY_LENGTH_true(sname, identifier) \
    inline static int sname##_##identifier##_length_wrap(PointerRNA *ptr) \
    { return sname##_##identifier##_length(ptr); } 

#define COLLECTION_PROPERTY_EMPTY_false(sname, identifier) \
    inline static bool sname##_##identifier##_empty_wrap(PointerRNA *ptr) \
    { \
        CollectionPropertyIterator iter; \
        sname##_##identifier##_begin(&iter, ptr); \
        bool empty = !iter.valid; \
        sname##_##identifier##_end(&iter); \
        return empty; \
    } 
#define COLLECTION_PROPERTY_EMPTY_true(sname, identifier) \
    inline static bool sname##_##identifier##_empty_wrap(PointerRNA *ptr) \
    { return sname##_##identifier##_length(ptr) == 0; } 

#define COLLECTION_PROPERTY_LOOKUP_INT_false(sname, identifier) \
    inline static int sname##_##identifier##_lookup_int_wrap(PointerRNA *ptr, int key, PointerRNA *r_ptr) \
    { \
        CollectionPropertyIterator iter; \
        int i = 0, found = 0; \
        sname##_##identifier##_begin(&iter, ptr); \
        while (iter.valid) { \
            if (i == key) { \
                *r_ptr = iter.ptr; \
                found = 1; \
                break; \
            } \
            sname##_##identifier##_next(&iter); \
            ++i; \
        } \
        sname##_##identifier##_end(&iter); \
        if (!found) { \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        } \
        return found; \
    } 
#define COLLECTION_PROPERTY_LOOKUP_INT_true(sname, identifier) \
    inline static int sname##_##identifier##_lookup_int_wrap(PointerRNA *ptr, int key, PointerRNA *r_ptr) \
    { \
        int found = sname##_##identifier##_lookup_int(ptr, key, r_ptr); \
        if (!found) { \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        } \
        return found; \
    } 
#define COLLECTION_PROPERTY_LOOKUP_STRING_false(sname, identifier) \
    inline static int sname##_##identifier##_lookup_string_wrap(PointerRNA *ptr, const char *key, PointerRNA *r_ptr) \
    { \
        CollectionPropertyIterator iter; \
        int found = 0; \
        PropertyRNA *item_name_prop = RNA_struct_name_property(ptr->type); \
        sname##_##identifier##_begin(&iter, ptr); \
        while (iter.valid && !found) { \
            char name_fixed[32]; \
            const char *name; \
            int name_length; \
            name = RNA_property_string_get_alloc(&iter.ptr, item_name_prop, name_fixed, sizeof(name_fixed), &name_length); \
            if (!strncmp(name, key, name_length)) { \
                *r_ptr = iter.ptr; \
                found = 1; \
            } \
            if (name_fixed != name) { \
                MEM_freeN((void *) name); \
            } \
            sname##_##identifier##_next(&iter); \
        } \
        sname##_##identifier##_end(&iter); \
        if (!found) { \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        } \
        return found; \
    } 
#define COLLECTION_PROPERTY_LOOKUP_STRING_true(sname, identifier) \
    inline static int sname##_##identifier##_lookup_string_wrap(PointerRNA *ptr, const char *key, PointerRNA *r_ptr) \
    { \
        int found = sname##_##identifier##_lookup_string(ptr, key, r_ptr); \
        if (!found) { \
            memset(r_ptr, 0, sizeof(*r_ptr)); \
        } \
        return found; \
    } 
#define COLLECTION_PROPERTY(collection_funcs, type, sname, identifier, has_length, has_lookup_int, has_lookup_string) \
    typedef CollectionIterator<type, sname##_##identifier##_begin, \
        sname##_##identifier##_next, sname##_##identifier##_end> identifier##_iterator; \
    COLLECTION_PROPERTY_LENGTH_##has_length(sname, identifier) \
    COLLECTION_PROPERTY_EMPTY_##has_length(sname, identifier) \
    COLLECTION_PROPERTY_LOOKUP_INT_##has_lookup_int(sname, identifier) \
    COLLECTION_PROPERTY_LOOKUP_STRING_##has_lookup_string(sname, identifier) \
    CollectionRef<sname, type, sname##_##identifier##_begin, \
        sname##_##identifier##_next, sname##_##identifier##_end, \
        sname##_##identifier##_length_wrap, \
        sname##_##identifier##_empty_wrap, \
        sname##_##identifier##_lookup_int_wrap, sname##_##identifier##_lookup_string_wrap, collection_funcs> identifier;

class Pointer {
public:
    Pointer(const PointerRNA &p) : ptr(p) { }
    operator const PointerRNA&() { return ptr; }
    bool is_a(StructRNA *type) { return RNA_struct_is_a(ptr.type, type) ? true: false; }
    operator void*() { return ptr.data; }
    operator bool() const { return ptr.data != nullptr; }

    bool operator==(const Pointer &other) const { return ptr.data == other.ptr.data; }
    bool operator!=(const Pointer &other) const { return ptr.data != other.ptr.data; }
    bool operator<(const Pointer &other) const { return ptr.data < other.ptr.data; }

    PointerRNA ptr;
};


template<typename T, int Tsize>
class Array {
public:
    T data[Tsize];

    Array() {}
    Array(const Array<T, Tsize>& other) { memcpy(data, other.data, sizeof(T) * Tsize); }
    const Array<T, Tsize>& operator = (const Array<T, Tsize>& other) { memcpy(data, other.data, sizeof(T) * Tsize); return *this; }

    operator T*() { return data; }
    operator const T*() const { return data; }
};

template<typename T>
class DynamicArray {
public:
    T *data;
    int length;

    DynamicArray() : data(nullptr), length(0) {}
    DynamicArray(int new_length) : data(nullptr), length(new_length) { data = (T *)malloc(sizeof(T) * new_length); }
    DynamicArray(const DynamicArray<T>& other) : data(nullptr), length(0) { copy_from(other); }
    const DynamicArray<T>& operator = (const DynamicArray<T>& other) { copy_from(other); return *this; }

    ~DynamicArray() { if (data) free(data); }

    operator T*() { return data; }

protected:
    void copy_from(const DynamicArray<T>& other) {
        if (data) free(data);
        data = (T *)malloc(sizeof(T) * other.length);
        memcpy(data, other.data, sizeof(T) * other.length);
        length = other.length;
    }
};

typedef void (*TBeginFunc)(CollectionPropertyIterator *iter, PointerRNA *ptr);
typedef void (*TNextFunc)(CollectionPropertyIterator *iter);
typedef void (*TEndFunc)(CollectionPropertyIterator *iter);
typedef int (*TLengthFunc)(PointerRNA *ptr);
typedef bool (*TEmptyFunc)(PointerRNA *ptr);
typedef int (*TLookupIntFunc)(PointerRNA *ptr, int key, PointerRNA *r_ptr);
typedef int (*TLookupStringFunc)(PointerRNA *ptr, const char *key, PointerRNA *r_ptr);

template<typename T, TBeginFunc Tbegin, TNextFunc Tnext, TEndFunc Tend>
class CollectionIterator {
public:
    CollectionIterator() : iter(), t(iter.ptr), init(false) { iter.valid = false; }
    CollectionIterator(const PointerRNA &ptr) : CollectionIterator() { this->begin(ptr); }
    ~CollectionIterator(void) { if (init) Tend(&iter); };

    CollectionIterator(const CollectionIterator &other) = delete;
    CollectionIterator(CollectionIterator &&other) = delete;
    CollectionIterator &operator=(const CollectionIterator &other) = delete;
    CollectionIterator &operator=(CollectionIterator &&other) = delete;

    operator bool(void) const
    { return iter.valid != 0; }
    const CollectionIterator<T, Tbegin, Tnext, Tend>& operator++() { Tnext(&iter); t = T(iter.ptr); return *this; }

    T& operator*(void) { return t; }
    T* operator->(void) { return &t; }
    bool operator == (const CollectionIterator<T, Tbegin, Tnext, Tend>& other) { return iter.valid == other.iter.valid; }
    bool operator!=(const CollectionIterator<T, Tbegin, Tnext, Tend>& other) { return iter.valid != other.iter.valid; }

    void begin(const Pointer &ptr)
    { if (init) Tend(&iter); Tbegin(&iter, (PointerRNA *)&ptr.ptr); t = T(iter.ptr); init = true; }

private:
    CollectionPropertyIterator iter;
    T t;
    bool init;
};

template<typename Tp, typename T, TBeginFunc Tbegin, TNextFunc Tnext, TEndFunc Tend,
         TLengthFunc Tlength, TEmptyFunc Tempty, TLookupIntFunc Tlookup_int,
         TLookupStringFunc Tlookup_string, typename Tcollection_funcs>
class CollectionRef : public Tcollection_funcs {
public:
    CollectionRef(const PointerRNA &p) : Tcollection_funcs(p), ptr(p) {}

    void begin(CollectionIterator<T, Tbegin, Tnext, Tend>& iter)
    { iter.begin(ptr); }
    CollectionIterator<T, Tbegin, Tnext, Tend> begin()
    { return CollectionIterator<T, Tbegin, Tnext, Tend>(ptr); }
    CollectionIterator<T, Tbegin, Tnext, Tend> end()
    { return CollectionIterator<T, Tbegin, Tnext, Tend>(); } /* test */ 
    int length()
    { return Tlength(&ptr); }
    bool empty()
    { return Tempty(&ptr); }
    T operator[](int key)
    { PointerRNA r_ptr; Tlookup_int(&ptr, key, &r_ptr); return T(r_ptr); }
    T operator[](const std::string &key)
    { PointerRNA r_ptr; Tlookup_string(&ptr, key.c_str(), &r_ptr); return T(r_ptr); }

private:
    PointerRNA ptr;
};

class DefaultCollectionFunctions {
public:
    DefaultCollectionFunctions(const PointerRNA & /*p*/) {}
};


/**************** Declarations ****************/

class Struct;
class Property;
class BoolProperty;
class IntProperty;
class FloatProperty;
class StringProperty;
class EnumProperty;
class EnumPropertyItem;
class PointerProperty;
class CollectionProperty;
class Function;
class BlenderRNA;
class PrimitiveString;
class PrimitiveInt;
class PrimitiveFloat;
class PrimitiveBoolean;
class UnknownType;
class AnyType;
class ID;
class IDOverrideLibrary;
class IDOverrideLibraryProperties;
class IDOverrideLibraryProperty;
class IDOverrideLibraryPropertyOperations;
class IDOverrideLibraryPropertyOperation;
class ImagePreview;
class PropertyGroupItem;
class PropertyGroup;
class IDMaterials;
class Library;
class LibraryWeakReference;
class IDPropertyWrapPtr;
class Texture;
class CloudsTexture;
class WoodTexture;
class MarbleTexture;
class MagicTexture;
class BlendTexture;
class StucciTexture;
class NoiseTexture;
class ImageTexture;
class MusgraveTexture;
class VoronoiTexture;
class DistortedNoiseTexture;
class TextureSlot;
class TexMapping;
class ColorMapping;
class Action;
class ActionFCurves;
class ActionGroups;
class ActionPoseMarkers;
class ActionGroup;
class DopeSheet;
class AnimData;
class NlaTracks;
class AnimDataDrivers;
class KeyingSet;
class KeyingSetPaths;
class KeyingSetPath;
class KeyingSetInfo;
class AnimViz;
class AnimVizMotionPaths;
class MotionPath;
class MotionPathVert;
class BoneColor;
class BoneCollection;
class Armature;
class ArmatureBones;
class ArmatureEditBones;
class BoneCollections;
class Bone;
class BoneCollectionMemberships;
class EditBone;
class Attribute;
class FloatAttribute;
class FloatAttributeValue;
class FloatVectorAttribute;
class FloatVectorAttributeValue;
class FloatColorAttribute;
class FloatColorAttributeValue;
class ByteColorAttribute;
class ByteColorAttributeValue;
class IntAttribute;
class IntAttributeValue;
class Int2Attribute;
class Int2AttributeValue;
class QuaternionAttribute;
class QuaternionAttributeValue;
class StringAttribute;
class StringAttributeValue;
class BoolAttribute;
class BoolAttributeValue;
class Float2Attribute;
class Float2AttributeValue;
class ByteIntAttribute;
class ByteIntAttributeValue;
class AttributeGroup;
class AssetTag;
class AssetMetaData;
class AssetTags;
class AssetLibraryReference;
class AssetHandle;
class AssetRepresentation;
class AssetCatalogPath;
class BoidRule;
class BoidRuleGoal;
class BoidRuleAvoid;
class BoidRuleAvoidCollision;
class BoidRuleFollowLeader;
class BoidRuleAverageSpeed;
class BoidRuleFight;
class BoidState;
class BoidSettings;
class Brush;
class BrushCapabilities;
class BrushCapabilitiesSculpt;
class BrushCapabilitiesImagePaint;
class BrushCapabilitiesVertexPaint;
class BrushCapabilitiesWeightPaint;
class BrushGpencilSettings;
class BrushCurvesSculptSettings;
class BrushTextureSlot;
class OperatorStrokeElement;
class CacheFile;
class CacheFileLayers;
class CacheObjectPaths;
class CacheObjectPath;
class CacheFileLayer;
class Camera;
class CameraBackgroundImage;
class CameraBackgroundImages;
class CameraStereoData;
class CameraDOFSettings;
class ClothSolverResult;
class ClothSettings;
class ClothCollisionSettings;
class Collection;
class CollectionObjects;
class CollectionChildren;
class CollectionLightLinking;
class CollectionObject;
class CollectionChild;
class CurveMapPoint;
class CurveMap;
class CurveMapPoints;
class CurveMapping;
class ColorRampElement;
class ColorRamp;
class ColorRampElements;
class Histogram;
class Scopes;
class ColorManagedDisplaySettings;
class ColorManagedViewSettings;
class ColorManagedInputColorspaceSettings;
class ColorManagedSequencerColorspaceSettings;
class Constraint;
class ConstraintTarget;
class ConstraintTargetBone;
class ChildOfConstraint;
class PythonConstraint;
class ArmatureConstraint;
class ArmatureConstraintTargets;
class StretchToConstraint;
class FollowPathConstraint;
class LockedTrackConstraint;
class ActionConstraint;
class CopyScaleConstraint;
class MaintainVolumeConstraint;
class CopyLocationConstraint;
class CopyRotationConstraint;
class CopyTransformsConstraint;
class FloorConstraint;
class TrackToConstraint;
class KinematicConstraint;
class ClampToConstraint;
class LimitDistanceConstraint;
class LimitScaleConstraint;
class LimitRotationConstraint;
class LimitLocationConstraint;
class TransformConstraint;
class ShrinkwrapConstraint;
class DampedTrackConstraint;
class SplineIKConstraint;
class PivotConstraint;
class FollowTrackConstraint;
class CameraSolverConstraint;
class ObjectSolverConstraint;
class TransformCacheConstraint;
class Context;
class Curve;
class CurveSplines;
class SurfaceCurve;
class TextCurve;
class TextBox;
class TextCharacterFormat;
class SplinePoint;
class BezierSplinePoint;
class Spline;
class SplinePoints;
class SplineBezierPoints;
class DynamicPaintCanvasSettings;
class DynamicPaintSurfaces;
class DynamicPaintBrushSettings;
class DynamicPaintSurface;
class FCurve;
class FCurveKeyframePoints;
class FCurveModifiers;
class Keyframe;
class FCurveSample;
class DriverTarget;
class DriverVariable;
class Driver;
class ChannelDriverVariables;
class FModifier;
class FModifierGenerator;
class FModifierFunctionGenerator;
class FModifierEnvelope;
class FModifierEnvelopeControlPoints;
class FModifierEnvelopeControlPoint;
class FModifierCycles;
class FModifierPython;
class FModifierLimits;
class FModifierNoise;
class FModifierStepped;
class GreasePencil;
class GreasePencilLayers;
class GreasePencilGrid;
class GPencilLayer;
class GPencilFrames;
class GreasePencilMaskLayers;
class GPencilLayerMask;
class GPencilFrame;
class GPencilStrokes;
class GPencilStroke;
class GPencilStrokePoints;
class GPencilStrokePoint;
class GPencilTriangle;
class GPencilEditCurve;
class GPencilEditCurvePoint;
class GpencilVertexGroupElement;
class GreasePencilv3;
class GreasePencilv3Layers;
class GreasePencilLayer;
class GreasePencilLayerGroup;
class CurvePoint;
class CurveSlice;
class Curves;
class FloatVectorValueReadOnly;
class RenderSlot;
class UDIMTile;
class Image;
class RenderSlots;
class UDIMTiles;
class ImageUser;
class ImagePackedFile;
class Key;
class ShapeKey;
class ShapeKeyPoint;
class ShapeKeyCurvePoint;
class ShapeKeyBezierPoint;
class Light;
class PointLight;
class AreaLight;
class SpotLight;
class SunLight;
class Lattice;
class LatticePoint;
class ViewLayer;
class AOVs;
class Lightgroups;
class LayerObjects;
class FreestyleLineSet;
class FreestyleModuleSettings;
class FreestyleSettings;
class FreestyleModules;
class Linesets;
class LayerCollection;
class ObjectBase;
class LineStyleModifier;
class LineStyleColorModifier;
class LineStyleColorModifier_AlongStroke;
class LineStyleColorModifier_DistanceFromCamera;
class LineStyleColorModifier_DistanceFromObject;
class LineStyleColorModifier_Material;
class LineStyleColorModifier_Tangent;
class LineStyleColorModifier_Noise;
class LineStyleColorModifier_CreaseAngle;
class LineStyleColorModifier_Curvature_3D;
class LineStyleAlphaModifier;
class LineStyleAlphaModifier_AlongStroke;
class LineStyleAlphaModifier_DistanceFromCamera;
class LineStyleAlphaModifier_DistanceFromObject;
class LineStyleAlphaModifier_Material;
class LineStyleAlphaModifier_Tangent;
class LineStyleAlphaModifier_Noise;
class LineStyleAlphaModifier_CreaseAngle;
class LineStyleAlphaModifier_Curvature_3D;
class LineStyleThicknessModifier;
class LineStyleThicknessModifier_Tangent;
class LineStyleThicknessModifier_AlongStroke;
class LineStyleThicknessModifier_DistanceFromCamera;
class LineStyleThicknessModifier_DistanceFromObject;
class LineStyleThicknessModifier_Material;
class LineStyleThicknessModifier_Calligraphy;
class LineStyleThicknessModifier_Noise;
class LineStyleThicknessModifier_Curvature_3D;
class LineStyleThicknessModifier_CreaseAngle;
class LineStyleGeometryModifier;
class LineStyleGeometryModifier_Sampling;
class LineStyleGeometryModifier_BezierCurve;
class LineStyleGeometryModifier_SinusDisplacement;
class LineStyleGeometryModifier_SpatialNoise;
class LineStyleGeometryModifier_PerlinNoise1D;
class LineStyleGeometryModifier_PerlinNoise2D;
class LineStyleGeometryModifier_BackboneStretcher;
class LineStyleGeometryModifier_TipRemover;
class LineStyleGeometryModifier_Polygonalization;
class LineStyleGeometryModifier_GuidingLines;
class LineStyleGeometryModifier_Blueprint;
class LineStyleGeometryModifier_2DOffset;
class LineStyleGeometryModifier_2DTransform;
class LineStyleGeometryModifier_Simplification;
class FreestyleLineStyle;
class LineStyleTextureSlots;
class LineStyleColorModifiers;
class LineStyleAlphaModifiers;
class LineStyleThicknessModifiers;
class LineStyleGeometryModifiers;
class LineStyleTextureSlot;
class BlendData;
class BlendDataCameras;
class BlendDataScenes;
class BlendDataObjects;
class BlendDataMaterials;
class BlendDataNodeTrees;
class BlendDataMeshes;
class BlendDataLights;
class BlendDataLibraries;
class BlendDataScreens;
class BlendDataWindowManagers;
class BlendDataImages;
class BlendDataLattices;
class BlendDataCurves;
class BlendDataMetaBalls;
class BlendDataFonts;
class BlendDataTextures;
class BlendDataBrushes;
class BlendDataWorlds;
class BlendDataCollections;
class BlendDataTexts;
class BlendDataSpeakers;
class BlendDataSounds;
class BlendDataArmatures;
class BlendDataActions;
class BlendDataParticles;
class BlendDataPalettes;
class BlendDataGreasePencils;
class BlendDataGreasePencilsV3;
class BlendDataMovieClips;
class BlendDataMasks;
class BlendDataLineStyles;
class BlendDataCacheFiles;
class BlendDataPaintCurves;
class BlendDataWorkSpaces;
class BlendDataProbes;
class BlendDataHairCurves;
class BlendDataPointClouds;
class BlendDataVolumes;
class FluidDomainSettings;
class FluidFlowSettings;
class FluidEffectorSettings;
class Material;
class TexPaintSlot;
class MaterialGPencilStyle;
class MaterialLineArt;
class Mesh;
class MeshVertices;
class MeshEdges;
class MeshLoops;
class MeshPolygons;
class MeshNormalValue;
class MeshLoopTriangles;
class ReadOnlyInteger;
class UVLoopLayers;
class LoopColors;
class MeshSkinVertexLayer;
class MeshSkinVertex;
class MeshPaintMaskLayer;
class MeshPaintMaskProperty;
class MeshVertex;
class VertexGroupElement;
class MeshEdge;
class MeshLoopTriangle;
class MeshLoop;
class MeshPolygon;
class MeshUVLoopLayer;
class MeshUVLoop;
class MeshLoopColorLayer;
class MeshLoopColor;
class MetaElement;
class MetaBall;
class MetaBallElements;
class Modifier;
class SubsurfModifier;
class LatticeModifier;
class CurveModifier;
class BuildModifier;
class MirrorModifier;
class DecimateModifier;
class WaveModifier;
class ArmatureModifier;
class HookModifier;
class SoftBodyModifier;
class BooleanModifier;
class ArrayModifier;
class EdgeSplitModifier;
class DisplaceModifier;
class UVProjectModifier;
class UVProjector;
class SmoothModifier;
class CorrectiveSmoothModifier;
class CastModifier;
class MeshDeformModifier;
class ParticleSystemModifier;
class ParticleInstanceModifier;
class ExplodeModifier;
class ClothModifier;
class CollisionModifier;
class BevelModifier;
class ShrinkwrapModifier;
class MaskModifier;
class SimpleDeformModifier;
class WarpModifier;
class MultiresModifier;
class SurfaceModifier;
class FluidModifier;
class SolidifyModifier;
class ScrewModifier;
class UVWarpModifier;
class VertexWeightEditModifier;
class VertexWeightMixModifier;
class VertexWeightProximityModifier;
class DynamicPaintModifier;
class OceanModifier;
class RemeshModifier;
class SkinModifier;
class LaplacianSmoothModifier;
class TriangulateModifier;
class MeshCacheModifier;
class LaplacianDeformModifier;
class WeldModifier;
class WireframeModifier;
class DataTransferModifier;
class NormalEditModifier;
class MeshSequenceCacheModifier;
class SurfaceDeformModifier;
class WeightedNormalModifier;
class NodesModifierBake;
class NodesModifierBakes;
class NodesModifier;
class MeshToVolumeModifier;
class VolumeDisplaceModifier;
class VolumeToMeshModifier;
class GpencilModifier;
class NoiseGpencilModifier;
class SmoothGpencilModifier;
class SubdivGpencilModifier;
class SimplifyGpencilModifier;
class ThickGpencilModifier;
class OffsetGpencilModifier;
class TintGpencilModifier;
class TimeGpencilModifierSegment;
class TimeGpencilModifier;
class ColorGpencilModifier;
class ArrayGpencilModifier;
class BuildGpencilModifier;
class OpacityGpencilModifier;
class OutlineGpencilModifier;
class LatticeGpencilModifier;
class MirrorGpencilModifier;
class HookGpencilModifier;
class ArmatureGpencilModifier;
class MultiplyGpencilModifier;
class TextureGpencilModifier;
class WeightAngleGpencilModifier;
class WeightProxGpencilModifier;
class LineartGpencilModifier;
class LengthGpencilModifier;
class DashGpencilModifierSegment;
class DashGpencilModifierData;
class ShrinkwrapGpencilModifier;
class EnvelopeGpencilModifier;
class ShaderFx;
class ShaderFxBlur;
class ShaderFxColorize;
class ShaderFxWave;
class ShaderFxPixel;
class ShaderFxRim;
class ShaderFxShadow;
class ShaderFxGlow;
class ShaderFxSwirl;
class ShaderFxFlip;
class NlaTrack;
class NlaStrips;
class NlaStrip;
class NlaStripFCurves;
class Node;
class NodeInputs;
class NodeOutputs;
class NodeLink;
class NodeInternalSocketTemplate;
class NodeInternal;
class ShaderNode;
class CompositorNode;
class CryptomatteEntry;
class TextureNode;
class GeometryNode;
class FunctionNode;
class NodeTree;
class Nodes;
class NodeLinks;
class CompositorNodeTree;
class ShaderNodeTree;
class TextureNodeTree;
class GeometryNodeTree;
class SimulationStateItem;
class RepeatItem;
class NodeFrame;
class NodeGroup;
class NodeGroupInput;
class NodeGroupOutput;
class NodeReroute;
class ShaderNodeRGB;
class ShaderNodeValue;
class ShaderNodeMixRGB;
class ShaderNodeValToRGB;
class ShaderNodeRGBToBW;
class ShaderNodeShaderToRGB;
class ShaderNodeNormal;
class ShaderNodeGamma;
class ShaderNodeBrightContrast;
class ShaderNodeMapping;
class ShaderNodeVectorCurve;
class ShaderNodeRGBCurve;
class ShaderNodeCameraData;
class ShaderNodeMapRange;
class ShaderNodeClamp;
class ShaderNodeMath;
class ShaderNodeVectorMath;
class ShaderNodeSqueeze;
class ShaderNodeInvert;
class ShaderNodeSeparateRGB;
class ShaderNodeCombineRGB;
class ShaderNodeHueSaturation;
class ShaderNodeOutputMaterial;
class ShaderNodeEeveeSpecular;
class ShaderNodeOutputLight;
class ShaderNodeOutputWorld;
class ShaderNodeOutputLineStyle;
class ShaderNodeFresnel;
class ShaderNodeLayerWeight;
class ShaderNodeMixShader;
class ShaderNodeAddShader;
class ShaderNodeAttribute;
class ShaderNodeAmbientOcclusion;
class ShaderNodeBackground;
class ShaderNodeHoldout;
class ShaderNodeBsdfDiffuse;
class ShaderNodeBsdfPrincipled;
class ShaderNodeBsdfAnisotropic;
class ShaderNodeBsdfGlass;
class ShaderNodeBsdfRefraction;
class ShaderNodeBsdfTranslucent;
class ShaderNodeBsdfTransparent;
class ShaderNodeBsdfSheen;
class ShaderNodeBsdfToon;
class ShaderNodeBsdfHair;
class ShaderNodeBsdfHairPrincipled;
class ShaderNodeSubsurfaceScattering;
class ShaderNodeVolumeAbsorption;
class ShaderNodeVolumeScatter;
class ShaderNodeVolumePrincipled;
class ShaderNodeEmission;
class ShaderNodeNewGeometry;
class ShaderNodeLightPath;
class ShaderNodeLightFalloff;
class ShaderNodeObjectInfo;
class ShaderNodeParticleInfo;
class ShaderNodeHairInfo;
class ShaderNodePointInfo;
class ShaderNodeVolumeInfo;
class ShaderNodeWireframe;
class ShaderNodeWavelength;
class ShaderNodeBlackbody;
class ShaderNodeBump;
class ShaderNodeNormalMap;
class ShaderNodeTangent;
class ShaderNodeScript;
class ShaderNodeTexImage;
class ShaderNodeTexEnvironment;
class ShaderNodeTexSky;
class ShaderNodeTexGradient;
class ShaderNodeTexNoise;
class ShaderNodeTexMagic;
class ShaderNodeTexWave;
class ShaderNodeTexMusgrave;
class ShaderNodeTexVoronoi;
class ShaderNodeTexChecker;
class ShaderNodeTexBrick;
class ShaderNodeTexPointDensity;
class ShaderNodeTexCoord;
class ShaderNodeVectorRotate;
class ShaderNodeVectorTransform;
class ShaderNodeSeparateHSV;
class ShaderNodeCombineHSV;
class ShaderNodeUVMap;
class ShaderNodeVertexColor;
class ShaderNodeUVAlongStroke;
class ShaderNodeSeparateXYZ;
class ShaderNodeCombineXYZ;
class ShaderNodeBevel;
class ShaderNodeDisplacement;
class ShaderNodeVectorDisplacement;
class ShaderNodeTexIES;
class ShaderNodeTexWhiteNoise;
class ShaderNodeOutputAOV;
class ShaderNodeFloatCurve;
class ShaderNodeCombineColor;
class ShaderNodeSeparateColor;
class ShaderNodeMix;
class CompositorNodeViewer;
class CompositorNodeRGB;
class CompositorNodeValue;
class CompositorNodeMixRGB;
class CompositorNodeValToRGB;
class CompositorNodeRGBToBW;
class CompositorNodeNormal;
class CompositorNodeCurveVec;
class CompositorNodeCurveRGB;
class CompositorNodeAlphaOver;
class CompositorNodeBlur;
class CompositorNodeFilter;
class CompositorNodeMapValue;
class CompositorNodeMapRange;
class CompositorNodeTime;
class CompositorNodeVecBlur;
class CompositorNodeSepRGBA;
class CompositorNodeSepHSVA;
class CompositorNodeSetAlpha;
class CompositorNodeHueSat;
class CompositorNodeImage;
class CompositorNodeRLayers;
class CompositorNodeComposite;
class CompositorNodeOutputFile;
class CompositorNodeOutputFileFileSlots;
class CompositorNodeOutputFileLayerSlots;
class CompositorNodeTexture;
class CompositorNodeTranslate;
class CompositorNodeZcombine;
class CompositorNodeCombRGBA;
class CompositorNodeDilateErode;
class CompositorNodeInpaint;
class CompositorNodeDespeckle;
class CompositorNodeRotate;
class CompositorNodeScale;
class CompositorNodeSepYCCA;
class CompositorNodeCombYCCA;
class CompositorNodeSepYUVA;
class CompositorNodeCombYUVA;
class CompositorNodeDiffMatte;
class CompositorNodeColorSpill;
class CompositorNodeChromaMatte;
class CompositorNodeChannelMatte;
class CompositorNodeFlip;
class CompositorNodeSplitViewer;
class CompositorNodeMapUV;
class CompositorNodeIDMask;
class CompositorNodeDoubleEdgeMask;
class CompositorNodeDefocus;
class CompositorNodeDisplace;
class CompositorNodeCombHSVA;
class CompositorNodeMath;
class CompositorNodeLumaMatte;
class CompositorNodeBrightContrast;
class CompositorNodeGamma;
class CompositorNodeInvert;
class CompositorNodeNormalize;
class CompositorNodeCrop;
class CompositorNodeDBlur;
class CompositorNodeBilateralblur;
class CompositorNodePremulKey;
class CompositorNodeGlare;
class CompositorNodeTonemap;
class CompositorNodeLensdist;
class CompositorNodeLevels;
class CompositorNodeColorMatte;
class CompositorNodeDistanceMatte;
class CompositorNodeColorBalance;
class CompositorNodeHueCorrect;
class CompositorNodeMovieClip;
class CompositorNodeTransform;
class CompositorNodeStabilize;
class CompositorNodeMovieDistortion;
class CompositorNodeBoxMask;
class CompositorNodeEllipseMask;
class CompositorNodeBokehImage;
class CompositorNodeBokehBlur;
class CompositorNodeSwitch;
class CompositorNodeSwitchView;
class CompositorNodeColorCorrection;
class CompositorNodeMask;
class CompositorNodeKeyingScreen;
class CompositorNodeKeying;
class CompositorNodeTrackPos;
class CompositorNodePixelate;
class CompositorNodePlaneTrackDeform;
class CompositorNodeCornerPin;
class CompositorNodeSunBeams;
class CompositorNodeCryptomatteV2;
class CompositorNodeCryptomatte;
class CompositorNodeDenoise;
class CompositorNodeExposure;
class CompositorNodeAntiAliasing;
class CompositorNodePosterize;
class CompositorNodeConvertColorSpace;
class CompositorNodeSceneTime;
class CompositorNodeCombineXYZ;
class CompositorNodeSeparateXYZ;
class CompositorNodeSeparateColor;
class CompositorNodeCombineColor;
class CompositorNodeKuwahara;
class TextureNodeOutput;
class TextureNodeChecker;
class TextureNodeTexture;
class TextureNodeBricks;
class TextureNodeMath;
class TextureNodeMixRGB;
class TextureNodeRGBToBW;
class TextureNodeValToRGB;
class TextureNodeImage;
class TextureNodeCurveRGB;
class TextureNodeInvert;
class TextureNodeHueSaturation;
class TextureNodeCurveTime;
class TextureNodeRotate;
class TextureNodeViewer;
class TextureNodeTranslate;
class TextureNodeCoordinates;
class TextureNodeDistance;
class TextureNodeCompose;
class TextureNodeDecompose;
class TextureNodeValToNor;
class TextureNodeScale;
class TextureNodeAt;
class TextureNodeCombineColor;
class TextureNodeSeparateColor;
class TextureNodeTexVoronoi;
class TextureNodeTexBlend;
class TextureNodeTexMagic;
class TextureNodeTexMarble;
class TextureNodeTexClouds;
class TextureNodeTexWood;
class TextureNodeTexMusgrave;
class TextureNodeTexNoise;
class TextureNodeTexStucci;
class TextureNodeTexDistNoise;
class FunctionNodeAlignEulerToVector;
class FunctionNodeAxisAngleToRotation;
class FunctionNodeBooleanMath;
class FunctionNodeCombineColor;
class FunctionNodeQuaternionToRotation;
class FunctionNodeCompare;
class FunctionNodeEulerToRotation;
class FunctionNodeFloatToInt;
class FunctionNodeInputBool;
class FunctionNodeInputColor;
class FunctionNodeInputInt;
class FunctionNodeInputSpecialCharacters;
class FunctionNodeInputString;
class FunctionNodeInputVector;
class FunctionNodeInvertRotation;
class FunctionNodeRandomValue;
class FunctionNodeReplaceString;
class FunctionNodeRotateEuler;
class FunctionNodeRotateVector;
class FunctionNodeRotationToAxisAngle;
class FunctionNodeRotationToEuler;
class FunctionNodeSeparateColor;
class FunctionNodeRotationToQuaternion;
class FunctionNodeSliceString;
class FunctionNodeStringLength;
class FunctionNodeValueToString;
class GeometryNodeAccumulateField;
class GeometryNodeAttributeDomainSize;
class GeometryNodeAttributeStatistic;
class GeometryNodeBlurAttribute;
class GeometryNodeBoundBox;
class GeometryNodeCaptureAttribute;
class GeometryNodeCollectionInfo;
class GeometryNodeConvexHull;
class GeometryNodeCurveEndpointSelection;
class GeometryNodeCurveHandleTypeSelection;
class GeometryNodeCurveLength;
class GeometryNodeCurveArc;
class GeometryNodeCurvePrimitiveBezierSegment;
class GeometryNodeCurvePrimitiveCircle;
class GeometryNodeCurvePrimitiveLine;
class GeometryNodeCurveQuadraticBezier;
class GeometryNodeCurvePrimitiveQuadrilateral;
class GeometryNodeCurveSpiral;
class GeometryNodeCurveStar;
class GeometryNodeCurveSetHandles;
class GeometryNodeSplineParameter;
class GeometryNodeCurveSplineType;
class GeometryNodeCurveToMesh;
class GeometryNodeCurveToPoints;
class GeometryNodeCurveOfPoint;
class GeometryNodePointsOfCurve;
class GeometryNodeDeformCurvesOnSurface;
class GeometryNodeDeleteGeometry;
class GeometryNodeDistributePointsInVolume;
class GeometryNodeDistributePointsOnFaces;
class GeometryNodeDualMesh;
class GeometryNodeDuplicateElements;
class GeometryNodeEdgePathsToCurves;
class GeometryNodeEdgePathsToSelection;
class GeometryNodeEdgesToFaceGroups;
class GeometryNodeFieldAtIndex;
class GeometryNodeFieldOnDomain;
class GeometryNodeExtrudeMesh;
class GeometryNodeFillCurve;
class GeometryNodeFilletCurve;
class GeometryNodeFlipFaces;
class GeometryNodeGeometryToInstance;
class GeometryNodeImageInfo;
class GeometryNodeImageTexture;
class GeometryNodeIndexOfNearest;
class GeometryNodeInputImage;
class GeometryNodeInputCurveHandlePositions;
class GeometryNodeInputCurveTilt;
class GeometryNodeInputID;
class GeometryNodeInputIndex;
class GeometryNodeInputInstanceRotation;
class GeometryNodeInputInstanceScale;
class GeometryNodeInputMaterialIndex;
class GeometryNodeInputMaterial;
class GeometryNodeInputMeshEdgeAngle;
class GeometryNodeInputMeshEdgeNeighbors;
class GeometryNodeInputMeshEdgeVertices;
class GeometryNodeInputMeshFaceArea;
class GeometryNodeInputMeshFaceIsPlanar;
class GeometryNodeInputMeshFaceNeighbors;
class GeometryNodeInputMeshIsland;
class GeometryNodeInputMeshVertexNeighbors;
class GeometryNodeInputNamedAttribute;
class GeometryNodeInputNamedLayerSelection;
class GeometryNodeInputNormal;
class GeometryNodeInputPosition;
class GeometryNodeInputRadius;
class GeometryNodeInputSceneTime;
class GeometryNodeInputShadeSmooth;
class GeometryNodeInputShortestEdgePaths;
class GeometryNodeInputSignedDistance;
class GeometryNodeInputSplineCyclic;
class GeometryNodeSplineLength;
class GeometryNodeInputSplineResolution;
class GeometryNodeInputTangent;
class GeometryNodeInstanceOnPoints;
class GeometryNodeInstancesToPoints;
class GeometryNodeIsViewport;
class GeometryNodeJoinGeometry;
class GeometryNodeMaterialSelection;
class GeometryNodeMeanFilterSDFVolume;
class GeometryNodeMergeByDistance;
class GeometryNodeMeshBoolean;
class GeometryNodeMeshFaceSetBoundaries;
class GeometryNodeMeshCircle;
class GeometryNodeMeshCone;
class GeometryNodeMeshCube;
class GeometryNodeMeshCylinder;
class GeometryNodeMeshGrid;
class GeometryNodeMeshIcoSphere;
class GeometryNodeMeshLine;
class GeometryNodeMeshUVSphere;
class GeometryNodeMeshToCurve;
class GeometryNodeMeshToPoints;
class GeometryNodeMeshToSDFVolume;
class GeometryNodeMeshToVolume;
class GeometryNodeCornersOfEdge;
class GeometryNodeCornersOfFace;
class GeometryNodeCornersOfVertex;
class GeometryNodeEdgesOfCorner;
class GeometryNodeEdgesOfVertex;
class GeometryNodeFaceOfCorner;
class GeometryNodeOffsetCornerInFace;
class GeometryNodeVertexOfCorner;
class GeometryNodeObjectInfo;
class GeometryNodeOffsetPointInCurve;
class GeometryNodeOffsetSDFVolume;
class GeometryNodeToolFaceSet;
class GeometryNodeTool3DCursor;
class GeometryNodeToolSelection;
class GeometryNodeToolSetSelection;
class GeometryNodeToolSetFaceSet;
class GeometryNodePointsToSDFVolume;
class GeometryNodePointsToVertices;
class GeometryNodePointsToVolume;
class GeometryNodePoints;
class GeometryNodeProximity;
class GeometryNodeRaycast;
class GeometryNodeRealizeInstances;
class GeometryNodeRemoveAttribute;
class GeometryNodeRepeatInput;
class GeometryNodeRepeatOutput;
class GeometryNodeReplaceMaterial;
class GeometryNodeResampleCurve;
class GeometryNodeReverseCurve;
class GeometryNodeRotateInstances;
class GeometryNodeSampleCurve;
class GeometryNodeSampleIndex;
class GeometryNodeSampleNearestSurface;
class GeometryNodeSampleNearest;
class GeometryNodeSampleUVSurface;
class GeometryNodeSampleVolume;
class GeometryNodeScaleElements;
class GeometryNodeScaleInstances;
class GeometryNodeSDFVolumeSphere;
class GeometryNodeSelfObject;
class GeometryNodeSeparateComponents;
class GeometryNodeSeparateGeometry;
class GeometryNodeSetCurveHandlePositions;
class GeometryNodeSetCurveNormal;
class GeometryNodeSetCurveRadius;
class GeometryNodeSetCurveTilt;
class GeometryNodeSetID;
class GeometryNodeSetMaterialIndex;
class GeometryNodeSetMaterial;
class GeometryNodeSetPointRadius;
class GeometryNodeSetPosition;
class GeometryNodeSetShadeSmooth;
class GeometryNodeSetSplineCyclic;
class GeometryNodeSetSplineResolution;
class GeometryNodeSimulationInput;
class GeometryNodeSimulationOutput;
class GeometryNodeSplitToInstances;
class GeometryNodeSplitEdges;
class GeometryNodeStoreNamedAttribute;
class GeometryNodeStringJoin;
class GeometryNodeStringToCurves;
class GeometryNodeSubdivideCurve;
class GeometryNodeSubdivideMesh;
class GeometryNodeSubdivisionSurface;
class GeometryNodeSwitch;
class GeometryNodeTransform;
class GeometryNodeTranslateInstances;
class GeometryNodeTriangulate;
class GeometryNodeTrimCurve;
class GeometryNodeUVPackIslands;
class GeometryNodeUVUnwrap;
class GeometryNodeViewer;
class GeometryNodeVolumeCube;
class GeometryNodeVolumeToMesh;
class GeometryNodeInterpolateCurves;
class GeometryNodePointsToCurves;
class GeometryNodeInputEdgeSmooth;
class ShaderNodeGroup;
class CompositorNodeGroup;
class TextureNodeGroup;
class GeometryNodeGroup;
class ShaderNodeCustomGroup;
class CompositorNodeCustomGroup;
class NodeCustomGroup;
class GeometryNodeCustomGroup;
class NodeOutputFileSlotFile;
class NodeOutputFileSlotLayer;
class NodeGeometrySimulationOutputItems;
class NodeGeometryRepeatOutputItems;
class NodeInstanceHash;
class NodeSocket;
class NodeSocketStandard;
class NodeSocketFloat;
class NodeSocketFloatUnsigned;
class NodeSocketFloatPercentage;
class NodeSocketFloatFactor;
class NodeSocketFloatAngle;
class NodeSocketFloatTime;
class NodeSocketFloatTimeAbsolute;
class NodeSocketFloatDistance;
class NodeSocketInt;
class NodeSocketIntUnsigned;
class NodeSocketIntPercentage;
class NodeSocketIntFactor;
class NodeSocketBool;
class NodeSocketRotation;
class NodeSocketVector;
class NodeSocketVectorTranslation;
class NodeSocketVectorDirection;
class NodeSocketVectorVelocity;
class NodeSocketVectorAcceleration;
class NodeSocketVectorEuler;
class NodeSocketVectorXYZ;
class NodeSocketColor;
class NodeSocketString;
class NodeSocketShader;
class NodeSocketObject;
class NodeSocketImage;
class NodeSocketGeometry;
class NodeSocketCollection;
class NodeSocketTexture;
class NodeSocketMaterial;
class NodeSocketVirtual;
class NodeTreeInterfaceItem;
class NodeTreeInterfaceSocket;
class NodeTreeInterfacePanel;
class NodeTreeInterface;
class NodeTreeInterfaceSocketFloat;
class NodeTreeInterfaceSocketFloatUnsigned;
class NodeTreeInterfaceSocketFloatPercentage;
class NodeTreeInterfaceSocketFloatFactor;
class NodeTreeInterfaceSocketFloatAngle;
class NodeTreeInterfaceSocketFloatTime;
class NodeTreeInterfaceSocketFloatTimeAbsolute;
class NodeTreeInterfaceSocketFloatDistance;
class NodeTreeInterfaceSocketInt;
class NodeTreeInterfaceSocketIntUnsigned;
class NodeTreeInterfaceSocketIntPercentage;
class NodeTreeInterfaceSocketIntFactor;
class NodeTreeInterfaceSocketBool;
class NodeTreeInterfaceSocketRotation;
class NodeTreeInterfaceSocketVector;
class NodeTreeInterfaceSocketVectorTranslation;
class NodeTreeInterfaceSocketVectorDirection;
class NodeTreeInterfaceSocketVectorVelocity;
class NodeTreeInterfaceSocketVectorAcceleration;
class NodeTreeInterfaceSocketVectorEuler;
class NodeTreeInterfaceSocketVectorXYZ;
class NodeTreeInterfaceSocketColor;
class NodeTreeInterfaceSocketString;
class NodeTreeInterfaceSocketShader;
class NodeTreeInterfaceSocketObject;
class NodeTreeInterfaceSocketImage;
class NodeTreeInterfaceSocketGeometry;
class NodeTreeInterfaceSocketCollection;
class NodeTreeInterfaceSocketTexture;
class NodeTreeInterfaceSocketMaterial;
class Object;
class ObjectModifiers;
class ObjectGpencilModifiers;
class ObjectShaderFx;
class ObjectConstraints;
class VertexGroups;
class ParticleSystems;
class VertexGroup;
class MaterialSlot;
class ObjectDisplay;
class ObjectLineArt;
class ObjectLightLinking;
class PointCache;
class PointCaches;
class PointCacheItem;
class CollisionSettings;
class EffectorWeights;
class FieldSettings;
class SoftBodySettings;
class DepsgraphObjectInstance;
class DepsgraphUpdate;
class Depsgraph;
class PackedFile;
class PaletteColor;
class Palette;
class PaletteColors;
class ParticleTarget;
class SPHFluidSettings;
class ParticleHairKey;
class ParticleKey;
class ChildParticle;
class Particle;
class ParticleDupliWeight;
class ParticleSystem;
class ParticleSettingsTextureSlot;
class ParticleSettings;
class ParticleSettingsTextureSlots;
class Point;
class PointCloud;
class Pose;
class PoseBone;
class PoseBoneConstraints;
class IKParam;
class Itasc;
class CurveProfilePoint;
class CurveProfile;
class CurveProfilePoints;
class LightProbe;
class RenderEngine;
class HydraRenderEngine;
class RenderResult;
class RenderView;
class RenderLayer;
class RenderPasses;
class RenderPass;
class RigidBodyWorld;
class RigidBodyObject;
class RigidBodyConstraint;
class Scene;
class SceneObjects;
class KeyingSets;
class KeyingSetsAll;
class TimelineMarkers;
class ViewLayers;
class ToolSettings;
class GPencilInterpolateSettings;
class UnifiedPaintSettings;
class CurvePaintSettings;
class SequencerToolSettings;
class MeshStatVis;
class UnitSettings;
class Stereo3dFormat;
class ImageFormatSettings;
class TransformOrientation;
class TransformOrientationSlot;
class View3DCursor;
class SelectedUvElement;
class DisplaySafeAreas;
class SceneDisplay;
class RaytraceEEVEE;
class SceneEEVEE;
class SceneHydra;
class AOV;
class Lightgroup;
class ViewLayerEEVEE;
class SceneGpencil;
class FFmpegSettings;
class RenderSettings;
class RenderViews;
class BakeSettings;
class SceneRenderView;
class Screen;
class Area;
class AreaSpaces;
class Region;
class View2D;
class PaintCurve;
class PaintToolSlot;
class Paint;
class Sculpt;
class UvSculpt;
class GpPaint;
class GpVertexPaint;
class GpSculptPaint;
class GpWeightPaint;
class VertexPaint;
class PaintModeSettings;
class ImagePaint;
class ParticleEdit;
class ParticleBrush;
class GPencilSculptGuide;
class GPencilSculptSettings;
class CurvesSculpt;
class SequenceColorBalanceData;
class SequenceElement;
class RetimingKey;
class SequenceProxy;
class SequenceColorBalance;
class SequenceCrop;
class SequenceTransform;
class Sequence;
class SequenceModifiers;
class SequenceEditor;
class SequencesTopLevel;
class SequenceTimelineChannel;
class ImageSequence;
class SequenceElements;
class MetaSequence;
class SequencesMeta;
class SceneSequence;
class MovieSequence;
class RetimingKeys;
class MovieClipSequence;
class MaskSequence;
class SoundSequence;
class EffectSequence;
class AddSequence;
class AdjustmentSequence;
class AlphaOverSequence;
class AlphaUnderSequence;
class ColorSequence;
class CrossSequence;
class GammaCrossSequence;
class GlowSequence;
class MulticamSequence;
class MultiplySequence;
class OverDropSequence;
class SpeedControlSequence;
class SubtractSequence;
class TransformSequence;
class WipeSequence;
class GaussianBlurSequence;
class TextSequence;
class ColorMixSequence;
class SequenceModifier;
class ColorBalanceModifier;
class CurvesModifier;
class HueCorrectModifier;
class BrightContrastModifier;
class WhiteBalanceModifier;
class SequencerTonemapModifierData;
class SoundEqualizerModifier;
class EQCurveMappingData;
class Space;
class ViewerPathElem;
class IDViewerPathElem;
class ModifierViewerPathElem;
class GroupNodeViewerPathElem;
class SimulationZoneViewerPathElem;
class RepeatZoneViewerPathElem;
class ViewerNodeViewerPathElem;
class ViewerPath;
class SpaceImageEditor;
class SpaceUVEditor;
class SpaceImageOverlay;
class SpaceSequenceEditor;
class SequencerPreviewOverlay;
class SequencerTimelineOverlay;
class SpaceTextEditor;
class FileSelectEntry;
class FileSelectParams;
class FileAssetSelectParams;
class FileSelectIDFilter;
class FileAssetSelectIDFilter;
class FileBrowserFSMenuEntry;
class SpaceFileBrowser;
class SpaceOutliner;
class SpaceView3D;
class View3DShading;
class View3DOverlay;
class RegionView3D;
class SpaceProperties;
class SpaceDopeSheetEditor;
class SpaceGraphEditor;
class SpaceNLA;
class SpaceConsole;
class ConsoleLine;
class SpaceInfo;
class SpacePreferences;
class NodeTreePath;
class SpaceNodeEditor;
class SpaceNodeEditorPath;
class SpaceNodeOverlay;
class SpaceClipEditor;
class SpaceSpreadsheet;
class SpreadsheetColumn;
class SpreadsheetColumnID;
class SpreadsheetRowFilter;
class Speaker;
class TextLine;
class Text;
class TimelineMarker;
class Sound;
class UILayout;
class Panel;
class UIList;
class Header;
class Menu;
class AssetShelf;
class USDHook;
class ThemeFontStyle;
class ThemeStyle;
class ThemeWidgetColors;
class ThemeWidgetStateColors;
class ThemePanelColors;
class ThemeGradientColors;
class ThemeUserInterface;
class ThemeSpaceGeneric;
class ThemeSpaceGradient;
class ThemeSpaceListGeneric;
class ThemeAssetShelf;
class ThemeView3D;
class ThemeGraphEditor;
class ThemeFileBrowser;
class ThemeNLAEditor;
class ThemeDopeSheet;
class ThemeImageEditor;
class ThemeSequenceEditor;
class ThemeProperties;
class ThemeTextEditor;
class ThemeNodeEditor;
class ThemeOutliner;
class ThemeInfo;
class ThemePreferences;
class ThemeConsole;
class ThemeClipEditor;
class ThemeTopBar;
class ThemeStatusBar;
class ThemeSpreadsheet;
class ThemeBoneColorSet;
class ThemeCollectionColor;
class ThemeStripColor;
class Theme;
class UserSolidLight;
class WalkNavigation;
class Preferences;
class Addons;
class PathCompareCollection;
class PreferencesView;
class PreferencesEdit;
class PreferencesInput;
class PreferencesKeymap;
class PreferencesFilePaths;
class ScriptDirectory;
class ScriptDirectoryCollection;
class UserAssetLibrary;
class UserExtensionRepo;
class UserExtensionRepoCollection;
class PreferencesSystem;
class Addon;
class AddonPreferences;
class StudioLights;
class StudioLight;
class PathCompare;
class PreferencesApps;
class PreferencesExperimental;
class VectorFont;
class VolumeGrid;
class VolumeDisplay;
class VolumeRender;
class Volume;
class VolumeGrids;
class Operator;
class OperatorProperties;
class OperatorOptions;
class OperatorMousePath;
class OperatorFileListElement;
class Macro;
class OperatorMacro;
class Event;
class Timer;
class UIPopupMenu;
class UIPopover;
class UIPieMenu;
class Window;
class Stereo3dDisplay;
class WindowManager;
class KeyConfigurations;
class KeyConfigPreferences;
class KeyConfig;
class KeyMaps;
class KeyMap;
class KeyMapItems;
class KeyMapItem;
class GizmoGroup;
class Gizmo;
class GizmoProperties;
class Gizmos;
class GizmoGroupProperties;
class wmOwnerID;
class WorkSpaceTool;
class WorkSpace;
class wmOwnerIDs;
class wmTools;
class World;
class WorldLighting;
class WorldMistSettings;
class MovieClip;
class MovieClipProxy;
class MovieClipUser;
class MovieClipScopes;
class MovieTrackingSettings;
class MovieTrackingCamera;
class MovieTrackingMarker;
class MovieTrackingTrack;
class MovieTrackingMarkers;
class MovieTrackingPlaneMarker;
class MovieTrackingPlaneTrack;
class MovieTrackingPlaneMarkers;
class MovieTrackingTracks;
class MovieTrackingPlaneTracks;
class MovieTrackingObjectTracks;
class MovieTrackingObjectPlaneTracks;
class MovieTrackingStabilization;
class MovieTrackingReconstructedCameras;
class MovieReconstructedCamera;
class MovieTrackingReconstruction;
class MovieTrackingObject;
class MovieTrackingDopesheet;
class MovieTracking;
class MovieTrackingObjects;
class MaskParent;
class MaskSplinePointUW;
class MaskSplinePoint;
class MaskSpline;
class MaskSplines;
class MaskSplinePoints;
class MaskLayer;
class Mask;
class MaskLayers;
class XrActionMap;
class XrActionMapItems;
class XrUserPath;
class XrActionMapItem;
class XrUserPaths;
class XrActionMapBindings;
class XrComponentPath;
class XrActionMapBinding;
class XrComponentPaths;
class XrSessionSettings;
class XrSessionState;
class XrActionMaps;
class XrEventData;

/**************** Struct Definition ****************/

class Struct : public Pointer {
public:
	Struct(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		properties(ptr_arg),
		functions(ptr_arg),
		property_tags(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline std::string translation_context(void);
	inline void translation_context(const std::string& value);
	inline Struct base(void);
	inline Struct nested(void);
	inline StringProperty name_property(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Property, Struct, properties, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Function, Struct, functions, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, Struct, property_tags, false, false, false)

};

/**************** Property Definition ****************/

class Property : public Pointer {
public:
	Property(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline std::string translation_context(void);
	inline void translation_context(const std::string& value);
	enum type_enum {
		type_BOOLEAN = 0,
		type_INT = 1,
		type_FLOAT = 2,
		type_STRING = 3,
		type_ENUM = 4,
		type_POINTER = 5,
		type_COLLECTION = 6,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum subtype_enum {
		subtype_NONE = 0,
		subtype_FILE_PATH = 1,
		subtype_DIR_PATH = 2,
		subtype_FILE_NAME = 3,
		subtype_BYTE_STRING = 4,
		subtype_PASSWORD = 6,
		subtype_PIXEL = 12,
		subtype_UNSIGNED = 13,
		subtype_PERCENTAGE = 14,
		subtype_FACTOR = 15,
		subtype_ANGLE = 327696,
		subtype_TIME = 393233,
		subtype_TIME_ABSOLUTE = 458769,
		subtype_DISTANCE = 65554,
		subtype_DISTANCE_CAMERA = 655379,
		subtype_POWER = 720938,
		subtype_TEMPERATURE = 786475,
		subtype_COLOR = 20,
		subtype_TRANSLATION = 65557,
		subtype_DIRECTION = 22,
		subtype_VELOCITY = 524311,
		subtype_ACCELERATION = 589848,
		subtype_MATRIX = 25,
		subtype_EULER = 327706,
		subtype_QUATERNION = 27,
		subtype_AXISANGLE = 28,
		subtype_XYZ = 29,
		subtype_XYZ_LENGTH = 65565,
		subtype_COLOR_GAMMA = 30,
		subtype_COORDINATES = 31,
		subtype_LAYER = 40,
		subtype_LAYER_MEMBER = 41,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Struct srna(void);
	enum unit_enum {
		unit_NONE = 0,
		unit_LENGTH = 65536,
		unit_AREA = 131072,
		unit_VOLUME = 196608,
		unit_ROTATION = 327680,
		unit_TIME = 393216,
		unit_TIME_ABSOLUTE = 458752,
		unit_VELOCITY = 524288,
		unit_ACCELERATION = 589824,
		unit_MASS = 262144,
		unit_CAMERA = 655360,
		unit_POWER = 720896,
		unit_TEMPERATURE = 786432,
	};
	inline unit_enum unit(void);
	inline void unit(unit_enum value);
	enum icon_enum {
		icon_NONE = 0,
		icon_QUESTION = 1,
		icon_ERROR = 2,
		icon_CANCEL = 3,
		icon_TRIA_RIGHT = 4,
		icon_TRIA_DOWN = 5,
		icon_TRIA_LEFT = 6,
		icon_TRIA_UP = 7,
		icon_ARROW_LEFTRIGHT = 8,
		icon_PLUS = 9,
		icon_DISCLOSURE_TRI_RIGHT = 10,
		icon_DISCLOSURE_TRI_DOWN = 11,
		icon_RADIOBUT_OFF = 12,
		icon_RADIOBUT_ON = 13,
		icon_MENU_PANEL = 14,
		icon_BLENDER = 15,
		icon_GRIP = 16,
		icon_DOT = 17,
		icon_COLLAPSEMENU = 18,
		icon_X = 19,
		icon_DUPLICATE = 20,
		icon_TRASH = 21,
		icon_COLLECTION_NEW = 22,
		icon_OPTIONS = 23,
		icon_NODE = 24,
		icon_NODE_SEL = 25,
		icon_WINDOW = 26,
		icon_WORKSPACE = 27,
		icon_RIGHTARROW_THIN = 28,
		icon_BORDERMOVE = 29,
		icon_VIEWZOOM = 30,
		icon_ADD = 31,
		icon_REMOVE = 32,
		icon_PANEL_CLOSE = 33,
		icon_COPY_ID = 34,
		icon_EYEDROPPER = 35,
		icon_CHECKMARK = 36,
		icon_AUTO = 37,
		icon_CHECKBOX_DEHLT = 38,
		icon_CHECKBOX_HLT = 39,
		icon_UNLOCKED = 40,
		icon_LOCKED = 41,
		icon_UNPINNED = 42,
		icon_PINNED = 43,
		icon_SCREEN_BACK = 44,
		icon_RIGHTARROW = 45,
		icon_DOWNARROW_HLT = 46,
		icon_FCURVE_SNAPSHOT = 47,
		icon_OBJECT_HIDDEN = 48,
		icon_TOPBAR = 49,
		icon_STATUSBAR = 50,
		icon_PLUGIN = 51,
		icon_HELP = 52,
		icon_GHOST_ENABLED = 53,
		icon_COLOR = 54,
		icon_UNLINKED = 55,
		icon_LINKED = 56,
		icon_HAND = 57,
		icon_ZOOM_ALL = 58,
		icon_ZOOM_SELECTED = 59,
		icon_ZOOM_PREVIOUS = 60,
		icon_ZOOM_IN = 61,
		icon_ZOOM_OUT = 62,
		icon_DRIVER_DISTANCE = 63,
		icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		icon_DRIVER_TRANSFORM = 65,
		icon_FREEZE = 66,
		icon_STYLUS_PRESSURE = 67,
		icon_GHOST_DISABLED = 68,
		icon_FILE_NEW = 69,
		icon_FILE_TICK = 70,
		icon_QUIT = 71,
		icon_URL = 72,
		icon_RECOVER_LAST = 73,
		icon_THREE_DOTS = 74,
		icon_FULLSCREEN_ENTER = 75,
		icon_FULLSCREEN_EXIT = 76,
		icon_BRUSHES_ALL = 77,
		icon_LIGHT = 78,
		icon_MATERIAL = 79,
		icon_TEXTURE = 80,
		icon_ANIM = 81,
		icon_WORLD = 82,
		icon_SCENE = 83,
		icon_OUTPUT = 84,
		icon_SCRIPT = 87,
		icon_PARTICLES = 88,
		icon_PHYSICS = 89,
		icon_SPEAKER = 90,
		icon_TOOL_SETTINGS = 92,
		icon_SHADERFX = 93,
		icon_MODIFIER = 94,
		icon_BLANK1 = 101,
		icon_FAKE_USER_OFF = 102,
		icon_FAKE_USER_ON = 103,
		icon_VIEW3D = 104,
		icon_GRAPH = 105,
		icon_OUTLINER = 106,
		icon_PROPERTIES = 107,
		icon_FILEBROWSER = 108,
		icon_IMAGE = 109,
		icon_INFO = 110,
		icon_SEQUENCE = 111,
		icon_TEXT = 112,
		icon_SPREADSHEET = 113,
		icon_SOUND = 114,
		icon_ACTION = 115,
		icon_NLA = 116,
		icon_PREFERENCES = 117,
		icon_TIME = 118,
		icon_NODETREE = 119,
		icon_GEOMETRY_NODES = 120,
		icon_CONSOLE = 121,
		icon_TRACKER = 123,
		icon_ASSET_MANAGER = 124,
		icon_NODE_COMPOSITING = 125,
		icon_NODE_TEXTURE = 126,
		icon_NODE_MATERIAL = 127,
		icon_UV = 128,
		icon_OBJECT_DATAMODE = 130,
		icon_EDITMODE_HLT = 131,
		icon_UV_DATA = 132,
		icon_VPAINT_HLT = 133,
		icon_TPAINT_HLT = 134,
		icon_WPAINT_HLT = 135,
		icon_SCULPTMODE_HLT = 136,
		icon_POSE_HLT = 137,
		icon_PARTICLEMODE = 138,
		icon_TRACKING = 146,
		icon_TRACKING_BACKWARDS = 147,
		icon_TRACKING_FORWARDS = 148,
		icon_TRACKING_BACKWARDS_SINGLE = 149,
		icon_TRACKING_FORWARDS_SINGLE = 150,
		icon_TRACKING_CLEAR_BACKWARDS = 151,
		icon_TRACKING_CLEAR_FORWARDS = 152,
		icon_TRACKING_REFINE_BACKWARDS = 153,
		icon_TRACKING_REFINE_FORWARDS = 154,
		icon_SCENE_DATA = 156,
		icon_RENDERLAYERS = 157,
		icon_WORLD_DATA = 158,
		icon_OBJECT_DATA = 159,
		icon_MESH_DATA = 160,
		icon_CURVE_DATA = 161,
		icon_META_DATA = 162,
		icon_LATTICE_DATA = 163,
		icon_LIGHT_DATA = 164,
		icon_MATERIAL_DATA = 165,
		icon_TEXTURE_DATA = 166,
		icon_ANIM_DATA = 167,
		icon_CAMERA_DATA = 168,
		icon_PARTICLE_DATA = 169,
		icon_LIBRARY_DATA_DIRECT = 170,
		icon_GROUP = 171,
		icon_ARMATURE_DATA = 172,
		icon_COMMUNITY = 173,
		icon_BONE_DATA = 174,
		icon_CONSTRAINT = 175,
		icon_SHAPEKEY_DATA = 176,
		icon_CONSTRAINT_BONE = 177,
		icon_CAMERA_STEREO = 178,
		icon_PACKAGE = 179,
		icon_UGLYPACKAGE = 180,
		icon_EXPERIMENTAL = 181,
		icon_BRUSH_DATA = 182,
		icon_IMAGE_DATA = 183,
		icon_FILE = 184,
		icon_FCURVE = 185,
		icon_FONT_DATA = 186,
		icon_RENDER_RESULT = 187,
		icon_SURFACE_DATA = 188,
		icon_EMPTY_DATA = 189,
		icon_PRESET = 190,
		icon_RENDER_ANIMATION = 191,
		icon_RENDER_STILL = 192,
		icon_LIBRARY_DATA_BROKEN = 193,
		icon_BOIDS = 194,
		icon_STRANDS = 195,
		icon_GREASEPENCIL = 197,
		icon_LINE_DATA = 198,
		icon_LIBRARY_DATA_OVERRIDE = 199,
		icon_GROUP_BONE = 200,
		icon_GROUP_VERTEX = 201,
		icon_GROUP_VCOL = 202,
		icon_GROUP_UVS = 203,
		icon_FACE_MAPS = 204,
		icon_RNA = 206,
		icon_RNA_ADD = 207,
		icon_MOUSE_LMB = 208,
		icon_MOUSE_MMB = 209,
		icon_MOUSE_RMB = 210,
		icon_MOUSE_MOVE = 211,
		icon_MOUSE_LMB_DRAG = 212,
		icon_MOUSE_MMB_DRAG = 213,
		icon_MOUSE_RMB_DRAG = 214,
		icon_MEMORY = 215,
		icon_PRESET_NEW = 216,
		icon_DECORATE = 218,
		icon_DECORATE_KEYFRAME = 219,
		icon_DECORATE_ANIMATE = 220,
		icon_DECORATE_DRIVER = 221,
		icon_DECORATE_LINKED = 222,
		icon_DECORATE_LIBRARY_OVERRIDE = 223,
		icon_DECORATE_UNLOCKED = 224,
		icon_DECORATE_LOCKED = 225,
		icon_DECORATE_OVERRIDE = 226,
		icon_FUND = 227,
		icon_TRACKER_DATA = 228,
		icon_HEART = 229,
		icon_ORPHAN_DATA = 230,
		icon_USER = 231,
		icon_SYSTEM = 232,
		icon_SETTINGS = 233,
		icon_OUTLINER_OB_EMPTY = 234,
		icon_OUTLINER_OB_MESH = 235,
		icon_OUTLINER_OB_CURVE = 236,
		icon_OUTLINER_OB_LATTICE = 237,
		icon_OUTLINER_OB_META = 238,
		icon_OUTLINER_OB_LIGHT = 239,
		icon_OUTLINER_OB_CAMERA = 240,
		icon_OUTLINER_OB_ARMATURE = 241,
		icon_OUTLINER_OB_FONT = 242,
		icon_OUTLINER_OB_SURFACE = 243,
		icon_OUTLINER_OB_SPEAKER = 244,
		icon_OUTLINER_OB_FORCE_FIELD = 245,
		icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		icon_OUTLINER_OB_GREASEPENCIL = 247,
		icon_OUTLINER_OB_LIGHTPROBE = 248,
		icon_OUTLINER_OB_IMAGE = 249,
		icon_OUTLINER_COLLECTION = 250,
		icon_RESTRICT_COLOR_OFF = 251,
		icon_RESTRICT_COLOR_ON = 252,
		icon_HIDE_ON = 253,
		icon_HIDE_OFF = 254,
		icon_RESTRICT_SELECT_ON = 255,
		icon_RESTRICT_SELECT_OFF = 256,
		icon_RESTRICT_RENDER_ON = 257,
		icon_RESTRICT_RENDER_OFF = 258,
		icon_RESTRICT_INSTANCED_OFF = 259,
		icon_OUTLINER_DATA_EMPTY = 260,
		icon_OUTLINER_DATA_MESH = 261,
		icon_OUTLINER_DATA_CURVE = 262,
		icon_OUTLINER_DATA_LATTICE = 263,
		icon_OUTLINER_DATA_META = 264,
		icon_OUTLINER_DATA_LIGHT = 265,
		icon_OUTLINER_DATA_CAMERA = 266,
		icon_OUTLINER_DATA_ARMATURE = 267,
		icon_OUTLINER_DATA_FONT = 268,
		icon_OUTLINER_DATA_SURFACE = 269,
		icon_OUTLINER_DATA_SPEAKER = 270,
		icon_OUTLINER_DATA_LIGHTPROBE = 271,
		icon_OUTLINER_DATA_GP_LAYER = 272,
		icon_OUTLINER_DATA_GREASEPENCIL = 273,
		icon_GP_SELECT_POINTS = 274,
		icon_GP_SELECT_STROKES = 275,
		icon_GP_MULTIFRAME_EDITING = 276,
		icon_GP_ONLY_SELECTED = 277,
		icon_GP_SELECT_BETWEEN_STROKES = 278,
		icon_MODIFIER_OFF = 279,
		icon_MODIFIER_ON = 280,
		icon_ONIONSKIN_OFF = 281,
		icon_ONIONSKIN_ON = 282,
		icon_RESTRICT_VIEW_ON = 283,
		icon_RESTRICT_VIEW_OFF = 284,
		icon_RESTRICT_INSTANCED_ON = 285,
		icon_MESH_PLANE = 286,
		icon_MESH_CUBE = 287,
		icon_MESH_CIRCLE = 288,
		icon_MESH_UVSPHERE = 289,
		icon_MESH_ICOSPHERE = 290,
		icon_MESH_GRID = 291,
		icon_MESH_MONKEY = 292,
		icon_MESH_CYLINDER = 293,
		icon_MESH_TORUS = 294,
		icon_MESH_CONE = 295,
		icon_MESH_CAPSULE = 296,
		icon_EMPTY_SINGLE_ARROW = 297,
		icon_LIGHT_POINT = 298,
		icon_LIGHT_SUN = 299,
		icon_LIGHT_SPOT = 300,
		icon_LIGHT_HEMI = 301,
		icon_LIGHT_AREA = 302,
		icon_CUBE = 303,
		icon_SPHERE = 304,
		icon_CONE = 305,
		icon_META_PLANE = 306,
		icon_META_CUBE = 307,
		icon_META_BALL = 308,
		icon_META_ELLIPSOID = 309,
		icon_META_CAPSULE = 310,
		icon_SURFACE_NCURVE = 312,
		icon_SURFACE_NCIRCLE = 313,
		icon_SURFACE_NSURFACE = 314,
		icon_SURFACE_NCYLINDER = 315,
		icon_SURFACE_NSPHERE = 316,
		icon_SURFACE_NTORUS = 317,
		icon_EMPTY_AXIS = 318,
		icon_STROKE = 319,
		icon_EMPTY_ARROWS = 320,
		icon_CURVE_BEZCURVE = 321,
		icon_CURVE_BEZCIRCLE = 322,
		icon_CURVE_NCURVE = 323,
		icon_CURVE_NCIRCLE = 324,
		icon_CURVE_PATH = 325,
		icon_LIGHTPROBE_SPHERE = 326,
		icon_LIGHTPROBE_PLANE = 327,
		icon_LIGHTPROBE_VOLUME = 328,
		icon_COLOR_RED = 331,
		icon_COLOR_GREEN = 332,
		icon_COLOR_BLUE = 333,
		icon_TRIA_RIGHT_BAR = 334,
		icon_TRIA_DOWN_BAR = 335,
		icon_TRIA_LEFT_BAR = 336,
		icon_TRIA_UP_BAR = 337,
		icon_FORCE_FORCE = 338,
		icon_FORCE_WIND = 339,
		icon_FORCE_VORTEX = 340,
		icon_FORCE_MAGNETIC = 341,
		icon_FORCE_HARMONIC = 342,
		icon_FORCE_CHARGE = 343,
		icon_FORCE_LENNARDJONES = 344,
		icon_FORCE_TEXTURE = 345,
		icon_FORCE_CURVE = 346,
		icon_FORCE_BOID = 347,
		icon_FORCE_TURBULENCE = 348,
		icon_FORCE_DRAG = 349,
		icon_FORCE_FLUIDFLOW = 350,
		icon_RIGID_BODY = 353,
		icon_RIGID_BODY_CONSTRAINT = 354,
		icon_SPLIT_HORIZONTAL = 359,
		icon_SPLIT_VERTICAL = 360,
		icon_IMAGE_PLANE = 361,
		icon_IMAGE_BACKGROUND = 362,
		icon_IMAGE_REFERENCE = 363,
		icon_NODE_INSERT_ON = 367,
		icon_NODE_INSERT_OFF = 368,
		icon_NODE_TOP = 369,
		icon_NODE_SIDE = 370,
		icon_NODE_CORNER = 371,
		icon_ANCHOR_TOP = 372,
		icon_ANCHOR_BOTTOM = 373,
		icon_ANCHOR_LEFT = 374,
		icon_ANCHOR_RIGHT = 375,
		icon_ANCHOR_CENTER = 376,
		icon_SELECT_SET = 385,
		icon_SELECT_EXTEND = 386,
		icon_SELECT_SUBTRACT = 387,
		icon_SELECT_INTERSECT = 388,
		icon_SELECT_DIFFERENCE = 389,
		icon_ALIGN_LEFT = 390,
		icon_ALIGN_CENTER = 391,
		icon_ALIGN_RIGHT = 392,
		icon_ALIGN_JUSTIFY = 393,
		icon_ALIGN_FLUSH = 394,
		icon_ALIGN_TOP = 395,
		icon_ALIGN_MIDDLE = 396,
		icon_ALIGN_BOTTOM = 397,
		icon_BOLD = 398,
		icon_ITALIC = 399,
		icon_UNDERLINE = 400,
		icon_SMALL_CAPS = 401,
		icon_CON_ACTION = 404,
		icon_MOD_ENVELOPE = 406,
		icon_MOD_OUTLINE = 407,
		icon_MOD_LENGTH = 408,
		icon_MOD_DASH = 409,
		icon_MOD_LINEART = 410,
		icon_HOLDOUT_OFF = 412,
		icon_HOLDOUT_ON = 413,
		icon_INDIRECT_ONLY_OFF = 414,
		icon_INDIRECT_ONLY_ON = 415,
		icon_CON_CAMERASOLVER = 416,
		icon_CON_FOLLOWTRACK = 417,
		icon_CON_OBJECTSOLVER = 418,
		icon_CON_LOCLIKE = 419,
		icon_CON_ROTLIKE = 420,
		icon_CON_SIZELIKE = 421,
		icon_CON_TRANSLIKE = 422,
		icon_CON_DISTLIMIT = 423,
		icon_CON_LOCLIMIT = 424,
		icon_CON_ROTLIMIT = 425,
		icon_CON_SIZELIMIT = 426,
		icon_CON_SAMEVOL = 427,
		icon_CON_TRANSFORM = 428,
		icon_CON_TRANSFORM_CACHE = 429,
		icon_CON_CLAMPTO = 430,
		icon_CON_KINEMATIC = 431,
		icon_CON_LOCKTRACK = 432,
		icon_CON_SPLINEIK = 433,
		icon_CON_STRETCHTO = 434,
		icon_CON_TRACKTO = 435,
		icon_CON_ARMATURE = 436,
		icon_CON_CHILDOF = 437,
		icon_CON_FLOOR = 438,
		icon_CON_FOLLOWPATH = 439,
		icon_CON_PIVOT = 440,
		icon_CON_SHRINKWRAP = 441,
		icon_MODIFIER_DATA = 442,
		icon_MOD_WAVE = 443,
		icon_MOD_BUILD = 444,
		icon_MOD_DECIM = 445,
		icon_MOD_MIRROR = 446,
		icon_MOD_SOFT = 447,
		icon_MOD_SUBSURF = 448,
		icon_HOOK = 449,
		icon_MOD_PHYSICS = 450,
		icon_MOD_PARTICLES = 451,
		icon_MOD_BOOLEAN = 452,
		icon_MOD_EDGESPLIT = 453,
		icon_MOD_ARRAY = 454,
		icon_MOD_UVPROJECT = 455,
		icon_MOD_DISPLACE = 456,
		icon_MOD_CURVE = 457,
		icon_MOD_LATTICE = 458,
		icon_MOD_TINT = 459,
		icon_MOD_ARMATURE = 460,
		icon_MOD_SHRINKWRAP = 461,
		icon_MOD_CAST = 462,
		icon_MOD_MESHDEFORM = 463,
		icon_MOD_BEVEL = 464,
		icon_MOD_SMOOTH = 465,
		icon_MOD_SIMPLEDEFORM = 466,
		icon_MOD_MASK = 467,
		icon_MOD_CLOTH = 468,
		icon_MOD_EXPLODE = 469,
		icon_MOD_FLUIDSIM = 470,
		icon_MOD_MULTIRES = 471,
		icon_MOD_FLUID = 472,
		icon_MOD_SOLIDIFY = 473,
		icon_MOD_SCREW = 474,
		icon_MOD_VERTEX_WEIGHT = 475,
		icon_MOD_DYNAMICPAINT = 476,
		icon_MOD_REMESH = 477,
		icon_MOD_OCEAN = 478,
		icon_MOD_WARP = 479,
		icon_MOD_SKIN = 480,
		icon_MOD_TRIANGULATE = 481,
		icon_MOD_WIREFRAME = 482,
		icon_MOD_DATA_TRANSFER = 483,
		icon_MOD_NORMALEDIT = 484,
		icon_MOD_PARTICLE_INSTANCE = 485,
		icon_MOD_HUE_SATURATION = 486,
		icon_MOD_NOISE = 487,
		icon_MOD_OFFSET = 488,
		icon_MOD_SIMPLIFY = 489,
		icon_MOD_THICKNESS = 490,
		icon_MOD_INSTANCE = 491,
		icon_MOD_TIME = 492,
		icon_MOD_OPACITY = 493,
		icon_REC = 494,
		icon_PLAY = 495,
		icon_FF = 496,
		icon_REW = 497,
		icon_PAUSE = 498,
		icon_PREV_KEYFRAME = 499,
		icon_NEXT_KEYFRAME = 500,
		icon_PLAY_SOUND = 501,
		icon_PLAY_REVERSE = 502,
		icon_PREVIEW_RANGE = 503,
		icon_ACTION_TWEAK = 504,
		icon_PMARKER_ACT = 505,
		icon_PMARKER_SEL = 506,
		icon_PMARKER = 507,
		icon_MARKER_HLT = 508,
		icon_MARKER = 509,
		icon_KEYFRAME_HLT = 510,
		icon_KEYFRAME = 511,
		icon_KEYINGSET = 512,
		icon_KEY_DEHLT = 513,
		icon_KEY_HLT = 514,
		icon_MUTE_IPO_OFF = 515,
		icon_MUTE_IPO_ON = 516,
		icon_DRIVER = 519,
		icon_SOLO_OFF = 520,
		icon_SOLO_ON = 521,
		icon_FRAME_PREV = 522,
		icon_FRAME_NEXT = 523,
		icon_NLA_PUSHDOWN = 524,
		icon_IPO_CONSTANT = 525,
		icon_IPO_LINEAR = 526,
		icon_IPO_BEZIER = 527,
		icon_IPO_SINE = 528,
		icon_IPO_QUAD = 529,
		icon_IPO_CUBIC = 530,
		icon_IPO_QUART = 531,
		icon_IPO_QUINT = 532,
		icon_IPO_EXPO = 533,
		icon_IPO_CIRC = 534,
		icon_IPO_BOUNCE = 535,
		icon_IPO_ELASTIC = 536,
		icon_IPO_BACK = 537,
		icon_IPO_EASE_IN = 538,
		icon_IPO_EASE_OUT = 539,
		icon_IPO_EASE_IN_OUT = 540,
		icon_NORMALIZE_FCURVES = 541,
		icon_ORIENTATION_PARENT = 542,
		icon_VERTEXSEL = 546,
		icon_EDGESEL = 547,
		icon_FACESEL = 548,
		icon_CURSOR = 550,
		icon_PIVOT_BOUNDBOX = 551,
		icon_PIVOT_CURSOR = 552,
		icon_PIVOT_INDIVIDUAL = 553,
		icon_PIVOT_MEDIAN = 554,
		icon_PIVOT_ACTIVE = 555,
		icon_CENTER_ONLY = 556,
		icon_ROOTCURVE = 557,
		icon_SMOOTHCURVE = 558,
		icon_SPHERECURVE = 559,
		icon_INVERSESQUARECURVE = 560,
		icon_SHARPCURVE = 561,
		icon_LINCURVE = 562,
		icon_NOCURVE = 563,
		icon_RNDCURVE = 564,
		icon_PROP_OFF = 565,
		icon_PROP_ON = 566,
		icon_PROP_CON = 567,
		icon_PROP_PROJECTED = 568,
		icon_PARTICLE_POINT = 569,
		icon_PARTICLE_TIP = 570,
		icon_PARTICLE_PATH = 571,
		icon_SNAP_FACE_NEAREST = 572,
		icon_SNAP_FACE_CENTER = 573,
		icon_SNAP_PERPENDICULAR = 574,
		icon_SNAP_MIDPOINT = 575,
		icon_SNAP_OFF = 576,
		icon_SNAP_ON = 577,
		icon_SNAP_NORMAL = 578,
		icon_SNAP_GRID = 579,
		icon_SNAP_VERTEX = 580,
		icon_SNAP_EDGE = 581,
		icon_SNAP_FACE = 582,
		icon_SNAP_VOLUME = 583,
		icon_SNAP_INCREMENT = 584,
		icon_STICKY_UVS_LOC = 585,
		icon_STICKY_UVS_DISABLE = 586,
		icon_STICKY_UVS_VERT = 587,
		icon_CLIPUV_DEHLT = 588,
		icon_CLIPUV_HLT = 589,
		icon_SNAP_PEEL_OBJECT = 590,
		icon_GRID = 591,
		icon_OBJECT_ORIGIN = 592,
		icon_ORIENTATION_GLOBAL = 593,
		icon_ORIENTATION_GIMBAL = 594,
		icon_ORIENTATION_LOCAL = 595,
		icon_ORIENTATION_NORMAL = 596,
		icon_ORIENTATION_VIEW = 597,
		icon_COPYDOWN = 598,
		icon_PASTEDOWN = 599,
		icon_PASTEFLIPUP = 600,
		icon_PASTEFLIPDOWN = 601,
		icon_VIS_SEL_11 = 602,
		icon_VIS_SEL_10 = 603,
		icon_VIS_SEL_01 = 604,
		icon_VIS_SEL_00 = 605,
		icon_AUTOMERGE_OFF = 607,
		icon_AUTOMERGE_ON = 608,
		icon_UV_VERTEXSEL = 610,
		icon_UV_EDGESEL = 611,
		icon_UV_FACESEL = 612,
		icon_UV_ISLANDSEL = 613,
		icon_UV_SYNC_SELECT = 614,
		icon_GP_CAPS_FLAT = 615,
		icon_GP_CAPS_ROUND = 616,
		icon_FIXED_SIZE = 617,
		icon_TRANSFORM_ORIGINS = 618,
		icon_GIZMO = 619,
		icon_ORIENTATION_CURSOR = 620,
		icon_NORMALS_VERTEX = 621,
		icon_NORMALS_FACE = 622,
		icon_NORMALS_VERTEX_FACE = 623,
		icon_SHADING_BBOX = 624,
		icon_SHADING_WIRE = 625,
		icon_SHADING_SOLID = 626,
		icon_SHADING_RENDERED = 627,
		icon_SHADING_TEXTURE = 628,
		icon_OVERLAY = 629,
		icon_XRAY = 630,
		icon_LOCKVIEW_OFF = 633,
		icon_LOCKVIEW_ON = 634,
		icon_AXIS_SIDE = 636,
		icon_AXIS_FRONT = 637,
		icon_AXIS_TOP = 638,
		icon_LAYER_USED = 643,
		icon_LAYER_ACTIVE = 644,
		icon_OUTLINER_OB_CURVES = 650,
		icon_OUTLINER_DATA_CURVES = 651,
		icon_CURVES_DATA = 652,
		icon_OUTLINER_OB_POINTCLOUD = 653,
		icon_OUTLINER_DATA_POINTCLOUD = 654,
		icon_POINTCLOUD_DATA = 655,
		icon_OUTLINER_OB_VOLUME = 656,
		icon_OUTLINER_DATA_VOLUME = 657,
		icon_VOLUME_DATA = 658,
		icon_CURRENT_FILE = 672,
		icon_HOME = 673,
		icon_DOCUMENTS = 674,
		icon_TEMP = 675,
		icon_SORTALPHA = 676,
		icon_SORTBYEXT = 677,
		icon_SORTTIME = 678,
		icon_SORTSIZE = 679,
		icon_SHORTDISPLAY = 680,
		icon_LONGDISPLAY = 681,
		icon_IMGDISPLAY = 683,
		icon_BOOKMARKS = 686,
		icon_FONTPREVIEW = 687,
		icon_FILTER = 688,
		icon_NEWFOLDER = 689,
		icon_FOLDER_REDIRECT = 690,
		icon_FILE_PARENT = 691,
		icon_FILE_REFRESH = 692,
		icon_FILE_FOLDER = 693,
		icon_FILE_BLANK = 694,
		icon_FILE_BLEND = 695,
		icon_FILE_IMAGE = 696,
		icon_FILE_MOVIE = 697,
		icon_FILE_SCRIPT = 698,
		icon_FILE_SOUND = 699,
		icon_FILE_FONT = 700,
		icon_FILE_TEXT = 701,
		icon_SORT_DESC = 702,
		icon_SORT_ASC = 703,
		icon_LINK_BLEND = 704,
		icon_APPEND_BLEND = 705,
		icon_IMPORT = 706,
		icon_EXPORT = 707,
		icon_LOOP_BACK = 715,
		icon_LOOP_FORWARDS = 716,
		icon_BACK = 717,
		icon_FORWARD = 718,
		icon_FILE_ARCHIVE = 721,
		icon_FILE_CACHE = 722,
		icon_FILE_VOLUME = 723,
		icon_FILE_3D = 724,
		icon_FILE_HIDDEN = 725,
		icon_FILE_BACKUP = 726,
		icon_DISK_DRIVE = 727,
		icon_MATPLANE = 728,
		icon_MATSPHERE = 729,
		icon_MATCUBE = 730,
		icon_MONKEY = 731,
		icon_CURVES = 732,
		icon_ALIASED = 733,
		icon_ANTIALIASED = 734,
		icon_MAT_SPHERE_SKY = 735,
		icon_MATSHADERBALL = 736,
		icon_MATCLOTH = 737,
		icon_MATFLUID = 738,
		icon_WORDWRAP_OFF = 740,
		icon_WORDWRAP_ON = 741,
		icon_SYNTAX_OFF = 742,
		icon_SYNTAX_ON = 743,
		icon_LINENUMBERS_OFF = 744,
		icon_LINENUMBERS_ON = 745,
		icon_SCRIPTPLUGINS = 746,
		icon_DISC = 750,
		icon_DESKTOP = 751,
		icon_EXTERNAL_DRIVE = 752,
		icon_NETWORK_DRIVE = 753,
		icon_SEQ_SEQUENCER = 754,
		icon_SEQ_PREVIEW = 755,
		icon_SEQ_LUMA_WAVEFORM = 756,
		icon_SEQ_CHROMA_SCOPE = 757,
		icon_SEQ_HISTOGRAM = 758,
		icon_SEQ_SPLITVIEW = 759,
		icon_SEQ_STRIP_META = 760,
		icon_SEQ_STRIP_DUPLICATE = 761,
		icon_IMAGE_RGB = 763,
		icon_IMAGE_RGB_ALPHA = 764,
		icon_IMAGE_ALPHA = 765,
		icon_IMAGE_ZDEPTH = 766,
		icon_HANDLE_AUTOCLAMPED = 767,
		icon_HANDLE_AUTO = 768,
		icon_HANDLE_ALIGNED = 769,
		icon_HANDLE_VECTOR = 770,
		icon_HANDLE_FREE = 771,
		icon_VIEW_PERSPECTIVE = 775,
		icon_VIEW_ORTHO = 776,
		icon_VIEW_CAMERA = 777,
		icon_VIEW_PAN = 778,
		icon_VIEW_ZOOM = 779,
		icon_BRUSH_BLOB = 780,
		icon_BRUSH_BLUR = 781,
		icon_BRUSH_CLAY = 782,
		icon_BRUSH_CLAY_STRIPS = 783,
		icon_BRUSH_CLONE = 784,
		icon_BRUSH_CREASE = 785,
		icon_BRUSH_FILL = 786,
		icon_BRUSH_FLATTEN = 787,
		icon_BRUSH_GRAB = 788,
		icon_BRUSH_INFLATE = 789,
		icon_BRUSH_LAYER = 790,
		icon_BRUSH_MASK = 791,
		icon_BRUSH_MIX = 792,
		icon_BRUSH_NUDGE = 793,
		icon_BRUSH_PAINT_SELECT = 794,
		icon_BRUSH_PINCH = 795,
		icon_BRUSH_SCRAPE = 796,
		icon_BRUSH_SCULPT_DRAW = 797,
		icon_BRUSH_SMEAR = 798,
		icon_BRUSH_SMOOTH = 799,
		icon_BRUSH_SNAKE_HOOK = 800,
		icon_BRUSH_SOFTEN = 801,
		icon_BRUSH_TEXDRAW = 802,
		icon_BRUSH_TEXFILL = 803,
		icon_BRUSH_TEXMASK = 804,
		icon_BRUSH_THUMB = 805,
		icon_BRUSH_ROTATE = 806,
		icon_GPBRUSH_SMOOTH = 807,
		icon_GPBRUSH_THICKNESS = 808,
		icon_GPBRUSH_STRENGTH = 809,
		icon_GPBRUSH_GRAB = 810,
		icon_GPBRUSH_PUSH = 811,
		icon_GPBRUSH_TWIST = 812,
		icon_GPBRUSH_PINCH = 813,
		icon_GPBRUSH_RANDOMIZE = 814,
		icon_GPBRUSH_CLONE = 815,
		icon_GPBRUSH_WEIGHT = 816,
		icon_GPBRUSH_PENCIL = 817,
		icon_GPBRUSH_PEN = 818,
		icon_GPBRUSH_INK = 819,
		icon_GPBRUSH_INKNOISE = 820,
		icon_GPBRUSH_BLOCK = 821,
		icon_GPBRUSH_MARKER = 822,
		icon_GPBRUSH_FILL = 823,
		icon_GPBRUSH_AIRBRUSH = 824,
		icon_GPBRUSH_CHISEL = 825,
		icon_GPBRUSH_ERASE_SOFT = 826,
		icon_GPBRUSH_ERASE_HARD = 827,
		icon_GPBRUSH_ERASE_STROKE = 828,
		icon_BRUSH_CURVES_ADD = 829,
		icon_BRUSH_CURVES_COMB = 830,
		icon_BRUSH_CURVES_CUT = 831,
		icon_BRUSH_CURVES_DELETE = 832,
		icon_BRUSH_CURVES_DENSITY = 833,
		icon_BRUSH_CURVES_GROW_SHRINK = 834,
		icon_BRUSH_CURVES_PINCH = 835,
		icon_BRUSH_CURVES_PUFF = 836,
		icon_BRUSH_CURVES_SLIDE = 837,
		icon_BRUSH_CURVES_SMOOTH = 838,
		icon_BRUSH_CURVES_SNAKE_HOOK = 839,
		icon_KEYTYPE_KEYFRAME_VEC = 840,
		icon_KEYTYPE_BREAKDOWN_VEC = 841,
		icon_KEYTYPE_EXTREME_VEC = 842,
		icon_KEYTYPE_JITTER_VEC = 843,
		icon_KEYTYPE_MOVING_HOLD_VEC = 844,
		icon_HANDLETYPE_FREE_VEC = 845,
		icon_HANDLETYPE_ALIGNED_VEC = 846,
		icon_HANDLETYPE_VECTOR_VEC = 847,
		icon_HANDLETYPE_AUTO_VEC = 848,
		icon_HANDLETYPE_AUTO_CLAMP_VEC = 849,
		icon_COLORSET_01_VEC = 850,
		icon_COLORSET_02_VEC = 851,
		icon_COLORSET_03_VEC = 852,
		icon_COLORSET_04_VEC = 853,
		icon_COLORSET_05_VEC = 854,
		icon_COLORSET_06_VEC = 855,
		icon_COLORSET_07_VEC = 856,
		icon_COLORSET_08_VEC = 857,
		icon_COLORSET_09_VEC = 858,
		icon_COLORSET_10_VEC = 859,
		icon_COLORSET_11_VEC = 860,
		icon_COLORSET_12_VEC = 861,
		icon_COLORSET_13_VEC = 862,
		icon_COLORSET_14_VEC = 863,
		icon_COLORSET_15_VEC = 864,
		icon_COLORSET_16_VEC = 865,
		icon_COLORSET_17_VEC = 866,
		icon_COLORSET_18_VEC = 867,
		icon_COLORSET_19_VEC = 868,
		icon_COLORSET_20_VEC = 869,
		icon_COLLECTION_COLOR_01 = 870,
		icon_COLLECTION_COLOR_02 = 871,
		icon_COLLECTION_COLOR_03 = 872,
		icon_COLLECTION_COLOR_04 = 873,
		icon_COLLECTION_COLOR_05 = 874,
		icon_COLLECTION_COLOR_06 = 875,
		icon_COLLECTION_COLOR_07 = 876,
		icon_COLLECTION_COLOR_08 = 877,
		icon_SEQUENCE_COLOR_01 = 878,
		icon_SEQUENCE_COLOR_02 = 879,
		icon_SEQUENCE_COLOR_03 = 880,
		icon_SEQUENCE_COLOR_04 = 881,
		icon_SEQUENCE_COLOR_05 = 882,
		icon_SEQUENCE_COLOR_06 = 883,
		icon_SEQUENCE_COLOR_07 = 884,
		icon_SEQUENCE_COLOR_08 = 885,
		icon_SEQUENCE_COLOR_09 = 886,
		icon_LIBRARY_DATA_INDIRECT = 887,
		icon_LIBRARY_DATA_OVERRIDE_NONEDITABLE = 888,
		icon_EVENT_A = 889,
		icon_EVENT_B = 890,
		icon_EVENT_C = 891,
		icon_EVENT_D = 892,
		icon_EVENT_E = 893,
		icon_EVENT_F = 894,
		icon_EVENT_G = 895,
		icon_EVENT_H = 896,
		icon_EVENT_I = 897,
		icon_EVENT_J = 898,
		icon_EVENT_K = 899,
		icon_EVENT_L = 900,
		icon_EVENT_M = 901,
		icon_EVENT_N = 902,
		icon_EVENT_O = 903,
		icon_EVENT_P = 904,
		icon_EVENT_Q = 905,
		icon_EVENT_R = 906,
		icon_EVENT_S = 907,
		icon_EVENT_T = 908,
		icon_EVENT_U = 909,
		icon_EVENT_V = 910,
		icon_EVENT_W = 911,
		icon_EVENT_X = 912,
		icon_EVENT_Y = 913,
		icon_EVENT_Z = 914,
		icon_EVENT_SHIFT = 915,
		icon_EVENT_CTRL = 916,
		icon_EVENT_ALT = 917,
		icon_EVENT_OS = 918,
		icon_EVENT_F1 = 919,
		icon_EVENT_F2 = 920,
		icon_EVENT_F3 = 921,
		icon_EVENT_F4 = 922,
		icon_EVENT_F5 = 923,
		icon_EVENT_F6 = 924,
		icon_EVENT_F7 = 925,
		icon_EVENT_F8 = 926,
		icon_EVENT_F9 = 927,
		icon_EVENT_F10 = 928,
		icon_EVENT_F11 = 929,
		icon_EVENT_F12 = 930,
		icon_EVENT_ESC = 931,
		icon_EVENT_TAB = 932,
		icon_EVENT_PAGEUP = 933,
		icon_EVENT_PAGEDOWN = 934,
		icon_EVENT_RETURN = 935,
		icon_EVENT_SPACEKEY = 936,
	};
	inline icon_enum icon(void);
	inline void icon(icon_enum value);
	inline bool is_readonly(void);
	inline void is_readonly(bool value);
	inline bool is_animatable(void);
	inline void is_animatable(bool value);
	inline bool is_overridable(void);
	inline void is_overridable(bool value);
	inline bool is_required(void);
	inline void is_required(bool value);
	inline bool is_argument_optional(void);
	inline void is_argument_optional(bool value);
	inline bool is_never_none(void);
	inline void is_never_none(bool value);
	inline bool is_hidden(void);
	inline void is_hidden(bool value);
	inline bool is_skip_save(void);
	inline void is_skip_save(bool value);
	inline bool is_output(void);
	inline void is_output(bool value);
	inline bool is_registered(void);
	inline void is_registered(bool value);
	inline bool is_registered_optional(void);
	inline void is_registered_optional(bool value);
	inline bool is_runtime(void);
	inline void is_runtime(bool value);
	inline bool is_enum_flag(void);
	inline void is_enum_flag(bool value);
	inline bool is_library_editable(void);
	inline void is_library_editable(bool value);
	inline bool is_path_output(void);
	inline void is_path_output(bool value);
	enum tags_enum {
	};
	inline tags_enum tags(void);
	inline void tags(tags_enum value);

};

/**************** Boolean Definition ****************/

class BoolProperty : public Property {
public:
	BoolProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline bool default_value(void);
	inline void default_value(bool value);
	inline Array<bool, 3> default_array(void);
	inline void default_array(bool values[3]);
	inline int array_length(void);
	inline void array_length(int value);
	inline Array<int, 3> array_dimensions(void);
	inline void array_dimensions(int values[3]);
	inline bool is_array(void);
	inline void is_array(bool value);

};

/**************** Int Definition ****************/

class IntProperty : public Property {
public:
	IntProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);
	inline Array<int, 3> default_array(void);
	inline void default_array(int values[3]);
	inline int array_length(void);
	inline void array_length(int value);
	inline Array<int, 3> array_dimensions(void);
	inline void array_dimensions(int values[3]);
	inline bool is_array(void);
	inline void is_array(bool value);
	inline int hard_min(void);
	inline void hard_min(int value);
	inline int hard_max(void);
	inline void hard_max(int value);
	inline int soft_min(void);
	inline void soft_min(int value);
	inline int soft_max(void);
	inline void soft_max(int value);
	inline int step(void);
	inline void step(int value);

};

/**************** Float Definition ****************/

class FloatProperty : public Property {
public:
	FloatProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);
	inline Array<float, 3> default_array(void);
	inline void default_array(float values[3]);
	inline int array_length(void);
	inline void array_length(int value);
	inline Array<int, 3> array_dimensions(void);
	inline void array_dimensions(int values[3]);
	inline bool is_array(void);
	inline void is_array(bool value);
	inline float hard_min(void);
	inline void hard_min(float value);
	inline float hard_max(void);
	inline void hard_max(float value);
	inline float soft_min(void);
	inline void soft_min(float value);
	inline float soft_max(void);
	inline void soft_max(float value);
	inline float step(void);
	inline void step(float value);
	inline int precision(void);
	inline void precision(int value);

};

/**************** String Definition ****************/

class StringProperty : public Property {
public:
	StringProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline std::string default_value(void);
	inline void default_value(const std::string& value);
	inline int length_max(void);
	inline void length_max(int value);

};

/**************** Enum Definition ****************/

class EnumProperty : public Property {
public:
	EnumProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg),
		enum_items(ptr_arg),
		enum_items_static(ptr_arg),
		enum_items_static_ui(ptr_arg)
		{}

	enum default_value_enum {
		default_value_DUMMY = 0,
	};
	inline default_value_enum default_value(void);
	inline void default_value(default_value_enum value);
	enum default_flag_enum {
		default_flag_DUMMY = 0,
	};
	inline default_flag_enum default_flag(void);
	inline void default_flag(default_flag_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, EnumProperty, enum_items, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, EnumProperty, enum_items_static, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, EnumProperty, enum_items_static_ui, false, false, false)

};

/**************** Enum Item Definition ****************/

class EnumPropertyItem : public Pointer {
public:
	EnumPropertyItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline int value(void);
	inline void value(int value);
	enum icon_enum {
		icon_NONE = 0,
		icon_QUESTION = 1,
		icon_ERROR = 2,
		icon_CANCEL = 3,
		icon_TRIA_RIGHT = 4,
		icon_TRIA_DOWN = 5,
		icon_TRIA_LEFT = 6,
		icon_TRIA_UP = 7,
		icon_ARROW_LEFTRIGHT = 8,
		icon_PLUS = 9,
		icon_DISCLOSURE_TRI_RIGHT = 10,
		icon_DISCLOSURE_TRI_DOWN = 11,
		icon_RADIOBUT_OFF = 12,
		icon_RADIOBUT_ON = 13,
		icon_MENU_PANEL = 14,
		icon_BLENDER = 15,
		icon_GRIP = 16,
		icon_DOT = 17,
		icon_COLLAPSEMENU = 18,
		icon_X = 19,
		icon_DUPLICATE = 20,
		icon_TRASH = 21,
		icon_COLLECTION_NEW = 22,
		icon_OPTIONS = 23,
		icon_NODE = 24,
		icon_NODE_SEL = 25,
		icon_WINDOW = 26,
		icon_WORKSPACE = 27,
		icon_RIGHTARROW_THIN = 28,
		icon_BORDERMOVE = 29,
		icon_VIEWZOOM = 30,
		icon_ADD = 31,
		icon_REMOVE = 32,
		icon_PANEL_CLOSE = 33,
		icon_COPY_ID = 34,
		icon_EYEDROPPER = 35,
		icon_CHECKMARK = 36,
		icon_AUTO = 37,
		icon_CHECKBOX_DEHLT = 38,
		icon_CHECKBOX_HLT = 39,
		icon_UNLOCKED = 40,
		icon_LOCKED = 41,
		icon_UNPINNED = 42,
		icon_PINNED = 43,
		icon_SCREEN_BACK = 44,
		icon_RIGHTARROW = 45,
		icon_DOWNARROW_HLT = 46,
		icon_FCURVE_SNAPSHOT = 47,
		icon_OBJECT_HIDDEN = 48,
		icon_TOPBAR = 49,
		icon_STATUSBAR = 50,
		icon_PLUGIN = 51,
		icon_HELP = 52,
		icon_GHOST_ENABLED = 53,
		icon_COLOR = 54,
		icon_UNLINKED = 55,
		icon_LINKED = 56,
		icon_HAND = 57,
		icon_ZOOM_ALL = 58,
		icon_ZOOM_SELECTED = 59,
		icon_ZOOM_PREVIOUS = 60,
		icon_ZOOM_IN = 61,
		icon_ZOOM_OUT = 62,
		icon_DRIVER_DISTANCE = 63,
		icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		icon_DRIVER_TRANSFORM = 65,
		icon_FREEZE = 66,
		icon_STYLUS_PRESSURE = 67,
		icon_GHOST_DISABLED = 68,
		icon_FILE_NEW = 69,
		icon_FILE_TICK = 70,
		icon_QUIT = 71,
		icon_URL = 72,
		icon_RECOVER_LAST = 73,
		icon_THREE_DOTS = 74,
		icon_FULLSCREEN_ENTER = 75,
		icon_FULLSCREEN_EXIT = 76,
		icon_BRUSHES_ALL = 77,
		icon_LIGHT = 78,
		icon_MATERIAL = 79,
		icon_TEXTURE = 80,
		icon_ANIM = 81,
		icon_WORLD = 82,
		icon_SCENE = 83,
		icon_OUTPUT = 84,
		icon_SCRIPT = 87,
		icon_PARTICLES = 88,
		icon_PHYSICS = 89,
		icon_SPEAKER = 90,
		icon_TOOL_SETTINGS = 92,
		icon_SHADERFX = 93,
		icon_MODIFIER = 94,
		icon_BLANK1 = 101,
		icon_FAKE_USER_OFF = 102,
		icon_FAKE_USER_ON = 103,
		icon_VIEW3D = 104,
		icon_GRAPH = 105,
		icon_OUTLINER = 106,
		icon_PROPERTIES = 107,
		icon_FILEBROWSER = 108,
		icon_IMAGE = 109,
		icon_INFO = 110,
		icon_SEQUENCE = 111,
		icon_TEXT = 112,
		icon_SPREADSHEET = 113,
		icon_SOUND = 114,
		icon_ACTION = 115,
		icon_NLA = 116,
		icon_PREFERENCES = 117,
		icon_TIME = 118,
		icon_NODETREE = 119,
		icon_GEOMETRY_NODES = 120,
		icon_CONSOLE = 121,
		icon_TRACKER = 123,
		icon_ASSET_MANAGER = 124,
		icon_NODE_COMPOSITING = 125,
		icon_NODE_TEXTURE = 126,
		icon_NODE_MATERIAL = 127,
		icon_UV = 128,
		icon_OBJECT_DATAMODE = 130,
		icon_EDITMODE_HLT = 131,
		icon_UV_DATA = 132,
		icon_VPAINT_HLT = 133,
		icon_TPAINT_HLT = 134,
		icon_WPAINT_HLT = 135,
		icon_SCULPTMODE_HLT = 136,
		icon_POSE_HLT = 137,
		icon_PARTICLEMODE = 138,
		icon_TRACKING = 146,
		icon_TRACKING_BACKWARDS = 147,
		icon_TRACKING_FORWARDS = 148,
		icon_TRACKING_BACKWARDS_SINGLE = 149,
		icon_TRACKING_FORWARDS_SINGLE = 150,
		icon_TRACKING_CLEAR_BACKWARDS = 151,
		icon_TRACKING_CLEAR_FORWARDS = 152,
		icon_TRACKING_REFINE_BACKWARDS = 153,
		icon_TRACKING_REFINE_FORWARDS = 154,
		icon_SCENE_DATA = 156,
		icon_RENDERLAYERS = 157,
		icon_WORLD_DATA = 158,
		icon_OBJECT_DATA = 159,
		icon_MESH_DATA = 160,
		icon_CURVE_DATA = 161,
		icon_META_DATA = 162,
		icon_LATTICE_DATA = 163,
		icon_LIGHT_DATA = 164,
		icon_MATERIAL_DATA = 165,
		icon_TEXTURE_DATA = 166,
		icon_ANIM_DATA = 167,
		icon_CAMERA_DATA = 168,
		icon_PARTICLE_DATA = 169,
		icon_LIBRARY_DATA_DIRECT = 170,
		icon_GROUP = 171,
		icon_ARMATURE_DATA = 172,
		icon_COMMUNITY = 173,
		icon_BONE_DATA = 174,
		icon_CONSTRAINT = 175,
		icon_SHAPEKEY_DATA = 176,
		icon_CONSTRAINT_BONE = 177,
		icon_CAMERA_STEREO = 178,
		icon_PACKAGE = 179,
		icon_UGLYPACKAGE = 180,
		icon_EXPERIMENTAL = 181,
		icon_BRUSH_DATA = 182,
		icon_IMAGE_DATA = 183,
		icon_FILE = 184,
		icon_FCURVE = 185,
		icon_FONT_DATA = 186,
		icon_RENDER_RESULT = 187,
		icon_SURFACE_DATA = 188,
		icon_EMPTY_DATA = 189,
		icon_PRESET = 190,
		icon_RENDER_ANIMATION = 191,
		icon_RENDER_STILL = 192,
		icon_LIBRARY_DATA_BROKEN = 193,
		icon_BOIDS = 194,
		icon_STRANDS = 195,
		icon_GREASEPENCIL = 197,
		icon_LINE_DATA = 198,
		icon_LIBRARY_DATA_OVERRIDE = 199,
		icon_GROUP_BONE = 200,
		icon_GROUP_VERTEX = 201,
		icon_GROUP_VCOL = 202,
		icon_GROUP_UVS = 203,
		icon_FACE_MAPS = 204,
		icon_RNA = 206,
		icon_RNA_ADD = 207,
		icon_MOUSE_LMB = 208,
		icon_MOUSE_MMB = 209,
		icon_MOUSE_RMB = 210,
		icon_MOUSE_MOVE = 211,
		icon_MOUSE_LMB_DRAG = 212,
		icon_MOUSE_MMB_DRAG = 213,
		icon_MOUSE_RMB_DRAG = 214,
		icon_MEMORY = 215,
		icon_PRESET_NEW = 216,
		icon_DECORATE = 218,
		icon_DECORATE_KEYFRAME = 219,
		icon_DECORATE_ANIMATE = 220,
		icon_DECORATE_DRIVER = 221,
		icon_DECORATE_LINKED = 222,
		icon_DECORATE_LIBRARY_OVERRIDE = 223,
		icon_DECORATE_UNLOCKED = 224,
		icon_DECORATE_LOCKED = 225,
		icon_DECORATE_OVERRIDE = 226,
		icon_FUND = 227,
		icon_TRACKER_DATA = 228,
		icon_HEART = 229,
		icon_ORPHAN_DATA = 230,
		icon_USER = 231,
		icon_SYSTEM = 232,
		icon_SETTINGS = 233,
		icon_OUTLINER_OB_EMPTY = 234,
		icon_OUTLINER_OB_MESH = 235,
		icon_OUTLINER_OB_CURVE = 236,
		icon_OUTLINER_OB_LATTICE = 237,
		icon_OUTLINER_OB_META = 238,
		icon_OUTLINER_OB_LIGHT = 239,
		icon_OUTLINER_OB_CAMERA = 240,
		icon_OUTLINER_OB_ARMATURE = 241,
		icon_OUTLINER_OB_FONT = 242,
		icon_OUTLINER_OB_SURFACE = 243,
		icon_OUTLINER_OB_SPEAKER = 244,
		icon_OUTLINER_OB_FORCE_FIELD = 245,
		icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		icon_OUTLINER_OB_GREASEPENCIL = 247,
		icon_OUTLINER_OB_LIGHTPROBE = 248,
		icon_OUTLINER_OB_IMAGE = 249,
		icon_OUTLINER_COLLECTION = 250,
		icon_RESTRICT_COLOR_OFF = 251,
		icon_RESTRICT_COLOR_ON = 252,
		icon_HIDE_ON = 253,
		icon_HIDE_OFF = 254,
		icon_RESTRICT_SELECT_ON = 255,
		icon_RESTRICT_SELECT_OFF = 256,
		icon_RESTRICT_RENDER_ON = 257,
		icon_RESTRICT_RENDER_OFF = 258,
		icon_RESTRICT_INSTANCED_OFF = 259,
		icon_OUTLINER_DATA_EMPTY = 260,
		icon_OUTLINER_DATA_MESH = 261,
		icon_OUTLINER_DATA_CURVE = 262,
		icon_OUTLINER_DATA_LATTICE = 263,
		icon_OUTLINER_DATA_META = 264,
		icon_OUTLINER_DATA_LIGHT = 265,
		icon_OUTLINER_DATA_CAMERA = 266,
		icon_OUTLINER_DATA_ARMATURE = 267,
		icon_OUTLINER_DATA_FONT = 268,
		icon_OUTLINER_DATA_SURFACE = 269,
		icon_OUTLINER_DATA_SPEAKER = 270,
		icon_OUTLINER_DATA_LIGHTPROBE = 271,
		icon_OUTLINER_DATA_GP_LAYER = 272,
		icon_OUTLINER_DATA_GREASEPENCIL = 273,
		icon_GP_SELECT_POINTS = 274,
		icon_GP_SELECT_STROKES = 275,
		icon_GP_MULTIFRAME_EDITING = 276,
		icon_GP_ONLY_SELECTED = 277,
		icon_GP_SELECT_BETWEEN_STROKES = 278,
		icon_MODIFIER_OFF = 279,
		icon_MODIFIER_ON = 280,
		icon_ONIONSKIN_OFF = 281,
		icon_ONIONSKIN_ON = 282,
		icon_RESTRICT_VIEW_ON = 283,
		icon_RESTRICT_VIEW_OFF = 284,
		icon_RESTRICT_INSTANCED_ON = 285,
		icon_MESH_PLANE = 286,
		icon_MESH_CUBE = 287,
		icon_MESH_CIRCLE = 288,
		icon_MESH_UVSPHERE = 289,
		icon_MESH_ICOSPHERE = 290,
		icon_MESH_GRID = 291,
		icon_MESH_MONKEY = 292,
		icon_MESH_CYLINDER = 293,
		icon_MESH_TORUS = 294,
		icon_MESH_CONE = 295,
		icon_MESH_CAPSULE = 296,
		icon_EMPTY_SINGLE_ARROW = 297,
		icon_LIGHT_POINT = 298,
		icon_LIGHT_SUN = 299,
		icon_LIGHT_SPOT = 300,
		icon_LIGHT_HEMI = 301,
		icon_LIGHT_AREA = 302,
		icon_CUBE = 303,
		icon_SPHERE = 304,
		icon_CONE = 305,
		icon_META_PLANE = 306,
		icon_META_CUBE = 307,
		icon_META_BALL = 308,
		icon_META_ELLIPSOID = 309,
		icon_META_CAPSULE = 310,
		icon_SURFACE_NCURVE = 312,
		icon_SURFACE_NCIRCLE = 313,
		icon_SURFACE_NSURFACE = 314,
		icon_SURFACE_NCYLINDER = 315,
		icon_SURFACE_NSPHERE = 316,
		icon_SURFACE_NTORUS = 317,
		icon_EMPTY_AXIS = 318,
		icon_STROKE = 319,
		icon_EMPTY_ARROWS = 320,
		icon_CURVE_BEZCURVE = 321,
		icon_CURVE_BEZCIRCLE = 322,
		icon_CURVE_NCURVE = 323,
		icon_CURVE_NCIRCLE = 324,
		icon_CURVE_PATH = 325,
		icon_LIGHTPROBE_SPHERE = 326,
		icon_LIGHTPROBE_PLANE = 327,
		icon_LIGHTPROBE_VOLUME = 328,
		icon_COLOR_RED = 331,
		icon_COLOR_GREEN = 332,
		icon_COLOR_BLUE = 333,
		icon_TRIA_RIGHT_BAR = 334,
		icon_TRIA_DOWN_BAR = 335,
		icon_TRIA_LEFT_BAR = 336,
		icon_TRIA_UP_BAR = 337,
		icon_FORCE_FORCE = 338,
		icon_FORCE_WIND = 339,
		icon_FORCE_VORTEX = 340,
		icon_FORCE_MAGNETIC = 341,
		icon_FORCE_HARMONIC = 342,
		icon_FORCE_CHARGE = 343,
		icon_FORCE_LENNARDJONES = 344,
		icon_FORCE_TEXTURE = 345,
		icon_FORCE_CURVE = 346,
		icon_FORCE_BOID = 347,
		icon_FORCE_TURBULENCE = 348,
		icon_FORCE_DRAG = 349,
		icon_FORCE_FLUIDFLOW = 350,
		icon_RIGID_BODY = 353,
		icon_RIGID_BODY_CONSTRAINT = 354,
		icon_SPLIT_HORIZONTAL = 359,
		icon_SPLIT_VERTICAL = 360,
		icon_IMAGE_PLANE = 361,
		icon_IMAGE_BACKGROUND = 362,
		icon_IMAGE_REFERENCE = 363,
		icon_NODE_INSERT_ON = 367,
		icon_NODE_INSERT_OFF = 368,
		icon_NODE_TOP = 369,
		icon_NODE_SIDE = 370,
		icon_NODE_CORNER = 371,
		icon_ANCHOR_TOP = 372,
		icon_ANCHOR_BOTTOM = 373,
		icon_ANCHOR_LEFT = 374,
		icon_ANCHOR_RIGHT = 375,
		icon_ANCHOR_CENTER = 376,
		icon_SELECT_SET = 385,
		icon_SELECT_EXTEND = 386,
		icon_SELECT_SUBTRACT = 387,
		icon_SELECT_INTERSECT = 388,
		icon_SELECT_DIFFERENCE = 389,
		icon_ALIGN_LEFT = 390,
		icon_ALIGN_CENTER = 391,
		icon_ALIGN_RIGHT = 392,
		icon_ALIGN_JUSTIFY = 393,
		icon_ALIGN_FLUSH = 394,
		icon_ALIGN_TOP = 395,
		icon_ALIGN_MIDDLE = 396,
		icon_ALIGN_BOTTOM = 397,
		icon_BOLD = 398,
		icon_ITALIC = 399,
		icon_UNDERLINE = 400,
		icon_SMALL_CAPS = 401,
		icon_CON_ACTION = 404,
		icon_MOD_ENVELOPE = 406,
		icon_MOD_OUTLINE = 407,
		icon_MOD_LENGTH = 408,
		icon_MOD_DASH = 409,
		icon_MOD_LINEART = 410,
		icon_HOLDOUT_OFF = 412,
		icon_HOLDOUT_ON = 413,
		icon_INDIRECT_ONLY_OFF = 414,
		icon_INDIRECT_ONLY_ON = 415,
		icon_CON_CAMERASOLVER = 416,
		icon_CON_FOLLOWTRACK = 417,
		icon_CON_OBJECTSOLVER = 418,
		icon_CON_LOCLIKE = 419,
		icon_CON_ROTLIKE = 420,
		icon_CON_SIZELIKE = 421,
		icon_CON_TRANSLIKE = 422,
		icon_CON_DISTLIMIT = 423,
		icon_CON_LOCLIMIT = 424,
		icon_CON_ROTLIMIT = 425,
		icon_CON_SIZELIMIT = 426,
		icon_CON_SAMEVOL = 427,
		icon_CON_TRANSFORM = 428,
		icon_CON_TRANSFORM_CACHE = 429,
		icon_CON_CLAMPTO = 430,
		icon_CON_KINEMATIC = 431,
		icon_CON_LOCKTRACK = 432,
		icon_CON_SPLINEIK = 433,
		icon_CON_STRETCHTO = 434,
		icon_CON_TRACKTO = 435,
		icon_CON_ARMATURE = 436,
		icon_CON_CHILDOF = 437,
		icon_CON_FLOOR = 438,
		icon_CON_FOLLOWPATH = 439,
		icon_CON_PIVOT = 440,
		icon_CON_SHRINKWRAP = 441,
		icon_MODIFIER_DATA = 442,
		icon_MOD_WAVE = 443,
		icon_MOD_BUILD = 444,
		icon_MOD_DECIM = 445,
		icon_MOD_MIRROR = 446,
		icon_MOD_SOFT = 447,
		icon_MOD_SUBSURF = 448,
		icon_HOOK = 449,
		icon_MOD_PHYSICS = 450,
		icon_MOD_PARTICLES = 451,
		icon_MOD_BOOLEAN = 452,
		icon_MOD_EDGESPLIT = 453,
		icon_MOD_ARRAY = 454,
		icon_MOD_UVPROJECT = 455,
		icon_MOD_DISPLACE = 456,
		icon_MOD_CURVE = 457,
		icon_MOD_LATTICE = 458,
		icon_MOD_TINT = 459,
		icon_MOD_ARMATURE = 460,
		icon_MOD_SHRINKWRAP = 461,
		icon_MOD_CAST = 462,
		icon_MOD_MESHDEFORM = 463,
		icon_MOD_BEVEL = 464,
		icon_MOD_SMOOTH = 465,
		icon_MOD_SIMPLEDEFORM = 466,
		icon_MOD_MASK = 467,
		icon_MOD_CLOTH = 468,
		icon_MOD_EXPLODE = 469,
		icon_MOD_FLUIDSIM = 470,
		icon_MOD_MULTIRES = 471,
		icon_MOD_FLUID = 472,
		icon_MOD_SOLIDIFY = 473,
		icon_MOD_SCREW = 474,
		icon_MOD_VERTEX_WEIGHT = 475,
		icon_MOD_DYNAMICPAINT = 476,
		icon_MOD_REMESH = 477,
		icon_MOD_OCEAN = 478,
		icon_MOD_WARP = 479,
		icon_MOD_SKIN = 480,
		icon_MOD_TRIANGULATE = 481,
		icon_MOD_WIREFRAME = 482,
		icon_MOD_DATA_TRANSFER = 483,
		icon_MOD_NORMALEDIT = 484,
		icon_MOD_PARTICLE_INSTANCE = 485,
		icon_MOD_HUE_SATURATION = 486,
		icon_MOD_NOISE = 487,
		icon_MOD_OFFSET = 488,
		icon_MOD_SIMPLIFY = 489,
		icon_MOD_THICKNESS = 490,
		icon_MOD_INSTANCE = 491,
		icon_MOD_TIME = 492,
		icon_MOD_OPACITY = 493,
		icon_REC = 494,
		icon_PLAY = 495,
		icon_FF = 496,
		icon_REW = 497,
		icon_PAUSE = 498,
		icon_PREV_KEYFRAME = 499,
		icon_NEXT_KEYFRAME = 500,
		icon_PLAY_SOUND = 501,
		icon_PLAY_REVERSE = 502,
		icon_PREVIEW_RANGE = 503,
		icon_ACTION_TWEAK = 504,
		icon_PMARKER_ACT = 505,
		icon_PMARKER_SEL = 506,
		icon_PMARKER = 507,
		icon_MARKER_HLT = 508,
		icon_MARKER = 509,
		icon_KEYFRAME_HLT = 510,
		icon_KEYFRAME = 511,
		icon_KEYINGSET = 512,
		icon_KEY_DEHLT = 513,
		icon_KEY_HLT = 514,
		icon_MUTE_IPO_OFF = 515,
		icon_MUTE_IPO_ON = 516,
		icon_DRIVER = 519,
		icon_SOLO_OFF = 520,
		icon_SOLO_ON = 521,
		icon_FRAME_PREV = 522,
		icon_FRAME_NEXT = 523,
		icon_NLA_PUSHDOWN = 524,
		icon_IPO_CONSTANT = 525,
		icon_IPO_LINEAR = 526,
		icon_IPO_BEZIER = 527,
		icon_IPO_SINE = 528,
		icon_IPO_QUAD = 529,
		icon_IPO_CUBIC = 530,
		icon_IPO_QUART = 531,
		icon_IPO_QUINT = 532,
		icon_IPO_EXPO = 533,
		icon_IPO_CIRC = 534,
		icon_IPO_BOUNCE = 535,
		icon_IPO_ELASTIC = 536,
		icon_IPO_BACK = 537,
		icon_IPO_EASE_IN = 538,
		icon_IPO_EASE_OUT = 539,
		icon_IPO_EASE_IN_OUT = 540,
		icon_NORMALIZE_FCURVES = 541,
		icon_ORIENTATION_PARENT = 542,
		icon_VERTEXSEL = 546,
		icon_EDGESEL = 547,
		icon_FACESEL = 548,
		icon_CURSOR = 550,
		icon_PIVOT_BOUNDBOX = 551,
		icon_PIVOT_CURSOR = 552,
		icon_PIVOT_INDIVIDUAL = 553,
		icon_PIVOT_MEDIAN = 554,
		icon_PIVOT_ACTIVE = 555,
		icon_CENTER_ONLY = 556,
		icon_ROOTCURVE = 557,
		icon_SMOOTHCURVE = 558,
		icon_SPHERECURVE = 559,
		icon_INVERSESQUARECURVE = 560,
		icon_SHARPCURVE = 561,
		icon_LINCURVE = 562,
		icon_NOCURVE = 563,
		icon_RNDCURVE = 564,
		icon_PROP_OFF = 565,
		icon_PROP_ON = 566,
		icon_PROP_CON = 567,
		icon_PROP_PROJECTED = 568,
		icon_PARTICLE_POINT = 569,
		icon_PARTICLE_TIP = 570,
		icon_PARTICLE_PATH = 571,
		icon_SNAP_FACE_NEAREST = 572,
		icon_SNAP_FACE_CENTER = 573,
		icon_SNAP_PERPENDICULAR = 574,
		icon_SNAP_MIDPOINT = 575,
		icon_SNAP_OFF = 576,
		icon_SNAP_ON = 577,
		icon_SNAP_NORMAL = 578,
		icon_SNAP_GRID = 579,
		icon_SNAP_VERTEX = 580,
		icon_SNAP_EDGE = 581,
		icon_SNAP_FACE = 582,
		icon_SNAP_VOLUME = 583,
		icon_SNAP_INCREMENT = 584,
		icon_STICKY_UVS_LOC = 585,
		icon_STICKY_UVS_DISABLE = 586,
		icon_STICKY_UVS_VERT = 587,
		icon_CLIPUV_DEHLT = 588,
		icon_CLIPUV_HLT = 589,
		icon_SNAP_PEEL_OBJECT = 590,
		icon_GRID = 591,
		icon_OBJECT_ORIGIN = 592,
		icon_ORIENTATION_GLOBAL = 593,
		icon_ORIENTATION_GIMBAL = 594,
		icon_ORIENTATION_LOCAL = 595,
		icon_ORIENTATION_NORMAL = 596,
		icon_ORIENTATION_VIEW = 597,
		icon_COPYDOWN = 598,
		icon_PASTEDOWN = 599,
		icon_PASTEFLIPUP = 600,
		icon_PASTEFLIPDOWN = 601,
		icon_VIS_SEL_11 = 602,
		icon_VIS_SEL_10 = 603,
		icon_VIS_SEL_01 = 604,
		icon_VIS_SEL_00 = 605,
		icon_AUTOMERGE_OFF = 607,
		icon_AUTOMERGE_ON = 608,
		icon_UV_VERTEXSEL = 610,
		icon_UV_EDGESEL = 611,
		icon_UV_FACESEL = 612,
		icon_UV_ISLANDSEL = 613,
		icon_UV_SYNC_SELECT = 614,
		icon_GP_CAPS_FLAT = 615,
		icon_GP_CAPS_ROUND = 616,
		icon_FIXED_SIZE = 617,
		icon_TRANSFORM_ORIGINS = 618,
		icon_GIZMO = 619,
		icon_ORIENTATION_CURSOR = 620,
		icon_NORMALS_VERTEX = 621,
		icon_NORMALS_FACE = 622,
		icon_NORMALS_VERTEX_FACE = 623,
		icon_SHADING_BBOX = 624,
		icon_SHADING_WIRE = 625,
		icon_SHADING_SOLID = 626,
		icon_SHADING_RENDERED = 627,
		icon_SHADING_TEXTURE = 628,
		icon_OVERLAY = 629,
		icon_XRAY = 630,
		icon_LOCKVIEW_OFF = 633,
		icon_LOCKVIEW_ON = 634,
		icon_AXIS_SIDE = 636,
		icon_AXIS_FRONT = 637,
		icon_AXIS_TOP = 638,
		icon_LAYER_USED = 643,
		icon_LAYER_ACTIVE = 644,
		icon_OUTLINER_OB_CURVES = 650,
		icon_OUTLINER_DATA_CURVES = 651,
		icon_CURVES_DATA = 652,
		icon_OUTLINER_OB_POINTCLOUD = 653,
		icon_OUTLINER_DATA_POINTCLOUD = 654,
		icon_POINTCLOUD_DATA = 655,
		icon_OUTLINER_OB_VOLUME = 656,
		icon_OUTLINER_DATA_VOLUME = 657,
		icon_VOLUME_DATA = 658,
		icon_CURRENT_FILE = 672,
		icon_HOME = 673,
		icon_DOCUMENTS = 674,
		icon_TEMP = 675,
		icon_SORTALPHA = 676,
		icon_SORTBYEXT = 677,
		icon_SORTTIME = 678,
		icon_SORTSIZE = 679,
		icon_SHORTDISPLAY = 680,
		icon_LONGDISPLAY = 681,
		icon_IMGDISPLAY = 683,
		icon_BOOKMARKS = 686,
		icon_FONTPREVIEW = 687,
		icon_FILTER = 688,
		icon_NEWFOLDER = 689,
		icon_FOLDER_REDIRECT = 690,
		icon_FILE_PARENT = 691,
		icon_FILE_REFRESH = 692,
		icon_FILE_FOLDER = 693,
		icon_FILE_BLANK = 694,
		icon_FILE_BLEND = 695,
		icon_FILE_IMAGE = 696,
		icon_FILE_MOVIE = 697,
		icon_FILE_SCRIPT = 698,
		icon_FILE_SOUND = 699,
		icon_FILE_FONT = 700,
		icon_FILE_TEXT = 701,
		icon_SORT_DESC = 702,
		icon_SORT_ASC = 703,
		icon_LINK_BLEND = 704,
		icon_APPEND_BLEND = 705,
		icon_IMPORT = 706,
		icon_EXPORT = 707,
		icon_LOOP_BACK = 715,
		icon_LOOP_FORWARDS = 716,
		icon_BACK = 717,
		icon_FORWARD = 718,
		icon_FILE_ARCHIVE = 721,
		icon_FILE_CACHE = 722,
		icon_FILE_VOLUME = 723,
		icon_FILE_3D = 724,
		icon_FILE_HIDDEN = 725,
		icon_FILE_BACKUP = 726,
		icon_DISK_DRIVE = 727,
		icon_MATPLANE = 728,
		icon_MATSPHERE = 729,
		icon_MATCUBE = 730,
		icon_MONKEY = 731,
		icon_CURVES = 732,
		icon_ALIASED = 733,
		icon_ANTIALIASED = 734,
		icon_MAT_SPHERE_SKY = 735,
		icon_MATSHADERBALL = 736,
		icon_MATCLOTH = 737,
		icon_MATFLUID = 738,
		icon_WORDWRAP_OFF = 740,
		icon_WORDWRAP_ON = 741,
		icon_SYNTAX_OFF = 742,
		icon_SYNTAX_ON = 743,
		icon_LINENUMBERS_OFF = 744,
		icon_LINENUMBERS_ON = 745,
		icon_SCRIPTPLUGINS = 746,
		icon_DISC = 750,
		icon_DESKTOP = 751,
		icon_EXTERNAL_DRIVE = 752,
		icon_NETWORK_DRIVE = 753,
		icon_SEQ_SEQUENCER = 754,
		icon_SEQ_PREVIEW = 755,
		icon_SEQ_LUMA_WAVEFORM = 756,
		icon_SEQ_CHROMA_SCOPE = 757,
		icon_SEQ_HISTOGRAM = 758,
		icon_SEQ_SPLITVIEW = 759,
		icon_SEQ_STRIP_META = 760,
		icon_SEQ_STRIP_DUPLICATE = 761,
		icon_IMAGE_RGB = 763,
		icon_IMAGE_RGB_ALPHA = 764,
		icon_IMAGE_ALPHA = 765,
		icon_IMAGE_ZDEPTH = 766,
		icon_HANDLE_AUTOCLAMPED = 767,
		icon_HANDLE_AUTO = 768,
		icon_HANDLE_ALIGNED = 769,
		icon_HANDLE_VECTOR = 770,
		icon_HANDLE_FREE = 771,
		icon_VIEW_PERSPECTIVE = 775,
		icon_VIEW_ORTHO = 776,
		icon_VIEW_CAMERA = 777,
		icon_VIEW_PAN = 778,
		icon_VIEW_ZOOM = 779,
		icon_BRUSH_BLOB = 780,
		icon_BRUSH_BLUR = 781,
		icon_BRUSH_CLAY = 782,
		icon_BRUSH_CLAY_STRIPS = 783,
		icon_BRUSH_CLONE = 784,
		icon_BRUSH_CREASE = 785,
		icon_BRUSH_FILL = 786,
		icon_BRUSH_FLATTEN = 787,
		icon_BRUSH_GRAB = 788,
		icon_BRUSH_INFLATE = 789,
		icon_BRUSH_LAYER = 790,
		icon_BRUSH_MASK = 791,
		icon_BRUSH_MIX = 792,
		icon_BRUSH_NUDGE = 793,
		icon_BRUSH_PAINT_SELECT = 794,
		icon_BRUSH_PINCH = 795,
		icon_BRUSH_SCRAPE = 796,
		icon_BRUSH_SCULPT_DRAW = 797,
		icon_BRUSH_SMEAR = 798,
		icon_BRUSH_SMOOTH = 799,
		icon_BRUSH_SNAKE_HOOK = 800,
		icon_BRUSH_SOFTEN = 801,
		icon_BRUSH_TEXDRAW = 802,
		icon_BRUSH_TEXFILL = 803,
		icon_BRUSH_TEXMASK = 804,
		icon_BRUSH_THUMB = 805,
		icon_BRUSH_ROTATE = 806,
		icon_GPBRUSH_SMOOTH = 807,
		icon_GPBRUSH_THICKNESS = 808,
		icon_GPBRUSH_STRENGTH = 809,
		icon_GPBRUSH_GRAB = 810,
		icon_GPBRUSH_PUSH = 811,
		icon_GPBRUSH_TWIST = 812,
		icon_GPBRUSH_PINCH = 813,
		icon_GPBRUSH_RANDOMIZE = 814,
		icon_GPBRUSH_CLONE = 815,
		icon_GPBRUSH_WEIGHT = 816,
		icon_GPBRUSH_PENCIL = 817,
		icon_GPBRUSH_PEN = 818,
		icon_GPBRUSH_INK = 819,
		icon_GPBRUSH_INKNOISE = 820,
		icon_GPBRUSH_BLOCK = 821,
		icon_GPBRUSH_MARKER = 822,
		icon_GPBRUSH_FILL = 823,
		icon_GPBRUSH_AIRBRUSH = 824,
		icon_GPBRUSH_CHISEL = 825,
		icon_GPBRUSH_ERASE_SOFT = 826,
		icon_GPBRUSH_ERASE_HARD = 827,
		icon_GPBRUSH_ERASE_STROKE = 828,
		icon_BRUSH_CURVES_ADD = 829,
		icon_BRUSH_CURVES_COMB = 830,
		icon_BRUSH_CURVES_CUT = 831,
		icon_BRUSH_CURVES_DELETE = 832,
		icon_BRUSH_CURVES_DENSITY = 833,
		icon_BRUSH_CURVES_GROW_SHRINK = 834,
		icon_BRUSH_CURVES_PINCH = 835,
		icon_BRUSH_CURVES_PUFF = 836,
		icon_BRUSH_CURVES_SLIDE = 837,
		icon_BRUSH_CURVES_SMOOTH = 838,
		icon_BRUSH_CURVES_SNAKE_HOOK = 839,
		icon_KEYTYPE_KEYFRAME_VEC = 840,
		icon_KEYTYPE_BREAKDOWN_VEC = 841,
		icon_KEYTYPE_EXTREME_VEC = 842,
		icon_KEYTYPE_JITTER_VEC = 843,
		icon_KEYTYPE_MOVING_HOLD_VEC = 844,
		icon_HANDLETYPE_FREE_VEC = 845,
		icon_HANDLETYPE_ALIGNED_VEC = 846,
		icon_HANDLETYPE_VECTOR_VEC = 847,
		icon_HANDLETYPE_AUTO_VEC = 848,
		icon_HANDLETYPE_AUTO_CLAMP_VEC = 849,
		icon_COLORSET_01_VEC = 850,
		icon_COLORSET_02_VEC = 851,
		icon_COLORSET_03_VEC = 852,
		icon_COLORSET_04_VEC = 853,
		icon_COLORSET_05_VEC = 854,
		icon_COLORSET_06_VEC = 855,
		icon_COLORSET_07_VEC = 856,
		icon_COLORSET_08_VEC = 857,
		icon_COLORSET_09_VEC = 858,
		icon_COLORSET_10_VEC = 859,
		icon_COLORSET_11_VEC = 860,
		icon_COLORSET_12_VEC = 861,
		icon_COLORSET_13_VEC = 862,
		icon_COLORSET_14_VEC = 863,
		icon_COLORSET_15_VEC = 864,
		icon_COLORSET_16_VEC = 865,
		icon_COLORSET_17_VEC = 866,
		icon_COLORSET_18_VEC = 867,
		icon_COLORSET_19_VEC = 868,
		icon_COLORSET_20_VEC = 869,
		icon_COLLECTION_COLOR_01 = 870,
		icon_COLLECTION_COLOR_02 = 871,
		icon_COLLECTION_COLOR_03 = 872,
		icon_COLLECTION_COLOR_04 = 873,
		icon_COLLECTION_COLOR_05 = 874,
		icon_COLLECTION_COLOR_06 = 875,
		icon_COLLECTION_COLOR_07 = 876,
		icon_COLLECTION_COLOR_08 = 877,
		icon_SEQUENCE_COLOR_01 = 878,
		icon_SEQUENCE_COLOR_02 = 879,
		icon_SEQUENCE_COLOR_03 = 880,
		icon_SEQUENCE_COLOR_04 = 881,
		icon_SEQUENCE_COLOR_05 = 882,
		icon_SEQUENCE_COLOR_06 = 883,
		icon_SEQUENCE_COLOR_07 = 884,
		icon_SEQUENCE_COLOR_08 = 885,
		icon_SEQUENCE_COLOR_09 = 886,
		icon_LIBRARY_DATA_INDIRECT = 887,
		icon_LIBRARY_DATA_OVERRIDE_NONEDITABLE = 888,
		icon_EVENT_A = 889,
		icon_EVENT_B = 890,
		icon_EVENT_C = 891,
		icon_EVENT_D = 892,
		icon_EVENT_E = 893,
		icon_EVENT_F = 894,
		icon_EVENT_G = 895,
		icon_EVENT_H = 896,
		icon_EVENT_I = 897,
		icon_EVENT_J = 898,
		icon_EVENT_K = 899,
		icon_EVENT_L = 900,
		icon_EVENT_M = 901,
		icon_EVENT_N = 902,
		icon_EVENT_O = 903,
		icon_EVENT_P = 904,
		icon_EVENT_Q = 905,
		icon_EVENT_R = 906,
		icon_EVENT_S = 907,
		icon_EVENT_T = 908,
		icon_EVENT_U = 909,
		icon_EVENT_V = 910,
		icon_EVENT_W = 911,
		icon_EVENT_X = 912,
		icon_EVENT_Y = 913,
		icon_EVENT_Z = 914,
		icon_EVENT_SHIFT = 915,
		icon_EVENT_CTRL = 916,
		icon_EVENT_ALT = 917,
		icon_EVENT_OS = 918,
		icon_EVENT_F1 = 919,
		icon_EVENT_F2 = 920,
		icon_EVENT_F3 = 921,
		icon_EVENT_F4 = 922,
		icon_EVENT_F5 = 923,
		icon_EVENT_F6 = 924,
		icon_EVENT_F7 = 925,
		icon_EVENT_F8 = 926,
		icon_EVENT_F9 = 927,
		icon_EVENT_F10 = 928,
		icon_EVENT_F11 = 929,
		icon_EVENT_F12 = 930,
		icon_EVENT_ESC = 931,
		icon_EVENT_TAB = 932,
		icon_EVENT_PAGEUP = 933,
		icon_EVENT_PAGEDOWN = 934,
		icon_EVENT_RETURN = 935,
		icon_EVENT_SPACEKEY = 936,
	};
	inline icon_enum icon(void);
	inline void icon(icon_enum value);

};

/**************** Pointer Definition ****************/

class PointerProperty : public Property {
public:
	PointerProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline Struct fixed_type(void);

};

/**************** Collection Definition ****************/

class CollectionProperty : public Property {
public:
	CollectionProperty(const PointerRNA &ptr_arg) :
		Property(ptr_arg)
		{}

	inline Struct fixed_type(void);

};

/**************** Function Definition ****************/

class Function : public Pointer {
public:
	Function(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		parameters(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Property, Function, parameters, false, false, false)
	inline bool is_registered(void);
	inline void is_registered(bool value);
	inline bool is_registered_optional(void);
	inline void is_registered_optional(bool value);
	inline bool use_self(void);
	inline void use_self(bool value);
	inline bool use_self_type(void);
	inline void use_self_type(bool value);

};

/**************** Blender RNA ****************/

class BlenderRNA : public Pointer {
public:
	BlenderRNA(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		structs(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Struct, BlenderRNA, structs, true, true, true)

};

/**************** String Value ****************/

class PrimitiveString : public Pointer {
public:
	PrimitiveString(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string value(void);
	inline void value(const std::string& value);

};

/**************** Primitive Int ****************/

class PrimitiveInt : public Pointer {
public:
	PrimitiveInt(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int value(void);
	inline void value(int value);

};

/**************** Primitive Float ****************/

class PrimitiveFloat : public Pointer {
public:
	PrimitiveFloat(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float value(void);
	inline void value(float value);

};

/**************** Primitive Boolean ****************/

class PrimitiveBoolean : public Pointer {
public:
	PrimitiveBoolean(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool value(void);
	inline void value(bool value);

};

/**************** Unknown Type ****************/

class UnknownType : public Pointer {
public:
	UnknownType(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Any Type ****************/

class AnyType : public Pointer {
public:
	AnyType(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** ID ****************/

class ID : public Pointer {
public:
	ID(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string name_full(void);
	inline void name_full(const std::string& value);
	inline bool is_evaluated(void);
	inline void is_evaluated(bool value);
	inline ID original(void);
	inline int users(void);
	inline void users(int value);
	inline bool use_fake_user(void);
	inline void use_fake_user(bool value);
	inline bool use_extra_user(void);
	inline void use_extra_user(bool value);
	inline bool is_embedded_data(void);
	inline void is_embedded_data(bool value);
	inline bool is_missing(void);
	inline void is_missing(bool value);
	inline bool is_runtime_data(void);
	inline void is_runtime_data(bool value);
	inline bool tag(void);
	inline void tag(bool value);
	inline bool is_library_indirect(void);
	inline void is_library_indirect(bool value);
	inline Library library(void);
	inline LibraryWeakReference library_weak_reference(void);
	inline AssetMetaData asset_data(void);
	inline IDOverrideLibrary override_library(void);
	inline ImagePreview preview(void);

	inline ID evaluated_get(Depsgraph& depsgraph);
	inline ID copy(void *main);
	inline void asset_mark();
	inline void asset_clear();
	inline void asset_generate_preview(Context C);
	inline ID override_create(void *main, bool remap_local_usages);
	inline ID override_hierarchy_create(void *main, Scene& scene, ViewLayer& view_layer, ID& reference, bool do_fully_editable);
	inline void override_template_create();
	inline void user_clear();
	inline void user_remap(void *main, ID& new_id);
	inline ID make_local(void *main, bool clear_proxy);
	inline int user_of_id(ID& id);
	inline AnimData animation_data_create(void *main);
	inline void animation_data_clear(void *main);
	inline void update_tag(void *main, int refresh);
	inline ImagePreview preview_ensure();
};

/**************** Override Properties ****************/

class IDOverrideLibraryProperties : public Pointer {
public:
	IDOverrideLibraryProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline IDOverrideLibraryProperty add(const char * rna_path);
	inline void remove(IDOverrideLibraryProperty& property);
};

/**************** Override Operations ****************/

class IDOverrideLibraryPropertyOperations : public Pointer {
public:
	IDOverrideLibraryPropertyOperations(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline IDOverrideLibraryPropertyOperation add(int operation, bool use_id, const char * subitem_reference_name, const char * subitem_local_name, ID& subitem_reference_id, ID& subitem_local_id, int subitem_reference_index, int subitem_local_index);
	inline void remove(IDOverrideLibraryPropertyOperation& operation);
};

/**************** ID Materials ****************/

class IDMaterials : public Pointer {
public:
	IDMaterials(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void append(void *main, Material& material);
	inline Material pop(void *main, int index);
	inline void clear(void *main);
};

/**************** Action F-Curves ****************/

class ActionFCurves : public Pointer {
public:
	ActionFCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FCurve create(void *main, const char * data_path, int index, const char * action_group);
	inline FCurve find(const char * data_path, int index);
	inline void remove(FCurve& fcurve);
	inline void clear();
};

/**************** Action Groups ****************/

class ActionGroups : public Pointer {
public:
	ActionGroups(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ActionGroup create(const char * name);
	inline void remove(ActionGroup& action_group);
};

/**************** Action Pose Markers ****************/

class ActionPoseMarkers : public Pointer {
public:
	ActionPoseMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline TimelineMarker active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline TimelineMarker create(const char * name);
	inline void remove(TimelineMarker& marker);
};

/**************** NLA Tracks ****************/

class NlaTracks : public Pointer {
public:
	NlaTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline NlaTrack active(void);

	inline NlaTrack create(void *main, Context C, NlaTrack& prev);
	inline void remove(void *main, Context C, NlaTrack& track);
};

/**************** Drivers ****************/

class AnimDataDrivers : public Pointer {
public:
	AnimDataDrivers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FCurve create(void *main, const char * data_path, int index);
	inline void remove(void *main, FCurve& driver);
	inline FCurve from_existing(Context C, FCurve& src_driver);
	inline FCurve find(const char * data_path, int index);
};

/**************** Keying set paths ****************/

class KeyingSetPaths : public Pointer {
public:
	KeyingSetPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyingSetPath active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline KeyingSetPath add(ID& target_id, const char * data_path, int index, int group_method, const char * group_name);
	inline void remove(KeyingSetPath& path);
	inline void clear();
};

/**************** Armature Bones ****************/

class ArmatureBones : public Pointer {
public:
	ArmatureBones(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Bone active(void);

};

/**************** Armature EditBones ****************/

class ArmatureEditBones : public Pointer {
public:
	ArmatureEditBones(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline EditBone active(void);

	inline EditBone create(const char * name);
	inline void remove(EditBone& bone);
};

/**************** Armature Bone Collections ****************/

class BoneCollections : public Pointer {
public:
	BoneCollections(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline BoneCollection active(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline std::string active_name(void);
	inline void active_name(const std::string& value);

	inline BoneCollection create(const char * name);
	inline void remove(BoneCollection& bone_collection);
	inline void move(int from_index, int to_index);
};

/**************** Bone Collection Memberships ****************/

class BoneCollectionMemberships : public Pointer {
public:
	BoneCollectionMemberships(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void clear();
};

/**************** Attribute Group ****************/

class AttributeGroup : public Pointer {
public:
	AttributeGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Attribute active(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline Attribute active_color(void);
	inline int active_color_index(void);
	inline void active_color_index(int value);
	inline int render_color_index(void);
	inline void render_color_index(int value);
	inline std::string default_color_name(void);
	inline void default_color_name(const std::string& value);
	inline std::string active_color_name(void);
	inline void active_color_name(const std::string& value);

	inline Attribute create(const char * name, int type, int domain);
	inline void remove(Attribute& attribute);
};

/**************** Asset Tags ****************/

class AssetTags : public Pointer {
public:
	AssetTags(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline AssetTag create(const char * name, bool skip_if_exists);
	inline void remove(AssetTag& tag);
};

/**************** Cache Layers ****************/

class CacheFileLayers : public Pointer {
public:
	CacheFileLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline CacheFileLayer active(void);

	inline CacheFileLayer create(Context C, const char * filepath);
	inline void remove(Context C, CacheFileLayer& layer);
};

/**************** Object Paths ****************/

class CacheObjectPaths : public Pointer {
public:
	CacheObjectPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Background Images ****************/

class CameraBackgroundImages : public Pointer {
public:
	CameraBackgroundImages(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline CameraBackgroundImage create();
	inline void remove(CameraBackgroundImage& image);
	inline void clear();
};

/**************** Collection Objects ****************/

class CollectionObjects : public Pointer {
public:
	CollectionObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void link(void *main, Object& object);
	inline void unlink(void *main, Object& object);
};

/**************** Collection Children ****************/

class CollectionChildren : public Pointer {
public:
	CollectionChildren(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void link(void *main, Collection& child);
	inline void unlink(void *main, Collection& child);
};

/**************** Curve Map Point ****************/

class CurveMapPoints : public Pointer {
public:
	CurveMapPoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline CurveMapPoint create(float position, float value);
	inline void remove(CurveMapPoint& point);
};

/**************** Color Ramp Elements ****************/

class ColorRampElements : public Pointer {
public:
	ColorRampElements(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ColorRampElement create(float position);
	inline void remove(ColorRampElement& element);
};

/**************** Armature Deform Constraint Targets ****************/

class ArmatureConstraintTargets : public Pointer {
public:
	ArmatureConstraintTargets(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ConstraintTargetBone create(void *main);
	inline void remove(void *main, ConstraintTargetBone& target);
	inline void clear(void *main);
};

/**************** Curve Splines ****************/

class CurveSplines : public Pointer {
public:
	CurveSplines(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Spline active(void);

	inline Spline create(int type);
	inline void remove(Spline& spline);
	inline void clear();
};

/**************** Spline Points ****************/

class SplinePoints : public Pointer {
public:
	SplinePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Spline Bezier Points ****************/

class SplineBezierPoints : public Pointer {
public:
	SplineBezierPoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Canvas Surfaces ****************/

class DynamicPaintSurfaces : public Pointer {
public:
	DynamicPaintSurfaces(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline DynamicPaintSurface active(void);

};

/**************** Keyframe Points ****************/

class FCurveKeyframePoints : public Pointer {
public:
	FCurveKeyframePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Keyframe insert(void *main, float frame, float value, int options, int keyframe_type);
	inline void add(void *main, int count);
	inline void remove(void *main, Keyframe& keyframe, bool fast);
	inline void clear(void *main);
	inline void sort(void *main);
	inline void deduplicate(void *main);
	inline void handles_recalc(void *main);
};

/**************** F-Curve Modifiers ****************/

class FCurveModifiers : public Pointer {
public:
	FCurveModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline FModifier active(void);

	inline FModifier create(int type);
	inline void remove(FModifier& modifier);
};

/**************** ChannelDriver Variables ****************/

class ChannelDriverVariables : public Pointer {
public:
	ChannelDriverVariables(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline DriverVariable create();
	inline void remove(DriverVariable& variable);
};

/**************** Control Points ****************/

class FModifierEnvelopeControlPoints : public Pointer {
public:
	FModifierEnvelopeControlPoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FModifierEnvelopeControlPoint add(void *main, float frame);
	inline void remove(void *main, FModifierEnvelopeControlPoint& point);
};

/**************** Grease Pencil Layers ****************/

class GreasePencilLayers : public Pointer {
public:
	GreasePencilLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline GPencilLayer active(void);
	inline int active_index(void);
	inline void active_index(int value);
	enum active_note_enum {
		active_note_DEFAULT = 0,
	};
	inline active_note_enum active_note(void);
	inline void active_note(active_note_enum value);

	inline GPencilLayer create(const char * name, bool set_active);
	inline void remove(GPencilLayer& layer);
	inline void move(GPencilLayer& layer, int type);
};

/**************** Grease Pencil Frames ****************/

class GPencilFrames : public Pointer {
public:
	GPencilFrames(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline GPencilFrame create(int frame_number, bool active);
	inline void remove(GPencilFrame& frame);
	inline GPencilFrame copy(GPencilFrame& source);
};

/**************** Grease Pencil Mask Layers ****************/

class GreasePencilMaskLayers : public Pointer {
public:
	GreasePencilMaskLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_mask_index(void);
	inline void active_mask_index(int value);

	inline void add(GPencilLayer& layer);
	inline void remove(GPencilLayerMask& mask);
};

/**************** Grease Pencil Frames ****************/

class GPencilStrokes : public Pointer {
public:
	GPencilStrokes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline GPencilStroke create();
	inline void remove(GPencilStroke& stroke);
	inline void close(GPencilStroke& stroke);
};

/**************** Grease Pencil Stroke Points ****************/

class GPencilStrokePoints : public Pointer {
public:
	GPencilStrokePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count, float pressure, float strength);
	inline void pop(int index);
	inline void update();
	inline float weight_get(int vertex_group_index, int point_index);
	inline void weight_set(int vertex_group_index, int point_index, float weight);
};

/**************** Grease Pencil Layers ****************/

class GreasePencilv3Layers : public Pointer {
public:
	GreasePencilv3Layers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline GreasePencilLayer active(void);

};

/**************** Render Layers ****************/

class RenderSlots : public Pointer {
public:
	RenderSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline RenderSlot active(void);

	inline RenderSlot create(const char * name);
};

/**************** UDIM Tiles ****************/

class UDIMTiles : public Pointer {
public:
	UDIMTiles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline UDIMTile active(void);

	inline UDIMTile create(int tile_number, const char * label);
	inline UDIMTile get(int tile_number);
	inline void remove(UDIMTile& tile);
};

/**************** List of AOVs ****************/

class AOVs : public Pointer {
public:
	AOVs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline AOV add();
	inline void remove(AOV& aov);
};

/**************** List of Lightgroups ****************/

class Lightgroups : public Pointer {
public:
	Lightgroups(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Lightgroup add(const char * name);
};

/**************** Layer Objects ****************/

class LayerObjects : public Pointer {
public:
	LayerObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		selected(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object active(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Object, LayerObjects, selected, false, true, true)

};

/**************** Style Modules ****************/

class FreestyleModules : public Pointer {
public:
	FreestyleModules(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FreestyleModuleSettings create();
	inline void remove(FreestyleModuleSettings& module);
};

/**************** Line Sets ****************/

class Linesets : public Pointer {
public:
	Linesets(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline FreestyleLineSet active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline FreestyleLineSet create(void *main, const char * name);
	inline void remove(FreestyleLineSet& lineset);
};

/**************** Texture Slots ****************/

class LineStyleTextureSlots : public Pointer {
public:
	LineStyleTextureSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleTextureSlot add(Context C);
	inline LineStyleTextureSlot create(Context C, int index);
	inline void clear(Context C, int index);
};

/**************** Color Modifiers ****************/

class LineStyleColorModifiers : public Pointer {
public:
	LineStyleColorModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleColorModifier create(const char * name, int type);
	inline void remove(LineStyleColorModifier& modifier);
};

/**************** Alpha Modifiers ****************/

class LineStyleAlphaModifiers : public Pointer {
public:
	LineStyleAlphaModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleAlphaModifier create(const char * name, int type);
	inline void remove(LineStyleAlphaModifier& modifier);
};

/**************** Thickness Modifiers ****************/

class LineStyleThicknessModifiers : public Pointer {
public:
	LineStyleThicknessModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleThicknessModifier create(const char * name, int type);
	inline void remove(LineStyleThicknessModifier& modifier);
};

/**************** Geometry Modifiers ****************/

class LineStyleGeometryModifiers : public Pointer {
public:
	LineStyleGeometryModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LineStyleGeometryModifier create(const char * name, int type);
	inline void remove(LineStyleGeometryModifier& modifier);
};

/**************** Main Cameras ****************/

class BlendDataCameras : public Pointer {
public:
	BlendDataCameras(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Camera create(const char * name);
	inline void remove(Camera& camera, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Scenes ****************/

class BlendDataScenes : public Pointer {
public:
	BlendDataScenes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Scene create(const char * name);
	inline void remove(Context C, Scene& scene, bool do_unlink);
	inline void tag(bool value);
};

/**************** Main Objects ****************/

class BlendDataObjects : public Pointer {
public:
	BlendDataObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Object create(const char * name, ID& object_data);
	inline void remove(Object& object, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Materials ****************/

class BlendDataMaterials : public Pointer {
public:
	BlendDataMaterials(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Material create(const char * name);
	inline void create_gpencil_data(Material& material);
	inline void remove_gpencil_data(Material& material);
	inline void remove(Material& material, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Node Trees ****************/

class BlendDataNodeTrees : public Pointer {
public:
	BlendDataNodeTrees(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeTree create(const char * name, int type);
	inline void remove(NodeTree& tree, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Meshes ****************/

class BlendDataMeshes : public Pointer {
public:
	BlendDataMeshes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Mesh create(const char * name);
	inline Mesh new_from_object(Object& object, bool preserve_all_data_layers, Depsgraph& depsgraph);
	inline void remove(Mesh& mesh, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Lights ****************/

class BlendDataLights : public Pointer {
public:
	BlendDataLights(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Light create(const char * name, int type);
	inline void remove(Light& light, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Libraries ****************/

class BlendDataLibraries : public Pointer {
public:
	BlendDataLibraries(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline void remove(Library& library, bool do_unlink, bool do_id_user, bool do_ui_user);
};

/**************** Main Screens ****************/

class BlendDataScreens : public Pointer {
public:
	BlendDataScreens(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Window Managers ****************/

class BlendDataWindowManagers : public Pointer {
public:
	BlendDataWindowManagers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Images ****************/

class BlendDataImages : public Pointer {
public:
	BlendDataImages(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Image create(const char * name, int width, int height, bool alpha, bool float_buffer, bool stereo3d, bool is_data, bool tiled);
	inline Image load(const char * filepath, bool check_existing);
	inline void remove(Image& image, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Lattices ****************/

class BlendDataLattices : public Pointer {
public:
	BlendDataLattices(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Lattice create(const char * name);
	inline void remove(Lattice& lattice, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Curves ****************/

class BlendDataCurves : public Pointer {
public:
	BlendDataCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Curve create(const char * name, int type);
	inline void remove(Curve& curve, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Metaballs ****************/

class BlendDataMetaBalls : public Pointer {
public:
	BlendDataMetaBalls(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MetaBall create(const char * name);
	inline void remove(MetaBall& metaball, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Fonts ****************/

class BlendDataFonts : public Pointer {
public:
	BlendDataFonts(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline VectorFont load(const char * filepath, bool check_existing);
	inline void remove(VectorFont& vfont, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Textures ****************/

class BlendDataTextures : public Pointer {
public:
	BlendDataTextures(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Texture create(const char * name, int type);
	inline void remove(Texture& texture, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Brushes ****************/

class BlendDataBrushes : public Pointer {
public:
	BlendDataBrushes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Brush create(const char * name, int mode);
	inline void remove(Brush& brush, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
	inline void create_gpencil_data(Brush& brush);
};

/**************** Main Worlds ****************/

class BlendDataWorlds : public Pointer {
public:
	BlendDataWorlds(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline World create(const char * name);
	inline void remove(World& world, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Collections ****************/

class BlendDataCollections : public Pointer {
public:
	BlendDataCollections(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Collection create(const char * name);
	inline void remove(Collection& collection, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Texts ****************/

class BlendDataTexts : public Pointer {
public:
	BlendDataTexts(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Text create(const char * name);
	inline void remove(Text& text, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline Text load(const char * filepath, bool internal);
	inline void tag(bool value);
};

/**************** Main Speakers ****************/

class BlendDataSpeakers : public Pointer {
public:
	BlendDataSpeakers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Speaker create(const char * name);
	inline void remove(Speaker& speaker, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Sounds ****************/

class BlendDataSounds : public Pointer {
public:
	BlendDataSounds(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Sound load(const char * filepath, bool check_existing);
	inline void remove(Sound& sound, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Armatures ****************/

class BlendDataArmatures : public Pointer {
public:
	BlendDataArmatures(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Armature create(const char * name);
	inline void remove(Armature& armature, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Actions ****************/

class BlendDataActions : public Pointer {
public:
	BlendDataActions(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Action create(const char * name);
	inline void remove(Action& action, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Particle Settings ****************/

class BlendDataParticles : public Pointer {
public:
	BlendDataParticles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ParticleSettings create(const char * name);
	inline void remove(ParticleSettings& particle, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Palettes ****************/

class BlendDataPalettes : public Pointer {
public:
	BlendDataPalettes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Palette create(const char * name);
	inline void remove(Palette& palette, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Grease Pencils ****************/

class BlendDataGreasePencils : public Pointer {
public:
	BlendDataGreasePencils(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline GreasePencil create(const char * name);
	inline void remove(GreasePencil& grease_pencil, bool do_unlink, bool do_id_user, bool do_ui_user);
};

/**************** Main Grease Pencils ****************/

class BlendDataGreasePencilsV3 : public Pointer {
public:
	BlendDataGreasePencilsV3(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Main Movie Clips ****************/

class BlendDataMovieClips : public Pointer {
public:
	BlendDataMovieClips(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline void remove(MovieClip& clip, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline MovieClip load(const char * filepath, bool check_existing);
};

/**************** Main Masks ****************/

class BlendDataMasks : public Pointer {
public:
	BlendDataMasks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline Mask create(const char * name);
	inline void remove(Mask& mask, bool do_unlink, bool do_id_user, bool do_ui_user);
};

/**************** Main Line Styles ****************/

class BlendDataLineStyles : public Pointer {
public:
	BlendDataLineStyles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
	inline FreestyleLineStyle create(const char * name);
	inline void remove(FreestyleLineStyle& linestyle, bool do_unlink, bool do_id_user, bool do_ui_user);
};

/**************** Main Cache Files ****************/

class BlendDataCacheFiles : public Pointer {
public:
	BlendDataCacheFiles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Paint Curves ****************/

class BlendDataPaintCurves : public Pointer {
public:
	BlendDataPaintCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Workspaces ****************/

class BlendDataWorkSpaces : public Pointer {
public:
	BlendDataWorkSpaces(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void tag(bool value);
};

/**************** Main Light Probes ****************/

class BlendDataProbes : public Pointer {
public:
	BlendDataProbes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline LightProbe create(const char * name, int type);
	inline void remove(LightProbe& lightprobe, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Hair Curves ****************/

class BlendDataHairCurves : public Pointer {
public:
	BlendDataHairCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Curves create(const char * name);
	inline void remove(Curves& curves, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Point Clouds ****************/

class BlendDataPointClouds : public Pointer {
public:
	BlendDataPointClouds(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline PointCloud create(const char * name);
	inline void remove(PointCloud& pointcloud, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Main Volumes ****************/

class BlendDataVolumes : public Pointer {
public:
	BlendDataVolumes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Volume create(const char * name);
	inline void remove(Volume& volume, bool do_unlink, bool do_id_user, bool do_ui_user);
	inline void tag(bool value);
};

/**************** Mesh Vertices ****************/

class MeshVertices : public Pointer {
public:
	MeshVertices(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Mesh Edges ****************/

class MeshEdges : public Pointer {
public:
	MeshEdges(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Mesh Loops ****************/

class MeshLoops : public Pointer {
public:
	MeshLoops(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
};

/**************** Mesh Polygons ****************/

class MeshPolygons : public Pointer {
public:
	MeshPolygons(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active(void);
	inline void active(int value);

	inline void add(int count);
};

/**************** Mesh Loop Triangles ****************/

class MeshLoopTriangles : public Pointer {
public:
	MeshLoopTriangles(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** UV Map Layers ****************/

class UVLoopLayers : public Pointer {
public:
	UVLoopLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MeshUVLoopLayer active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline MeshUVLoopLayer create(const char * name, bool do_init);
	inline void remove(MeshUVLoopLayer& layer);
};

/**************** Loop Colors ****************/

class LoopColors : public Pointer {
public:
	LoopColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MeshLoopColorLayer active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline MeshLoopColorLayer create(const char * name, bool do_init);
	inline void remove(MeshLoopColorLayer& layer);
};

/**************** Metaball Elements ****************/

class MetaBallElements : public Pointer {
public:
	MetaBallElements(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MetaElement active(void);

	inline MetaElement create(int type);
	inline void remove(MetaElement& element);
	inline void clear();
};

/**************** Bakes ****************/

class NodesModifierBakes : public Pointer {
public:
	NodesModifierBakes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** NLA Strips ****************/

class NlaStrips : public Pointer {
public:
	NlaStrips(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NlaStrip create(void *main, Context C, const char * name, int start, Action& action);
	inline void remove(void *main, Context C, NlaStrip& strip);
};

/**************** NLA-Strip F-Curves ****************/

class NlaStripFCurves : public Pointer {
public:
	NlaStripFCurves(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline FCurve find(const char * data_path, int index);
};

/**************** Node Inputs ****************/

class NodeInputs : public Pointer {
public:
	NodeInputs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(void *main, const char * type, const char * name, const char * identifier);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Node Outputs ****************/

class NodeOutputs : public Pointer {
public:
	NodeOutputs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(void *main, const char * type, const char * name, const char * identifier);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Nodes ****************/

class Nodes : public Pointer {
public:
	Nodes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Node active(void);

	inline Node create(Context C, const char * type);
	inline void remove(void *main, Node& node);
	inline void clear(void *main);
};

/**************** Node Links ****************/

class NodeLinks : public Pointer {
public:
	NodeLinks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeLink create(void *main, NodeSocket& input, NodeSocket& output, bool verify_limits);
	inline void remove(void *main, NodeLink& link);
	inline void clear(void *main);
};

/**************** File Output Slots ****************/

class CompositorNodeOutputFileFileSlots : public Pointer {
public:
	CompositorNodeOutputFileFileSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(Context C, const char * name);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** File Output Slots ****************/

class CompositorNodeOutputFileLayerSlots : public Pointer {
public:
	CompositorNodeOutputFileLayerSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline NodeSocket create(Context C, const char * name);
	inline void remove(void *main, NodeSocket& socket);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Items ****************/

class NodeGeometrySimulationOutputItems : public Pointer {
public:
	NodeGeometrySimulationOutputItems(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline SimulationStateItem create(void *main, int socket_type, const char * name);
	inline void remove(void *main, SimulationStateItem& item);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Items ****************/

class NodeGeometryRepeatOutputItems : public Pointer {
public:
	NodeGeometryRepeatOutputItems(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline RepeatItem create(void *main, int socket_type, const char * name);
	inline void remove(void *main, RepeatItem& item);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
};

/**************** Object Modifiers ****************/

class ObjectModifiers : public Pointer {
public:
	ObjectModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Modifier active(void);

	inline Modifier create(Context C, const char * name, int type);
	inline void remove(Context C, Modifier& modifier);
	inline void clear(Context C);
	inline void move(int from_index, int to_index);
};

/**************** Object Grease Pencil Modifiers ****************/

class ObjectGpencilModifiers : public Pointer {
public:
	ObjectGpencilModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline GpencilModifier create(Context C, const char * name, int type);
	inline void remove(Context C, GpencilModifier& greasepencil_modifier);
	inline void clear(Context C);
};

/**************** Object Shader Effects ****************/

class ObjectShaderFx : public Pointer {
public:
	ObjectShaderFx(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ShaderFx create(Context C, const char * name, int type);
	inline void remove(Context C, ShaderFx& shader_fx);
	inline void clear(Context C);
};

/**************** Object Constraints ****************/

class ObjectConstraints : public Pointer {
public:
	ObjectConstraints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Constraint active(void);

	inline Constraint create(void *main, int type);
	inline void remove(void *main, Constraint& constraint);
	inline void clear(void *main);
	inline void move(void *main, int from_index, int to_index);
	inline Constraint copy(void *main, Constraint& constraint);
};

/**************** Vertex Groups ****************/

class VertexGroups : public Pointer {
public:
	VertexGroups(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline VertexGroup active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline VertexGroup create(void *main, const char * name);
	inline void remove(void *main, VertexGroup& group);
	inline void clear(void *main);
};

/**************** Particle Systems ****************/

class ParticleSystems : public Pointer {
public:
	ParticleSystems(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ParticleSystem active(void);
	inline int active_index(void);
	inline void active_index(int value);

};

/**************** Point Caches ****************/

class PointCaches : public Pointer {
public:
	PointCaches(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);

};

/**************** Palette Splines ****************/

class PaletteColors : public Pointer {
public:
	PaletteColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline PaletteColor active(void);

	inline PaletteColor create();
	inline void remove(PaletteColor& color);
	inline void clear();
};

/**************** Texture Slots ****************/

class ParticleSettingsTextureSlots : public Pointer {
public:
	ParticleSettingsTextureSlots(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ParticleSettingsTextureSlot add(Context C);
	inline ParticleSettingsTextureSlot create(Context C, int index);
	inline void clear(Context C, int index);
};

/**************** PoseBone Constraints ****************/

class PoseBoneConstraints : public Pointer {
public:
	PoseBoneConstraints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Constraint active(void);

	inline Constraint create(void *main, int type);
	inline void remove(void *main, Constraint& constraint);
	inline void move(void *main, int from_index, int to_index);
	inline Constraint copy(void *main, Constraint& constraint);
};

/**************** Profile Point ****************/

class CurveProfilePoints : public Pointer {
public:
	CurveProfilePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline CurveProfilePoint add(float x, float y);
	inline void remove(CurveProfilePoint& point);
};

/**************** Render Passes ****************/

class RenderPasses : public Pointer {
public:
	RenderPasses(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline RenderPass find_by_type(int pass_type, const char * view);
	inline RenderPass find_by_name(const char * name, const char * view);
};

/**************** Scene Objects ****************/

class SceneObjects : public Pointer {
public:
	SceneObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Keying Sets ****************/

class KeyingSets : public Pointer {
public:
	KeyingSets(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyingSet active(void);
	inline int active_index(void);
	inline void active_index(int value);

	inline KeyingSet create(const char * idname, const char * name);
};

/**************** Keying Sets All ****************/

class KeyingSetsAll : public Pointer {
public:
	KeyingSetsAll(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyingSet active(void);
	inline int active_index(void);
	inline void active_index(int value);

};

/**************** Timeline Markers ****************/

class TimelineMarkers : public Pointer {
public:
	TimelineMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline TimelineMarker create(const char * name, int frame);
	inline void remove(TimelineMarker& marker);
	inline void clear();
};

/**************** Render Layers ****************/

class ViewLayers : public Pointer {
public:
	ViewLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ViewLayer create(void *main, const char * name);
	inline void remove(void *main, ViewLayer& layer);
};

/**************** Render Views ****************/

class RenderViews : public Pointer {
public:
	RenderViews(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline SceneRenderView active(void);

	inline SceneRenderView create(const char * name);
	inline void remove(void *main, SceneRenderView& view);
};

/**************** Area Spaces ****************/

class AreaSpaces : public Pointer {
public:
	AreaSpaces(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Space active(void);

};

/**************** Strip Modifiers ****************/

class SequenceModifiers : public Pointer {
public:
	SequenceModifiers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline SequenceModifier create(Context C, const char * name, int type);
	inline void remove(Context C, SequenceModifier& modifier);
	inline void clear(Context C);
};

/**************** Sequences ****************/

class SequencesTopLevel : public Pointer {
public:
	SequencesTopLevel(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Sequence new_clip(void *main, const char * name, MovieClip& clip, int channel, int frame_start);
	inline Sequence new_mask(void *main, const char * name, Mask& mask, int channel, int frame_start);
	inline Sequence new_scene(void *main, const char * name, Scene& scene, int channel, int frame_start);
	inline Sequence new_image(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method);
	inline Sequence new_movie(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method);
	inline Sequence new_sound(void *main, const char * name, const char * filepath, int channel, int frame_start);
	inline Sequence new_meta(const char * name, int channel, int frame_start);
	inline Sequence new_effect(const char * name, int type, int channel, int frame_start, int frame_end, Sequence& seq1, Sequence& seq2, Sequence& seq3);
	inline void remove(void *main, Sequence& sequence);
};

/**************** SequenceElements ****************/

class SequenceElements : public Pointer {
public:
	SequenceElements(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline SequenceElement append(const char * filename);
	inline void pop(int index);
};

/**************** Sequences ****************/

class SequencesMeta : public Pointer {
public:
	SequencesMeta(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Sequence new_clip(void *main, const char * name, MovieClip& clip, int channel, int frame_start);
	inline Sequence new_mask(void *main, const char * name, Mask& mask, int channel, int frame_start);
	inline Sequence new_scene(void *main, const char * name, Scene& scene, int channel, int frame_start);
	inline Sequence new_image(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method);
	inline Sequence new_movie(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method);
	inline Sequence new_sound(void *main, const char * name, const char * filepath, int channel, int frame_start);
	inline Sequence new_meta(const char * name, int channel, int frame_start);
	inline Sequence new_effect(const char * name, int type, int channel, int frame_start, int frame_end, Sequence& seq1, Sequence& seq2, Sequence& seq3);
	inline void remove(void *main, Sequence& sequence);
};

/**************** RetimingKeys ****************/

class RetimingKeys : public Pointer {
public:
	RetimingKeys(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline RetimingKey add(int timeline_frame);
	inline void reset();
};

/**************** Path ****************/

class SpaceNodeEditorPath : public Pointer {
public:
	SpaceNodeEditorPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string to_string(void);
	inline void to_string(const std::string& value);

	inline void clear(Context C);
	inline void start(Context C, NodeTree& node_tree);
	inline void append(Context C, NodeTree& node_tree, Node& node);
	inline void pop(Context C);
};

/**************** User Add-ons ****************/

class Addons : public Pointer {
public:
	Addons(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Addon create();
	inline void remove(Addon& addon);
};

/**************** Paths Compare ****************/

class PathCompareCollection : public Pointer {
public:
	PathCompareCollection(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline PathCompare create();
	inline void remove(PathCompare& pathcmp);
};

/**************** Python Scripts Directories ****************/

class ScriptDirectoryCollection : public Pointer {
public:
	ScriptDirectoryCollection(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline ScriptDirectory create();
	inline void remove(ScriptDirectory& script_directory);
};

/**************** User Extension Repositories ****************/

class UserExtensionRepoCollection : public Pointer {
public:
	UserExtensionRepoCollection(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline UserExtensionRepo create(const char * name, const char * module, const char * directory, const char * remote_path);
	inline void remove(UserExtensionRepo& repo);
};

/**************** Studio Lights ****************/

class StudioLights : public Pointer {
public:
	StudioLights(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline StudioLight load(const char * path, int type);
	inline StudioLight create(const char * path);
	inline void remove(StudioLight& studio_light);
	inline void refresh();
};

/**************** Volume Grids ****************/

class VolumeGrids : public Pointer {
public:
	VolumeGrids(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int active_index(void);
	inline void active_index(int value);
	inline std::string error_message(void);
	inline void error_message(const std::string& value);
	inline bool is_loaded(void);
	inline void is_loaded(bool value);
	inline int frame(void);
	inline void frame(int value);
	inline std::string frame_filepath(void);
	inline void frame_filepath(const std::string& value);

	inline bool load(void *main);
	inline void unload();
	inline bool save(void *main, const char * filepath);
};

/**************** KeyConfigs ****************/

class KeyConfigurations : public Pointer {
public:
	KeyConfigurations(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline KeyConfig active(void);
	inline KeyConfig default_value(void);
	inline KeyConfig addon(void);
	inline KeyConfig user(void);

	inline KeyConfig create(const char * name);
	inline void remove(KeyConfig& keyconfig);
	inline KeyMapItem find_item_from_operator(Context C, const char * idname, int context, OperatorProperties& properties, int include, int exclude, KeyMap *keymap);
	inline void update(bool keep_properties);
};

/**************** Key Maps ****************/

class KeyMaps : public Pointer {
public:
	KeyMaps(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline KeyMap create(const char * name, int space_type, int region_type, bool modal, bool tool);
	inline void remove(KeyMap& keymap);
	inline void clear();
	inline KeyMap find(const char * name, int space_type, int region_type);
	inline KeyMap find_modal(const char * name);
};

/**************** KeyMap Items ****************/

class KeyMapItems : public Pointer {
public:
	KeyMapItems(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline KeyMapItem create(const char * idname, int type, int value, bool any, int shift, int ctrl, int alt, int oskey, int key_modifier, int direction, bool repeat, bool head);
	inline KeyMapItem new_modal(const char * propvalue, int type, int value, bool any, int shift, int ctrl, int alt, int oskey, int key_modifier, int direction, bool repeat);
	inline KeyMapItem new_from_item(KeyMapItem& item, bool head);
	inline void remove(KeyMapItem& item);
	inline KeyMapItem from_id(int id);
	inline KeyMapItem find_from_operator(const char * idname, OperatorProperties& properties, int include, int exclude);
	inline KeyMapItem match_event(Context C, Event& event);
};

/**************** Gizmos ****************/

class Gizmos : public Pointer {
public:
	Gizmos(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline Gizmo create(const char * type);
	inline void remove(Context C, Gizmo& gizmo);
	inline void clear(Context C);
};

/**************** WorkSpace UI Tags ****************/

class wmOwnerIDs : public Pointer {
public:
	wmOwnerIDs(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline wmOwnerID create(const char * name);
	inline void remove(wmOwnerID& owner_id);
	inline void clear();
};

/**************** WorkSpace UI Tags ****************/

class wmTools : public Pointer {
public:
	wmTools(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline WorkSpaceTool from_space_view3d_mode(int mode, bool create);
	inline WorkSpaceTool from_space_image_mode(int mode, bool create);
	inline WorkSpaceTool from_space_node(bool create);
	inline WorkSpaceTool from_space_sequencer(int mode, bool create);
};

/**************** Movie Tracking Markers ****************/

class MovieTrackingMarkers : public Pointer {
public:
	MovieTrackingMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MovieTrackingMarker find_frame(int frame, bool exact);
	inline MovieTrackingMarker insert_frame(int frame, float co[2]);
	inline void delete_frame(int frame);
};

/**************** Movie Tracking Plane Markers ****************/

class MovieTrackingPlaneMarkers : public Pointer {
public:
	MovieTrackingPlaneMarkers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MovieTrackingPlaneMarker find_frame(int frame, bool exact);
	inline MovieTrackingPlaneMarker insert_frame(int frame);
	inline void delete_frame(int frame);
};

/**************** Movie Tracks ****************/

class MovieTrackingTracks : public Pointer {
public:
	MovieTrackingTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingTrack active(void);

	inline MovieTrackingTrack create(const char * name, int frame);
};

/**************** Movie Plane Tracks ****************/

class MovieTrackingPlaneTracks : public Pointer {
public:
	MovieTrackingPlaneTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingPlaneTrack active(void);

};

/**************** Movie Tracks ****************/

class MovieTrackingObjectTracks : public Pointer {
public:
	MovieTrackingObjectTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingTrack active(void);

	inline MovieTrackingTrack create(const char * name, int frame);
};

/**************** Plane Tracks ****************/

class MovieTrackingObjectPlaneTracks : public Pointer {
public:
	MovieTrackingObjectPlaneTracks(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingTrack active(void);

};

/**************** Reconstructed Cameras ****************/

class MovieTrackingReconstructedCameras : public Pointer {
public:
	MovieTrackingReconstructedCameras(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline MovieReconstructedCamera find_frame(int frame);
	inline void matrix_from_frame(int frame, float matrix[16]);
};

/**************** Movie Objects ****************/

class MovieTrackingObjects : public Pointer {
public:
	MovieTrackingObjects(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingObject active(void);

	inline MovieTrackingObject create(const char * name);
	inline void remove(MovieTrackingObject& object);
};

/**************** Mask Splines ****************/

class MaskSplines : public Pointer {
public:
	MaskSplines(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MaskSpline active(void);
	inline MaskSplinePoint active_point(void);

	inline MaskSpline create();
	inline void remove(MaskSpline& spline);
};

/**************** Mask Spline Points ****************/

class MaskSplinePoints : public Pointer {
public:
	MaskSplinePoints(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void add(int count);
	inline void remove(MaskSplinePoint& point);
};

/**************** Mask Layers ****************/

class MaskLayers : public Pointer {
public:
	MaskLayers(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MaskLayer active(void);

	inline MaskLayer create(const char * name);
	inline void remove(MaskLayer& layer);
	inline void clear();
};

/**************** XR Action Map Items ****************/

class XrActionMapItems : public Pointer {
public:
	XrActionMapItems(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline XrActionMapItem create(const char * name, bool replace_existing);
	inline XrActionMapItem new_from_item(XrActionMapItem& item);
	inline void remove(XrActionMapItem& item);
	inline XrActionMapItem find(const char * name);
};

/**************** XR User Paths ****************/

class XrUserPaths : public Pointer {
public:
	XrUserPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline XrUserPath create(const char * path);
	inline void remove(XrUserPath& user_path);
	inline XrUserPath find(const char * path);
};

/**************** XR Action Map Bindings ****************/

class XrActionMapBindings : public Pointer {
public:
	XrActionMapBindings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline XrActionMapBinding create(const char * name, bool replace_existing);
	inline XrActionMapBinding new_from_binding(XrActionMapBinding& binding);
	inline void remove(XrActionMapBinding& binding);
	inline XrActionMapBinding find(const char * name);
};

/**************** XR Component Paths ****************/

class XrComponentPaths : public Pointer {
public:
	XrComponentPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline XrComponentPath create(const char * path);
	inline void remove(XrComponentPath& component_path);
	inline XrComponentPath find(const char * path);
};

/**************** XR Action Maps ****************/

class XrActionMaps : public Pointer {
public:
	XrActionMaps(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline XrActionMap create(XrSessionState& xr_session_state, const char * name, bool replace_existing);
	inline XrActionMap new_from_actionmap(XrSessionState& xr_session_state, XrActionMap& actionmap);
	inline void remove(XrSessionState& xr_session_state, XrActionMap& actionmap);
	inline XrActionMap find(XrSessionState& xr_session_state, const char * name);
};

/**************** ID Library Override ****************/

class IDOverrideLibrary : public Pointer {
public:
	IDOverrideLibrary(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		properties(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID reference(void);
	inline ID hierarchy_root(void);
	inline bool is_in_hierarchy(void);
	inline void is_in_hierarchy(bool value);
	inline bool is_system_override(void);
	inline void is_system_override(bool value);
	COLLECTION_PROPERTY(IDOverrideLibraryProperties, IDOverrideLibraryProperty, IDOverrideLibrary, properties, false, true, false)

	inline void operations_update(void *main);
	inline void reset(void *main, bool do_hierarchy, bool set_system_override);
	inline void destroy(void *main, bool do_hierarchy);
	inline bool resync(void *main, Scene& scene, ViewLayer& view_layer, Collection& residual_storage, bool do_hierarchy_enforce, bool do_whole_hierarchy);
};

/**************** ID Library Override Property ****************/

class IDOverrideLibraryProperty : public Pointer {
public:
	IDOverrideLibraryProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		operations(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string rna_path(void);
	inline void rna_path(const std::string& value);
	COLLECTION_PROPERTY(IDOverrideLibraryPropertyOperations, IDOverrideLibraryPropertyOperation, IDOverrideLibraryProperty, operations, false, true, false)

};

/**************** ID Library Override Property Operation ****************/

class IDOverrideLibraryPropertyOperation : public Pointer {
public:
	IDOverrideLibraryPropertyOperation(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum operation_enum {
		operation_NOOP = 0,
		operation_REPLACE = 1,
		operation_DIFF_ADD = 101,
		operation_DIFF_SUB = 102,
		operation_FACT_MULTIPLY = 103,
		operation_INSERT_AFTER = 201,
		operation_INSERT_BEFORE = 202,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	enum flag_enum {
		flag_MANDATORY = 1,
		flag_LOCKED = 2,
		flag_IDPOINTER_MATCH_REFERENCE = 256,
		flag_IDPOINTER_ITEM_USE_ID = 512,
	};
	inline flag_enum flag(void);
	inline void flag(flag_enum value);
	inline std::string subitem_reference_name(void);
	inline void subitem_reference_name(const std::string& value);
	inline std::string subitem_local_name(void);
	inline void subitem_local_name(const std::string& value);
	inline ID subitem_reference_id(void);
	inline ID subitem_local_id(void);
	inline int subitem_reference_index(void);
	inline void subitem_reference_index(int value);
	inline int subitem_local_index(void);
	inline void subitem_local_index(int value);

};

/**************** Image Preview ****************/

class ImagePreview : public Pointer {
public:
	ImagePreview(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_image_custom(void);
	inline void is_image_custom(bool value);
	inline Array<int, 2> image_size(void);
	inline void image_size(int values[2]);
	inline DynamicArray<int> image_pixels(void);
	inline void image_pixels(int values[]);
	inline DynamicArray<float> image_pixels_float(void);
	inline void image_pixels_float(float values[]);
	inline bool is_icon_custom(void);
	inline void is_icon_custom(bool value);
	inline Array<int, 2> icon_size(void);
	inline void icon_size(int values[2]);
	inline DynamicArray<int> icon_pixels(void);
	inline void icon_pixels(int values[]);
	inline DynamicArray<float> icon_pixels_float(void);
	inline void icon_pixels_float(float values[]);
	inline int icon_id(void);
	inline void icon_id(int value);

	inline void reload();
};

/**************** ID Property ****************/

class PropertyGroupItem : public Pointer {
public:
	PropertyGroupItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** ID Property Group ****************/

class PropertyGroup : public Pointer {
public:
	PropertyGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Library ****************/

class Library : public ID {
public:
	Library(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline Library parent(void);
	inline PackedFile packed_file(void);
	inline Array<int, 3> version(void);
	inline void version(int values[3]);
	inline bool needs_liboverride_resync(void);
	inline void needs_liboverride_resync(bool value);

	inline void reload(Context C);
};

/**************** LibraryWeakReference ****************/

class LibraryWeakReference : public Pointer {
public:
	LibraryWeakReference(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string id_name(void);
	inline void id_name(const std::string& value);

};

/**************** IDPropertyWrapPtr ****************/

class IDPropertyWrapPtr : public Pointer {
public:
	IDPropertyWrapPtr(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Texture ****************/

class Texture : public ID {
public:
	Texture(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum type_enum {
		type_NONE = 0,
		type_BLEND = 5,
		type_CLOUDS = 1,
		type_DISTORTED_NOISE = 13,
		type_IMAGE = 8,
		type_MAGIC = 4,
		type_MARBLE = 3,
		type_MUSGRAVE = 11,
		type_NOISE = 7,
		type_STUCCI = 6,
		type_VORONOI = 12,
		type_WOOD = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);
	inline bool use_color_ramp(void);
	inline void use_color_ramp(bool value);
	inline ColorRamp color_ramp(void);
	inline float intensity(void);
	inline void intensity(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float saturation(void);
	inline void saturation(float value);
	inline float factor_red(void);
	inline void factor_red(float value);
	inline float factor_green(void);
	inline void factor_green(float value);
	inline float factor_blue(void);
	inline void factor_blue(float value);
	inline bool use_preview_alpha(void);
	inline void use_preview_alpha(bool value);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline NodeTree node_tree(void);
	inline AnimData animation_data(void);

	inline void evaluate(float value[3], float result[4]);
};

/**************** Clouds Texture ****************/

class CloudsTexture : public Texture {
public:
	CloudsTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline int noise_depth(void);
	inline void noise_depth(int value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum cloud_type_enum {
		cloud_type_GRAYSCALE = 0,
		cloud_type_COLOR = 1,
	};
	inline cloud_type_enum cloud_type(void);
	inline void cloud_type(cloud_type_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Wood Texture ****************/

class WoodTexture : public Texture {
public:
	WoodTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline float turbulence(void);
	inline void turbulence(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum wood_type_enum {
		wood_type_BANDS = 0,
		wood_type_RINGS = 1,
		wood_type_BANDNOISE = 2,
		wood_type_RINGNOISE = 3,
	};
	inline wood_type_enum wood_type(void);
	inline void wood_type(wood_type_enum value);
	enum noise_basis_2_enum {
		noise_basis_2_SIN = 0,
		noise_basis_2_SAW = 1,
		noise_basis_2_TRI = 2,
	};
	inline noise_basis_2_enum noise_basis_2(void);
	inline void noise_basis_2(noise_basis_2_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Marble Texture ****************/

class MarbleTexture : public Texture {
public:
	MarbleTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline float turbulence(void);
	inline void turbulence(float value);
	inline int noise_depth(void);
	inline void noise_depth(int value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum marble_type_enum {
		marble_type_SOFT = 0,
		marble_type_SHARP = 1,
		marble_type_SHARPER = 2,
	};
	inline marble_type_enum marble_type(void);
	inline void marble_type(marble_type_enum value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_basis_2_enum {
		noise_basis_2_SIN = 0,
		noise_basis_2_SAW = 1,
		noise_basis_2_TRI = 2,
	};
	inline noise_basis_2_enum noise_basis_2(void);
	inline void noise_basis_2(noise_basis_2_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Magic Texture ****************/

class MagicTexture : public Texture {
public:
	MagicTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float turbulence(void);
	inline void turbulence(float value);
	inline int noise_depth(void);
	inline void noise_depth(int value);

};

/**************** Blend Texture ****************/

class BlendTexture : public Texture {
public:
	BlendTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	enum progression_enum {
		progression_LINEAR = 0,
		progression_QUADRATIC = 1,
		progression_EASING = 2,
		progression_DIAGONAL = 3,
		progression_SPHERICAL = 4,
		progression_QUADRATIC_SPHERE = 5,
		progression_RADIAL = 6,
	};
	inline progression_enum progression(void);
	inline void progression(progression_enum value);
	enum use_flip_axis_enum {
		use_flip_axis_HORIZONTAL = 0,
		use_flip_axis_VERTICAL = 2,
	};
	inline use_flip_axis_enum use_flip_axis(void);
	inline void use_flip_axis(use_flip_axis_enum value);

};

/**************** Stucci Texture ****************/

class StucciTexture : public Texture {
public:
	StucciTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float turbulence(void);
	inline void turbulence(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};
	inline noise_type_enum noise_type(void);
	inline void noise_type(noise_type_enum value);
	enum stucci_type_enum {
		stucci_type_PLASTIC = 0,
		stucci_type_WALL_IN = 1,
		stucci_type_WALL_OUT = 2,
	};
	inline stucci_type_enum stucci_type(void);
	inline void stucci_type(stucci_type_enum value);

};

/**************** Noise Texture ****************/

class NoiseTexture : public Texture {
public:
	NoiseTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}


};

/**************** Image Texture ****************/

class ImageTexture : public Texture {
public:
	ImageTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline bool use_interpolation(void);
	inline void use_interpolation(bool value);
	inline bool use_flip_axis(void);
	inline void use_flip_axis(bool value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_calculate_alpha(void);
	inline void use_calculate_alpha(bool value);
	inline bool invert_alpha(void);
	inline void invert_alpha(bool value);
	inline bool use_mipmap(void);
	inline void use_mipmap(bool value);
	inline bool use_mipmap_gauss(void);
	inline void use_mipmap_gauss(bool value);
	enum filter_type_enum {
		filter_type_BOX = 0,
		filter_type_EWA = 1,
		filter_type_FELINE = 2,
		filter_type_AREA = 3,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline int filter_lightprobes(void);
	inline void filter_lightprobes(int value);
	inline int filter_eccentricity(void);
	inline void filter_eccentricity(int value);
	inline bool use_filter_size_min(void);
	inline void use_filter_size_min(bool value);
	inline float filter_size(void);
	inline void filter_size(float value);
	enum extension_enum {
		extension_EXTEND = 1,
		extension_CLIP = 2,
		extension_CLIP_CUBE = 4,
		extension_REPEAT = 3,
		extension_CHECKER = 5,
	};
	inline extension_enum extension(void);
	inline void extension(extension_enum value);
	inline int repeat_x(void);
	inline void repeat_x(int value);
	inline int repeat_y(void);
	inline void repeat_y(int value);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool use_mirror_y(void);
	inline void use_mirror_y(bool value);
	inline bool use_checker_odd(void);
	inline void use_checker_odd(bool value);
	inline bool use_checker_even(void);
	inline void use_checker_even(bool value);
	inline float checker_distance(void);
	inline void checker_distance(float value);
	inline float crop_min_x(void);
	inline void crop_min_x(float value);
	inline float crop_min_y(void);
	inline void crop_min_y(float value);
	inline float crop_max_x(void);
	inline void crop_max_x(float value);
	inline float crop_max_y(void);
	inline void crop_max_y(float value);
	inline Image image(void);
	inline ImageUser image_user(void);
	inline bool use_normal_map(void);
	inline void use_normal_map(bool value);

};

/**************** Musgrave ****************/

class MusgraveTexture : public Texture {
public:
	MusgraveTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	enum musgrave_type_enum {
		musgrave_type_MULTIFRACTAL = 0,
		musgrave_type_RIDGED_MULTIFRACTAL = 1,
		musgrave_type_HYBRID_MULTIFRACTAL = 2,
		musgrave_type_FBM = 3,
		musgrave_type_HETERO_TERRAIN = 4,
	};
	inline musgrave_type_enum musgrave_type(void);
	inline void musgrave_type(musgrave_type_enum value);
	inline float dimension_max(void);
	inline void dimension_max(float value);
	inline float lacunarity(void);
	inline void lacunarity(float value);
	inline float octaves(void);
	inline void octaves(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float gain(void);
	inline void gain(float value);
	inline float noise_intensity(void);
	inline void noise_intensity(float value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Voronoi ****************/

class VoronoiTexture : public Texture {
public:
	VoronoiTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float weight_1(void);
	inline void weight_1(float value);
	inline float weight_2(void);
	inline void weight_2(float value);
	inline float weight_3(void);
	inline void weight_3(float value);
	inline float weight_4(void);
	inline void weight_4(float value);
	inline float minkovsky_exponent(void);
	inline void minkovsky_exponent(float value);
	enum distance_metric_enum {
		distance_metric_DISTANCE = 0,
		distance_metric_DISTANCE_SQUARED = 1,
		distance_metric_MANHATTAN = 2,
		distance_metric_CHEBYCHEV = 3,
		distance_metric_MINKOVSKY_HALF = 4,
		distance_metric_MINKOVSKY_FOUR = 5,
		distance_metric_MINKOVSKY = 6,
	};
	inline distance_metric_enum distance_metric(void);
	inline void distance_metric(distance_metric_enum value);
	enum color_mode_enum {
		color_mode_INTENSITY = 0,
		color_mode_POSITION = 1,
		color_mode_POSITION_OUTLINE = 2,
		color_mode_POSITION_OUTLINE_INTENSITY = 3,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);
	inline float noise_intensity(void);
	inline void noise_intensity(float value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Distorted Noise ****************/

class DistortedNoiseTexture : public Texture {
public:
	DistortedNoiseTexture(const PointerRNA &ptr_arg) :
		Texture(ptr_arg)
		{}

	inline float distortion(void);
	inline void distortion(float value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};
	inline noise_basis_enum noise_basis(void);
	inline void noise_basis(noise_basis_enum value);
	enum noise_distortion_enum {
		noise_distortion_BLENDER_ORIGINAL = 0,
		noise_distortion_ORIGINAL_PERLIN = 1,
		noise_distortion_IMPROVED_PERLIN = 2,
		noise_distortion_VORONOI_F1 = 3,
		noise_distortion_VORONOI_F2 = 4,
		noise_distortion_VORONOI_F3 = 5,
		noise_distortion_VORONOI_F4 = 6,
		noise_distortion_VORONOI_F2_F1 = 7,
		noise_distortion_VORONOI_CRACKLE = 8,
		noise_distortion_CELL_NOISE = 14,
	};
	inline noise_distortion_enum noise_distortion(void);
	inline void noise_distortion(noise_distortion_enum value);
	inline float nabla(void);
	inline void nabla(float value);

};

/**************** Texture Slot ****************/

class TextureSlot : public Pointer {
public:
	TextureSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Texture texture(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 5,
		blend_type_MULTIPLY = 1,
		blend_type_LIGHTEN = 7,
		blend_type_SCREEN = 8,
		blend_type_ADD = 2,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 15,
		blend_type_LINEAR_LIGHT = 16,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 4,
		blend_type_HUE = 10,
		blend_type_SATURATION = 11,
		blend_type_COLOR = 13,
		blend_type_VALUE = 12,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	enum output_node_enum {
		output_node_DUMMY = 0,
	};
	inline output_node_enum output_node(void);
	inline void output_node(output_node_enum value);

};

/**************** Texture Mapping ****************/

class TexMapping : public Pointer {
public:
	TexMapping(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum vector_type_enum {
		vector_type_POINT = 0,
		vector_type_TEXTURE = 1,
		vector_type_VECTOR = 2,
		vector_type_NORMAL = 3,
	};
	inline vector_type_enum vector_type(void);
	inline void vector_type(vector_type_enum value);
	inline Array<float, 3> translation(void);
	inline void translation(float values[3]);
	inline Array<float, 3> rotation(void);
	inline void rotation(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> min(void);
	inline void min(float values[3]);
	inline Array<float, 3> max(void);
	inline void max(float values[3]);
	inline bool use_min(void);
	inline void use_min(bool value);
	inline bool use_max(void);
	inline void use_max(bool value);
	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};
	inline mapping_x_enum mapping_x(void);
	inline void mapping_x(mapping_x_enum value);
	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};
	inline mapping_y_enum mapping_y(void);
	inline void mapping_y(mapping_y_enum value);
	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};
	inline mapping_z_enum mapping_z(void);
	inline void mapping_z(mapping_z_enum value);
	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);

};

/**************** Color Mapping ****************/

class ColorMapping : public Pointer {
public:
	ColorMapping(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_color_ramp(void);
	inline void use_color_ramp(bool value);
	inline ColorRamp color_ramp(void);
	inline float brightness(void);
	inline void brightness(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float saturation(void);
	inline void saturation(float value);
	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 5,
		blend_type_MULTIPLY = 1,
		blend_type_LIGHTEN = 7,
		blend_type_SCREEN = 8,
		blend_type_ADD = 2,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 15,
		blend_type_LINEAR_LIGHT = 16,
		blend_type_DIFFERENCE = 6,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 4,
		blend_type_HUE = 10,
		blend_type_SATURATION = 11,
		blend_type_COLOR = 13,
		blend_type_VALUE = 12,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline Array<float, 3> blend_color(void);
	inline void blend_color(float values[3]);
	inline float blend_factor(void);
	inline void blend_factor(float value);

};

/**************** Action ****************/

class Action : public ID {
public:
	Action(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		fcurves(ptr_arg),
		groups(ptr_arg),
		pose_markers(ptr_arg)
		{}

	COLLECTION_PROPERTY(ActionFCurves, FCurve, Action, fcurves, false, true, false)
	COLLECTION_PROPERTY(ActionGroups, ActionGroup, Action, groups, false, true, true)
	COLLECTION_PROPERTY(ActionPoseMarkers, TimelineMarker, Action, pose_markers, false, true, true)
	inline bool use_frame_range(void);
	inline void use_frame_range(bool value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline Array<float, 2> frame_range(void);
	inline void frame_range(float values[2]);
	inline Array<float, 2> curve_frame_range(void);
	inline void curve_frame_range(float values[2]);
	enum id_root_enum {
		id_root_ACTION = 17217,
		id_root_ARMATURE = 21057,
		id_root_BRUSH = 21058,
		id_root_CACHEFILE = 17987,
		id_root_CAMERA = 16707,
		id_root_COLLECTION = 21063,
		id_root_CURVE = 21827,
		id_root_CURVES = 22083,
		id_root_FONT = 18006,
		id_root_GREASEPENCIL = 17479,
		id_root_GREASEPENCIL_V3 = 20551,
		id_root_IMAGE = 19785,
		id_root_KEY = 17739,
		id_root_LATTICE = 21580,
		id_root_LIBRARY = 18764,
		id_root_LIGHT = 16716,
		id_root_LIGHT_PROBE = 20556,
		id_root_LINESTYLE = 21324,
		id_root_MASK = 21325,
		id_root_MATERIAL = 16717,
		id_root_MESH = 17741,
		id_root_META = 16973,
		id_root_MOVIECLIP = 17229,
		id_root_NODETREE = 21582,
		id_root_OBJECT = 16975,
		id_root_PAINTCURVE = 17232,
		id_root_PALETTE = 19536,
		id_root_PARTICLE = 16720,
		id_root_POINTCLOUD = 21584,
		id_root_SCENE = 17235,
		id_root_SOUND = 20307,
		id_root_SPEAKER = 19283,
		id_root_TEXT = 22612,
		id_root_TEXTURE = 17748,
		id_root_VOLUME = 20310,
		id_root_WINDOWMANAGER = 19799,
		id_root_WORKSPACE = 21335,
		id_root_WORLD = 20311,
	};
	inline id_root_enum id_root(void);
	inline void id_root(id_root_enum value);

	inline void flip_with_pose(Object& object);
};

/**************** Action Group ****************/

class ActionGroup : public Pointer {
public:
	ActionGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		channels(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FCurve, ActionGroup, channels, false, false, false)
	inline bool select(void);
	inline void select(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool show_expanded_graph(void);
	inline void show_expanded_graph(bool value);
	inline bool use_pin(void);
	inline void use_pin(bool value);
	enum color_set_enum {
		color_set_DEFAULT = 0,
		color_set_THEME01 = 1,
		color_set_THEME02 = 2,
		color_set_THEME03 = 3,
		color_set_THEME04 = 4,
		color_set_THEME05 = 5,
		color_set_THEME06 = 6,
		color_set_THEME07 = 7,
		color_set_THEME08 = 8,
		color_set_THEME09 = 9,
		color_set_THEME10 = 10,
		color_set_THEME11 = 11,
		color_set_THEME12 = 12,
		color_set_THEME13 = 13,
		color_set_THEME14 = 14,
		color_set_THEME15 = 15,
		color_set_THEME16 = 16,
		color_set_THEME17 = 17,
		color_set_THEME18 = 18,
		color_set_THEME19 = 19,
		color_set_THEME20 = 20,
		color_set_CUSTOM = -1,
	};
	inline color_set_enum color_set(void);
	inline void color_set(color_set_enum value);
	inline bool is_custom_color_set(void);
	inline void is_custom_color_set(bool value);
	inline ThemeBoneColorSet colors(void);

};

/**************** Dope Sheet ****************/

class DopeSheet : public Pointer {
public:
	DopeSheet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID source(void);
	inline bool show_datablock_filters(void);
	inline void show_datablock_filters(bool value);
	inline bool show_only_selected(void);
	inline void show_only_selected(bool value);
	inline bool show_hidden(void);
	inline void show_hidden(bool value);
	inline bool use_datablock_sort(void);
	inline void use_datablock_sort(bool value);
	inline bool use_filter_invert(void);
	inline void use_filter_invert(bool value);
	inline bool show_only_errors(void);
	inline void show_only_errors(bool value);
	inline Collection filter_collection(void);
	inline std::string filter_fcurve_name(void);
	inline void filter_fcurve_name(const std::string& value);
	inline std::string filter_text(void);
	inline void filter_text(const std::string& value);
	inline bool use_multi_word_filter(void);
	inline void use_multi_word_filter(bool value);
	inline bool show_missing_nla(void);
	inline void show_missing_nla(bool value);
	inline bool show_summary(void);
	inline void show_summary(bool value);
	inline bool show_expanded_summary(void);
	inline void show_expanded_summary(bool value);
	inline bool show_transforms(void);
	inline void show_transforms(bool value);
	inline bool show_shapekeys(void);
	inline void show_shapekeys(bool value);
	inline bool show_modifiers(void);
	inline void show_modifiers(bool value);
	inline bool show_meshes(void);
	inline void show_meshes(bool value);
	inline bool show_lattices(void);
	inline void show_lattices(bool value);
	inline bool show_cameras(void);
	inline void show_cameras(bool value);
	inline bool show_materials(void);
	inline void show_materials(bool value);
	inline bool show_lights(void);
	inline void show_lights(bool value);
	inline bool show_linestyles(void);
	inline void show_linestyles(bool value);
	inline bool show_textures(void);
	inline void show_textures(bool value);
	inline bool show_curves(void);
	inline void show_curves(bool value);
	inline bool show_worlds(void);
	inline void show_worlds(bool value);
	inline bool show_scenes(void);
	inline void show_scenes(bool value);
	inline bool show_particles(void);
	inline void show_particles(bool value);
	inline bool show_metaballs(void);
	inline void show_metaballs(bool value);
	inline bool show_armatures(void);
	inline void show_armatures(bool value);
	inline bool show_nodes(void);
	inline void show_nodes(bool value);
	inline bool show_speakers(void);
	inline void show_speakers(bool value);
	inline bool show_cache_files(void);
	inline void show_cache_files(bool value);
	inline bool show_hair_curves(void);
	inline void show_hair_curves(bool value);
	inline bool show_pointclouds(void);
	inline void show_pointclouds(bool value);
	inline bool show_volumes(void);
	inline void show_volumes(bool value);
	inline bool show_gpencil(void);
	inline void show_gpencil(bool value);
	inline bool show_movieclips(void);
	inline void show_movieclips(bool value);

};

/**************** Animation Data ****************/

class AnimData : public Pointer {
public:
	AnimData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		nla_tracks(ptr_arg),
		drivers(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(NlaTracks, NlaTrack, AnimData, nla_tracks, false, true, true)
	inline Action action(void);
	enum action_extrapolation_enum {
		action_extrapolation_NOTHING = 2,
		action_extrapolation_HOLD = 0,
		action_extrapolation_HOLD_FORWARD = 1,
	};
	inline action_extrapolation_enum action_extrapolation(void);
	inline void action_extrapolation(action_extrapolation_enum value);
	enum action_blend_type_enum {
		action_blend_type_REPLACE = 0,
		action_blend_type_COMBINE = 4,
		action_blend_type_ADD = 1,
		action_blend_type_SUBTRACT = 2,
		action_blend_type_MULTIPLY = 3,
	};
	inline action_blend_type_enum action_blend_type(void);
	inline void action_blend_type(action_blend_type_enum value);
	inline float action_influence(void);
	inline void action_influence(float value);
	inline Action action_tweak_storage(void);
	COLLECTION_PROPERTY(AnimDataDrivers, FCurve, AnimData, drivers, false, true, false)
	inline bool use_nla(void);
	inline void use_nla(bool value);
	inline bool use_tweak_mode(void);
	inline void use_tweak_mode(bool value);
	inline bool use_pin(void);
	inline void use_pin(bool value);

	inline float nla_tweak_strip_time_to_scene(float frame, bool invert);
};

/**************** Keying Set ****************/

class KeyingSet : public Pointer {
public:
	KeyingSet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		paths(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline KeyingSetInfo type_info(void);
	COLLECTION_PROPERTY(KeyingSetPaths, KeyingSetPath, KeyingSet, paths, false, true, true)
	inline bool is_path_absolute(void);
	inline void is_path_absolute(bool value);
	inline bool use_insertkey_override_needed(void);
	inline void use_insertkey_override_needed(bool value);
	inline bool use_insertkey_override_visual(void);
	inline void use_insertkey_override_visual(bool value);
	inline bool use_insertkey_override_xyz_to_rgb(void);
	inline void use_insertkey_override_xyz_to_rgb(bool value);
	inline bool use_insertkey_needed(void);
	inline void use_insertkey_needed(bool value);
	inline bool use_insertkey_visual(void);
	inline void use_insertkey_visual(bool value);
	inline bool use_insertkey_xyz_to_rgb(void);
	inline void use_insertkey_xyz_to_rgb(bool value);

	inline void refresh(Context C);
};

/**************** Keying Set Path ****************/

class KeyingSetPath : public Pointer {
public:
	KeyingSetPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	enum id_type_enum {
		id_type_ACTION = 17217,
		id_type_ARMATURE = 21057,
		id_type_BRUSH = 21058,
		id_type_CACHEFILE = 17987,
		id_type_CAMERA = 16707,
		id_type_COLLECTION = 21063,
		id_type_CURVE = 21827,
		id_type_CURVES = 22083,
		id_type_FONT = 18006,
		id_type_GREASEPENCIL = 17479,
		id_type_GREASEPENCIL_V3 = 20551,
		id_type_IMAGE = 19785,
		id_type_KEY = 17739,
		id_type_LATTICE = 21580,
		id_type_LIBRARY = 18764,
		id_type_LIGHT = 16716,
		id_type_LIGHT_PROBE = 20556,
		id_type_LINESTYLE = 21324,
		id_type_MASK = 21325,
		id_type_MATERIAL = 16717,
		id_type_MESH = 17741,
		id_type_META = 16973,
		id_type_MOVIECLIP = 17229,
		id_type_NODETREE = 21582,
		id_type_OBJECT = 16975,
		id_type_PAINTCURVE = 17232,
		id_type_PALETTE = 19536,
		id_type_PARTICLE = 16720,
		id_type_POINTCLOUD = 21584,
		id_type_SCENE = 17235,
		id_type_SOUND = 20307,
		id_type_SPEAKER = 19283,
		id_type_TEXT = 22612,
		id_type_TEXTURE = 17748,
		id_type_VOLUME = 20310,
		id_type_WINDOWMANAGER = 19799,
		id_type_WORKSPACE = 21335,
		id_type_WORLD = 20311,
	};
	inline id_type_enum id_type(void);
	inline void id_type(id_type_enum value);
	inline std::string group(void);
	inline void group(const std::string& value);
	enum group_method_enum {
		group_method_NAMED = 0,
		group_method_NONE = 1,
		group_method_KEYINGSET = 2,
	};
	inline group_method_enum group_method(void);
	inline void group_method(group_method_enum value);
	inline std::string data_path(void);
	inline void data_path(const std::string& value);
	inline int array_index(void);
	inline void array_index(int value);
	inline bool use_entire_array(void);
	inline void use_entire_array(bool value);
	inline bool use_insertkey_override_needed(void);
	inline void use_insertkey_override_needed(bool value);
	inline bool use_insertkey_override_visual(void);
	inline void use_insertkey_override_visual(bool value);
	inline bool use_insertkey_override_xyz_to_rgb(void);
	inline void use_insertkey_override_xyz_to_rgb(bool value);
	inline bool use_insertkey_needed(void);
	inline void use_insertkey_needed(bool value);
	inline bool use_insertkey_visual(void);
	inline void use_insertkey_visual(bool value);
	inline bool use_insertkey_xyz_to_rgb(void);
	inline void use_insertkey_xyz_to_rgb(bool value);

};

/**************** Keying Set Info ****************/

class KeyingSetInfo : public Pointer {
public:
	KeyingSetInfo(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	enum bl_options_enum {
		bl_options_INSERTKEY_NEEDED = 1,
		bl_options_INSERTKEY_VISUAL = 2,
		bl_options_INSERTKEY_XYZ_TO_RGB = 32,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);

};

/**************** Animation Visualization ****************/

class AnimViz : public Pointer {
public:
	AnimViz(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline AnimVizMotionPaths motion_path(void);

};

/**************** Motion Path Settings ****************/

class AnimVizMotionPaths : public Pointer {
public:
	AnimVizMotionPaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_CURRENT_FRAME = 1,
		type_RANGE = 0,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum range_enum {
		range_KEYS_ALL = 2,
		range_KEYS_SELECTED = 1,
		range_SCENE = 0,
		range_MANUAL = 3,
	};
	inline range_enum range(void);
	inline void range(range_enum value);
	enum bake_location_enum {
		bake_location_HEADS = 2,
		bake_location_TAILS = 0,
	};
	inline bake_location_enum bake_location(void);
	inline void bake_location(bake_location_enum value);
	inline bool show_frame_numbers(void);
	inline void show_frame_numbers(bool value);
	inline bool show_keyframe_highlight(void);
	inline void show_keyframe_highlight(bool value);
	inline bool show_keyframe_numbers(void);
	inline void show_keyframe_numbers(bool value);
	inline bool show_keyframe_action_all(void);
	inline void show_keyframe_action_all(bool value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_before(void);
	inline void frame_before(int value);
	inline int frame_after(void);
	inline void frame_after(int value);
	inline bool has_motion_paths(void);
	inline void has_motion_paths(bool value);

};

/**************** Motion Path ****************/

class MotionPath : public Pointer {
public:
	MotionPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MotionPathVert, MotionPath, points, true, true, false)
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int length(void);
	inline void length(int value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline int line_thickness(void);
	inline void line_thickness(int value);
	inline bool use_bone_head(void);
	inline void use_bone_head(bool value);
	inline bool is_modified(void);
	inline void is_modified(bool value);
	inline bool use_custom_color(void);
	inline void use_custom_color(bool value);
	inline bool lines(void);
	inline void lines(bool value);

};

/**************** Motion Path Cache Point ****************/

class MotionPathVert : public Pointer {
public:
	MotionPathVert(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline bool select(void);
	inline void select(bool value);

};

/**************** BoneColor ****************/

class BoneColor : public Pointer {
public:
	BoneColor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum palette_enum {
		palette_DEFAULT = 0,
		palette_THEME01 = 1,
		palette_THEME02 = 2,
		palette_THEME03 = 3,
		palette_THEME04 = 4,
		palette_THEME05 = 5,
		palette_THEME06 = 6,
		palette_THEME07 = 7,
		palette_THEME08 = 8,
		palette_THEME09 = 9,
		palette_THEME10 = 10,
		palette_THEME11 = 11,
		palette_THEME12 = 12,
		palette_THEME13 = 13,
		palette_THEME14 = 14,
		palette_THEME15 = 15,
		palette_THEME16 = 16,
		palette_THEME17 = 17,
		palette_THEME18 = 18,
		palette_THEME19 = 19,
		palette_THEME20 = 20,
		palette_CUSTOM = -1,
	};
	inline palette_enum palette(void);
	inline void palette(palette_enum value);
	inline bool is_custom(void);
	inline void is_custom(bool value);
	inline ThemeBoneColorSet custom(void);

};

/**************** BoneCollection ****************/

class BoneCollection : public Pointer {
public:
	BoneCollection(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		bones(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool is_visible(void);
	inline void is_visible(bool value);
	inline bool is_local_override(void);
	inline void is_local_override(bool value);
	inline bool is_editable(void);
	inline void is_editable(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Bone, BoneCollection, bones, false, true, true)

	inline bool assign(Context C, AnyType& bone);
	inline bool unassign(Context C, AnyType& bone);
};

/**************** Armature ****************/

class Armature : public ID {
public:
	Armature(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		bones(ptr_arg),
		edit_bones(ptr_arg),
		collections(ptr_arg)
		{}

	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(ArmatureBones, Bone, Armature, bones, false, false, true)
	COLLECTION_PROPERTY(ArmatureEditBones, EditBone, Armature, edit_bones, false, true, true)
	COLLECTION_PROPERTY(BoneCollections, BoneCollection, Armature, collections, false, true, true)
	enum pose_position_enum {
		pose_position_POSE = 0,
		pose_position_REST = 1,
	};
	inline pose_position_enum pose_position(void);
	inline void pose_position(pose_position_enum value);
	enum display_type_enum {
		display_type_OCTAHEDRAL = 0,
		display_type_STICK = 1,
		display_type_BBONE = 2,
		display_type_ENVELOPE = 3,
		display_type_WIRE = 4,
	};
	inline display_type_enum display_type(void);
	inline void display_type(display_type_enum value);
	inline bool show_axes(void);
	inline void show_axes(bool value);
	inline float axes_position(void);
	inline void axes_position(float value);
	enum relation_line_position_enum {
		relation_line_position_TAIL = 0,
		relation_line_position_HEAD = 1,
	};
	inline relation_line_position_enum relation_line_position(void);
	inline void relation_line_position(relation_line_position_enum value);
	inline bool show_names(void);
	inline void show_names(bool value);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool show_bone_custom_shapes(void);
	inline void show_bone_custom_shapes(bool value);
	inline bool show_bone_colors(void);
	inline void show_bone_colors(bool value);
	inline bool is_editmode(void);
	inline void is_editmode(bool value);

	inline void transform(float matrix[16]);
};

/**************** Bone ****************/

class Bone : public Pointer {
public:
	Bone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		children(ptr_arg),
		collections(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Bone parent(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Bone, Bone, children, false, true, true)
	COLLECTION_PROPERTY(BoneCollectionMemberships, BoneCollection, Bone, collections, false, false, false)
	inline std::string name(void);
	inline void name(const std::string& value);
	inline BoneColor color(void);
	inline bool use_connect(void);
	inline void use_connect(bool value);
	inline bool use_inherit_rotation(void);
	inline void use_inherit_rotation(bool value);
	inline bool use_envelope_multiply(void);
	inline void use_envelope_multiply(bool value);
	inline bool use_deform(void);
	inline void use_deform(bool value);
	enum inherit_scale_enum {
		inherit_scale_FULL = 0,
		inherit_scale_FIX_SHEAR = 1,
		inherit_scale_ALIGNED = 5,
		inherit_scale_AVERAGE = 2,
		inherit_scale_NONE = 3,
		inherit_scale_NONE_LEGACY = 4,
	};
	inline inherit_scale_enum inherit_scale(void);
	inline void inherit_scale(inherit_scale_enum value);
	inline bool use_local_location(void);
	inline void use_local_location(bool value);
	inline bool use_relative_parent(void);
	inline void use_relative_parent(bool value);
	inline bool show_wire(void);
	inline void show_wire(bool value);
	inline bool use_cyclic_offset(void);
	inline void use_cyclic_offset(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline float envelope_distance(void);
	inline void envelope_distance(float value);
	inline float envelope_weight(void);
	inline void envelope_weight(float value);
	inline float head_radius(void);
	inline void head_radius(float value);
	inline float tail_radius(void);
	inline void tail_radius(float value);
	inline int bbone_segments(void);
	inline void bbone_segments(int value);
	enum bbone_mapping_mode_enum {
		bbone_mapping_mode_STRAIGHT = 0,
		bbone_mapping_mode_CURVED = 1,
	};
	inline bbone_mapping_mode_enum bbone_mapping_mode(void);
	inline void bbone_mapping_mode(bbone_mapping_mode_enum value);
	inline float bbone_x(void);
	inline void bbone_x(float value);
	inline float bbone_z(void);
	inline void bbone_z(float value);
	enum bbone_handle_type_start_enum {
		bbone_handle_type_start_AUTO = 0,
		bbone_handle_type_start_ABSOLUTE = 1,
		bbone_handle_type_start_RELATIVE = 2,
		bbone_handle_type_start_TANGENT = 3,
	};
	inline bbone_handle_type_start_enum bbone_handle_type_start(void);
	inline void bbone_handle_type_start(bbone_handle_type_start_enum value);
	inline Bone bbone_custom_handle_start(void);
	inline Array<bool, 3> bbone_handle_use_scale_start(void);
	inline void bbone_handle_use_scale_start(bool values[3]);
	inline bool bbone_handle_use_ease_start(void);
	inline void bbone_handle_use_ease_start(bool value);
	enum bbone_handle_type_end_enum {
		bbone_handle_type_end_AUTO = 0,
		bbone_handle_type_end_ABSOLUTE = 1,
		bbone_handle_type_end_RELATIVE = 2,
		bbone_handle_type_end_TANGENT = 3,
	};
	inline bbone_handle_type_end_enum bbone_handle_type_end(void);
	inline void bbone_handle_type_end(bbone_handle_type_end_enum value);
	inline Bone bbone_custom_handle_end(void);
	inline Array<bool, 3> bbone_handle_use_scale_end(void);
	inline void bbone_handle_use_scale_end(bool values[3]);
	inline bool bbone_handle_use_ease_end(void);
	inline void bbone_handle_use_ease_end(bool value);
	inline float bbone_rollin(void);
	inline void bbone_rollin(float value);
	inline float bbone_rollout(void);
	inline void bbone_rollout(float value);
	inline bool use_endroll_as_inroll(void);
	inline void use_endroll_as_inroll(bool value);
	inline float bbone_curveinx(void);
	inline void bbone_curveinx(float value);
	inline float bbone_curveinz(void);
	inline void bbone_curveinz(float value);
	inline float bbone_curveoutx(void);
	inline void bbone_curveoutx(float value);
	inline float bbone_curveoutz(void);
	inline void bbone_curveoutz(float value);
	inline float bbone_easein(void);
	inline void bbone_easein(float value);
	inline float bbone_easeout(void);
	inline void bbone_easeout(float value);
	inline bool use_scale_easing(void);
	inline void use_scale_easing(bool value);
	inline Array<float, 3> bbone_scalein(void);
	inline void bbone_scalein(float values[3]);
	inline Array<float, 3> bbone_scaleout(void);
	inline void bbone_scaleout(float values[3]);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_head(void);
	inline void select_head(bool value);
	inline bool select_tail(void);
	inline void select_tail(bool value);
	inline Array<float, 9> matrix(void);
	inline void matrix(float values[9]);
	inline Array<float, 16> matrix_local(void);
	inline void matrix_local(float values[16]);
	inline Array<float, 3> tail(void);
	inline void tail(float values[3]);
	inline Array<float, 3> tail_local(void);
	inline void tail_local(float values[3]);
	inline Array<float, 3> head(void);
	inline void head(float values[3]);
	inline Array<float, 3> head_local(void);
	inline void head_local(float values[3]);
	inline float length(void);
	inline void length(float value);

	inline float evaluate_envelope(float point[3]);
	inline void convert_local_to_pose(float matrix_return[16], float matrix[16], float matrix_local[16], float parent_matrix[16], float parent_matrix_local[16], bool invert);
	inline void MatrixFromAxisRoll(float axis[3], float roll, float result_matrix[9]);
	inline void AxisRollFromMatrix(float matrix[9], float axis[3], float result_axis[3], float *result_roll);
};

/**************** Edit Bone ****************/

class EditBone : public Pointer {
public:
	EditBone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		collections(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoneCollection, EditBone, collections, false, false, false)
	inline EditBone parent(void);
	inline float roll(void);
	inline void roll(float value);
	inline Array<float, 3> head(void);
	inline void head(float values[3]);
	inline Array<float, 3> tail(void);
	inline void tail(float values[3]);
	inline float length(void);
	inline void length(float value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline BoneColor color(void);
	inline bool use_connect(void);
	inline void use_connect(bool value);
	inline bool use_inherit_rotation(void);
	inline void use_inherit_rotation(bool value);
	inline bool use_envelope_multiply(void);
	inline void use_envelope_multiply(bool value);
	inline bool use_deform(void);
	inline void use_deform(bool value);
	enum inherit_scale_enum {
		inherit_scale_FULL = 0,
		inherit_scale_FIX_SHEAR = 1,
		inherit_scale_ALIGNED = 5,
		inherit_scale_AVERAGE = 2,
		inherit_scale_NONE = 3,
		inherit_scale_NONE_LEGACY = 4,
	};
	inline inherit_scale_enum inherit_scale(void);
	inline void inherit_scale(inherit_scale_enum value);
	inline bool use_local_location(void);
	inline void use_local_location(bool value);
	inline bool use_relative_parent(void);
	inline void use_relative_parent(bool value);
	inline bool show_wire(void);
	inline void show_wire(bool value);
	inline bool use_cyclic_offset(void);
	inline void use_cyclic_offset(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline float envelope_distance(void);
	inline void envelope_distance(float value);
	inline float envelope_weight(void);
	inline void envelope_weight(float value);
	inline float head_radius(void);
	inline void head_radius(float value);
	inline float tail_radius(void);
	inline void tail_radius(float value);
	inline int bbone_segments(void);
	inline void bbone_segments(int value);
	enum bbone_mapping_mode_enum {
		bbone_mapping_mode_STRAIGHT = 0,
		bbone_mapping_mode_CURVED = 1,
	};
	inline bbone_mapping_mode_enum bbone_mapping_mode(void);
	inline void bbone_mapping_mode(bbone_mapping_mode_enum value);
	inline float bbone_x(void);
	inline void bbone_x(float value);
	inline float bbone_z(void);
	inline void bbone_z(float value);
	enum bbone_handle_type_start_enum {
		bbone_handle_type_start_AUTO = 0,
		bbone_handle_type_start_ABSOLUTE = 1,
		bbone_handle_type_start_RELATIVE = 2,
		bbone_handle_type_start_TANGENT = 3,
	};
	inline bbone_handle_type_start_enum bbone_handle_type_start(void);
	inline void bbone_handle_type_start(bbone_handle_type_start_enum value);
	inline EditBone bbone_custom_handle_start(void);
	inline Array<bool, 3> bbone_handle_use_scale_start(void);
	inline void bbone_handle_use_scale_start(bool values[3]);
	inline bool bbone_handle_use_ease_start(void);
	inline void bbone_handle_use_ease_start(bool value);
	enum bbone_handle_type_end_enum {
		bbone_handle_type_end_AUTO = 0,
		bbone_handle_type_end_ABSOLUTE = 1,
		bbone_handle_type_end_RELATIVE = 2,
		bbone_handle_type_end_TANGENT = 3,
	};
	inline bbone_handle_type_end_enum bbone_handle_type_end(void);
	inline void bbone_handle_type_end(bbone_handle_type_end_enum value);
	inline EditBone bbone_custom_handle_end(void);
	inline Array<bool, 3> bbone_handle_use_scale_end(void);
	inline void bbone_handle_use_scale_end(bool values[3]);
	inline bool bbone_handle_use_ease_end(void);
	inline void bbone_handle_use_ease_end(bool value);
	inline float bbone_rollin(void);
	inline void bbone_rollin(float value);
	inline float bbone_rollout(void);
	inline void bbone_rollout(float value);
	inline bool use_endroll_as_inroll(void);
	inline void use_endroll_as_inroll(bool value);
	inline float bbone_curveinx(void);
	inline void bbone_curveinx(float value);
	inline float bbone_curveinz(void);
	inline void bbone_curveinz(float value);
	inline float bbone_curveoutx(void);
	inline void bbone_curveoutx(float value);
	inline float bbone_curveoutz(void);
	inline void bbone_curveoutz(float value);
	inline float bbone_easein(void);
	inline void bbone_easein(float value);
	inline float bbone_easeout(void);
	inline void bbone_easeout(float value);
	inline bool use_scale_easing(void);
	inline void use_scale_easing(bool value);
	inline Array<float, 3> bbone_scalein(void);
	inline void bbone_scalein(float values[3]);
	inline Array<float, 3> bbone_scaleout(void);
	inline void bbone_scaleout(float values[3]);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_head(void);
	inline void select_head(bool value);
	inline bool select_tail(void);
	inline void select_tail(bool value);
	inline Array<float, 16> matrix(void);
	inline void matrix(float values[16]);

	inline void align_roll(float vector[3]);
};

/**************** Attribute ****************/

class Attribute : public Pointer {
public:
	Attribute(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum data_type_enum {
		data_type_FLOAT = 10,
		data_type_INT = 11,
		data_type_FLOAT_VECTOR = 48,
		data_type_FLOAT_COLOR = 47,
		data_type_BYTE_COLOR = 17,
		data_type_STRING = 12,
		data_type_BOOLEAN = 50,
		data_type_FLOAT2 = 49,
		data_type_INT8 = 45,
		data_type_INT32_2D = 46,
		data_type_QUATERNION = 52,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);
	enum domain_enum {
		domain_POINT = 0,
		domain_EDGE = 1,
		domain_FACE = 2,
		domain_CORNER = 3,
		domain_CURVE = 4,
		domain_INSTANCE = 5,
		domain_LAYER = 6,
	};
	inline domain_enum domain(void);
	inline void domain(domain_enum value);
	inline bool is_internal(void);
	inline void is_internal(bool value);
	inline bool is_required(void);
	inline void is_required(bool value);

};

/**************** Float Attribute ****************/

class FloatAttribute : public Attribute {
public:
	FloatAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, FloatAttributeValue, FloatAttribute, data, true, true, false)

};

/**************** Float Attribute Value ****************/

class FloatAttributeValue : public Pointer {
public:
	FloatAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float value(void);
	inline void value(float value);

};

/**************** Float Vector Attribute ****************/

class FloatVectorAttribute : public Attribute {
public:
	FloatVectorAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, FloatVectorAttributeValue, FloatVectorAttribute, data, true, true, false)

};

/**************** Float Vector Attribute Value ****************/

class FloatVectorAttributeValue : public Pointer {
public:
	FloatVectorAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> vector(void);
	inline void vector(float values[3]);

};

/**************** Float Color Attribute ****************/

class FloatColorAttribute : public Attribute {
public:
	FloatColorAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, FloatColorAttributeValue, FloatColorAttribute, data, true, true, false)

};

/**************** Float Color Attribute Value ****************/

class FloatColorAttributeValue : public Pointer {
public:
	FloatColorAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline Array<float, 4> color_srgb(void);
	inline void color_srgb(float values[4]);

};

/**************** Byte Color Attribute ****************/

class ByteColorAttribute : public Attribute {
public:
	ByteColorAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, ByteColorAttributeValue, ByteColorAttribute, data, true, true, false)

};

/**************** Byte Color Attribute Value ****************/

class ByteColorAttributeValue : public Pointer {
public:
	ByteColorAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline Array<float, 4> color_srgb(void);
	inline void color_srgb(float values[4]);

};

/**************** Integer Attribute ****************/

class IntAttribute : public Attribute {
public:
	IntAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, IntAttributeValue, IntAttribute, data, true, true, false)

};

/**************** Integer Attribute Value ****************/

class IntAttributeValue : public Pointer {
public:
	IntAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int value(void);
	inline void value(int value);

};

/**************** 2D Integer Vector Attribute ****************/

class Int2Attribute : public Attribute {
public:
	Int2Attribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Int2AttributeValue, Int2Attribute, data, true, true, false)

};

/**************** 2D Integer Vector Attribute Value ****************/

class Int2AttributeValue : public Pointer {
public:
	Int2AttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<int, 2> value(void);
	inline void value(int values[2]);

};

/**************** Quaternion Attribute ****************/

class QuaternionAttribute : public Attribute {
public:
	QuaternionAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, QuaternionAttributeValue, QuaternionAttribute, data, true, true, false)

};

/**************** Quaternion Attribute Value ****************/

class QuaternionAttributeValue : public Pointer {
public:
	QuaternionAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> value(void);
	inline void value(float values[4]);

};

/**************** String Attribute ****************/

class StringAttribute : public Attribute {
public:
	StringAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, StringAttributeValue, StringAttribute, data, true, true, false)

};

/**************** String Attribute Value ****************/

class StringAttributeValue : public Pointer {
public:
	StringAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string value(void);
	inline void value(const std::string& value);

};

/**************** Bool Attribute ****************/

class BoolAttribute : public Attribute {
public:
	BoolAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoolAttributeValue, BoolAttribute, data, true, true, false)

};

/**************** Bool Attribute Value ****************/

class BoolAttributeValue : public Pointer {
public:
	BoolAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool value(void);
	inline void value(bool value);

};

/**************** Float2 Attribute ****************/

class Float2Attribute : public Attribute {
public:
	Float2Attribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Float2AttributeValue, Float2Attribute, data, true, true, false)

};

/**************** Float2 Attribute Value ****************/

class Float2AttributeValue : public Pointer {
public:
	Float2AttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> vector(void);
	inline void vector(float values[2]);

};

/**************** 8-bit Integer Attribute ****************/

class ByteIntAttribute : public Attribute {
public:
	ByteIntAttribute(const PointerRNA &ptr_arg) :
		Attribute(ptr_arg),
		data(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, ByteIntAttributeValue, ByteIntAttribute, data, true, true, false)

};

/**************** 8-bit Integer Attribute Value ****************/

class ByteIntAttributeValue : public Pointer {
public:
	ByteIntAttributeValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int value(void);
	inline void value(int value);

};

/**************** Asset Tag ****************/

class AssetTag : public Pointer {
public:
	AssetTag(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Asset Data ****************/

class AssetMetaData : public Pointer {
public:
	AssetMetaData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tags(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string author(void);
	inline void author(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline std::string copyright(void);
	inline void copyright(const std::string& value);
	inline std::string license(void);
	inline void license(const std::string& value);
	COLLECTION_PROPERTY(AssetTags, AssetTag, AssetMetaData, tags, false, true, true)
	inline int active_tag(void);
	inline void active_tag(int value);
	inline std::string catalog_id(void);
	inline void catalog_id(const std::string& value);
	inline std::string catalog_simple_name(void);
	inline void catalog_simple_name(const std::string& value);

};

/**************** Asset Library Reference ****************/

class AssetLibraryReference : public Pointer {
public:
	AssetLibraryReference(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Asset Handle ****************/

class AssetHandle : public PropertyGroup {
public:
	AssetHandle(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}

	inline FileSelectEntry file_data(void);

};

/**************** Asset Representation ****************/

class AssetRepresentation : public Pointer {
public:
	AssetRepresentation(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline AssetMetaData metadata(void);
	enum id_type_enum {
		id_type_ACTION = 17217,
		id_type_ARMATURE = 21057,
		id_type_BRUSH = 21058,
		id_type_CACHEFILE = 17987,
		id_type_CAMERA = 16707,
		id_type_COLLECTION = 21063,
		id_type_CURVE = 21827,
		id_type_CURVES = 22083,
		id_type_FONT = 18006,
		id_type_GREASEPENCIL = 17479,
		id_type_GREASEPENCIL_V3 = 20551,
		id_type_IMAGE = 19785,
		id_type_KEY = 17739,
		id_type_LATTICE = 21580,
		id_type_LIBRARY = 18764,
		id_type_LIGHT = 16716,
		id_type_LIGHT_PROBE = 20556,
		id_type_LINESTYLE = 21324,
		id_type_MASK = 21325,
		id_type_MATERIAL = 16717,
		id_type_MESH = 17741,
		id_type_META = 16973,
		id_type_MOVIECLIP = 17229,
		id_type_NODETREE = 21582,
		id_type_OBJECT = 16975,
		id_type_PAINTCURVE = 17232,
		id_type_PALETTE = 19536,
		id_type_PARTICLE = 16720,
		id_type_POINTCLOUD = 21584,
		id_type_SCENE = 17235,
		id_type_SOUND = 20307,
		id_type_SPEAKER = 19283,
		id_type_TEXT = 22612,
		id_type_TEXTURE = 17748,
		id_type_VOLUME = 20310,
		id_type_WINDOWMANAGER = 19799,
		id_type_WORKSPACE = 21335,
		id_type_WORLD = 20311,
	};
	inline id_type_enum id_type(void);
	inline void id_type(id_type_enum value);
	inline ID local_id(void);
	inline std::string full_library_path(void);
	inline void full_library_path(const std::string& value);
	inline std::string full_path(void);
	inline void full_path(const std::string& value);

};

/**************** Catalog Path ****************/

class AssetCatalogPath : public Pointer {
public:
	AssetCatalogPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Boid Rule ****************/

class BoidRule : public Pointer {
public:
	BoidRule(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_GOAL = 1,
		type_AVOID = 2,
		type_AVOID_COLLISION = 3,
		type_SEPARATE = 4,
		type_FLOCK = 5,
		type_FOLLOW_LEADER = 6,
		type_AVERAGE_SPEED = 7,
		type_FIGHT = 8,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use_in_air(void);
	inline void use_in_air(bool value);
	inline bool use_on_land(void);
	inline void use_on_land(bool value);

};

/**************** Goal ****************/

class BoidRuleGoal : public BoidRule {
public:
	BoidRuleGoal(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_predict(void);
	inline void use_predict(bool value);

};

/**************** Avoid ****************/

class BoidRuleAvoid : public BoidRule {
public:
	BoidRuleAvoid(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_predict(void);
	inline void use_predict(bool value);
	inline float fear_factor(void);
	inline void fear_factor(float value);

};

/**************** Avoid Collision ****************/

class BoidRuleAvoidCollision : public BoidRule {
public:
	BoidRuleAvoidCollision(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline bool use_avoid(void);
	inline void use_avoid(bool value);
	inline bool use_avoid_collision(void);
	inline void use_avoid_collision(bool value);
	inline float look_ahead(void);
	inline void look_ahead(float value);

};

/**************** Follow Leader ****************/

class BoidRuleFollowLeader : public BoidRule {
public:
	BoidRuleFollowLeader(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline Object object(void);
	inline float distance(void);
	inline void distance(float value);
	inline int queue_count(void);
	inline void queue_count(int value);
	inline bool use_line(void);
	inline void use_line(bool value);

};

/**************** Average Speed ****************/

class BoidRuleAverageSpeed : public BoidRule {
public:
	BoidRuleAverageSpeed(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline float wander(void);
	inline void wander(float value);
	inline float level(void);
	inline void level(float value);
	inline float speed(void);
	inline void speed(float value);

};

/**************** Fight ****************/

class BoidRuleFight : public BoidRule {
public:
	BoidRuleFight(const PointerRNA &ptr_arg) :
		BoidRule(ptr_arg)
		{}

	inline float distance(void);
	inline void distance(float value);
	inline float flee_distance(void);
	inline void flee_distance(float value);

};

/**************** Boid State ****************/

class BoidState : public Pointer {
public:
	BoidState(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		rules(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum ruleset_type_enum {
		ruleset_type_FUZZY = 0,
		ruleset_type_RANDOM = 1,
		ruleset_type_AVERAGE = 2,
	};
	inline ruleset_type_enum ruleset_type(void);
	inline void ruleset_type(ruleset_type_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoidRule, BoidState, rules, false, true, true)
	inline BoidRule active_boid_rule(void);
	inline int active_boid_rule_index(void);
	inline void active_boid_rule_index(int value);
	inline float rule_fuzzy(void);
	inline void rule_fuzzy(float value);
	inline float volume(void);
	inline void volume(float value);
	inline float falloff(void);
	inline void falloff(float value);

};

/**************** Boid Settings ****************/

class BoidSettings : public Pointer {
public:
	BoidSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		states(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float land_smooth(void);
	inline void land_smooth(float value);
	inline float bank(void);
	inline void bank(float value);
	inline float pitch(void);
	inline void pitch(float value);
	inline float height(void);
	inline void height(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoidState, BoidSettings, states, false, true, true)
	inline BoidRule active_boid_state(void);
	inline int active_boid_state_index(void);
	inline void active_boid_state_index(int value);
	inline float health(void);
	inline void health(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float aggression(void);
	inline void aggression(float value);
	inline float accuracy(void);
	inline void accuracy(float value);
	inline float range(void);
	inline void range(float value);
	inline float air_speed_min(void);
	inline void air_speed_min(float value);
	inline float air_speed_max(void);
	inline void air_speed_max(float value);
	inline float air_acc_max(void);
	inline void air_acc_max(float value);
	inline float air_ave_max(void);
	inline void air_ave_max(float value);
	inline float air_personal_space(void);
	inline void air_personal_space(float value);
	inline float land_jump_speed(void);
	inline void land_jump_speed(float value);
	inline float land_speed_max(void);
	inline void land_speed_max(float value);
	inline float land_acc_max(void);
	inline void land_acc_max(float value);
	inline float land_ave_max(void);
	inline void land_ave_max(float value);
	inline float land_personal_space(void);
	inline void land_personal_space(float value);
	inline float land_stick_force(void);
	inline void land_stick_force(float value);
	inline bool use_flight(void);
	inline void use_flight(bool value);
	inline bool use_land(void);
	inline void use_land(bool value);
	inline bool use_climb(void);
	inline void use_climb(bool value);

};

/**************** Brush ****************/

class Brush : public ID {
public:
	Brush(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 5,
		blend_MUL = 3,
		blend_COLORBURN = 10,
		blend_LINEARBURN = 11,
		blend_LIGHTEN = 4,
		blend_SCREEN = 13,
		blend_COLORDODGE = 12,
		blend_ADD = 1,
		blend_OVERLAY = 8,
		blend_SOFTLIGHT = 14,
		blend_HARDLIGHT = 9,
		blend_VIVIDLIGHT = 16,
		blend_LINEARLIGHT = 17,
		blend_PINLIGHT = 15,
		blend_DIFFERENCE = 18,
		blend_EXCLUSION = 19,
		blend_SUB = 2,
		blend_HUE = 20,
		blend_SATURATION = 21,
		blend_COLOR = 23,
		blend_LUMINOSITY = 22,
		blend_ERASE_ALPHA = 6,
		blend_ADD_ALPHA = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	enum sculpt_tool_enum {
		sculpt_tool_DRAW = 1,
		sculpt_tool_DRAW_SHARP = 20,
		sculpt_tool_CLAY = 8,
		sculpt_tool_CLAY_STRIPS = 18,
		sculpt_tool_CLAY_THUMB = 25,
		sculpt_tool_LAYER = 6,
		sculpt_tool_INFLATE = 4,
		sculpt_tool_BLOB = 17,
		sculpt_tool_CREASE = 16,
		sculpt_tool_SMOOTH = 2,
		sculpt_tool_FLATTEN = 7,
		sculpt_tool_FILL = 9,
		sculpt_tool_SCRAPE = 10,
		sculpt_tool_MULTIPLANE_SCRAPE = 23,
		sculpt_tool_PINCH = 3,
		sculpt_tool_GRAB = 5,
		sculpt_tool_ELASTIC_DEFORM = 21,
		sculpt_tool_SNAKE_HOOK = 13,
		sculpt_tool_THUMB = 12,
		sculpt_tool_POSE = 22,
		sculpt_tool_NUDGE = 11,
		sculpt_tool_ROTATE = 14,
		sculpt_tool_TOPOLOGY = 24,
		sculpt_tool_BOUNDARY = 30,
		sculpt_tool_CLOTH = 26,
		sculpt_tool_SIMPLIFY = 15,
		sculpt_tool_MASK = 19,
		sculpt_tool_DRAW_FACE_SETS = 27,
		sculpt_tool_DISPLACEMENT_ERASER = 31,
		sculpt_tool_DISPLACEMENT_SMEAR = 32,
		sculpt_tool_PAINT = 28,
		sculpt_tool_SMEAR = 29,
	};
	inline sculpt_tool_enum sculpt_tool(void);
	inline void sculpt_tool(sculpt_tool_enum value);
	enum uv_sculpt_tool_enum {
		uv_sculpt_tool_GRAB = 0,
		uv_sculpt_tool_RELAX = 1,
		uv_sculpt_tool_PINCH = 2,
	};
	inline uv_sculpt_tool_enum uv_sculpt_tool(void);
	inline void uv_sculpt_tool(uv_sculpt_tool_enum value);
	enum vertex_tool_enum {
		vertex_tool_DRAW = 0,
		vertex_tool_BLUR = 1,
		vertex_tool_AVERAGE = 2,
		vertex_tool_SMEAR = 3,
	};
	inline vertex_tool_enum vertex_tool(void);
	inline void vertex_tool(vertex_tool_enum value);
	enum weight_tool_enum {
		weight_tool_DRAW = 0,
		weight_tool_BLUR = 1,
		weight_tool_AVERAGE = 2,
		weight_tool_SMEAR = 3,
	};
	inline weight_tool_enum weight_tool(void);
	inline void weight_tool(weight_tool_enum value);
	enum image_tool_enum {
		image_tool_DRAW = 0,
		image_tool_SOFTEN = 1,
		image_tool_SMEAR = 2,
		image_tool_CLONE = 3,
		image_tool_FILL = 4,
		image_tool_MASK = 5,
	};
	inline image_tool_enum image_tool(void);
	inline void image_tool(image_tool_enum value);
	enum gpencil_tool_enum {
		gpencil_tool_DRAW = 0,
		gpencil_tool_FILL = 1,
		gpencil_tool_ERASE = 2,
		gpencil_tool_TINT = 3,
	};
	inline gpencil_tool_enum gpencil_tool(void);
	inline void gpencil_tool(gpencil_tool_enum value);
	enum gpencil_vertex_tool_enum {
		gpencil_vertex_tool_DRAW = 0,
		gpencil_vertex_tool_BLUR = 1,
		gpencil_vertex_tool_AVERAGE = 2,
		gpencil_vertex_tool_SMEAR = 4,
		gpencil_vertex_tool_REPLACE = 5,
	};
	inline gpencil_vertex_tool_enum gpencil_vertex_tool(void);
	inline void gpencil_vertex_tool(gpencil_vertex_tool_enum value);
	enum gpencil_sculpt_tool_enum {
		gpencil_sculpt_tool_SMOOTH = 0,
		gpencil_sculpt_tool_THICKNESS = 1,
		gpencil_sculpt_tool_STRENGTH = 2,
		gpencil_sculpt_tool_RANDOMIZE = 7,
		gpencil_sculpt_tool_GRAB = 3,
		gpencil_sculpt_tool_PUSH = 4,
		gpencil_sculpt_tool_TWIST = 5,
		gpencil_sculpt_tool_PINCH = 6,
		gpencil_sculpt_tool_CLONE = 8,
	};
	inline gpencil_sculpt_tool_enum gpencil_sculpt_tool(void);
	inline void gpencil_sculpt_tool(gpencil_sculpt_tool_enum value);
	enum gpencil_weight_tool_enum {
		gpencil_weight_tool_WEIGHT = 0,
		gpencil_weight_tool_BLUR = 1,
		gpencil_weight_tool_AVERAGE = 2,
		gpencil_weight_tool_SMEAR = 3,
	};
	inline gpencil_weight_tool_enum gpencil_weight_tool(void);
	inline void gpencil_weight_tool(gpencil_weight_tool_enum value);
	enum curves_sculpt_tool_enum {
		curves_sculpt_tool_SELECTION_PAINT = 5,
		curves_sculpt_tool_ADD = 3,
		curves_sculpt_tool_DELETE = 1,
		curves_sculpt_tool_DENSITY = 9,
		curves_sculpt_tool_COMB = 0,
		curves_sculpt_tool_SNAKE_HOOK = 2,
		curves_sculpt_tool_GROW_SHRINK = 4,
		curves_sculpt_tool_PINCH = 6,
		curves_sculpt_tool_PUFF = 8,
		curves_sculpt_tool_SMOOTH = 7,
		curves_sculpt_tool_SLIDE = 10,
	};
	inline curves_sculpt_tool_enum curves_sculpt_tool(void);
	inline void curves_sculpt_tool(curves_sculpt_tool_enum value);
	enum direction_enum {
		direction_ADD = 0,
		direction_SUBTRACT = 512,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	enum stroke_method_enum {
		stroke_method_DOTS = 0,
		stroke_method_DRAG_DOT = 8388608,
		stroke_method_SPACE = 1024,
		stroke_method_AIRBRUSH = 1,
		stroke_method_ANCHORED = 256,
		stroke_method_LINE = 536870912,
		stroke_method_CURVE = -2147483648,
	};
	inline stroke_method_enum stroke_method(void);
	inline void stroke_method(stroke_method_enum value);
	enum sculpt_plane_enum {
		sculpt_plane_AREA = 0,
		sculpt_plane_VIEW = 1,
		sculpt_plane_X = 2,
		sculpt_plane_Y = 3,
		sculpt_plane_Z = 4,
	};
	inline sculpt_plane_enum sculpt_plane(void);
	inline void sculpt_plane(sculpt_plane_enum value);
	enum mask_tool_enum {
		mask_tool_DRAW = 0,
		mask_tool_SMOOTH = 1,
	};
	inline mask_tool_enum mask_tool(void);
	inline void mask_tool(mask_tool_enum value);
	enum curve_preset_enum {
		curve_preset_CUSTOM = 0,
		curve_preset_SMOOTH = 1,
		curve_preset_SMOOTHER = 9,
		curve_preset_SPHERE = 2,
		curve_preset_ROOT = 3,
		curve_preset_SHARP = 4,
		curve_preset_LIN = 5,
		curve_preset_POW4 = 6,
		curve_preset_INVSQUARE = 7,
		curve_preset_CONSTANT = 8,
	};
	inline curve_preset_enum curve_preset(void);
	inline void curve_preset(curve_preset_enum value);
	enum deform_target_enum {
		deform_target_GEOMETRY = 0,
		deform_target_CLOTH_SIM = 1,
	};
	inline deform_target_enum deform_target(void);
	inline void deform_target(deform_target_enum value);
	enum elastic_deform_type_enum {
		elastic_deform_type_GRAB = 0,
		elastic_deform_type_GRAB_BISCALE = 1,
		elastic_deform_type_GRAB_TRISCALE = 2,
		elastic_deform_type_SCALE = 3,
		elastic_deform_type_TWIST = 4,
	};
	inline elastic_deform_type_enum elastic_deform_type(void);
	inline void elastic_deform_type(elastic_deform_type_enum value);
	enum snake_hook_deform_type_enum {
		snake_hook_deform_type_FALLOFF = 0,
		snake_hook_deform_type_ELASTIC = 1,
	};
	inline snake_hook_deform_type_enum snake_hook_deform_type(void);
	inline void snake_hook_deform_type(snake_hook_deform_type_enum value);
	enum cloth_deform_type_enum {
		cloth_deform_type_DRAG = 0,
		cloth_deform_type_PUSH = 1,
		cloth_deform_type_PINCH_POINT = 3,
		cloth_deform_type_PINCH_PERPENDICULAR = 4,
		cloth_deform_type_INFLATE = 5,
		cloth_deform_type_GRAB = 2,
		cloth_deform_type_EXPAND = 6,
		cloth_deform_type_SNAKE_HOOK = 7,
	};
	inline cloth_deform_type_enum cloth_deform_type(void);
	inline void cloth_deform_type(cloth_deform_type_enum value);
	enum cloth_force_falloff_type_enum {
		cloth_force_falloff_type_RADIAL = 0,
		cloth_force_falloff_type_PLANE = 1,
	};
	inline cloth_force_falloff_type_enum cloth_force_falloff_type(void);
	inline void cloth_force_falloff_type(cloth_force_falloff_type_enum value);
	enum cloth_simulation_area_type_enum {
		cloth_simulation_area_type_LOCAL = 0,
		cloth_simulation_area_type_GLOBAL = 1,
		cloth_simulation_area_type_DYNAMIC = 2,
	};
	inline cloth_simulation_area_type_enum cloth_simulation_area_type(void);
	inline void cloth_simulation_area_type(cloth_simulation_area_type_enum value);
	enum boundary_falloff_type_enum {
		boundary_falloff_type_CONSTANT = 0,
		boundary_falloff_type_RADIUS = 1,
		boundary_falloff_type_LOOP = 2,
		boundary_falloff_type_LOOP_INVERT = 3,
	};
	inline boundary_falloff_type_enum boundary_falloff_type(void);
	inline void boundary_falloff_type(boundary_falloff_type_enum value);
	enum smooth_deform_type_enum {
		smooth_deform_type_LAPLACIAN = 0,
		smooth_deform_type_SURFACE = 1,
	};
	inline smooth_deform_type_enum smooth_deform_type(void);
	inline void smooth_deform_type(smooth_deform_type_enum value);
	enum smear_deform_type_enum {
		smear_deform_type_DRAG = 0,
		smear_deform_type_PINCH = 1,
		smear_deform_type_EXPAND = 2,
	};
	inline smear_deform_type_enum smear_deform_type(void);
	inline void smear_deform_type(smear_deform_type_enum value);
	enum slide_deform_type_enum {
		slide_deform_type_DRAG = 0,
		slide_deform_type_PINCH = 1,
		slide_deform_type_EXPAND = 2,
	};
	inline slide_deform_type_enum slide_deform_type(void);
	inline void slide_deform_type(slide_deform_type_enum value);
	enum boundary_deform_type_enum {
		boundary_deform_type_BEND = 0,
		boundary_deform_type_EXPAND = 1,
		boundary_deform_type_INFLATE = 2,
		boundary_deform_type_GRAB = 3,
		boundary_deform_type_TWIST = 4,
		boundary_deform_type_SMOOTH = 5,
	};
	inline boundary_deform_type_enum boundary_deform_type(void);
	inline void boundary_deform_type(boundary_deform_type_enum value);
	enum pose_deform_type_enum {
		pose_deform_type_ROTATE_TWIST = 0,
		pose_deform_type_SCALE_TRANSLATE = 1,
		pose_deform_type_SQUASH_STRETCH = 2,
	};
	inline pose_deform_type_enum pose_deform_type(void);
	inline void pose_deform_type(pose_deform_type_enum value);
	enum pose_origin_type_enum {
		pose_origin_type_TOPOLOGY = 0,
		pose_origin_type_FACE_SETS = 1,
		pose_origin_type_FACE_SETS_FK = 2,
	};
	inline pose_origin_type_enum pose_origin_type(void);
	inline void pose_origin_type(pose_origin_type_enum value);
	enum jitter_unit_enum {
		jitter_unit_VIEW = 1073741824,
		jitter_unit_BRUSH = 0,
	};
	inline jitter_unit_enum jitter_unit(void);
	inline void jitter_unit(jitter_unit_enum value);
	enum falloff_shape_enum {
		falloff_shape_SPHERE = 0,
		falloff_shape_PROJECTED = 1,
	};
	inline falloff_shape_enum falloff_shape(void);
	inline void falloff_shape(falloff_shape_enum value);
	inline int size(void);
	inline void size(int value);
	inline float unprojected_radius(void);
	inline void unprojected_radius(float value);
	inline float jitter(void);
	inline void jitter(float value);
	inline int jitter_absolute(void);
	inline void jitter_absolute(int value);
	inline int spacing(void);
	inline void spacing(int value);
	inline int grad_spacing(void);
	inline void grad_spacing(int value);
	inline int smooth_stroke_radius(void);
	inline void smooth_stroke_radius(int value);
	inline float smooth_stroke_factor(void);
	inline void smooth_stroke_factor(float value);
	inline float rate(void);
	inline void rate(float value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline Array<float, 3> secondary_color(void);
	inline void secondary_color(float values[3]);
	inline float weight(void);
	inline void weight(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float flow(void);
	inline void flow(float value);
	inline float wet_mix(void);
	inline void wet_mix(float value);
	inline float wet_persistence(void);
	inline void wet_persistence(float value);
	inline float density(void);
	inline void density(float value);
	inline float tip_scale_x(void);
	inline void tip_scale_x(float value);
	inline bool use_hardness_pressure(void);
	inline void use_hardness_pressure(bool value);
	inline bool invert_hardness_pressure(void);
	inline void invert_hardness_pressure(bool value);
	inline bool use_flow_pressure(void);
	inline void use_flow_pressure(bool value);
	inline bool invert_flow_pressure(void);
	inline void invert_flow_pressure(bool value);
	inline bool use_wet_mix_pressure(void);
	inline void use_wet_mix_pressure(bool value);
	inline bool invert_wet_mix_pressure(void);
	inline void invert_wet_mix_pressure(bool value);
	inline bool use_wet_persistence_pressure(void);
	inline void use_wet_persistence_pressure(bool value);
	inline bool invert_wet_persistence_pressure(void);
	inline void invert_wet_persistence_pressure(bool value);
	inline bool use_density_pressure(void);
	inline void use_density_pressure(bool value);
	inline bool invert_density_pressure(void);
	inline void invert_density_pressure(bool value);
	inline float dash_ratio(void);
	inline void dash_ratio(float value);
	inline int dash_samples(void);
	inline void dash_samples(int value);
	inline float plane_offset(void);
	inline void plane_offset(float value);
	inline float plane_trim(void);
	inline void plane_trim(float value);
	inline float height(void);
	inline void height(float value);
	inline float texture_sample_bias(void);
	inline void texture_sample_bias(float value);
	inline bool use_color_as_displacement(void);
	inline void use_color_as_displacement(bool value);
	inline float normal_weight(void);
	inline void normal_weight(float value);
	inline float elastic_deform_volume_preservation(void);
	inline void elastic_deform_volume_preservation(float value);
	inline float rake_factor(void);
	inline void rake_factor(float value);
	inline float crease_pinch_factor(void);
	inline void crease_pinch_factor(float value);
	inline float pose_offset(void);
	inline void pose_offset(float value);
	inline float disconnected_distance_max(void);
	inline void disconnected_distance_max(float value);
	inline float boundary_offset(void);
	inline void boundary_offset(float value);
	inline float surface_smooth_shape_preservation(void);
	inline void surface_smooth_shape_preservation(float value);
	inline float surface_smooth_current_vertex(void);
	inline void surface_smooth_current_vertex(float value);
	inline int surface_smooth_iterations(void);
	inline void surface_smooth_iterations(int value);
	inline float multiplane_scrape_angle(void);
	inline void multiplane_scrape_angle(float value);
	inline int pose_smooth_iterations(void);
	inline void pose_smooth_iterations(int value);
	inline int pose_ik_segments(void);
	inline void pose_ik_segments(int value);
	inline float tip_roundness(void);
	inline void tip_roundness(float value);
	inline float cloth_mass(void);
	inline void cloth_mass(float value);
	inline float cloth_damping(void);
	inline void cloth_damping(float value);
	inline float cloth_sim_limit(void);
	inline void cloth_sim_limit(float value);
	inline float cloth_sim_falloff(void);
	inline void cloth_sim_falloff(float value);
	inline float cloth_constraint_softbody_strength(void);
	inline void cloth_constraint_softbody_strength(float value);
	inline float hardness(void);
	inline void hardness(float value);
	inline int automasking_boundary_edges_propagation_steps(void);
	inline void automasking_boundary_edges_propagation_steps(int value);
	inline float auto_smooth_factor(void);
	inline void auto_smooth_factor(float value);
	inline float topology_rake_factor(void);
	inline void topology_rake_factor(float value);
	inline float tilt_strength_factor(void);
	inline void tilt_strength_factor(float value);
	inline float normal_radius_factor(void);
	inline void normal_radius_factor(float value);
	inline float area_radius_factor(void);
	inline void area_radius_factor(float value);
	inline float wet_paint_radius_factor(void);
	inline void wet_paint_radius_factor(float value);
	inline Array<float, 2> stencil_pos(void);
	inline void stencil_pos(float values[2]);
	inline Array<float, 2> stencil_dimension(void);
	inline void stencil_dimension(float values[2]);
	inline Array<float, 2> mask_stencil_pos(void);
	inline void mask_stencil_pos(float values[2]);
	inline Array<float, 2> mask_stencil_dimension(void);
	inline void mask_stencil_dimension(float values[2]);
	inline float sharp_threshold(void);
	inline void sharp_threshold(float value);
	inline float fill_threshold(void);
	inline void fill_threshold(float value);
	inline int blur_kernel_radius(void);
	inline void blur_kernel_radius(int value);
	enum blur_mode_enum {
		blur_mode_BOX = 1,
		blur_mode_GAUSSIAN = 0,
	};
	inline blur_mode_enum blur_mode(void);
	inline void blur_mode(blur_mode_enum value);
	inline float falloff_angle(void);
	inline void falloff_angle(float value);
	inline bool use_airbrush(void);
	inline void use_airbrush(bool value);
	inline bool use_original_normal(void);
	inline void use_original_normal(bool value);
	inline bool use_original_plane(void);
	inline void use_original_plane(bool value);
	inline bool use_automasking_topology(void);
	inline void use_automasking_topology(bool value);
	inline bool use_automasking_face_sets(void);
	inline void use_automasking_face_sets(bool value);
	inline bool use_automasking_boundary_edges(void);
	inline void use_automasking_boundary_edges(bool value);
	inline bool use_automasking_boundary_face_sets(void);
	inline void use_automasking_boundary_face_sets(bool value);
	inline bool use_automasking_cavity(void);
	inline void use_automasking_cavity(bool value);
	inline bool use_automasking_cavity_inverted(void);
	inline void use_automasking_cavity_inverted(bool value);
	inline bool use_automasking_custom_cavity_curve(void);
	inline void use_automasking_custom_cavity_curve(bool value);
	inline float automasking_cavity_factor(void);
	inline void automasking_cavity_factor(float value);
	inline int automasking_cavity_blur_steps(void);
	inline void automasking_cavity_blur_steps(int value);
	inline CurveMapping automasking_cavity_curve(void);
	inline bool use_automasking_start_normal(void);
	inline void use_automasking_start_normal(bool value);
	inline bool use_automasking_view_normal(void);
	inline void use_automasking_view_normal(bool value);
	inline bool use_automasking_view_occlusion(void);
	inline void use_automasking_view_occlusion(bool value);
	enum use_scene_spacing_enum {
		use_scene_spacing_VIEW = 0,
		use_scene_spacing_SCENE = 131072,
	};
	inline use_scene_spacing_enum use_scene_spacing(void);
	inline void use_scene_spacing(use_scene_spacing_enum value);
	inline bool use_grab_active_vertex(void);
	inline void use_grab_active_vertex(bool value);
	inline bool use_grab_silhouette(void);
	inline void use_grab_silhouette(bool value);
	inline bool use_paint_antialiasing(void);
	inline void use_paint_antialiasing(bool value);
	inline bool use_multiplane_scrape_dynamic(void);
	inline void use_multiplane_scrape_dynamic(bool value);
	inline bool show_multiplane_scrape_planes_preview(void);
	inline void show_multiplane_scrape_planes_preview(bool value);
	inline bool use_pose_ik_anchored(void);
	inline void use_pose_ik_anchored(bool value);
	inline bool use_pose_lock_rotation(void);
	inline void use_pose_lock_rotation(bool value);
	inline bool use_connected_only(void);
	inline void use_connected_only(bool value);
	inline bool use_cloth_pin_simulation_boundary(void);
	inline void use_cloth_pin_simulation_boundary(bool value);
	inline bool use_cloth_collision(void);
	inline void use_cloth_collision(bool value);
	inline bool invert_to_scrape_fill(void);
	inline void invert_to_scrape_fill(bool value);
	inline bool use_pressure_strength(void);
	inline void use_pressure_strength(bool value);
	inline bool use_offset_pressure(void);
	inline void use_offset_pressure(bool value);
	inline bool use_pressure_area_radius(void);
	inline void use_pressure_area_radius(bool value);
	inline bool use_pressure_size(void);
	inline void use_pressure_size(bool value);
	inline bool use_pressure_jitter(void);
	inline void use_pressure_jitter(bool value);
	inline bool use_pressure_spacing(void);
	inline void use_pressure_spacing(bool value);
	enum use_pressure_masking_enum {
		use_pressure_masking_NONE = 0,
		use_pressure_masking_RAMP = 2,
		use_pressure_masking_CUTOFF = 4,
	};
	inline use_pressure_masking_enum use_pressure_masking(void);
	inline void use_pressure_masking(use_pressure_masking_enum value);
	inline bool use_inverse_smooth_pressure(void);
	inline void use_inverse_smooth_pressure(bool value);
	inline bool use_plane_trim(void);
	inline void use_plane_trim(bool value);
	inline bool use_frontface(void);
	inline void use_frontface(bool value);
	inline bool use_frontface_falloff(void);
	inline void use_frontface_falloff(bool value);
	inline bool use_anchor(void);
	inline void use_anchor(bool value);
	inline bool use_space(void);
	inline void use_space(bool value);
	inline bool use_line(void);
	inline void use_line(bool value);
	inline bool use_curve(void);
	inline void use_curve(bool value);
	inline bool use_smooth_stroke(void);
	inline void use_smooth_stroke(bool value);
	inline bool use_persistent(void);
	inline void use_persistent(bool value);
	inline bool use_accumulate(void);
	inline void use_accumulate(bool value);
	inline bool use_space_attenuation(void);
	inline void use_space_attenuation(bool value);
	inline bool use_adaptive_space(void);
	inline void use_adaptive_space(bool value);
	enum use_locked_size_enum {
		use_locked_size_VIEW = 0,
		use_locked_size_SCENE = 1048576,
	};
	inline use_locked_size_enum use_locked_size(void);
	inline void use_locked_size(use_locked_size_enum value);
	enum color_type_enum {
		color_type_COLOR = 0,
		color_type_GRADIENT = 2097152,
	};
	inline color_type_enum color_type(void);
	inline void color_type(color_type_enum value);
	inline bool use_edge_to_edge(void);
	inline void use_edge_to_edge(bool value);
	inline bool use_restore_mesh(void);
	inline void use_restore_mesh(bool value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline CurveMapping curve(void);
	inline PaintCurve paint_curve(void);
	inline ColorRamp gradient(void);
	enum gradient_stroke_mode_enum {
		gradient_stroke_mode_PRESSURE = 0,
		gradient_stroke_mode_SPACING_REPEAT = 1,
		gradient_stroke_mode_SPACING_CLAMP = 2,
	};
	inline gradient_stroke_mode_enum gradient_stroke_mode(void);
	inline void gradient_stroke_mode(gradient_stroke_mode_enum value);
	enum gradient_fill_mode_enum {
		gradient_fill_mode_LINEAR = 0,
		gradient_fill_mode_RADIAL = 1,
	};
	inline gradient_fill_mode_enum gradient_fill_mode(void);
	inline void gradient_fill_mode(gradient_fill_mode_enum value);
	inline bool use_primary_overlay(void);
	inline void use_primary_overlay(bool value);
	inline bool use_secondary_overlay(void);
	inline void use_secondary_overlay(bool value);
	inline bool use_cursor_overlay(void);
	inline void use_cursor_overlay(bool value);
	inline bool use_cursor_overlay_override(void);
	inline void use_cursor_overlay_override(bool value);
	inline bool use_primary_overlay_override(void);
	inline void use_primary_overlay_override(bool value);
	inline bool use_secondary_overlay_override(void);
	inline void use_secondary_overlay_override(bool value);
	inline bool use_paint_sculpt(void);
	inline void use_paint_sculpt(bool value);
	inline bool use_paint_uv_sculpt(void);
	inline void use_paint_uv_sculpt(bool value);
	inline bool use_paint_vertex(void);
	inline void use_paint_vertex(bool value);
	inline bool use_paint_weight(void);
	inline void use_paint_weight(bool value);
	inline bool use_paint_image(void);
	inline void use_paint_image(bool value);
	inline bool use_paint_grease_pencil(void);
	inline void use_paint_grease_pencil(bool value);
	inline bool use_vertex_grease_pencil(void);
	inline void use_vertex_grease_pencil(bool value);
	inline bool use_paint_sculpt_curves(void);
	inline void use_paint_sculpt_curves(bool value);
	inline BrushTextureSlot texture_slot(void);
	inline Texture texture(void);
	inline BrushTextureSlot mask_texture_slot(void);
	inline Texture mask_texture(void);
	inline int texture_overlay_alpha(void);
	inline void texture_overlay_alpha(int value);
	inline int mask_overlay_alpha(void);
	inline void mask_overlay_alpha(int value);
	inline int cursor_overlay_alpha(void);
	inline void cursor_overlay_alpha(int value);
	inline Array<float, 4> cursor_color_add(void);
	inline void cursor_color_add(float values[4]);
	inline Array<float, 4> cursor_color_subtract(void);
	inline void cursor_color_subtract(float values[4]);
	inline bool use_custom_icon(void);
	inline void use_custom_icon(bool value);
	inline std::string icon_filepath(void);
	inline void icon_filepath(const std::string& value);
	inline Image clone_image(void);
	inline float clone_alpha(void);
	inline void clone_alpha(float value);
	inline Array<float, 2> clone_offset(void);
	inline void clone_offset(float values[2]);
	inline BrushCapabilities brush_capabilities(void);
	inline BrushCapabilitiesSculpt sculpt_capabilities(void);
	inline BrushCapabilitiesImagePaint image_paint_capabilities(void);
	inline BrushCapabilitiesVertexPaint vertex_paint_capabilities(void);
	inline BrushCapabilitiesWeightPaint weight_paint_capabilities(void);
	inline BrushGpencilSettings gpencil_settings(void);
	inline BrushCurvesSculptSettings curves_sculpt_settings(void);

};

/**************** Brush Capabilities ****************/

class BrushCapabilities : public Pointer {
public:
	BrushCapabilities(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_overlay(void);
	inline void has_overlay(bool value);
	inline bool has_random_texture_angle(void);
	inline void has_random_texture_angle(bool value);
	inline bool has_spacing(void);
	inline void has_spacing(bool value);
	inline bool has_smooth_stroke(void);
	inline void has_smooth_stroke(bool value);

};

/**************** Sculpt Capabilities ****************/

class BrushCapabilitiesSculpt : public Pointer {
public:
	BrushCapabilitiesSculpt(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_accumulate(void);
	inline void has_accumulate(bool value);
	inline bool has_auto_smooth(void);
	inline void has_auto_smooth(bool value);
	inline bool has_topology_rake(void);
	inline void has_topology_rake(bool value);
	inline bool has_height(void);
	inline void has_height(bool value);
	inline bool has_jitter(void);
	inline void has_jitter(bool value);
	inline bool has_normal_weight(void);
	inline void has_normal_weight(bool value);
	inline bool has_rake_factor(void);
	inline void has_rake_factor(bool value);
	inline bool has_persistence(void);
	inline void has_persistence(bool value);
	inline bool has_pinch_factor(void);
	inline void has_pinch_factor(bool value);
	inline bool has_plane_offset(void);
	inline void has_plane_offset(bool value);
	inline bool has_random_texture_angle(void);
	inline void has_random_texture_angle(bool value);
	inline bool has_sculpt_plane(void);
	inline void has_sculpt_plane(bool value);
	inline bool has_color(void);
	inline void has_color(bool value);
	inline bool has_secondary_color(void);
	inline void has_secondary_color(bool value);
	inline bool has_smooth_stroke(void);
	inline void has_smooth_stroke(bool value);
	inline bool has_space_attenuation(void);
	inline void has_space_attenuation(bool value);
	inline bool has_strength_pressure(void);
	inline void has_strength_pressure(bool value);
	inline bool has_direction(void);
	inline void has_direction(bool value);
	inline bool has_gravity(void);
	inline void has_gravity(bool value);
	inline bool has_tilt(void);
	inline void has_tilt(bool value);

};

/**************** Image Paint Capabilities ****************/

class BrushCapabilitiesImagePaint : public Pointer {
public:
	BrushCapabilitiesImagePaint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_accumulate(void);
	inline void has_accumulate(bool value);
	inline bool has_space_attenuation(void);
	inline void has_space_attenuation(bool value);
	inline bool has_radius(void);
	inline void has_radius(bool value);
	inline bool has_color(void);
	inline void has_color(bool value);

};

/**************** Vertex Paint Capabilities ****************/

class BrushCapabilitiesVertexPaint : public Pointer {
public:
	BrushCapabilitiesVertexPaint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_color(void);
	inline void has_color(bool value);

};

/**************** Weight Paint Capabilities ****************/

class BrushCapabilitiesWeightPaint : public Pointer {
public:
	BrushCapabilitiesWeightPaint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool has_weight(void);
	inline void has_weight(bool value);

};

/**************** Grease Pencil Brush Settings ****************/

class BrushGpencilSettings : public Pointer {
public:
	BrushGpencilSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float pen_strength(void);
	inline void pen_strength(float value);
	inline float pen_jitter(void);
	inline void pen_jitter(float value);
	inline float random_pressure(void);
	inline void random_pressure(float value);
	inline float random_strength(void);
	inline void random_strength(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float angle_factor(void);
	inline void angle_factor(float value);
	inline float pen_smooth_factor(void);
	inline void pen_smooth_factor(float value);
	inline int pen_smooth_steps(void);
	inline void pen_smooth_steps(int value);
	inline int pen_subdivision_steps(void);
	inline void pen_subdivision_steps(int value);
	inline float simplify_factor(void);
	inline void simplify_factor(float value);
	inline CurveMapping curve_sensitivity(void);
	inline CurveMapping curve_strength(void);
	inline CurveMapping curve_jitter(void);
	inline CurveMapping curve_random_pressure(void);
	inline CurveMapping curve_random_strength(void);
	inline CurveMapping curve_random_uv(void);
	inline CurveMapping curve_random_hue(void);
	inline CurveMapping curve_random_saturation(void);
	inline CurveMapping curve_random_value(void);
	inline float fill_threshold(void);
	inline void fill_threshold(float value);
	inline float fill_factor(void);
	inline void fill_factor(float value);
	inline int fill_simplify_level(void);
	inline void fill_simplify_level(int value);
	inline float uv_random(void);
	inline void uv_random(float value);
	inline float hardness(void);
	inline void hardness(float value);
	inline Array<float, 2> aspect(void);
	inline void aspect(float values[2]);
	inline int input_samples(void);
	inline void input_samples(int value);
	inline float active_smooth_factor(void);
	inline void active_smooth_factor(float value);
	inline float eraser_strength_factor(void);
	inline void eraser_strength_factor(float value);
	inline float eraser_thickness_factor(void);
	inline void eraser_thickness_factor(float value);
	enum gpencil_paint_icon_enum {
		gpencil_paint_icon_PENCIL = 1,
		gpencil_paint_icon_PEN = 2,
		gpencil_paint_icon_INK = 3,
		gpencil_paint_icon_INKNOISE = 4,
		gpencil_paint_icon_BLOCK = 5,
		gpencil_paint_icon_MARKER = 6,
		gpencil_paint_icon_AIRBRUSH = 11,
		gpencil_paint_icon_CHISEL = 12,
		gpencil_paint_icon_FILL = 7,
		gpencil_paint_icon_SOFT = 8,
		gpencil_paint_icon_HARD = 9,
		gpencil_paint_icon_STROKE = 10,
	};
	inline gpencil_paint_icon_enum gpencil_paint_icon(void);
	inline void gpencil_paint_icon(gpencil_paint_icon_enum value);
	enum gpencil_sculpt_icon_enum {
		gpencil_sculpt_icon_SMOOTH = 19,
		gpencil_sculpt_icon_THICKNESS = 20,
		gpencil_sculpt_icon_STRENGTH = 21,
		gpencil_sculpt_icon_RANDOMIZE = 22,
		gpencil_sculpt_icon_GRAB = 23,
		gpencil_sculpt_icon_PUSH = 24,
		gpencil_sculpt_icon_TWIST = 25,
		gpencil_sculpt_icon_PINCH = 26,
		gpencil_sculpt_icon_CLONE = 27,
	};
	inline gpencil_sculpt_icon_enum gpencil_sculpt_icon(void);
	inline void gpencil_sculpt_icon(gpencil_sculpt_icon_enum value);
	enum gpencil_weight_icon_enum {
		gpencil_weight_icon_DRAW = 28,
		gpencil_weight_icon_BLUR = 29,
		gpencil_weight_icon_AVERAGE = 30,
		gpencil_weight_icon_SMEAR = 31,
	};
	inline gpencil_weight_icon_enum gpencil_weight_icon(void);
	inline void gpencil_weight_icon(gpencil_weight_icon_enum value);
	enum gpencil_vertex_icon_enum {
		gpencil_vertex_icon_DRAW = 14,
		gpencil_vertex_icon_BLUR = 15,
		gpencil_vertex_icon_AVERAGE = 16,
		gpencil_vertex_icon_SMEAR = 17,
		gpencil_vertex_icon_REPLACE = 18,
	};
	inline gpencil_vertex_icon_enum gpencil_vertex_icon(void);
	inline void gpencil_vertex_icon(gpencil_vertex_icon_enum value);
	enum vertex_mode_enum {
		vertex_mode_STROKE = 0,
		vertex_mode_FILL = 1,
		vertex_mode_BOTH = 2,
	};
	inline vertex_mode_enum vertex_mode(void);
	inline void vertex_mode(vertex_mode_enum value);
	inline float vertex_color_factor(void);
	inline void vertex_color_factor(float value);
	inline float random_hue_factor(void);
	inline void random_hue_factor(float value);
	inline float random_saturation_factor(void);
	inline void random_saturation_factor(float value);
	inline float random_value_factor(void);
	inline void random_value_factor(float value);
	inline float extend_stroke_factor(void);
	inline void extend_stroke_factor(float value);
	enum fill_extend_mode_enum {
		fill_extend_mode_EXTEND = 0,
		fill_extend_mode_RADIUS = 1,
	};
	inline fill_extend_mode_enum fill_extend_mode(void);
	inline void fill_extend_mode(fill_extend_mode_enum value);
	inline int dilate(void);
	inline void dilate(int value);
	inline float outline_thickness_factor(void);
	inline void outline_thickness_factor(float value);
	inline bool use_pressure(void);
	inline void use_pressure(bool value);
	inline bool use_strength_pressure(void);
	inline void use_strength_pressure(bool value);
	inline bool use_jitter_pressure(void);
	inline void use_jitter_pressure(bool value);
	inline bool use_stroke_random_hue(void);
	inline void use_stroke_random_hue(bool value);
	inline bool use_stroke_random_sat(void);
	inline void use_stroke_random_sat(bool value);
	inline bool use_stroke_random_val(void);
	inline void use_stroke_random_val(bool value);
	inline bool use_stroke_random_radius(void);
	inline void use_stroke_random_radius(bool value);
	inline bool use_stroke_random_strength(void);
	inline void use_stroke_random_strength(bool value);
	inline bool use_stroke_random_uv(void);
	inline void use_stroke_random_uv(bool value);
	inline bool use_random_press_hue(void);
	inline void use_random_press_hue(bool value);
	inline bool use_random_press_sat(void);
	inline void use_random_press_sat(bool value);
	inline bool use_random_press_val(void);
	inline void use_random_press_val(bool value);
	inline bool use_random_press_radius(void);
	inline void use_random_press_radius(bool value);
	inline bool use_random_press_strength(void);
	inline void use_random_press_strength(bool value);
	inline bool use_random_press_uv(void);
	inline void use_random_press_uv(bool value);
	inline bool use_settings_stabilizer(void);
	inline void use_settings_stabilizer(bool value);
	enum eraser_mode_enum {
		eraser_mode_SOFT = 0,
		eraser_mode_HARD = 1,
		eraser_mode_STROKE = 2,
	};
	inline eraser_mode_enum eraser_mode(void);
	inline void eraser_mode(eraser_mode_enum value);
	enum caps_type_enum {
		caps_type_ROUND = 0,
		caps_type_FLAT = 1,
	};
	inline caps_type_enum caps_type(void);
	inline void caps_type(caps_type_enum value);
	enum fill_draw_mode_enum {
		fill_draw_mode_BOTH = 0,
		fill_draw_mode_STROKE = 1,
		fill_draw_mode_CONTROL = 2,
	};
	inline fill_draw_mode_enum fill_draw_mode(void);
	inline void fill_draw_mode(fill_draw_mode_enum value);
	enum fill_layer_mode_enum {
		fill_layer_mode_VISIBLE = 0,
		fill_layer_mode_ACTIVE = 1,
		fill_layer_mode_ABOVE = 4,
		fill_layer_mode_BELOW = 5,
		fill_layer_mode_ALL_ABOVE = 2,
		fill_layer_mode_ALL_BELOW = 3,
	};
	inline fill_layer_mode_enum fill_layer_mode(void);
	inline void fill_layer_mode(fill_layer_mode_enum value);
	enum fill_direction_enum {
		fill_direction_NORMAL = 0,
		fill_direction_INVERT = 512,
	};
	inline fill_direction_enum fill_direction(void);
	inline void fill_direction(fill_direction_enum value);
	inline bool pin_draw_mode(void);
	inline void pin_draw_mode(bool value);
	enum brush_draw_mode_enum {
		brush_draw_mode_ACTIVE = 0,
		brush_draw_mode_MATERIAL = 1,
		brush_draw_mode_VERTEXCOLOR = 2,
	};
	inline brush_draw_mode_enum brush_draw_mode(void);
	inline void brush_draw_mode(brush_draw_mode_enum value);
	inline bool use_trim(void);
	inline void use_trim(bool value);
	inline bool use_settings_outline(void);
	inline void use_settings_outline(bool value);
	enum direction_enum {
		direction_ADD = 0,
		direction_SUBTRACT = 512,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	inline bool use_edit_position(void);
	inline void use_edit_position(bool value);
	inline bool use_edit_strength(void);
	inline void use_edit_strength(bool value);
	inline bool use_edit_thickness(void);
	inline void use_edit_thickness(bool value);
	inline bool use_edit_uv(void);
	inline void use_edit_uv(bool value);
	inline Material material(void);
	inline Material material_alt(void);
	inline bool show_fill_boundary(void);
	inline void show_fill_boundary(bool value);
	inline bool show_fill_extend(void);
	inline void show_fill_extend(bool value);
	inline bool use_collide_strokes(void);
	inline void use_collide_strokes(bool value);
	inline bool show_fill(void);
	inline void show_fill(bool value);
	inline bool use_fill_limit(void);
	inline void use_fill_limit(bool value);
	inline bool use_default_eraser(void);
	inline void use_default_eraser(bool value);
	inline bool use_settings_postprocess(void);
	inline void use_settings_postprocess(bool value);
	inline bool use_settings_random(void);
	inline void use_settings_random(bool value);
	inline bool use_material_pin(void);
	inline void use_material_pin(bool value);
	inline bool show_lasso(void);
	inline void show_lasso(bool value);
	inline bool use_occlude_eraser(void);
	inline void use_occlude_eraser(bool value);
	inline bool use_keep_caps_eraser(void);
	inline void use_keep_caps_eraser(bool value);
	inline bool use_active_layer_only(void);
	inline void use_active_layer_only(bool value);

};

/**************** Curves Sculpt Brush Settings ****************/

class BrushCurvesSculptSettings : public Pointer {
public:
	BrushCurvesSculptSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int add_amount(void);
	inline void add_amount(int value);
	inline int points_per_curve(void);
	inline void points_per_curve(int value);
	inline bool scale_uniform(void);
	inline void scale_uniform(bool value);
	inline float minimum_length(void);
	inline void minimum_length(float value);
	inline bool interpolate_length(void);
	inline void interpolate_length(bool value);
	inline bool interpolate_point_count(void);
	inline void interpolate_point_count(bool value);
	inline bool interpolate_shape(void);
	inline void interpolate_shape(bool value);
	inline float curve_length(void);
	inline void curve_length(float value);
	inline float minimum_distance(void);
	inline void minimum_distance(float value);
	inline int density_add_attempts(void);
	inline void density_add_attempts(int value);
	enum density_mode_enum {
		density_mode_AUTO = 0,
		density_mode_ADD = 1,
		density_mode_REMOVE = 2,
	};
	inline density_mode_enum density_mode(void);
	inline void density_mode(density_mode_enum value);
	inline CurveMapping curve_parameter_falloff(void);

};

/**************** Brush Texture Slot ****************/

class BrushTextureSlot : public TextureSlot {
public:
	BrushTextureSlot(const PointerRNA &ptr_arg) :
		TextureSlot(ptr_arg)
		{}

	inline float angle(void);
	inline void angle(float value);
	enum map_mode_enum {
		map_mode_VIEW_PLANE = 0,
		map_mode_AREA_PLANE = 3,
		map_mode_TILED = 1,
		map_mode_3D = 2,
		map_mode_RANDOM = 4,
		map_mode_STENCIL = 5,
	};
	inline map_mode_enum map_mode(void);
	inline void map_mode(map_mode_enum value);
	enum mask_map_mode_enum {
		mask_map_mode_VIEW_PLANE = 0,
		mask_map_mode_TILED = 1,
		mask_map_mode_RANDOM = 4,
		mask_map_mode_STENCIL = 5,
	};
	inline mask_map_mode_enum mask_map_mode(void);
	inline void mask_map_mode(mask_map_mode_enum value);
	inline bool use_rake(void);
	inline void use_rake(bool value);
	inline bool use_random(void);
	inline void use_random(bool value);
	inline float random_angle(void);
	inline void random_angle(float value);
	inline bool has_texture_angle_source(void);
	inline void has_texture_angle_source(bool value);
	inline bool has_random_texture_angle(void);
	inline void has_random_texture_angle(bool value);
	inline bool has_texture_angle(void);
	inline void has_texture_angle(bool value);

};

/**************** Operator Stroke Element ****************/

class OperatorStrokeElement : public PropertyGroup {
public:
	OperatorStrokeElement(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** CacheFile ****************/

class CacheFile : public ID {
public:
	CacheFile(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		object_paths(ptr_arg),
		layers(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool is_sequence(void);
	inline void is_sequence(bool value);
	inline bool use_render_procedural(void);
	inline void use_render_procedural(bool value);
	inline bool override_frame(void);
	inline void override_frame(bool value);
	inline float frame(void);
	inline void frame(float value);
	inline float frame_offset(void);
	inline void frame_offset(float value);
	inline bool use_prefetch(void);
	inline void use_prefetch(bool value);
	inline int prefetch_cache_size(void);
	inline void prefetch_cache_size(int value);
	enum forward_axis_enum {
		forward_axis_POS_X = 0,
		forward_axis_POS_Y = 1,
		forward_axis_POS_Z = 2,
		forward_axis_NEG_X = 3,
		forward_axis_NEG_Y = 4,
		forward_axis_NEG_Z = 5,
	};
	inline forward_axis_enum forward_axis(void);
	inline void forward_axis(forward_axis_enum value);
	enum up_axis_enum {
		up_axis_POS_X = 0,
		up_axis_POS_Y = 1,
		up_axis_POS_Z = 2,
		up_axis_NEG_X = 3,
		up_axis_NEG_Y = 4,
		up_axis_NEG_Z = 5,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	inline float scale(void);
	inline void scale(float value);
	COLLECTION_PROPERTY(CacheObjectPaths, CacheObjectPath, CacheFile, object_paths, false, true, true)
	inline std::string velocity_name(void);
	inline void velocity_name(const std::string& value);
	enum velocity_unit_enum {
		velocity_unit_SECOND = 1,
		velocity_unit_FRAME = 0,
	};
	inline velocity_unit_enum velocity_unit(void);
	inline void velocity_unit(velocity_unit_enum value);
	COLLECTION_PROPERTY(CacheFileLayers, CacheFileLayer, CacheFile, layers, false, true, false)
	inline int active_index(void);
	inline void active_index(int value);
	inline AnimData animation_data(void);

};

/**************** Object Path ****************/

class CacheObjectPath : public Pointer {
public:
	CacheObjectPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);

};

/**************** Cache Layer ****************/

class CacheFileLayer : public Pointer {
public:
	CacheFileLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool hide_layer(void);
	inline void hide_layer(bool value);

};

/**************** Camera ****************/

class Camera : public ID {
public:
	Camera(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		background_images(ptr_arg)
		{}

	enum type_enum {
		type_PERSP = 0,
		type_ORTHO = 1,
		type_PANO = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum sensor_fit_enum {
		sensor_fit_AUTO = 0,
		sensor_fit_HORIZONTAL = 1,
		sensor_fit_VERTICAL = 2,
	};
	inline sensor_fit_enum sensor_fit(void);
	inline void sensor_fit(sensor_fit_enum value);
	inline float passepartout_alpha(void);
	inline void passepartout_alpha(float value);
	inline float angle_x(void);
	inline void angle_x(float value);
	inline float angle_y(void);
	inline void angle_y(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float clip_start(void);
	inline void clip_start(float value);
	inline float clip_end(void);
	inline void clip_end(float value);
	inline float lens(void);
	inline void lens(float value);
	inline float sensor_width(void);
	inline void sensor_width(float value);
	inline float sensor_height(void);
	inline void sensor_height(float value);
	inline float ortho_scale(void);
	inline void ortho_scale(float value);
	inline float display_size(void);
	inline void display_size(float value);
	inline float shift_x(void);
	inline void shift_x(float value);
	inline float shift_y(void);
	inline void shift_y(float value);
	inline CameraStereoData stereo(void);
	inline bool show_limits(void);
	inline void show_limits(bool value);
	inline bool show_mist(void);
	inline void show_mist(bool value);
	inline bool show_passepartout(void);
	inline void show_passepartout(bool value);
	inline bool show_safe_areas(void);
	inline void show_safe_areas(bool value);
	inline bool show_safe_center(void);
	inline void show_safe_center(bool value);
	inline bool show_name(void);
	inline void show_name(bool value);
	inline bool show_sensor(void);
	inline void show_sensor(bool value);
	inline bool show_background_images(void);
	inline void show_background_images(bool value);
	enum lens_unit_enum {
		lens_unit_MILLIMETERS = 0,
		lens_unit_FOV = 32,
	};
	inline lens_unit_enum lens_unit(void);
	inline void lens_unit(lens_unit_enum value);
	inline bool show_composition_center(void);
	inline void show_composition_center(bool value);
	inline bool show_composition_center_diagonal(void);
	inline void show_composition_center_diagonal(bool value);
	inline bool show_composition_thirds(void);
	inline void show_composition_thirds(bool value);
	inline bool show_composition_golden(void);
	inline void show_composition_golden(bool value);
	inline bool show_composition_golden_tria_a(void);
	inline void show_composition_golden_tria_a(bool value);
	inline bool show_composition_golden_tria_b(void);
	inline void show_composition_golden_tria_b(bool value);
	inline bool show_composition_harmony_tri_a(void);
	inline void show_composition_harmony_tri_a(bool value);
	inline bool show_composition_harmony_tri_b(void);
	inline void show_composition_harmony_tri_b(bool value);
	enum panorama_type_enum {
		panorama_type_EQUIRECTANGULAR = 0,
		panorama_type_EQUIANGULAR_CUBEMAP_FACE = 5,
		panorama_type_MIRRORBALL = 3,
		panorama_type_FISHEYE_EQUIDISTANT = 1,
		panorama_type_FISHEYE_EQUISOLID = 2,
		panorama_type_FISHEYE_LENS_POLYNOMIAL = 4,
	};
	inline panorama_type_enum panorama_type(void);
	inline void panorama_type(panorama_type_enum value);
	inline float fisheye_fov(void);
	inline void fisheye_fov(float value);
	inline float fisheye_lens(void);
	inline void fisheye_lens(float value);
	inline float latitude_min(void);
	inline void latitude_min(float value);
	inline float latitude_max(void);
	inline void latitude_max(float value);
	inline float longitude_min(void);
	inline void longitude_min(float value);
	inline float longitude_max(void);
	inline void longitude_max(float value);
	inline float fisheye_polynomial_k0(void);
	inline void fisheye_polynomial_k0(float value);
	inline float fisheye_polynomial_k1(void);
	inline void fisheye_polynomial_k1(float value);
	inline float fisheye_polynomial_k2(void);
	inline void fisheye_polynomial_k2(float value);
	inline float fisheye_polynomial_k3(void);
	inline void fisheye_polynomial_k3(float value);
	inline float fisheye_polynomial_k4(void);
	inline void fisheye_polynomial_k4(float value);
	inline CameraDOFSettings dof(void);
	COLLECTION_PROPERTY(CameraBackgroundImages, CameraBackgroundImage, Camera, background_images, false, true, false)
	inline AnimData animation_data(void);

	inline void view_frame(Scene& scene, float result_1[3], float result_2[3], float result_3[3], float result_4[3]);
};

/**************** Background Image ****************/

class CameraBackgroundImage : public Pointer {
public:
	CameraBackgroundImage(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_override_data(void);
	inline void is_override_data(bool value);
	enum source_enum {
		source_IMAGE = 0,
		source_MOVIE_CLIP = 1,
	};
	inline source_enum source(void);
	inline void source(source_enum value);
	inline Image image(void);
	inline MovieClip clip(void);
	inline ImageUser image_user(void);
	inline MovieClipUser clip_user(void);
	inline Array<float, 2> offset(void);
	inline void offset(float values[2]);
	inline float scale(void);
	inline void scale(float value);
	inline float rotation(void);
	inline void rotation(float value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline float alpha(void);
	inline void alpha(float value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool use_camera_clip(void);
	inline void use_camera_clip(bool value);
	inline bool show_background_image(void);
	inline void show_background_image(bool value);
	inline bool show_on_foreground(void);
	inline void show_on_foreground(bool value);
	enum display_depth_enum {
		display_depth_BACK = 0,
		display_depth_FRONT = 16,
	};
	inline display_depth_enum display_depth(void);
	inline void display_depth(display_depth_enum value);
	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 32,
		frame_method_CROP = 96,
	};
	inline frame_method_enum frame_method(void);
	inline void frame_method(frame_method_enum value);

};

/**************** Stereo ****************/

class CameraStereoData : public Pointer {
public:
	CameraStereoData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum convergence_mode_enum {
		convergence_mode_OFFAXIS = 0,
		convergence_mode_PARALLEL = 1,
		convergence_mode_TOE = 2,
	};
	inline convergence_mode_enum convergence_mode(void);
	inline void convergence_mode(convergence_mode_enum value);
	enum pivot_enum {
		pivot_LEFT = 0,
		pivot_RIGHT = 1,
		pivot_CENTER = 2,
	};
	inline pivot_enum pivot(void);
	inline void pivot(pivot_enum value);
	inline float interocular_distance(void);
	inline void interocular_distance(float value);
	inline float convergence_distance(void);
	inline void convergence_distance(float value);
	inline bool use_spherical_stereo(void);
	inline void use_spherical_stereo(bool value);
	inline bool use_pole_merge(void);
	inline void use_pole_merge(bool value);
	inline float pole_merge_angle_from(void);
	inline void pole_merge_angle_from(float value);
	inline float pole_merge_angle_to(void);
	inline void pole_merge_angle_to(float value);

};

/**************** Depth of Field ****************/

class CameraDOFSettings : public Pointer {
public:
	CameraDOFSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_dof(void);
	inline void use_dof(bool value);
	inline Object focus_object(void);
	inline std::string focus_subtarget(void);
	inline void focus_subtarget(const std::string& value);
	inline float focus_distance(void);
	inline void focus_distance(float value);
	inline float aperture_fstop(void);
	inline void aperture_fstop(float value);
	inline int aperture_blades(void);
	inline void aperture_blades(int value);
	inline float aperture_rotation(void);
	inline void aperture_rotation(float value);
	inline float aperture_ratio(void);
	inline void aperture_ratio(float value);

};

/**************** Solver Result ****************/

class ClothSolverResult : public Pointer {
public:
	ClothSolverResult(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum status_enum {
		status_SUCCESS = 1,
		status_NUMERICAL_ISSUE = 2,
		status_NO_CONVERGENCE = 4,
		status_INVALID_INPUT = 8,
	};
	inline status_enum status(void);
	inline void status(status_enum value);
	inline float max_error(void);
	inline void max_error(float value);
	inline float min_error(void);
	inline void min_error(float value);
	inline float avg_error(void);
	inline void avg_error(float value);
	inline int max_iterations(void);
	inline void max_iterations(int value);
	inline int min_iterations(void);
	inline void min_iterations(int value);
	inline float avg_iterations(void);
	inline void avg_iterations(float value);

};

/**************** Cloth Settings ****************/

class ClothSettings : public Pointer {
public:
	ClothSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float goal_min(void);
	inline void goal_min(float value);
	inline float goal_max(void);
	inline void goal_max(float value);
	inline float goal_default(void);
	inline void goal_default(float value);
	inline float goal_spring(void);
	inline void goal_spring(float value);
	inline float goal_friction(void);
	inline void goal_friction(float value);
	inline float internal_friction(void);
	inline void internal_friction(float value);
	inline float collider_friction(void);
	inline void collider_friction(float value);
	inline float density_target(void);
	inline void density_target(float value);
	inline float density_strength(void);
	inline void density_strength(float value);
	inline float mass(void);
	inline void mass(float value);
	inline std::string vertex_group_mass(void);
	inline void vertex_group_mass(const std::string& value);
	inline Array<float, 3> gravity(void);
	inline void gravity(float values[3]);
	inline float air_damping(void);
	inline void air_damping(float value);
	inline float pin_stiffness(void);
	inline void pin_stiffness(float value);
	inline int quality(void);
	inline void quality(int value);
	inline float time_scale(void);
	inline void time_scale(float value);
	inline std::string vertex_group_shrink(void);
	inline void vertex_group_shrink(const std::string& value);
	inline float shrink_min(void);
	inline void shrink_min(float value);
	inline float shrink_max(void);
	inline void shrink_max(float value);
	inline float voxel_cell_size(void);
	inline void voxel_cell_size(float value);
	inline float tension_damping(void);
	inline void tension_damping(float value);
	inline float compression_damping(void);
	inline void compression_damping(float value);
	inline float shear_damping(void);
	inline void shear_damping(float value);
	inline float tension_stiffness(void);
	inline void tension_stiffness(float value);
	inline float tension_stiffness_max(void);
	inline void tension_stiffness_max(float value);
	inline float compression_stiffness(void);
	inline void compression_stiffness(float value);
	inline float compression_stiffness_max(void);
	inline void compression_stiffness_max(float value);
	inline float shear_stiffness(void);
	inline void shear_stiffness(float value);
	inline float shear_stiffness_max(void);
	inline void shear_stiffness_max(float value);
	inline float sewing_force_max(void);
	inline void sewing_force_max(float value);
	inline std::string vertex_group_structural_stiffness(void);
	inline void vertex_group_structural_stiffness(const std::string& value);
	inline std::string vertex_group_shear_stiffness(void);
	inline void vertex_group_shear_stiffness(const std::string& value);
	inline float bending_stiffness(void);
	inline void bending_stiffness(float value);
	inline float bending_stiffness_max(void);
	inline void bending_stiffness_max(float value);
	inline float bending_damping(void);
	inline void bending_damping(float value);
	inline bool use_sewing_springs(void);
	inline void use_sewing_springs(bool value);
	inline std::string vertex_group_bending(void);
	inline void vertex_group_bending(const std::string& value);
	inline EffectorWeights effector_weights(void);
	inline ShapeKey rest_shape_key(void);
	inline bool use_dynamic_mesh(void);
	inline void use_dynamic_mesh(bool value);
	enum bending_model_enum {
		bending_model_ANGULAR = 1,
		bending_model_LINEAR = 0,
	};
	inline bending_model_enum bending_model(void);
	inline void bending_model(bending_model_enum value);
	inline bool use_internal_springs(void);
	inline void use_internal_springs(bool value);
	inline bool internal_spring_normal_check(void);
	inline void internal_spring_normal_check(bool value);
	inline float internal_spring_max_length(void);
	inline void internal_spring_max_length(float value);
	inline float internal_spring_max_diversion(void);
	inline void internal_spring_max_diversion(float value);
	inline float internal_tension_stiffness(void);
	inline void internal_tension_stiffness(float value);
	inline float internal_tension_stiffness_max(void);
	inline void internal_tension_stiffness_max(float value);
	inline float internal_compression_stiffness(void);
	inline void internal_compression_stiffness(float value);
	inline float internal_compression_stiffness_max(void);
	inline void internal_compression_stiffness_max(float value);
	inline std::string vertex_group_intern(void);
	inline void vertex_group_intern(const std::string& value);
	inline bool use_pressure(void);
	inline void use_pressure(bool value);
	inline bool use_pressure_volume(void);
	inline void use_pressure_volume(bool value);
	inline float uniform_pressure_force(void);
	inline void uniform_pressure_force(float value);
	inline float target_volume(void);
	inline void target_volume(float value);
	inline float pressure_factor(void);
	inline void pressure_factor(float value);
	inline float fluid_density(void);
	inline void fluid_density(float value);
	inline std::string vertex_group_pressure(void);
	inline void vertex_group_pressure(const std::string& value);

};

/**************** Cloth Collision Settings ****************/

class ClothCollisionSettings : public Pointer {
public:
	ClothCollisionSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_collision(void);
	inline void use_collision(bool value);
	inline float distance_min(void);
	inline void distance_min(float value);
	inline float friction(void);
	inline void friction(float value);
	inline float damping(void);
	inline void damping(float value);
	inline int collision_quality(void);
	inline void collision_quality(int value);
	inline float impulse_clamp(void);
	inline void impulse_clamp(float value);
	inline bool use_self_collision(void);
	inline void use_self_collision(bool value);
	inline float self_distance_min(void);
	inline void self_distance_min(float value);
	inline float self_friction(void);
	inline void self_friction(float value);
	inline Collection collection(void);
	inline std::string vertex_group_self_collisions(void);
	inline void vertex_group_self_collisions(const std::string& value);
	inline std::string vertex_group_object_collisions(void);
	inline void vertex_group_object_collisions(const std::string& value);
	inline float self_impulse_clamp(void);
	inline void self_impulse_clamp(float value);

};

/**************** Collection ****************/

class Collection : public ID {
public:
	Collection(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		objects(ptr_arg),
		all_objects(ptr_arg),
		children(ptr_arg),
		collection_objects(ptr_arg),
		collection_children(ptr_arg)
		{}

	inline Array<float, 3> instance_offset(void);
	inline void instance_offset(float values[3]);
	COLLECTION_PROPERTY(CollectionObjects, Object, Collection, objects, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Object, Collection, all_objects, false, false, false)
	COLLECTION_PROPERTY(CollectionChildren, Collection, Collection, children, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CollectionObject, Collection, collection_objects, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CollectionChild, Collection, collection_children, false, true, false)
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool hide_viewport(void);
	inline void hide_viewport(bool value);
	inline bool hide_render(void);
	inline void hide_render(bool value);
	enum lineart_usage_enum {
		lineart_usage_INCLUDE = 0,
		lineart_usage_OCCLUSION_ONLY = 1,
		lineart_usage_EXCLUDE = 2,
		lineart_usage_INTERSECTION_ONLY = 4,
		lineart_usage_NO_INTERSECTION = 8,
		lineart_usage_FORCE_INTERSECTION = 16,
	};
	inline lineart_usage_enum lineart_usage(void);
	inline void lineart_usage(lineart_usage_enum value);
	inline bool lineart_use_intersection_mask(void);
	inline void lineart_use_intersection_mask(bool value);
	inline Array<bool, 8> lineart_intersection_mask(void);
	inline void lineart_intersection_mask(bool values[8]);
	inline int lineart_intersection_priority(void);
	inline void lineart_intersection_priority(int value);
	inline bool use_lineart_intersection_priority(void);
	inline void use_lineart_intersection_priority(bool value);
	enum color_tag_enum {
		color_tag_NONE = -1,
		color_tag_COLOR_01 = 0,
		color_tag_COLOR_02 = 1,
		color_tag_COLOR_03 = 2,
		color_tag_COLOR_04 = 3,
		color_tag_COLOR_05 = 4,
		color_tag_COLOR_06 = 5,
		color_tag_COLOR_07 = 6,
		color_tag_COLOR_08 = 7,
	};
	inline color_tag_enum color_tag(void);
	inline void color_tag(color_tag_enum value);

};

/**************** Collection Light Linking ****************/

class CollectionLightLinking : public Pointer {
public:
	CollectionLightLinking(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum link_state_enum {
		link_state_INCLUDE = 0,
		link_state_EXCLUDE = 1,
	};
	inline link_state_enum link_state(void);
	inline void link_state(link_state_enum value);

};

/**************** Collection Object ****************/

class CollectionObject : public Pointer {
public:
	CollectionObject(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline CollectionLightLinking light_linking(void);

};

/**************** Collection Child ****************/

class CollectionChild : public Pointer {
public:
	CollectionChild(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline CollectionLightLinking light_linking(void);

};

/**************** CurveMapPoint ****************/

class CurveMapPoint : public Pointer {
public:
	CurveMapPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> location(void);
	inline void location(float values[2]);
	enum handle_type_enum {
		handle_type_AUTO = 0,
		handle_type_AUTO_CLAMPED = 4,
		handle_type_VECTOR = 2,
	};
	inline handle_type_enum handle_type(void);
	inline void handle_type(handle_type_enum value);
	inline bool select(void);
	inline void select(bool value);

};

/**************** CurveMap ****************/

class CurveMap : public Pointer {
public:
	CurveMap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(CurveMapPoints, CurveMapPoint, CurveMap, points, true, true, false)

};

/**************** CurveMapping ****************/

class CurveMapping : public Pointer {
public:
	CurveMapping(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		curves(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum tone_enum {
		tone_STANDARD = 0,
		tone_FILMLIKE = 2,
	};
	inline tone_enum tone(void);
	inline void tone(tone_enum value);
	inline bool use_clip(void);
	inline void use_clip(bool value);
	inline float clip_min_x(void);
	inline void clip_min_x(float value);
	inline float clip_min_y(void);
	inline void clip_min_y(float value);
	inline float clip_max_x(void);
	inline void clip_max_x(float value);
	inline float clip_max_y(void);
	inline void clip_max_y(float value);
	enum extend_enum {
		extend_HORIZONTAL = 0,
		extend_EXTRAPOLATED = 16,
	};
	inline extend_enum extend(void);
	inline void extend(extend_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CurveMap, CurveMapping, curves, true, false, false)
	inline Array<float, 3> black_level(void);
	inline void black_level(float values[3]);
	inline Array<float, 3> white_level(void);
	inline void white_level(float values[3]);

	inline void update();
	inline void reset_view();
	inline void initialize();
	inline float evaluate(CurveMap& curve, float position);
};

/**************** Color Ramp Element ****************/

class ColorRampElement : public Pointer {
public:
	ColorRampElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline float alpha(void);
	inline void alpha(float value);
	inline float position(void);
	inline void position(float value);

};

/**************** Color Ramp ****************/

class ColorRamp : public Pointer {
public:
	ColorRamp(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		elements(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(ColorRampElements, ColorRampElement, ColorRamp, elements, true, true, false)
	enum interpolation_enum {
		interpolation_EASE = 1,
		interpolation_CARDINAL = 3,
		interpolation_LINEAR = 0,
		interpolation_B_SPLINE = 2,
		interpolation_CONSTANT = 4,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum hue_interpolation_enum {
		hue_interpolation_NEAR = 0,
		hue_interpolation_FAR = 1,
		hue_interpolation_CW = 2,
		hue_interpolation_CCW = 3,
	};
	inline hue_interpolation_enum hue_interpolation(void);
	inline void hue_interpolation(hue_interpolation_enum value);
	enum color_mode_enum {
		color_mode_RGB = 0,
		color_mode_HSV = 1,
		color_mode_HSL = 2,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);

	inline void evaluate(float position, float color[4]);
};

/**************** Histogram ****************/

class Histogram : public Pointer {
public:
	Histogram(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum mode_enum {
		mode_LUMA = 0,
		mode_RGB = 1,
		mode_R = 2,
		mode_G = 3,
		mode_B = 4,
		mode_A = 5,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool show_line(void);
	inline void show_line(bool value);

};

/**************** Scopes ****************/

class Scopes : public Pointer {
public:
	Scopes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_full_resolution(void);
	inline void use_full_resolution(bool value);
	inline float accuracy(void);
	inline void accuracy(float value);
	inline Histogram histogram(void);
	enum waveform_mode_enum {
		waveform_mode_LUMA = 0,
		waveform_mode_PARADE = 1,
		waveform_mode_YCBCR601 = 2,
		waveform_mode_YCBCR709 = 3,
		waveform_mode_YCBCRJPG = 4,
		waveform_mode_RGB = 5,
	};
	inline waveform_mode_enum waveform_mode(void);
	inline void waveform_mode(waveform_mode_enum value);
	inline float waveform_alpha(void);
	inline void waveform_alpha(float value);
	inline float vectorscope_alpha(void);
	inline void vectorscope_alpha(float value);

};

/**************** ColorManagedDisplaySettings ****************/

class ColorManagedDisplaySettings : public Pointer {
public:
	ColorManagedDisplaySettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum display_device_enum {
		display_device_NONE = 0,
	};
	inline display_device_enum display_device(void);
	inline void display_device(display_device_enum value);

};

/**************** ColorManagedViewSettings ****************/

class ColorManagedViewSettings : public Pointer {
public:
	ColorManagedViewSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum look_enum {
		look_NONE = 0,
	};
	inline look_enum look(void);
	inline void look(look_enum value);
	enum view_transform_enum {
		view_transform_NONE = 0,
	};
	inline view_transform_enum view_transform(void);
	inline void view_transform(view_transform_enum value);
	inline float exposure(void);
	inline void exposure(float value);
	inline float gamma(void);
	inline void gamma(float value);
	inline CurveMapping curve_mapping(void);
	inline bool use_curve_mapping(void);
	inline void use_curve_mapping(bool value);
	inline bool use_hdr_view(void);
	inline void use_hdr_view(bool value);

};

/**************** ColorManagedInputColorspaceSettings ****************/

class ColorManagedInputColorspaceSettings : public Pointer {
public:
	ColorManagedInputColorspaceSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum name_enum {
		name_NONE = 0,
	};
	inline name_enum name(void);
	inline void name(name_enum value);
	inline bool is_data(void);
	inline void is_data(bool value);

};

/**************** ColorManagedSequencerColorspaceSettings ****************/

class ColorManagedSequencerColorspaceSettings : public Pointer {
public:
	ColorManagedSequencerColorspaceSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum name_enum {
		name_NONE = 0,
	};
	inline name_enum name(void);
	inline void name(name_enum value);

};

/**************** Constraint ****************/

class Constraint : public Pointer {
public:
	Constraint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_CAMERA_SOLVER = 27,
		type_FOLLOW_TRACK = 26,
		type_OBJECT_SOLVER = 28,
		type_COPY_LOCATION = 9,
		type_COPY_ROTATION = 8,
		type_COPY_SCALE = 10,
		type_COPY_TRANSFORMS = 23,
		type_LIMIT_DISTANCE = 14,
		type_LIMIT_LOCATION = 6,
		type_LIMIT_ROTATION = 5,
		type_LIMIT_SCALE = 7,
		type_MAINTAIN_VOLUME = 24,
		type_TRANSFORM = 19,
		type_TRANSFORM_CACHE = 29,
		type_CLAMP_TO = 18,
		type_DAMPED_TRACK = 21,
		type_IK = 3,
		type_LOCKED_TRACK = 13,
		type_SPLINE_IK = 22,
		type_STRETCH_TO = 15,
		type_TRACK_TO = 2,
		type_ACTION = 12,
		type_ARMATURE = 30,
		type_CHILD_OF = 1,
		type_FLOOR = 16,
		type_FOLLOW_PATH = 4,
		type_PIVOT = 25,
		type_SHRINKWRAP = 20,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool is_override_data(void);
	inline void is_override_data(bool value);
	enum owner_space_enum {
		owner_space_WORLD = 0,
		owner_space_CUSTOM = 5,
		owner_space_POSE = 2,
		owner_space_LOCAL_WITH_PARENT = 3,
		owner_space_LOCAL = 1,
	};
	inline owner_space_enum owner_space(void);
	inline void owner_space(owner_space_enum value);
	enum target_space_enum {
		target_space_WORLD = 0,
		target_space_CUSTOM = 5,
		target_space_POSE = 2,
		target_space_LOCAL_WITH_PARENT = 3,
		target_space_LOCAL = 1,
		target_space_LOCAL_OWNER_ORIENT = 6,
	};
	inline target_space_enum target_space(void);
	inline void target_space(target_space_enum value);
	inline Object space_object(void);
	inline std::string space_subtarget(void);
	inline void space_subtarget(const std::string& value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool active(void);
	inline void active(bool value);
	inline float influence(void);
	inline void influence(float value);
	inline float error_location(void);
	inline void error_location(float value);
	inline float error_rotation(void);
	inline void error_rotation(float value);

};

/**************** Constraint Target ****************/

class ConstraintTarget : public Pointer {
public:
	ConstraintTarget(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);

};

/**************** Constraint Target Bone ****************/

class ConstraintTargetBone : public Pointer {
public:
	ConstraintTargetBone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Child Of Constraint ****************/

class ChildOfConstraint : public Constraint {
public:
	ChildOfConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_location_x(void);
	inline void use_location_x(bool value);
	inline bool use_location_y(void);
	inline void use_location_y(bool value);
	inline bool use_location_z(void);
	inline void use_location_z(bool value);
	inline bool use_rotation_x(void);
	inline void use_rotation_x(bool value);
	inline bool use_rotation_y(void);
	inline void use_rotation_y(bool value);
	inline bool use_rotation_z(void);
	inline void use_rotation_z(bool value);
	inline bool use_scale_x(void);
	inline void use_scale_x(bool value);
	inline bool use_scale_y(void);
	inline void use_scale_y(bool value);
	inline bool use_scale_z(void);
	inline void use_scale_z(bool value);
	inline bool set_inverse_pending(void);
	inline void set_inverse_pending(bool value);
	inline Array<float, 16> inverse_matrix(void);
	inline void inverse_matrix(float values[16]);

};

/**************** Python Constraint ****************/

class PythonConstraint : public Constraint {
public:
	PythonConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg),
		targets(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, ConstraintTarget, PythonConstraint, targets, false, true, false)
	inline int target_count(void);
	inline void target_count(int value);
	inline Text text(void);
	inline bool use_targets(void);
	inline void use_targets(bool value);
	inline bool has_script_error(void);
	inline void has_script_error(bool value);

};

/**************** Armature Constraint ****************/

class ArmatureConstraint : public Constraint {
public:
	ArmatureConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg),
		targets(ptr_arg)
		{}

	COLLECTION_PROPERTY(ArmatureConstraintTargets, ConstraintTargetBone, ArmatureConstraint, targets, false, true, false)
	inline bool use_deform_preserve_volume(void);
	inline void use_deform_preserve_volume(bool value);
	inline bool use_bone_envelopes(void);
	inline void use_bone_envelopes(bool value);
	inline bool use_current_location(void);
	inline void use_current_location(bool value);

};

/**************** Stretch To Constraint ****************/

class StretchToConstraint : public Constraint {
public:
	StretchToConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum volume_enum {
		volume_VOLUME_XZX = 0,
		volume_VOLUME_X = 1,
		volume_VOLUME_Z = 2,
		volume_NO_VOLUME = 3,
	};
	inline volume_enum volume(void);
	inline void volume(volume_enum value);
	enum keep_axis_enum {
		keep_axis_PLANE_X = 0,
		keep_axis_PLANE_Z = 2,
		keep_axis_SWING_Y = 1,
	};
	inline keep_axis_enum keep_axis(void);
	inline void keep_axis(keep_axis_enum value);
	inline float rest_length(void);
	inline void rest_length(float value);
	inline float bulge(void);
	inline void bulge(float value);
	inline bool use_bulge_min(void);
	inline void use_bulge_min(bool value);
	inline bool use_bulge_max(void);
	inline void use_bulge_max(bool value);
	inline float bulge_min(void);
	inline void bulge_min(float value);
	inline float bulge_max(void);
	inline void bulge_max(float value);
	inline float bulge_smooth(void);
	inline void bulge_smooth(float value);

};

/**************** Follow Path Constraint ****************/

class FollowPathConstraint : public Constraint {
public:
	FollowPathConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline float offset(void);
	inline void offset(float value);
	inline float offset_factor(void);
	inline void offset_factor(float value);
	enum forward_axis_enum {
		forward_axis_FORWARD_X = 0,
		forward_axis_FORWARD_Y = 1,
		forward_axis_FORWARD_Z = 2,
		forward_axis_TRACK_NEGATIVE_X = 3,
		forward_axis_TRACK_NEGATIVE_Y = 4,
		forward_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline forward_axis_enum forward_axis(void);
	inline void forward_axis(forward_axis_enum value);
	enum up_axis_enum {
		up_axis_UP_X = 0,
		up_axis_UP_Y = 1,
		up_axis_UP_Z = 2,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	inline bool use_curve_follow(void);
	inline void use_curve_follow(bool value);
	inline bool use_fixed_location(void);
	inline void use_fixed_location(bool value);
	inline bool use_curve_radius(void);
	inline void use_curve_radius(bool value);

};

/**************** Locked Track Constraint ****************/

class LockedTrackConstraint : public Constraint {
public:
	LockedTrackConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);
	enum lock_axis_enum {
		lock_axis_LOCK_X = 0,
		lock_axis_LOCK_Y = 1,
		lock_axis_LOCK_Z = 2,
	};
	inline lock_axis_enum lock_axis(void);
	inline void lock_axis(lock_axis_enum value);

};

/**************** Action Constraint ****************/

class ActionConstraint : public Constraint {
public:
	ActionConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum mix_mode_enum {
		mix_mode_BEFORE_FULL = 3,
		mix_mode_BEFORE = 2,
		mix_mode_BEFORE_SPLIT = 5,
		mix_mode_AFTER_FULL = 0,
		mix_mode_AFTER = 1,
		mix_mode_AFTER_SPLIT = 4,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	enum transform_channel_enum {
		transform_channel_LOCATION_X = 20,
		transform_channel_LOCATION_Y = 21,
		transform_channel_LOCATION_Z = 22,
		transform_channel_ROTATION_X = 0,
		transform_channel_ROTATION_Y = 1,
		transform_channel_ROTATION_Z = 2,
		transform_channel_SCALE_X = 10,
		transform_channel_SCALE_Y = 11,
		transform_channel_SCALE_Z = 12,
	};
	inline transform_channel_enum transform_channel(void);
	inline void transform_channel(transform_channel_enum value);
	inline Action action(void);
	inline bool use_bone_object_action(void);
	inline void use_bone_object_action(bool value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline float max(void);
	inline void max(float value);
	inline float min(void);
	inline void min(float value);
	inline float eval_time(void);
	inline void eval_time(float value);
	inline bool use_eval_time(void);
	inline void use_eval_time(bool value);

};

/**************** Copy Scale Constraint ****************/

class CopyScaleConstraint : public Constraint {
public:
	CopyScaleConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline float power(void);
	inline void power(float value);
	inline bool use_make_uniform(void);
	inline void use_make_uniform(bool value);
	inline bool use_offset(void);
	inline void use_offset(bool value);
	inline bool use_add(void);
	inline void use_add(bool value);

};

/**************** Maintain Volume Constraint ****************/

class MaintainVolumeConstraint : public Constraint {
public:
	MaintainVolumeConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	enum free_axis_enum {
		free_axis_SAMEVOL_X = 0,
		free_axis_SAMEVOL_Y = 1,
		free_axis_SAMEVOL_Z = 2,
	};
	inline free_axis_enum free_axis(void);
	inline void free_axis(free_axis_enum value);
	enum mode_enum {
		mode_STRICT = 0,
		mode_UNIFORM = 1,
		mode_SINGLE_AXIS = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float volume(void);
	inline void volume(float value);

};

/**************** Copy Location Constraint ****************/

class CopyLocationConstraint : public Constraint {
public:
	CopyLocationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool invert_x(void);
	inline void invert_x(bool value);
	inline bool invert_y(void);
	inline void invert_y(bool value);
	inline bool invert_z(void);
	inline void invert_z(bool value);
	inline bool use_offset(void);
	inline void use_offset(bool value);

};

/**************** Copy Rotation Constraint ****************/

class CopyRotationConstraint : public Constraint {
public:
	CopyRotationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool invert_x(void);
	inline void invert_x(bool value);
	inline bool invert_y(void);
	inline void invert_y(bool value);
	inline bool invert_z(void);
	inline void invert_z(bool value);
	enum euler_order_enum {
		euler_order_AUTO = 0,
		euler_order_XYZ = 1,
		euler_order_XZY = 2,
		euler_order_YXZ = 3,
		euler_order_YZX = 4,
		euler_order_ZXY = 5,
		euler_order_ZYX = 6,
	};
	inline euler_order_enum euler_order(void);
	inline void euler_order(euler_order_enum value);
	enum mix_mode_enum {
		mix_mode_REPLACE = 0,
		mix_mode_ADD = 2,
		mix_mode_BEFORE = 3,
		mix_mode_AFTER = 4,
		mix_mode_OFFSET = 1,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	inline bool use_offset(void);
	inline void use_offset(bool value);

};

/**************** Copy Transforms Constraint ****************/

class CopyTransformsConstraint : public Constraint {
public:
	CopyTransformsConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool remove_target_shear(void);
	inline void remove_target_shear(bool value);
	enum mix_mode_enum {
		mix_mode_REPLACE = 0,
		mix_mode_BEFORE_FULL = 5,
		mix_mode_BEFORE = 1,
		mix_mode_BEFORE_SPLIT = 3,
		mix_mode_AFTER_FULL = 6,
		mix_mode_AFTER = 2,
		mix_mode_AFTER_SPLIT = 4,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);

};

/**************** Floor Constraint ****************/

class FloorConstraint : public Constraint {
public:
	FloorConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum floor_location_enum {
		floor_location_FLOOR_X = 0,
		floor_location_FLOOR_Y = 1,
		floor_location_FLOOR_Z = 2,
		floor_location_FLOOR_NEGATIVE_X = 3,
		floor_location_FLOOR_NEGATIVE_Y = 4,
		floor_location_FLOOR_NEGATIVE_Z = 5,
	};
	inline floor_location_enum floor_location(void);
	inline void floor_location(floor_location_enum value);
	inline bool use_rotation(void);
	inline void use_rotation(bool value);
	inline float offset(void);
	inline void offset(float value);

};

/**************** Track To Constraint ****************/

class TrackToConstraint : public Constraint {
public:
	TrackToConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);
	enum up_axis_enum {
		up_axis_UP_X = 0,
		up_axis_UP_Y = 1,
		up_axis_UP_Z = 2,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	inline bool use_target_z(void);
	inline void use_target_z(bool value);

};

/**************** Kinematic Constraint ****************/

class KinematicConstraint : public Constraint {
public:
	KinematicConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline int iterations(void);
	inline void iterations(int value);
	inline Object pole_target(void);
	inline std::string pole_subtarget(void);
	inline void pole_subtarget(const std::string& value);
	inline float pole_angle(void);
	inline void pole_angle(float value);
	inline float weight(void);
	inline void weight(float value);
	inline float orient_weight(void);
	inline void orient_weight(float value);
	inline int chain_count(void);
	inline void chain_count(int value);
	inline bool use_tail(void);
	inline void use_tail(bool value);
	enum reference_axis_enum {
		reference_axis_BONE = 0,
		reference_axis_TARGET = 16384,
	};
	inline reference_axis_enum reference_axis(void);
	inline void reference_axis(reference_axis_enum value);
	inline bool use_location(void);
	inline void use_location(bool value);
	inline bool lock_location_x(void);
	inline void lock_location_x(bool value);
	inline bool lock_location_y(void);
	inline void lock_location_y(bool value);
	inline bool lock_location_z(void);
	inline void lock_location_z(bool value);
	inline bool use_rotation(void);
	inline void use_rotation(bool value);
	inline bool lock_rotation_x(void);
	inline void lock_rotation_x(bool value);
	inline bool lock_rotation_y(void);
	inline void lock_rotation_y(bool value);
	inline bool lock_rotation_z(void);
	inline void lock_rotation_z(bool value);
	inline bool use_stretch(void);
	inline void use_stretch(bool value);
	enum ik_type_enum {
		ik_type_COPY_POSE = 0,
		ik_type_DISTANCE = 1,
	};
	inline ik_type_enum ik_type(void);
	inline void ik_type(ik_type_enum value);
	enum limit_mode_enum {
		limit_mode_LIMITDIST_INSIDE = 0,
		limit_mode_LIMITDIST_OUTSIDE = 1,
		limit_mode_LIMITDIST_ONSURFACE = 2,
	};
	inline limit_mode_enum limit_mode(void);
	inline void limit_mode(limit_mode_enum value);
	inline float distance(void);
	inline void distance(float value);

};

/**************** Clamp To Constraint ****************/

class ClampToConstraint : public Constraint {
public:
	ClampToConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	enum main_axis_enum {
		main_axis_CLAMPTO_AUTO = 0,
		main_axis_CLAMPTO_X = 1,
		main_axis_CLAMPTO_Y = 2,
		main_axis_CLAMPTO_Z = 3,
	};
	inline main_axis_enum main_axis(void);
	inline void main_axis(main_axis_enum value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);

};

/**************** Limit Distance Constraint ****************/

class LimitDistanceConstraint : public Constraint {
public:
	LimitDistanceConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline float distance(void);
	inline void distance(float value);
	enum limit_mode_enum {
		limit_mode_LIMITDIST_INSIDE = 0,
		limit_mode_LIMITDIST_OUTSIDE = 1,
		limit_mode_LIMITDIST_ONSURFACE = 2,
	};
	inline limit_mode_enum limit_mode(void);
	inline void limit_mode(limit_mode_enum value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Limit Size Constraint ****************/

class LimitScaleConstraint : public Constraint {
public:
	LimitScaleConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline bool use_min_x(void);
	inline void use_min_x(bool value);
	inline bool use_min_y(void);
	inline void use_min_y(bool value);
	inline bool use_min_z(void);
	inline void use_min_z(bool value);
	inline bool use_max_x(void);
	inline void use_max_x(bool value);
	inline bool use_max_y(void);
	inline void use_max_y(bool value);
	inline bool use_max_z(void);
	inline void use_max_z(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float min_z(void);
	inline void min_z(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);
	inline float max_z(void);
	inline void max_z(float value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Limit Rotation Constraint ****************/

class LimitRotationConstraint : public Constraint {
public:
	LimitRotationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline bool use_limit_x(void);
	inline void use_limit_x(bool value);
	inline bool use_limit_y(void);
	inline void use_limit_y(bool value);
	inline bool use_limit_z(void);
	inline void use_limit_z(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float min_z(void);
	inline void min_z(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);
	inline float max_z(void);
	inline void max_z(float value);
	enum euler_order_enum {
		euler_order_AUTO = 0,
		euler_order_XYZ = 1,
		euler_order_XZY = 2,
		euler_order_YXZ = 3,
		euler_order_YZX = 4,
		euler_order_ZXY = 5,
		euler_order_ZYX = 6,
	};
	inline euler_order_enum euler_order(void);
	inline void euler_order(euler_order_enum value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Limit Location Constraint ****************/

class LimitLocationConstraint : public Constraint {
public:
	LimitLocationConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline bool use_min_x(void);
	inline void use_min_x(bool value);
	inline bool use_min_y(void);
	inline void use_min_y(bool value);
	inline bool use_min_z(void);
	inline void use_min_z(bool value);
	inline bool use_max_x(void);
	inline void use_max_x(bool value);
	inline bool use_max_y(void);
	inline void use_max_y(bool value);
	inline bool use_max_z(void);
	inline void use_max_z(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float min_z(void);
	inline void min_z(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);
	inline float max_z(void);
	inline void max_z(float value);
	inline bool use_transform_limit(void);
	inline void use_transform_limit(bool value);

};

/**************** Transformation Constraint ****************/

class TransformConstraint : public Constraint {
public:
	TransformConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum map_from_enum {
		map_from_LOCATION = 0,
		map_from_ROTATION = 1,
		map_from_SCALE = 2,
	};
	inline map_from_enum map_from(void);
	inline void map_from(map_from_enum value);
	enum map_to_enum {
		map_to_LOCATION = 0,
		map_to_ROTATION = 1,
		map_to_SCALE = 2,
	};
	inline map_to_enum map_to(void);
	inline void map_to(map_to_enum value);
	enum map_to_x_from_enum {
		map_to_x_from_X = 0,
		map_to_x_from_Y = 1,
		map_to_x_from_Z = 2,
	};
	inline map_to_x_from_enum map_to_x_from(void);
	inline void map_to_x_from(map_to_x_from_enum value);
	enum map_to_y_from_enum {
		map_to_y_from_X = 0,
		map_to_y_from_Y = 1,
		map_to_y_from_Z = 2,
	};
	inline map_to_y_from_enum map_to_y_from(void);
	inline void map_to_y_from(map_to_y_from_enum value);
	enum map_to_z_from_enum {
		map_to_z_from_X = 0,
		map_to_z_from_Y = 1,
		map_to_z_from_Z = 2,
	};
	inline map_to_z_from_enum map_to_z_from(void);
	inline void map_to_z_from(map_to_z_from_enum value);
	inline bool use_motion_extrapolate(void);
	inline void use_motion_extrapolate(bool value);
	enum from_rotation_mode_enum {
		from_rotation_mode_AUTO = 0,
		from_rotation_mode_XYZ = 1,
		from_rotation_mode_XZY = 2,
		from_rotation_mode_YXZ = 3,
		from_rotation_mode_YZX = 4,
		from_rotation_mode_ZXY = 5,
		from_rotation_mode_ZYX = 6,
		from_rotation_mode_QUATERNION = 7,
		from_rotation_mode_SWING_TWIST_X = 8,
		from_rotation_mode_SWING_TWIST_Y = 9,
		from_rotation_mode_SWING_TWIST_Z = 10,
	};
	inline from_rotation_mode_enum from_rotation_mode(void);
	inline void from_rotation_mode(from_rotation_mode_enum value);
	enum to_euler_order_enum {
		to_euler_order_AUTO = 0,
		to_euler_order_XYZ = 1,
		to_euler_order_XZY = 2,
		to_euler_order_YXZ = 3,
		to_euler_order_YZX = 4,
		to_euler_order_ZXY = 5,
		to_euler_order_ZYX = 6,
	};
	inline to_euler_order_enum to_euler_order(void);
	inline void to_euler_order(to_euler_order_enum value);
	inline float from_min_x(void);
	inline void from_min_x(float value);
	inline float from_min_y(void);
	inline void from_min_y(float value);
	inline float from_min_z(void);
	inline void from_min_z(float value);
	inline float from_max_x(void);
	inline void from_max_x(float value);
	inline float from_max_y(void);
	inline void from_max_y(float value);
	inline float from_max_z(void);
	inline void from_max_z(float value);
	inline float to_min_x(void);
	inline void to_min_x(float value);
	inline float to_min_y(void);
	inline void to_min_y(float value);
	inline float to_min_z(void);
	inline void to_min_z(float value);
	inline float to_max_x(void);
	inline void to_max_x(float value);
	inline float to_max_y(void);
	inline void to_max_y(float value);
	inline float to_max_z(void);
	inline void to_max_z(float value);
	enum mix_mode_enum {
		mix_mode_REPLACE = 1,
		mix_mode_ADD = 0,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	inline float from_min_x_rot(void);
	inline void from_min_x_rot(float value);
	inline float from_min_y_rot(void);
	inline void from_min_y_rot(float value);
	inline float from_min_z_rot(void);
	inline void from_min_z_rot(float value);
	inline float from_max_x_rot(void);
	inline void from_max_x_rot(float value);
	inline float from_max_y_rot(void);
	inline void from_max_y_rot(float value);
	inline float from_max_z_rot(void);
	inline void from_max_z_rot(float value);
	inline float to_min_x_rot(void);
	inline void to_min_x_rot(float value);
	inline float to_min_y_rot(void);
	inline void to_min_y_rot(float value);
	inline float to_min_z_rot(void);
	inline void to_min_z_rot(float value);
	inline float to_max_x_rot(void);
	inline void to_max_x_rot(float value);
	inline float to_max_y_rot(void);
	inline void to_max_y_rot(float value);
	inline float to_max_z_rot(void);
	inline void to_max_z_rot(float value);
	enum mix_mode_rot_enum {
		mix_mode_rot_REPLACE = 1,
		mix_mode_rot_ADD = 0,
		mix_mode_rot_BEFORE = 2,
		mix_mode_rot_AFTER = 3,
	};
	inline mix_mode_rot_enum mix_mode_rot(void);
	inline void mix_mode_rot(mix_mode_rot_enum value);
	inline float from_min_x_scale(void);
	inline void from_min_x_scale(float value);
	inline float from_min_y_scale(void);
	inline void from_min_y_scale(float value);
	inline float from_min_z_scale(void);
	inline void from_min_z_scale(float value);
	inline float from_max_x_scale(void);
	inline void from_max_x_scale(float value);
	inline float from_max_y_scale(void);
	inline void from_max_y_scale(float value);
	inline float from_max_z_scale(void);
	inline void from_max_z_scale(float value);
	inline float to_min_x_scale(void);
	inline void to_min_x_scale(float value);
	inline float to_min_y_scale(void);
	inline void to_min_y_scale(float value);
	inline float to_min_z_scale(void);
	inline void to_min_z_scale(float value);
	inline float to_max_x_scale(void);
	inline void to_max_x_scale(float value);
	inline float to_max_y_scale(void);
	inline void to_max_y_scale(float value);
	inline float to_max_z_scale(void);
	inline void to_max_z_scale(float value);
	enum mix_mode_scale_enum {
		mix_mode_scale_REPLACE = 0,
		mix_mode_scale_MULTIPLY = 1,
	};
	inline mix_mode_scale_enum mix_mode_scale(void);
	inline void mix_mode_scale(mix_mode_scale_enum value);

};

/**************** Shrinkwrap Constraint ****************/

class ShrinkwrapConstraint : public Constraint {
public:
	ShrinkwrapConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	enum shrinkwrap_type_enum {
		shrinkwrap_type_NEAREST_SURFACE = 0,
		shrinkwrap_type_PROJECT = 1,
		shrinkwrap_type_NEAREST_VERTEX = 2,
		shrinkwrap_type_TARGET_PROJECT = 3,
	};
	inline shrinkwrap_type_enum shrinkwrap_type(void);
	inline void shrinkwrap_type(shrinkwrap_type_enum value);
	enum wrap_mode_enum {
		wrap_mode_ON_SURFACE = 0,
		wrap_mode_INSIDE = 1,
		wrap_mode_OUTSIDE = 2,
		wrap_mode_OUTSIDE_SURFACE = 3,
		wrap_mode_ABOVE_SURFACE = 4,
	};
	inline wrap_mode_enum wrap_mode(void);
	inline void wrap_mode(wrap_mode_enum value);
	inline float distance(void);
	inline void distance(float value);
	enum project_axis_enum {
		project_axis_POS_X = 0,
		project_axis_POS_Y = 1,
		project_axis_POS_Z = 2,
		project_axis_NEG_X = 3,
		project_axis_NEG_Y = 4,
		project_axis_NEG_Z = 5,
	};
	inline project_axis_enum project_axis(void);
	inline void project_axis(project_axis_enum value);
	enum project_axis_space_enum {
		project_axis_space_WORLD = 0,
		project_axis_space_CUSTOM = 5,
		project_axis_space_POSE = 2,
		project_axis_space_LOCAL_WITH_PARENT = 3,
		project_axis_space_LOCAL = 1,
	};
	inline project_axis_space_enum project_axis_space(void);
	inline void project_axis_space(project_axis_space_enum value);
	inline float project_limit(void);
	inline void project_limit(float value);
	inline bool use_project_opposite(void);
	inline void use_project_opposite(bool value);
	enum cull_face_enum {
		cull_face_OFF = 0,
		cull_face_FRONT = 8,
		cull_face_BACK = 16,
	};
	inline cull_face_enum cull_face(void);
	inline void cull_face(cull_face_enum value);
	inline bool use_invert_cull(void);
	inline void use_invert_cull(bool value);
	inline bool use_track_normal(void);
	inline void use_track_normal(bool value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);

};

/**************** Damped Track Constraint ****************/

class DampedTrackConstraint : public Constraint {
public:
	DampedTrackConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);

};

/**************** Spline IK Constraint ****************/

class SplineIKConstraint : public Constraint {
public:
	SplineIKConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline Object target(void);
	inline int chain_count(void);
	inline void chain_count(int value);
	inline Array<float, 32> joint_bindings(void);
	inline void joint_bindings(float values[32]);
	inline bool use_chain_offset(void);
	inline void use_chain_offset(bool value);
	inline bool use_even_divisions(void);
	inline void use_even_divisions(bool value);
	inline bool use_curve_radius(void);
	inline void use_curve_radius(bool value);
	enum xz_scale_mode_enum {
		xz_scale_mode_NONE = 0,
		xz_scale_mode_BONE_ORIGINAL = 1,
		xz_scale_mode_INVERSE_PRESERVE = 2,
		xz_scale_mode_VOLUME_PRESERVE = 3,
	};
	inline xz_scale_mode_enum xz_scale_mode(void);
	inline void xz_scale_mode(xz_scale_mode_enum value);
	enum y_scale_mode_enum {
		y_scale_mode_NONE = 0,
		y_scale_mode_FIT_CURVE = 1,
		y_scale_mode_BONE_ORIGINAL = 2,
	};
	inline y_scale_mode_enum y_scale_mode(void);
	inline void y_scale_mode(y_scale_mode_enum value);
	inline bool use_original_scale(void);
	inline void use_original_scale(bool value);
	inline float bulge(void);
	inline void bulge(float value);
	inline bool use_bulge_min(void);
	inline void use_bulge_min(bool value);
	inline bool use_bulge_max(void);
	inline void use_bulge_max(bool value);
	inline float bulge_min(void);
	inline void bulge_min(float value);
	inline float bulge_max(void);
	inline void bulge_max(float value);
	inline float bulge_smooth(void);
	inline void bulge_smooth(float value);

};

/**************** Pivot Constraint ****************/

class PivotConstraint : public Constraint {
public:
	PivotConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline float head_tail(void);
	inline void head_tail(float value);
	inline bool use_bbone_shape(void);
	inline void use_bbone_shape(bool value);
	inline Object target(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_relative_location(void);
	inline void use_relative_location(bool value);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	enum rotation_range_enum {
		rotation_range_ALWAYS_ACTIVE = -1,
		rotation_range_NX = 0,
		rotation_range_NY = 1,
		rotation_range_NZ = 2,
		rotation_range_X = 3,
		rotation_range_Y = 4,
		rotation_range_Z = 5,
	};
	inline rotation_range_enum rotation_range(void);
	inline void rotation_range(rotation_range_enum value);

};

/**************** Follow Track Constraint ****************/

class FollowTrackConstraint : public Constraint {
public:
	FollowTrackConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline std::string track(void);
	inline void track(const std::string& value);
	inline bool use_active_clip(void);
	inline void use_active_clip(bool value);
	inline bool use_3d_position(void);
	inline void use_3d_position(bool value);
	inline std::string object(void);
	inline void object(const std::string& value);
	inline Object camera(void);
	inline Object depth_object(void);
	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 1,
		frame_method_CROP = 2,
	};
	inline frame_method_enum frame_method(void);
	inline void frame_method(frame_method_enum value);
	inline bool use_undistorted_position(void);
	inline void use_undistorted_position(bool value);

};

/**************** Camera Solver Constraint ****************/

class CameraSolverConstraint : public Constraint {
public:
	CameraSolverConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline bool use_active_clip(void);
	inline void use_active_clip(bool value);

};

/**************** Object Solver Constraint ****************/

class ObjectSolverConstraint : public Constraint {
public:
	ObjectSolverConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline bool use_active_clip(void);
	inline void use_active_clip(bool value);
	inline bool set_inverse_pending(void);
	inline void set_inverse_pending(bool value);
	inline std::string object(void);
	inline void object(const std::string& value);
	inline Object camera(void);

};

/**************** Transform Cache Constraint ****************/

class TransformCacheConstraint : public Constraint {
public:
	TransformCacheConstraint(const PointerRNA &ptr_arg) :
		Constraint(ptr_arg)
		{}

	inline CacheFile cache_file(void);
	inline std::string object_path(void);
	inline void object_path(const std::string& value);

};

/**************** Context ****************/

class Context : public Pointer {
public:
	Context(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline WindowManager window_manager(void);
	inline Window window(void);
	inline WorkSpace workspace(void);
	inline Screen screen(void);
	inline Area area(void);
	inline Space space_data(void);
	inline Region region(void);
	inline RegionView3D region_data(void);
	inline GizmoGroup gizmo_group(void);
	inline AssetRepresentation asset(void);
	inline BlendData blend_data(void);
	inline Scene scene(void);
	inline ViewLayer view_layer(void);
	inline std::string engine(void);
	inline void engine(const std::string& value);
	inline Collection collection(void);
	inline LayerCollection layer_collection(void);
	inline ToolSettings tool_settings(void);
	inline Preferences preferences(void);
	enum mode_enum {
		mode_EDIT_MESH = 0,
		mode_EDIT_CURVE = 1,
		mode_EDIT_CURVES = 7,
		mode_EDIT_SURFACE = 2,
		mode_EDIT_TEXT = 3,
		mode_EDIT_ARMATURE = 4,
		mode_EDIT_METABALL = 5,
		mode_EDIT_LATTICE = 6,
		mode_EDIT_GREASE_PENCIL = 8,
		mode_EDIT_POINT_CLOUD = 9,
		mode_POSE = 10,
		mode_SCULPT = 11,
		mode_PAINT_WEIGHT = 12,
		mode_PAINT_VERTEX = 13,
		mode_PAINT_TEXTURE = 14,
		mode_PARTICLE = 15,
		mode_OBJECT = 16,
		mode_PAINT_GPENCIL = 17,
		mode_EDIT_GPENCIL = 18,
		mode_SCULPT_GPENCIL = 19,
		mode_WEIGHT_GPENCIL = 20,
		mode_VERTEX_GPENCIL = 21,
		mode_SCULPT_CURVES = 22,
		mode_PAINT_GREASE_PENCIL = 23,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline Depsgraph evaluated_depsgraph_get();
};

/**************** Curve ****************/

class Curve : public ID {
public:
	Curve(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		splines(ptr_arg),
		materials(ptr_arg)
		{}

	inline Key shape_keys(void);
	COLLECTION_PROPERTY(CurveSplines, Spline, Curve, splines, false, false, false)
	inline int path_duration(void);
	inline void path_duration(int value);
	inline bool use_path(void);
	inline void use_path(bool value);
	inline bool use_path_follow(void);
	inline void use_path_follow(bool value);
	inline bool use_path_clamp(void);
	inline void use_path_clamp(bool value);
	inline bool use_stretch(void);
	inline void use_stretch(bool value);
	inline bool use_deform_bounds(void);
	inline void use_deform_bounds(bool value);
	inline bool use_radius(void);
	inline void use_radius(bool value);
	enum bevel_mode_enum {
		bevel_mode_ROUND = 0,
		bevel_mode_OBJECT = 1,
		bevel_mode_PROFILE = 2,
	};
	inline bevel_mode_enum bevel_mode(void);
	inline void bevel_mode(bevel_mode_enum value);
	inline CurveProfile bevel_profile(void);
	inline int bevel_resolution(void);
	inline void bevel_resolution(int value);
	inline float offset(void);
	inline void offset(float value);
	inline float extrude(void);
	inline void extrude(float value);
	inline float bevel_depth(void);
	inline void bevel_depth(float value);
	inline int resolution_u(void);
	inline void resolution_u(int value);
	inline int resolution_v(void);
	inline void resolution_v(int value);
	inline int render_resolution_u(void);
	inline void render_resolution_u(int value);
	inline int render_resolution_v(void);
	inline void render_resolution_v(int value);
	inline float eval_time(void);
	inline void eval_time(float value);
	inline Object bevel_object(void);
	inline Object taper_object(void);
	enum dimensions_enum {
		dimensions_2D = 0,
		dimensions_3D = 1,
	};
	inline dimensions_enum dimensions(void);
	inline void dimensions(dimensions_enum value);
	enum fill_mode_enum {
		fill_mode_FULL = 0,
		fill_mode_BACK = 4,
		fill_mode_FRONT = 2,
		fill_mode_HALF = 6,
	};
	inline fill_mode_enum fill_mode(void);
	inline void fill_mode(fill_mode_enum value);
	enum twist_mode_enum {
		twist_mode_Z_UP = 0,
		twist_mode_MINIMUM = 3,
		twist_mode_TANGENT = 4,
	};
	inline twist_mode_enum twist_mode(void);
	inline void twist_mode(twist_mode_enum value);
	enum taper_radius_mode_enum {
		taper_radius_mode_OVERRIDE = 0,
		taper_radius_mode_MULTIPLY = 1,
		taper_radius_mode_ADD = 2,
	};
	inline taper_radius_mode_enum taper_radius_mode(void);
	inline void taper_radius_mode(taper_radius_mode_enum value);
	enum bevel_factor_mapping_start_enum {
		bevel_factor_mapping_start_RESOLUTION = 0,
		bevel_factor_mapping_start_SEGMENTS = 1,
		bevel_factor_mapping_start_SPLINE = 2,
	};
	inline bevel_factor_mapping_start_enum bevel_factor_mapping_start(void);
	inline void bevel_factor_mapping_start(bevel_factor_mapping_start_enum value);
	enum bevel_factor_mapping_end_enum {
		bevel_factor_mapping_end_RESOLUTION = 0,
		bevel_factor_mapping_end_SEGMENTS = 1,
		bevel_factor_mapping_end_SPLINE = 2,
	};
	inline bevel_factor_mapping_end_enum bevel_factor_mapping_end(void);
	inline void bevel_factor_mapping_end(bevel_factor_mapping_end_enum value);
	inline float twist_smooth(void);
	inline void twist_smooth(float value);
	inline bool use_fill_caps(void);
	inline void use_fill_caps(bool value);
	inline bool use_map_taper(void);
	inline void use_map_taper(bool value);
	inline bool use_auto_texspace(void);
	inline void use_auto_texspace(bool value);
	inline Array<float, 3> texspace_location(void);
	inline void texspace_location(float values[3]);
	inline Array<float, 3> texspace_size(void);
	inline void texspace_size(float values[3]);
	COLLECTION_PROPERTY(IDMaterials, Material, Curve, materials, true, true, true)
	inline float bevel_factor_start(void);
	inline void bevel_factor_start(float value);
	inline float bevel_factor_end(void);
	inline void bevel_factor_end(float value);
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);

	inline void transform(float matrix[16], bool shape_keys);
	inline bool validate_material_indices();
	inline void update_gpu_tag();
};

/**************** Surface Curve ****************/

class SurfaceCurve : public Curve {
public:
	SurfaceCurve(const PointerRNA &ptr_arg) :
		Curve(ptr_arg)
		{}


};

/**************** Text Curve ****************/

class TextCurve : public Curve {
public:
	TextCurve(const PointerRNA &ptr_arg) :
		Curve(ptr_arg),
		text_boxes(ptr_arg),
		body_format(ptr_arg)
		{}

	enum align_x_enum {
		align_x_LEFT = 0,
		align_x_CENTER = 1,
		align_x_RIGHT = 2,
		align_x_JUSTIFY = 3,
		align_x_FLUSH = 4,
	};
	inline align_x_enum align_x(void);
	inline void align_x(align_x_enum value);
	enum align_y_enum {
		align_y_TOP = 1,
		align_y_TOP_BASELINE = 0,
		align_y_CENTER = 2,
		align_y_BOTTOM_BASELINE = 3,
		align_y_BOTTOM = 4,
	};
	inline align_y_enum align_y(void);
	inline void align_y(align_y_enum value);
	enum overflow_enum {
		overflow_NONE = 0,
		overflow_SCALE = 1,
		overflow_TRUNCATE = 2,
	};
	inline overflow_enum overflow(void);
	inline void overflow(overflow_enum value);
	inline float size(void);
	inline void size(float value);
	inline float small_caps_scale(void);
	inline void small_caps_scale(float value);
	inline float space_line(void);
	inline void space_line(float value);
	inline float space_word(void);
	inline void space_word(float value);
	inline float space_character(void);
	inline void space_character(float value);
	inline float shear(void);
	inline void shear(float value);
	inline float offset_x(void);
	inline void offset_x(float value);
	inline float offset_y(void);
	inline void offset_y(float value);
	inline float underline_position(void);
	inline void underline_position(float value);
	inline float underline_height(void);
	inline void underline_height(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TextBox, TextCurve, text_boxes, true, true, false)
	inline int active_textbox(void);
	inline void active_textbox(int value);
	inline std::string family(void);
	inline void family(const std::string& value);
	inline std::string body(void);
	inline void body(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TextCharacterFormat, TextCurve, body_format, true, true, false)
	inline Object follow_curve(void);
	inline VectorFont font(void);
	inline VectorFont font_bold(void);
	inline VectorFont font_italic(void);
	inline VectorFont font_bold_italic(void);
	inline TextCharacterFormat edit_format(void);
	inline bool use_fast_edit(void);
	inline void use_fast_edit(bool value);
	inline bool is_select_bold(void);
	inline void is_select_bold(bool value);
	inline bool is_select_italic(void);
	inline void is_select_italic(bool value);
	inline bool is_select_underline(void);
	inline void is_select_underline(bool value);
	inline bool is_select_smallcaps(void);
	inline void is_select_smallcaps(bool value);
	inline bool has_selection(void);
	inline void has_selection(bool value);

};

/**************** Text Box ****************/

class TextBox : public Pointer {
public:
	TextBox(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);
	inline float width(void);
	inline void width(float value);
	inline float height(void);
	inline void height(float value);

};

/**************** Text Character Format ****************/

class TextCharacterFormat : public Pointer {
public:
	TextCharacterFormat(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_bold(void);
	inline void use_bold(bool value);
	inline bool use_italic(void);
	inline void use_italic(bool value);
	inline bool use_underline(void);
	inline void use_underline(bool value);
	inline bool use_small_caps(void);
	inline void use_small_caps(bool value);
	inline int material_index(void);
	inline void material_index(int value);
	inline float kerning(void);
	inline void kerning(float value);

};

/**************** SplinePoint ****************/

class SplinePoint : public Pointer {
public:
	SplinePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline Array<float, 4> co(void);
	inline void co(float values[4]);
	inline float weight(void);
	inline void weight(float value);
	inline float tilt(void);
	inline void tilt(float value);
	inline float weight_softbody(void);
	inline void weight_softbody(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Bezier Curve Point ****************/

class BezierSplinePoint : public Pointer {
public:
	BezierSplinePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select_left_handle(void);
	inline void select_left_handle(bool value);
	inline bool select_right_handle(void);
	inline void select_right_handle(bool value);
	inline bool select_control_point(void);
	inline void select_control_point(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	enum handle_left_type_enum {
		handle_left_type_FREE = 0,
		handle_left_type_VECTOR = 2,
		handle_left_type_ALIGNED = 3,
		handle_left_type_AUTO = 1,
	};
	inline handle_left_type_enum handle_left_type(void);
	inline void handle_left_type(handle_left_type_enum value);
	enum handle_right_type_enum {
		handle_right_type_FREE = 0,
		handle_right_type_VECTOR = 2,
		handle_right_type_ALIGNED = 3,
		handle_right_type_AUTO = 1,
	};
	inline handle_right_type_enum handle_right_type(void);
	inline void handle_right_type(handle_right_type_enum value);
	inline Array<float, 3> handle_left(void);
	inline void handle_left(float values[3]);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> handle_right(void);
	inline void handle_right(float values[3]);
	inline float tilt(void);
	inline void tilt(float value);
	inline float weight_softbody(void);
	inline void weight_softbody(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Spline ****************/

class Spline : public Pointer {
public:
	Spline(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg),
		bezier_points(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(SplinePoints, SplinePoint, Spline, points, true, true, false)
	COLLECTION_PROPERTY(SplineBezierPoints, BezierSplinePoint, Spline, bezier_points, true, true, false)
	enum tilt_interpolation_enum {
		tilt_interpolation_LINEAR = 0,
		tilt_interpolation_CARDINAL = 1,
		tilt_interpolation_BSPLINE = 2,
		tilt_interpolation_EASE = 3,
	};
	inline tilt_interpolation_enum tilt_interpolation(void);
	inline void tilt_interpolation(tilt_interpolation_enum value);
	enum radius_interpolation_enum {
		radius_interpolation_LINEAR = 0,
		radius_interpolation_CARDINAL = 1,
		radius_interpolation_BSPLINE = 2,
		radius_interpolation_EASE = 3,
	};
	inline radius_interpolation_enum radius_interpolation(void);
	inline void radius_interpolation(radius_interpolation_enum value);
	enum type_enum {
		type_POLY = 0,
		type_BEZIER = 1,
		type_NURBS = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline int point_count_u(void);
	inline void point_count_u(int value);
	inline int point_count_v(void);
	inline void point_count_v(int value);
	inline int order_u(void);
	inline void order_u(int value);
	inline int order_v(void);
	inline void order_v(int value);
	inline int resolution_u(void);
	inline void resolution_u(int value);
	inline int resolution_v(void);
	inline void resolution_v(int value);
	inline bool use_cyclic_u(void);
	inline void use_cyclic_u(bool value);
	inline bool use_cyclic_v(void);
	inline void use_cyclic_v(bool value);
	inline bool use_endpoint_u(void);
	inline void use_endpoint_u(bool value);
	inline bool use_endpoint_v(void);
	inline void use_endpoint_v(bool value);
	inline bool use_bezier_u(void);
	inline void use_bezier_u(bool value);
	inline bool use_bezier_v(void);
	inline void use_bezier_v(bool value);
	inline bool use_smooth(void);
	inline void use_smooth(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline int material_index(void);
	inline void material_index(int value);
	inline int character_index(void);
	inline void character_index(int value);

	inline float calc_length(int resolution);
	inline void valid_message(int direction, int *result_len, const char * *result);
};

/**************** Canvas Settings ****************/

class DynamicPaintCanvasSettings : public Pointer {
public:
	DynamicPaintCanvasSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		canvas_surfaces(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DynamicPaintSurfaces, DynamicPaintSurface, DynamicPaintCanvasSettings, canvas_surfaces, false, false, false)

};

/**************** Brush Settings ****************/

class DynamicPaintBrushSettings : public Pointer {
public:
	DynamicPaintBrushSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> paint_color(void);
	inline void paint_color(float values[3]);
	inline float paint_alpha(void);
	inline void paint_alpha(float value);
	inline bool use_absolute_alpha(void);
	inline void use_absolute_alpha(bool value);
	inline float paint_wetness(void);
	inline void paint_wetness(float value);
	inline bool use_paint_erase(void);
	inline void use_paint_erase(bool value);
	enum wave_type_enum {
		wave_type_CHANGE = 3,
		wave_type_DEPTH = 0,
		wave_type_FORCE = 1,
		wave_type_REFLECT = 2,
	};
	inline wave_type_enum wave_type(void);
	inline void wave_type(wave_type_enum value);
	inline float wave_factor(void);
	inline void wave_factor(float value);
	inline float wave_clamp(void);
	inline void wave_clamp(float value);
	inline bool use_smudge(void);
	inline void use_smudge(bool value);
	inline float smudge_strength(void);
	inline void smudge_strength(float value);
	inline float velocity_max(void);
	inline void velocity_max(float value);
	inline bool use_velocity_alpha(void);
	inline void use_velocity_alpha(bool value);
	inline bool use_velocity_depth(void);
	inline void use_velocity_depth(bool value);
	inline bool use_velocity_color(void);
	inline void use_velocity_color(bool value);
	enum paint_source_enum {
		paint_source_PARTICLE_SYSTEM = 3,
		paint_source_POINT = 4,
		paint_source_DISTANCE = 1,
		paint_source_VOLUME_DISTANCE = 2,
		paint_source_VOLUME = 0,
	};
	inline paint_source_enum paint_source(void);
	inline void paint_source(paint_source_enum value);
	inline float paint_distance(void);
	inline void paint_distance(float value);
	inline bool use_proximity_ramp_alpha(void);
	inline void use_proximity_ramp_alpha(bool value);
	enum proximity_falloff_enum {
		proximity_falloff_SMOOTH = 1,
		proximity_falloff_CONSTANT = 0,
		proximity_falloff_RAMP = 2,
	};
	inline proximity_falloff_enum proximity_falloff(void);
	inline void proximity_falloff(proximity_falloff_enum value);
	inline bool use_proximity_project(void);
	inline void use_proximity_project(bool value);
	enum ray_direction_enum {
		ray_direction_CANVAS = 0,
		ray_direction_BRUSH = 1,
		ray_direction_Z_AXIS = 2,
	};
	inline ray_direction_enum ray_direction(void);
	inline void ray_direction(ray_direction_enum value);
	inline bool invert_proximity(void);
	inline void invert_proximity(bool value);
	inline bool use_negative_volume(void);
	inline void use_negative_volume(bool value);
	inline ParticleSystem particle_system(void);
	inline bool use_particle_radius(void);
	inline void use_particle_radius(bool value);
	inline float solid_radius(void);
	inline void solid_radius(float value);
	inline float smooth_radius(void);
	inline void smooth_radius(float value);
	inline ColorRamp paint_ramp(void);
	inline ColorRamp velocity_ramp(void);

};

/**************** Paint Surface ****************/

class DynamicPaintSurface : public Pointer {
public:
	DynamicPaintSurface(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum surface_format_enum {
		surface_format_VERTEX = 1,
		surface_format_IMAGE = 2,
	};
	inline surface_format_enum surface_format(void);
	inline void surface_format(surface_format_enum value);
	enum surface_type_enum {
		surface_type_PAINT = 0,
	};
	inline surface_type_enum surface_type(void);
	inline void surface_type(surface_type_enum value);
	inline bool is_active(void);
	inline void is_active(bool value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Collection brush_collection(void);
	inline bool use_dissolve(void);
	inline void use_dissolve(bool value);
	inline int dissolve_speed(void);
	inline void dissolve_speed(int value);
	inline bool use_drying(void);
	inline void use_drying(bool value);
	inline int dry_speed(void);
	inline void dry_speed(int value);
	inline int image_resolution(void);
	inline void image_resolution(int value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_substeps(void);
	inline void frame_substeps(int value);
	inline bool use_antialiasing(void);
	inline void use_antialiasing(bool value);
	inline float brush_influence_scale(void);
	inline void brush_influence_scale(float value);
	inline float brush_radius_scale(void);
	inline void brush_radius_scale(float value);
	enum init_color_type_enum {
		init_color_type_NONE = 0,
		init_color_type_COLOR = 1,
		init_color_type_TEXTURE = 2,
		init_color_type_VERTEX_COLOR = 3,
	};
	inline init_color_type_enum init_color_type(void);
	inline void init_color_type(init_color_type_enum value);
	inline Array<float, 4> init_color(void);
	inline void init_color(float values[4]);
	inline Texture init_texture(void);
	inline std::string init_layername(void);
	inline void init_layername(const std::string& value);
	enum effect_ui_enum {
		effect_ui_SPREAD = 1,
		effect_ui_DRIP = 2,
		effect_ui_SHRINK = 3,
	};
	inline effect_ui_enum effect_ui(void);
	inline void effect_ui(effect_ui_enum value);
	inline bool use_dry_log(void);
	inline void use_dry_log(bool value);
	inline bool use_dissolve_log(void);
	inline void use_dissolve_log(bool value);
	inline bool use_spread(void);
	inline void use_spread(bool value);
	inline float spread_speed(void);
	inline void spread_speed(float value);
	inline float color_dry_threshold(void);
	inline void color_dry_threshold(float value);
	inline float color_spread_speed(void);
	inline void color_spread_speed(float value);
	inline bool use_drip(void);
	inline void use_drip(bool value);
	inline bool use_shrink(void);
	inline void use_shrink(bool value);
	inline float shrink_speed(void);
	inline void shrink_speed(float value);
	inline EffectorWeights effector_weights(void);
	inline float drip_velocity(void);
	inline void drip_velocity(float value);
	inline float drip_acceleration(void);
	inline void drip_acceleration(float value);
	inline bool use_premultiply(void);
	inline void use_premultiply(bool value);
	inline std::string image_output_path(void);
	inline void image_output_path(const std::string& value);
	inline std::string output_name_a(void);
	inline void output_name_a(const std::string& value);
	inline bool use_output_a(void);
	inline void use_output_a(bool value);
	inline std::string output_name_b(void);
	inline void output_name_b(const std::string& value);
	inline bool use_output_b(void);
	inline void use_output_b(bool value);
	inline float depth_clamp(void);
	inline void depth_clamp(float value);
	inline float displace_factor(void);
	inline void displace_factor(float value);
	enum image_fileformat_enum {
		image_fileformat_PNG = 0,
		image_fileformat_OPENEXR = 1,
	};
	inline image_fileformat_enum image_fileformat(void);
	inline void image_fileformat(image_fileformat_enum value);
	enum displace_type_enum {
		displace_type_DISPLACE = 0,
		displace_type_DEPTH = 1,
	};
	inline displace_type_enum displace_type(void);
	inline void displace_type(displace_type_enum value);
	inline bool use_incremental_displace(void);
	inline void use_incremental_displace(bool value);
	inline float wave_damping(void);
	inline void wave_damping(float value);
	inline float wave_speed(void);
	inline void wave_speed(float value);
	inline float wave_timescale(void);
	inline void wave_timescale(float value);
	inline float wave_spring(void);
	inline void wave_spring(float value);
	inline float wave_smoothness(void);
	inline void wave_smoothness(float value);
	inline bool use_wave_open_border(void);
	inline void use_wave_open_border(bool value);
	inline PointCache point_cache(void);
	inline bool is_cache_user(void);
	inline void is_cache_user(bool value);

	inline bool output_exists(Object& object, int index);
};

/**************** F-Curve ****************/

class FCurve : public Pointer {
public:
	FCurve(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		sampled_points(ptr_arg),
		keyframe_points(ptr_arg),
		modifiers(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum extrapolation_enum {
		extrapolation_CONSTANT = 0,
		extrapolation_LINEAR = 1,
	};
	inline extrapolation_enum extrapolation(void);
	inline void extrapolation(extrapolation_enum value);
	inline Driver driver(void);
	inline ActionGroup group(void);
	inline std::string data_path(void);
	inline void data_path(const std::string& value);
	inline int array_index(void);
	inline void array_index(int value);
	enum color_mode_enum {
		color_mode_AUTO_RAINBOW = 0,
		color_mode_AUTO_RGB = 1,
		color_mode_AUTO_YRGB = 3,
		color_mode_CUSTOM = 2,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline bool select(void);
	inline void select(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	enum auto_smoothing_enum {
		auto_smoothing_NONE = 0,
		auto_smoothing_CONT_ACCEL = 1,
	};
	inline auto_smoothing_enum auto_smoothing(void);
	inline void auto_smoothing(auto_smoothing_enum value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool is_empty(void);
	inline void is_empty(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FCurveSample, FCurve, sampled_points, true, true, false)
	COLLECTION_PROPERTY(FCurveKeyframePoints, Keyframe, FCurve, keyframe_points, true, true, false)
	COLLECTION_PROPERTY(FCurveModifiers, FModifier, FCurve, modifiers, false, true, true)

	inline float evaluate(float frame);
	inline void update(void *main);
	inline void range(float range[2]);
	inline void update_autoflags(Context C, AnyType& data);
	inline void convert_to_samples(int start, int end);
	inline void convert_to_keyframes(int start, int end);
};

/**************** Keyframe ****************/

class Keyframe : public Pointer {
public:
	Keyframe(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select_left_handle(void);
	inline void select_left_handle(bool value);
	inline bool select_right_handle(void);
	inline void select_right_handle(bool value);
	inline bool select_control_point(void);
	inline void select_control_point(bool value);
	enum handle_left_type_enum {
		handle_left_type_FREE = 0,
		handle_left_type_ALIGNED = 3,
		handle_left_type_VECTOR = 2,
		handle_left_type_AUTO = 1,
		handle_left_type_AUTO_CLAMPED = 4,
	};
	inline handle_left_type_enum handle_left_type(void);
	inline void handle_left_type(handle_left_type_enum value);
	enum handle_right_type_enum {
		handle_right_type_FREE = 0,
		handle_right_type_ALIGNED = 3,
		handle_right_type_VECTOR = 2,
		handle_right_type_AUTO = 1,
		handle_right_type_AUTO_CLAMPED = 4,
	};
	inline handle_right_type_enum handle_right_type(void);
	inline void handle_right_type(handle_right_type_enum value);
	enum interpolation_enum {
		interpolation_CONSTANT = 0,
		interpolation_LINEAR = 1,
		interpolation_BEZIER = 2,
		interpolation_SINE = 12,
		interpolation_QUAD = 9,
		interpolation_CUBIC = 6,
		interpolation_QUART = 10,
		interpolation_QUINT = 11,
		interpolation_EXPO = 8,
		interpolation_CIRC = 5,
		interpolation_BACK = 3,
		interpolation_BOUNCE = 4,
		interpolation_ELASTIC = 7,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum type_enum {
		type_KEYFRAME = 0,
		type_BREAKDOWN = 2,
		type_MOVING_HOLD = 4,
		type_EXTREME = 1,
		type_JITTER = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum easing_enum {
		easing_AUTO = 0,
		easing_EASE_IN = 1,
		easing_EASE_OUT = 2,
		easing_EASE_IN_OUT = 3,
	};
	inline easing_enum easing(void);
	inline void easing(easing_enum value);
	inline float back(void);
	inline void back(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline Array<float, 2> handle_left(void);
	inline void handle_left(float values[2]);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);
	inline Array<float, 2> co_ui(void);
	inline void co_ui(float values[2]);
	inline Array<float, 2> handle_right(void);
	inline void handle_right(float values[2]);

};

/**************** F-Curve Sample ****************/

class FCurveSample : public Pointer {
public:
	FCurveSample(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select(void);
	inline void select(bool value);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);

};

/**************** Driver Target ****************/

class DriverTarget : public Pointer {
public:
	DriverTarget(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	enum id_type_enum {
		id_type_ACTION = 17217,
		id_type_ARMATURE = 21057,
		id_type_BRUSH = 21058,
		id_type_CACHEFILE = 17987,
		id_type_CAMERA = 16707,
		id_type_COLLECTION = 21063,
		id_type_CURVE = 21827,
		id_type_CURVES = 22083,
		id_type_FONT = 18006,
		id_type_GREASEPENCIL = 17479,
		id_type_GREASEPENCIL_V3 = 20551,
		id_type_IMAGE = 19785,
		id_type_KEY = 17739,
		id_type_LATTICE = 21580,
		id_type_LIBRARY = 18764,
		id_type_LIGHT = 16716,
		id_type_LIGHT_PROBE = 20556,
		id_type_LINESTYLE = 21324,
		id_type_MASK = 21325,
		id_type_MATERIAL = 16717,
		id_type_MESH = 17741,
		id_type_META = 16973,
		id_type_MOVIECLIP = 17229,
		id_type_NODETREE = 21582,
		id_type_OBJECT = 16975,
		id_type_PAINTCURVE = 17232,
		id_type_PALETTE = 19536,
		id_type_PARTICLE = 16720,
		id_type_POINTCLOUD = 21584,
		id_type_SCENE = 17235,
		id_type_SOUND = 20307,
		id_type_SPEAKER = 19283,
		id_type_TEXT = 22612,
		id_type_TEXTURE = 17748,
		id_type_VOLUME = 20310,
		id_type_WINDOWMANAGER = 19799,
		id_type_WORKSPACE = 21335,
		id_type_WORLD = 20311,
	};
	inline id_type_enum id_type(void);
	inline void id_type(id_type_enum value);
	inline std::string data_path(void);
	inline void data_path(const std::string& value);
	inline std::string bone_target(void);
	inline void bone_target(const std::string& value);
	enum transform_type_enum {
		transform_type_LOC_X = 0,
		transform_type_LOC_Y = 1,
		transform_type_LOC_Z = 2,
		transform_type_ROT_X = 3,
		transform_type_ROT_Y = 4,
		transform_type_ROT_Z = 5,
		transform_type_ROT_W = 10,
		transform_type_SCALE_X = 6,
		transform_type_SCALE_Y = 7,
		transform_type_SCALE_Z = 8,
		transform_type_SCALE_AVG = 9,
	};
	inline transform_type_enum transform_type(void);
	inline void transform_type(transform_type_enum value);
	enum rotation_mode_enum {
		rotation_mode_AUTO = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_QUATERNION = 7,
		rotation_mode_SWING_TWIST_X = 8,
		rotation_mode_SWING_TWIST_Y = 9,
		rotation_mode_SWING_TWIST_Z = 10,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	enum transform_space_enum {
		transform_space_WORLD_SPACE = 0,
		transform_space_TRANSFORM_SPACE = 4,
		transform_space_LOCAL_SPACE = 12,
	};
	inline transform_space_enum transform_space(void);
	inline void transform_space(transform_space_enum value);
	enum context_property_enum {
		context_property_ACTIVE_SCENE = 0,
		context_property_ACTIVE_VIEW_LAYER = 1,
	};
	inline context_property_enum context_property(void);
	inline void context_property(context_property_enum value);

};

/**************** Driver Variable ****************/

class DriverVariable : public Pointer {
public:
	DriverVariable(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		targets(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_SINGLE_PROP = 0,
		type_TRANSFORMS = 3,
		type_ROTATION_DIFF = 1,
		type_LOC_DIFF = 2,
		type_CONTEXT_PROP = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, DriverTarget, DriverVariable, targets, true, true, false)
	inline bool is_name_valid(void);
	inline void is_name_valid(bool value);

};

/**************** Driver ****************/

class Driver : public Pointer {
public:
	Driver(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		variables(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_AVERAGE = 0,
		type_SUM = 2,
		type_SCRIPTED = 1,
		type_MIN = 3,
		type_MAX = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string expression(void);
	inline void expression(const std::string& value);
	COLLECTION_PROPERTY(ChannelDriverVariables, DriverVariable, Driver, variables, false, true, true)
	inline bool use_self(void);
	inline void use_self(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool is_simple_expression(void);
	inline void is_simple_expression(bool value);

};

/**************** F-Modifier ****************/

class FModifier : public Pointer {
public:
	FModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_nullptr = 0,
		type_GENERATOR = 1,
		type_FNGENERATOR = 2,
		type_ENVELOPE = 3,
		type_CYCLES = 4,
		type_NOISE = 5,
		type_LIMITS = 8,
		type_STEPPED = 9,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool active(void);
	inline void active(bool value);
	inline bool use_restricted_range(void);
	inline void use_restricted_range(bool value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline float blend_in(void);
	inline void blend_in(float value);
	inline float blend_out(void);
	inline void blend_out(float value);
	inline bool use_influence(void);
	inline void use_influence(bool value);
	inline float influence(void);
	inline void influence(float value);

};

/**************** Generator F-Modifier ****************/

class FModifierGenerator : public FModifier {
public:
	FModifierGenerator(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline bool use_additive(void);
	inline void use_additive(bool value);
	enum mode_enum {
		mode_POLYNOMIAL = 0,
		mode_POLYNOMIAL_FACTORISED = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline int poly_order(void);
	inline void poly_order(int value);
	inline Array<float, 32> coefficients(void);
	inline void coefficients(float values[32]);

};

/**************** Built-In Function F-Modifier ****************/

class FModifierFunctionGenerator : public FModifier {
public:
	FModifierFunctionGenerator(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline float amplitude(void);
	inline void amplitude(float value);
	inline float phase_multiplier(void);
	inline void phase_multiplier(float value);
	inline float phase_offset(void);
	inline void phase_offset(float value);
	inline float value_offset(void);
	inline void value_offset(float value);
	inline bool use_additive(void);
	inline void use_additive(bool value);
	enum function_type_enum {
		function_type_SIN = 0,
		function_type_COS = 1,
		function_type_TAN = 2,
		function_type_SQRT = 3,
		function_type_LN = 4,
		function_type_SINC = 5,
	};
	inline function_type_enum function_type(void);
	inline void function_type(function_type_enum value);

};

/**************** Envelope F-Modifier ****************/

class FModifierEnvelope : public FModifier {
public:
	FModifierEnvelope(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg),
		control_points(ptr_arg)
		{}

	COLLECTION_PROPERTY(FModifierEnvelopeControlPoints, FModifierEnvelopeControlPoint, FModifierEnvelope, control_points, true, true, false)
	inline float reference_value(void);
	inline void reference_value(float value);
	inline float default_min(void);
	inline void default_min(float value);
	inline float default_max(void);
	inline void default_max(float value);

};

/**************** Envelope Control Point ****************/

class FModifierEnvelopeControlPoint : public Pointer {
public:
	FModifierEnvelopeControlPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float min(void);
	inline void min(float value);
	inline float max(void);
	inline void max(float value);
	inline float frame(void);
	inline void frame(float value);

};

/**************** Cycles F-Modifier ****************/

class FModifierCycles : public FModifier {
public:
	FModifierCycles(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	enum mode_before_enum {
		mode_before_NONE = 0,
		mode_before_REPEAT = 1,
		mode_before_REPEAT_OFFSET = 2,
		mode_before_MIRROR = 3,
	};
	inline mode_before_enum mode_before(void);
	inline void mode_before(mode_before_enum value);
	inline int cycles_before(void);
	inline void cycles_before(int value);
	enum mode_after_enum {
		mode_after_NONE = 0,
		mode_after_REPEAT = 1,
		mode_after_REPEAT_OFFSET = 2,
		mode_after_MIRROR = 3,
	};
	inline mode_after_enum mode_after(void);
	inline void mode_after(mode_after_enum value);
	inline int cycles_after(void);
	inline void cycles_after(int value);

};

/**************** Python F-Modifier ****************/

class FModifierPython : public FModifier {
public:
	FModifierPython(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}


};

/**************** Limit F-Modifier ****************/

class FModifierLimits : public FModifier {
public:
	FModifierLimits(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline bool use_min_x(void);
	inline void use_min_x(bool value);
	inline bool use_min_y(void);
	inline void use_min_y(bool value);
	inline bool use_max_x(void);
	inline void use_max_x(bool value);
	inline bool use_max_y(void);
	inline void use_max_y(bool value);
	inline float min_x(void);
	inline void min_x(float value);
	inline float min_y(void);
	inline void min_y(float value);
	inline float max_x(void);
	inline void max_x(float value);
	inline float max_y(void);
	inline void max_y(float value);

};

/**************** Noise F-Modifier ****************/

class FModifierNoise : public FModifier {
public:
	FModifierNoise(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_ADD = 1,
		blend_type_SUBTRACT = 2,
		blend_type_MULTIPLY = 3,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float scale(void);
	inline void scale(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float phase(void);
	inline void phase(float value);
	inline float offset(void);
	inline void offset(float value);
	inline int depth(void);
	inline void depth(int value);

};

/**************** Stepped Interpolation F-Modifier ****************/

class FModifierStepped : public FModifier {
public:
	FModifierStepped(const PointerRNA &ptr_arg) :
		FModifier(ptr_arg)
		{}

	inline float frame_step(void);
	inline void frame_step(float value);
	inline float frame_offset(void);
	inline void frame_offset(float value);
	inline bool use_frame_start(void);
	inline void use_frame_start(bool value);
	inline bool use_frame_end(void);
	inline void use_frame_end(bool value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);

};

/**************** Grease Pencil ****************/

class GreasePencil : public ID {
public:
	GreasePencil(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		layers(ptr_arg),
		materials(ptr_arg)
		{}

	COLLECTION_PROPERTY(GreasePencilLayers, GPencilLayer, GreasePencil, layers, false, true, true)
	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(IDMaterials, Material, GreasePencil, materials, true, true, true)
	enum stroke_depth_order_enum {
		stroke_depth_order_2D = 0,
		stroke_depth_order_3D = 1,
	};
	inline stroke_depth_order_enum stroke_depth_order(void);
	inline void stroke_depth_order(stroke_depth_order_enum value);
	inline bool use_stroke_edit_mode(void);
	inline void use_stroke_edit_mode(bool value);
	inline bool is_stroke_paint_mode(void);
	inline void is_stroke_paint_mode(bool value);
	inline bool is_stroke_sculpt_mode(void);
	inline void is_stroke_sculpt_mode(bool value);
	inline bool is_stroke_weight_mode(void);
	inline void is_stroke_weight_mode(bool value);
	inline bool is_stroke_vertex_mode(void);
	inline void is_stroke_vertex_mode(bool value);
	inline bool use_onion_skinning(void);
	inline void use_onion_skinning(bool value);
	enum stroke_thickness_space_enum {
		stroke_thickness_space_WORLDSPACE = 0,
		stroke_thickness_space_SCREENSPACE = 32768,
	};
	inline stroke_thickness_space_enum stroke_thickness_space(void);
	inline void stroke_thickness_space(stroke_thickness_space_enum value);
	inline float pixel_factor(void);
	inline void pixel_factor(float value);
	inline int edit_curve_resolution(void);
	inline void edit_curve_resolution(int value);
	inline bool use_adaptive_curve_resolution(void);
	inline void use_adaptive_curve_resolution(bool value);
	inline float curve_edit_threshold(void);
	inline void curve_edit_threshold(float value);
	inline float curve_edit_corner_angle(void);
	inline void curve_edit_corner_angle(float value);
	inline bool use_multiedit(void);
	inline void use_multiedit(bool value);
	inline bool use_curve_edit(void);
	inline void use_curve_edit(bool value);
	inline bool use_autolock_layers(void);
	inline void use_autolock_layers(bool value);
	inline Array<float, 4> edit_line_color(void);
	inline void edit_line_color(float values[4]);
	inline int ghost_before_range(void);
	inline void ghost_before_range(int value);
	inline int ghost_after_range(void);
	inline void ghost_after_range(int value);
	inline bool use_ghost_custom_colors(void);
	inline void use_ghost_custom_colors(bool value);
	inline Array<float, 3> before_color(void);
	inline void before_color(float values[3]);
	inline Array<float, 3> after_color(void);
	inline void after_color(float values[3]);
	inline bool use_ghosts_always(void);
	inline void use_ghosts_always(bool value);
	enum onion_mode_enum {
		onion_mode_ABSOLUTE = 0,
		onion_mode_RELATIVE = 1,
		onion_mode_SELECTED = 2,
	};
	inline onion_mode_enum onion_mode(void);
	inline void onion_mode(onion_mode_enum value);
	enum onion_keyframe_type_enum {
		onion_keyframe_type_ALL = -1,
		onion_keyframe_type_KEYFRAME = 0,
		onion_keyframe_type_BREAKDOWN = 2,
		onion_keyframe_type_MOVING_HOLD = 4,
		onion_keyframe_type_EXTREME = 1,
		onion_keyframe_type_JITTER = 3,
	};
	inline onion_keyframe_type_enum onion_keyframe_type(void);
	inline void onion_keyframe_type(onion_keyframe_type_enum value);
	inline bool use_onion_fade(void);
	inline void use_onion_fade(bool value);
	inline bool use_onion_loop(void);
	inline void use_onion_loop(bool value);
	inline float onion_factor(void);
	inline void onion_factor(float value);
	inline float zdepth_offset(void);
	inline void zdepth_offset(float value);
	inline bool is_annotation(void);
	inline void is_annotation(bool value);
	inline GreasePencilGrid grid(void);

	inline void clear();
};

/**************** Grid and Canvas Settings ****************/

class GreasePencilGrid : public Pointer {
public:
	GreasePencilGrid(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> scale(void);
	inline void scale(float values[2]);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline int lines(void);
	inline void lines(int value);
	inline Array<float, 2> offset(void);
	inline void offset(float values[2]);

};

/**************** Grease Pencil Layer ****************/

class GPencilLayer : public Pointer {
public:
	GPencilLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		frames(ptr_arg),
		mask_layers(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string info(void);
	inline void info(const std::string& value);
	COLLECTION_PROPERTY(GPencilFrames, GPencilFrame, GPencilLayer, frames, false, true, false)
	COLLECTION_PROPERTY(GreasePencilMaskLayers, GPencilLayerMask, GPencilLayer, mask_layers, false, true, true)
	inline GPencilFrame active_frame(void);
	inline float opacity(void);
	inline void opacity(float value);
	inline Array<float, 3> channel_color(void);
	inline void channel_color(float values[3]);
	inline float annotation_opacity(void);
	inline void annotation_opacity(float value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline int thickness(void);
	inline void thickness(int value);
	inline Array<float, 3> tint_color(void);
	inline void tint_color(float values[3]);
	inline float tint_factor(void);
	inline void tint_factor(float value);
	inline float vertex_paint_opacity(void);
	inline void vertex_paint_opacity(float value);
	inline int line_change(void);
	inline void line_change(int value);
	inline bool use_onion_skinning(void);
	inline void use_onion_skinning(bool value);
	inline bool use_annotation_onion_skinning(void);
	inline void use_annotation_onion_skinning(bool value);
	inline int annotation_onion_before_range(void);
	inline void annotation_onion_before_range(int value);
	inline int annotation_onion_after_range(void);
	inline void annotation_onion_after_range(int value);
	inline Array<float, 3> annotation_onion_before_color(void);
	inline void annotation_onion_before_color(float values[3]);
	inline Array<float, 3> annotation_onion_after_color(void);
	inline void annotation_onion_after_color(float values[3]);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline std::string viewlayer_render(void);
	inline void viewlayer_render(const std::string& value);
	inline bool use_viewlayer_masks(void);
	inline void use_viewlayer_masks(bool value);
	enum blend_mode_enum {
		blend_mode_REGULAR = 0,
		blend_mode_HARDLIGHT = 1,
		blend_mode_ADD = 2,
		blend_mode_SUBTRACT = 3,
		blend_mode_MULTIPLY = 4,
		blend_mode_DIVIDE = 5,
	};
	inline blend_mode_enum blend_mode(void);
	inline void blend_mode(blend_mode_enum value);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> rotation(void);
	inline void rotation(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 16> matrix_layer(void);
	inline void matrix_layer(float values[16]);
	inline Array<float, 16> matrix_inverse_layer(void);
	inline void matrix_inverse_layer(float values[16]);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool annotation_hide(void);
	inline void annotation_hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool lock_frame(void);
	inline void lock_frame(bool value);
	inline bool lock_material(void);
	inline void lock_material(bool value);
	inline bool use_mask_layer(void);
	inline void use_mask_layer(bool value);
	inline bool use_lights(void);
	inline void use_lights(bool value);
	inline bool use_solo_mode(void);
	inline void use_solo_mode(bool value);
	inline bool is_ruler(void);
	inline void is_ruler(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool show_points(void);
	inline void show_points(bool value);
	inline bool show_in_front(void);
	inline void show_in_front(bool value);
	inline Object parent(void);
	enum parent_type_enum {
		parent_type_OBJECT = 0,
		parent_type_ARMATURE = 4,
		parent_type_BONE = 7,
	};
	inline parent_type_enum parent_type(void);
	inline void parent_type(parent_type_enum value);
	inline std::string parent_bone(void);
	inline void parent_bone(const std::string& value);
	inline Array<float, 16> matrix_inverse(void);
	inline void matrix_inverse(float values[16]);
	inline bool is_parented(void);
	inline void is_parented(bool value);

	inline void clear();
};

/**************** Grease Pencil Masking Layers ****************/

class GPencilLayerMask : public Pointer {
public:
	GPencilLayerMask(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool invert(void);
	inline void invert(bool value);

};

/**************** Grease Pencil Frame ****************/

class GPencilFrame : public Pointer {
public:
	GPencilFrame(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		strokes(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(GPencilStrokes, GPencilStroke, GPencilFrame, strokes, false, true, false)
	inline int frame_number(void);
	inline void frame_number(int value);
	enum keyframe_type_enum {
		keyframe_type_KEYFRAME = 0,
		keyframe_type_BREAKDOWN = 2,
		keyframe_type_MOVING_HOLD = 4,
		keyframe_type_EXTREME = 1,
		keyframe_type_JITTER = 3,
	};
	inline keyframe_type_enum keyframe_type(void);
	inline void keyframe_type(keyframe_type_enum value);
	inline bool is_edited(void);
	inline void is_edited(bool value);
	inline bool select(void);
	inline void select(bool value);

	inline void clear();
};

/**************** Grease Pencil Stroke ****************/

class GPencilStroke : public Pointer {
public:
	GPencilStroke(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg),
		triangles(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(GPencilStrokePoints, GPencilStrokePoint, GPencilStroke, points, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, GPencilTriangle, GPencilStroke, triangles, true, true, false)
	inline GPencilEditCurve edit_curve(void);
	inline int material_index(void);
	inline void material_index(int value);
	enum display_mode_enum {
		display_mode_SCREEN = 0,
		display_mode_3DSPACE = 1,
		display_mode_2DSPACE = 2,
		display_mode_2DIMAGE = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	inline bool select(void);
	inline void select(bool value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool has_edit_curve(void);
	inline void has_edit_curve(bool value);
	enum start_cap_mode_enum {
		start_cap_mode_ROUND = 0,
		start_cap_mode_FLAT = 1,
	};
	inline start_cap_mode_enum start_cap_mode(void);
	inline void start_cap_mode(start_cap_mode_enum value);
	enum end_cap_mode_enum {
		end_cap_mode_ROUND = 0,
		end_cap_mode_FLAT = 1,
	};
	inline end_cap_mode_enum end_cap_mode(void);
	inline void end_cap_mode(end_cap_mode_enum value);
	inline bool is_nofill_stroke(void);
	inline void is_nofill_stroke(bool value);
	inline int line_width(void);
	inline void line_width(int value);
	inline float hardness(void);
	inline void hardness(float value);
	inline Array<float, 3> bound_box_min(void);
	inline void bound_box_min(float values[3]);
	inline Array<float, 3> bound_box_max(void);
	inline void bound_box_max(float values[3]);
	inline Array<float, 2> aspect(void);
	inline void aspect(float values[2]);
	inline Array<float, 2> uv_translation(void);
	inline void uv_translation(float values[2]);
	inline float uv_rotation(void);
	inline void uv_rotation(float value);
	inline float uv_scale(void);
	inline void uv_scale(float value);
	inline Array<float, 4> vertex_color_fill(void);
	inline void vertex_color_fill(float values[4]);
	inline int select_index(void);
	inline void select_index(int value);
	inline float time_start(void);
	inline void time_start(float value);

};

/**************** Grease Pencil Stroke Point ****************/

class GPencilStrokePoint : public Pointer {
public:
	GPencilStrokePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline float pressure(void);
	inline void pressure(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float uv_factor(void);
	inline void uv_factor(float value);
	inline float uv_rotation(void);
	inline void uv_rotation(float value);
	inline Array<float, 2> uv_fill(void);
	inline void uv_fill(float values[2]);
	inline bool select(void);
	inline void select(bool value);
	inline float time(void);
	inline void time(float value);
	inline Array<float, 4> vertex_color(void);
	inline void vertex_color(float values[4]);

};

/**************** Triangle ****************/

class GPencilTriangle : public Pointer {
public:
	GPencilTriangle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int v1(void);
	inline void v1(int value);
	inline int v2(void);
	inline void v2(int value);
	inline int v3(void);
	inline void v3(int value);

};

/**************** Edit Curve ****************/

class GPencilEditCurve : public Pointer {
public:
	GPencilEditCurve(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		curve_points(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, GPencilEditCurvePoint, GPencilEditCurve, curve_points, true, true, false)
	inline bool select(void);
	inline void select(bool value);

};

/**************** Bezier Curve Point ****************/

class GPencilEditCurvePoint : public Pointer {
public:
	GPencilEditCurvePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select_left_handle(void);
	inline void select_left_handle(bool value);
	inline bool select_right_handle(void);
	inline void select_right_handle(bool value);
	inline bool select_control_point(void);
	inline void select_control_point(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline Array<float, 3> handle_left(void);
	inline void handle_left(float values[3]);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> handle_right(void);
	inline void handle_right(float values[3]);
	inline float pressure(void);
	inline void pressure(float value);
	inline float strength(void);
	inline void strength(float value);
	inline int point_index(void);
	inline void point_index(int value);
	inline float uv_factor(void);
	inline void uv_factor(float value);
	inline float uv_rotation(void);
	inline void uv_rotation(float value);
	inline Array<float, 4> vertex_color(void);
	inline void vertex_color(float values[4]);

};

/**************** Vertex Group Element ****************/

class GpencilVertexGroupElement : public Pointer {
public:
	GpencilVertexGroupElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int group(void);
	inline void group(int value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Grease Pencil ****************/

class GreasePencilv3 : public ID {
public:
	GreasePencilv3(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		attributes(ptr_arg),
		color_attributes(ptr_arg),
		layers(ptr_arg),
		layer_groups(ptr_arg)
		{}

	COLLECTION_PROPERTY(AttributeGroup, Attribute, GreasePencilv3, attributes, true, false, false)
	COLLECTION_PROPERTY(AttributeGroup, Attribute, GreasePencilv3, color_attributes, true, false, false)
	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(GreasePencilv3Layers, GreasePencilLayer, GreasePencilv3, layers, true, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, GreasePencilLayerGroup, GreasePencilv3, layer_groups, true, false, false)

};

/**************** Grease Pencil Layer ****************/

class GreasePencilLayer : public Pointer {
public:
	GreasePencilLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline float opacity(void);
	inline void opacity(float value);
	inline bool use_onion_skinning(void);
	inline void use_onion_skinning(bool value);

};

/**************** Grease Pencil Layer Group ****************/

class GreasePencilLayerGroup : public Pointer {
public:
	GreasePencilLayerGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);

};

/**************** Curve Point ****************/

class CurvePoint : public Pointer {
public:
	CurvePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> position(void);
	inline void position(float values[3]);
	inline float radius(void);
	inline void radius(float value);
	inline int index(void);
	inline void index(int value);

};

/**************** Curve Slice ****************/

class CurveSlice : public Pointer {
public:
	CurveSlice(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CurvePoint, CurveSlice, points, true, false, false)
	inline int first_point_index(void);
	inline void first_point_index(int value);
	inline int points_length(void);
	inline void points_length(int value);
	inline int index(void);
	inline void index(int value);

};

/**************** Hair Curves ****************/

class Curves : public ID {
public:
	Curves(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		curves(ptr_arg),
		points(ptr_arg),
		position_data(ptr_arg),
		curve_offset_data(ptr_arg),
		normals(ptr_arg),
		materials(ptr_arg),
		attributes(ptr_arg),
		color_attributes(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, CurveSlice, Curves, curves, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CurvePoint, Curves, points, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FloatVectorAttributeValue, Curves, position_data, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, IntAttributeValue, Curves, curve_offset_data, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FloatVectorValueReadOnly, Curves, normals, true, false, false)
	COLLECTION_PROPERTY(IDMaterials, Material, Curves, materials, true, true, true)
	inline Object surface(void);
	inline std::string surface_uv_map(void);
	inline void surface_uv_map(const std::string& value);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool use_mirror_y(void);
	inline void use_mirror_y(bool value);
	inline bool use_mirror_z(void);
	inline void use_mirror_z(bool value);
	enum selection_domain_enum {
		selection_domain_POINT = 0,
		selection_domain_CURVE = 4,
	};
	inline selection_domain_enum selection_domain(void);
	inline void selection_domain(selection_domain_enum value);
	inline bool use_sculpt_collision(void);
	inline void use_sculpt_collision(bool value);
	COLLECTION_PROPERTY(AttributeGroup, Attribute, Curves, attributes, true, false, false)
	COLLECTION_PROPERTY(AttributeGroup, Attribute, Curves, color_attributes, true, false, false)
	inline AnimData animation_data(void);

	inline void add_curves(int sizes_len, int *sizes);
};

/**************** Read-Only Vector ****************/

class FloatVectorValueReadOnly : public Pointer {
public:
	FloatVectorValueReadOnly(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> vector(void);
	inline void vector(float values[3]);

};

/**************** Render Slot ****************/

class RenderSlot : public Pointer {
public:
	RenderSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

	inline void clear(ImageUser& iuser);
};

/**************** UDIM Tile ****************/

class UDIMTile : public Pointer {
public:
	UDIMTile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string label(void);
	inline void label(const std::string& value);
	inline int number(void);
	inline void number(int value);
	inline Array<int, 2> size(void);
	inline void size(int values[2]);
	inline int channels(void);
	inline void channels(int value);
	enum generated_type_enum {
		generated_type_BLANK = 0,
		generated_type_UV_GRID = 1,
		generated_type_COLOR_GRID = 2,
	};
	inline generated_type_enum generated_type(void);
	inline void generated_type(generated_type_enum value);
	inline int generated_width(void);
	inline void generated_width(int value);
	inline int generated_height(void);
	inline void generated_height(int value);
	inline bool use_generated_float(void);
	inline void use_generated_float(bool value);
	inline Array<float, 4> generated_color(void);
	inline void generated_color(float values[4]);

};

/**************** Image ****************/

class Image : public ID {
public:
	Image(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		packed_files(ptr_arg),
		render_slots(ptr_arg),
		tiles(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string filepath_raw(void);
	inline void filepath_raw(const std::string& value);
	enum file_format_enum {
		file_format_BMP = 20,
		file_format_IRIS = 1,
		file_format_PNG = 17,
		file_format_JPEG = 4,
		file_format_JPEG2000 = 30,
		file_format_TARGA = 0,
		file_format_TARGA_RAW = 14,
		file_format_CINEON = 26,
		file_format_DPX = 27,
		file_format_OPEN_EXR_MULTILAYER = 28,
		file_format_OPEN_EXR = 23,
		file_format_HDR = 21,
		file_format_TIFF = 22,
		file_format_WEBP = 35,
		file_format_AVI_JPEG = 16,
		file_format_AVI_RAW = 15,
		file_format_FFMPEG = 24,
	};
	inline file_format_enum file_format(void);
	inline void file_format(file_format_enum value);
	enum source_enum {
		source_FILE = 1,
		source_SEQUENCE = 2,
		source_MOVIE = 3,
		source_GENERATED = 4,
		source_VIEWER = 5,
		source_TILED = 6,
	};
	inline source_enum source(void);
	inline void source(source_enum value);
	enum type_enum {
		type_IMAGE = 0,
		type_MULTILAYER = 1,
		type_UV_TEST = 2,
		type_RENDER_RESULT = 4,
		type_COMPOSITING = 5,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline PackedFile packed_file(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ImagePackedFile, Image, packed_files, false, true, true)
	inline bool use_view_as_render(void);
	inline void use_view_as_render(bool value);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	inline bool is_stereo_3d(void);
	inline void is_stereo_3d(bool value);
	inline bool is_multiview(void);
	inline void is_multiview(bool value);
	inline bool is_dirty(void);
	inline void is_dirty(bool value);
	enum generated_type_enum {
		generated_type_BLANK = 0,
		generated_type_UV_GRID = 1,
		generated_type_COLOR_GRID = 2,
	};
	inline generated_type_enum generated_type(void);
	inline void generated_type(generated_type_enum value);
	inline int generated_width(void);
	inline void generated_width(int value);
	inline int generated_height(void);
	inline void generated_height(int value);
	inline bool use_generated_float(void);
	inline void use_generated_float(bool value);
	inline Array<float, 4> generated_color(void);
	inline void generated_color(float values[4]);
	inline Array<float, 2> display_aspect(void);
	inline void display_aspect(float values[2]);
	inline int bindcode(void);
	inline void bindcode(int value);
	COLLECTION_PROPERTY(RenderSlots, RenderSlot, Image, render_slots, false, true, false)
	COLLECTION_PROPERTY(UDIMTiles, UDIMTile, Image, tiles, false, true, false)
	inline bool has_data(void);
	inline void has_data(bool value);
	inline int depth(void);
	inline void depth(int value);
	inline Array<int, 2> size(void);
	inline void size(int values[2]);
	inline Array<float, 2> resolution(void);
	inline void resolution(float values[2]);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline DynamicArray<float> pixels(void);
	inline void pixels(float values[]);
	inline int channels(void);
	inline void channels(int value);
	inline bool is_float(void);
	inline void is_float(bool value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
		alpha_mode_CHANNEL_PACKED = 2,
		alpha_mode_NONE = 3,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_half_precision(void);
	inline void use_half_precision(bool value);
	inline int seam_margin(void);
	inline void seam_margin(int value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);

	inline void save_render(Context C, const char * filepath, Scene& scene, int quality);
	inline void save(void *main, Context C, const char * filepath, int quality);
	inline void pack(void *main, Context C, const char * data, int data_len);
	inline void unpack(void *main, int method);
	inline void reload(void *main);
	inline void update();
	inline void scale(int width, int height);
	inline int gl_touch(int frame, int layer_index, int pass_index);
	inline int gl_load(int frame, int layer_index, int pass_index);
	inline void gl_free();
	inline void filepath_from_user(ImageUser& image_user, char * filepath);
	inline void buffers_free();
};

/**************** Image User ****************/

class ImageUser : public Pointer {
public:
	ImageUser(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_auto_refresh(void);
	inline void use_auto_refresh(bool value);
	inline int frame_current(void);
	inline void frame_current(int value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int multilayer_layer(void);
	inline void multilayer_layer(int value);
	inline int multilayer_pass(void);
	inline void multilayer_pass(int value);
	inline int multilayer_view(void);
	inline void multilayer_view(int value);
	inline int tile(void);
	inline void tile(int value);

};

/**************** ImagePackedFile ****************/

class ImagePackedFile : public Pointer {
public:
	ImagePackedFile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline PackedFile packed_file(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline int view(void);
	inline void view(int value);
	inline int tile_number(void);
	inline void tile_number(int value);

	inline void save(void *main);
};

/**************** Key ****************/

class Key : public ID {
public:
	Key(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		key_blocks(ptr_arg)
		{}

	inline ShapeKey reference_key(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ShapeKey, Key, key_blocks, false, true, true)
	inline AnimData animation_data(void);
	inline ID user(void);
	inline bool use_relative(void);
	inline void use_relative(bool value);
	inline float eval_time(void);
	inline void eval_time(float value);

};

/**************** Shape Key ****************/

class ShapeKey : public Pointer {
public:
	ShapeKey(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline float frame(void);
	inline void frame(float value);
	inline float value(void);
	inline void value(float value);
	enum interpolation_enum {
		interpolation_KEY_LINEAR = 0,
		interpolation_KEY_CARDINAL = 1,
		interpolation_KEY_CATMULL_ROM = 3,
		interpolation_KEY_BSPLINE = 2,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline ShapeKey relative_key(void);
	inline bool mute(void);
	inline void mute(bool value);
	inline float slider_min(void);
	inline void slider_min(float value);
	inline float slider_max(void);
	inline void slider_max(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UnknownType, ShapeKey, data, true, true, false)

	inline void normals_vertex_get(int *normals_len, float **normals);
	inline void normals_polygon_get(int *normals_len, float **normals);
	inline void normals_split_get(int *normals_len, float **normals);
};

/**************** Shape Key Point ****************/

class ShapeKeyPoint : public Pointer {
public:
	ShapeKeyPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);

};

/**************** Shape Key Curve Point ****************/

class ShapeKeyCurvePoint : public Pointer {
public:
	ShapeKeyCurvePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline float tilt(void);
	inline void tilt(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Shape Key Bezier Point ****************/

class ShapeKeyBezierPoint : public Pointer {
public:
	ShapeKeyBezierPoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> handle_left(void);
	inline void handle_left(float values[3]);
	inline Array<float, 3> handle_right(void);
	inline void handle_right(float values[3]);
	inline float tilt(void);
	inline void tilt(float value);
	inline float radius(void);
	inline void radius(float value);

};

/**************** Light ****************/

class Light : public ID {
public:
	Light(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum type_enum {
		type_POINT = 0,
		type_SUN = 1,
		type_SPOT = 2,
		type_AREA = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float specular_factor(void);
	inline void specular_factor(float value);
	inline float diffuse_factor(void);
	inline void diffuse_factor(float value);
	inline float volume_factor(void);
	inline void volume_factor(float value);
	inline bool use_custom_distance(void);
	inline void use_custom_distance(bool value);
	inline float cutoff_distance(void);
	inline void cutoff_distance(float value);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline AnimData animation_data(void);

};

/**************** Point Light ****************/

class PointLight : public Light {
public:
	PointLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);
	inline float shadow_softness_factor(void);
	inline void shadow_softness_factor(float value);

};

/**************** Area Light ****************/

class AreaLight : public Light {
public:
	AreaLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);
	inline float shadow_softness_factor(void);
	inline void shadow_softness_factor(float value);
	enum shape_enum {
		shape_SQUARE = 0,
		shape_RECTANGLE = 1,
		shape_DISK = 4,
		shape_ELLIPSE = 5,
	};
	inline shape_enum shape(void);
	inline void shape(shape_enum value);
	inline float size(void);
	inline void size(float value);
	inline float size_y(void);
	inline void size_y(float value);
	inline float spread(void);
	inline void spread(float value);

};

/**************** Spot Light ****************/

class SpotLight : public Light {
public:
	SpotLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float energy(void);
	inline void energy(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);
	inline float shadow_softness_factor(void);
	inline void shadow_softness_factor(float value);
	inline bool use_square(void);
	inline void use_square(bool value);
	inline float spot_blend(void);
	inline void spot_blend(float value);
	inline float spot_size(void);
	inline void spot_size(float value);
	inline bool show_cone(void);
	inline void show_cone(bool value);

};

/**************** Sun Light ****************/

class SunLight : public Light {
public:
	SunLight(const PointerRNA &ptr_arg) :
		Light(ptr_arg)
		{}

	inline float angle(void);
	inline void angle(float value);
	inline float energy(void);
	inline void energy(float value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline float shadow_buffer_clip_start(void);
	inline void shadow_buffer_clip_start(float value);
	inline float shadow_buffer_bias(void);
	inline void shadow_buffer_bias(float value);
	inline Array<float, 3> shadow_color(void);
	inline void shadow_color(float values[3]);
	inline float shadow_soft_size(void);
	inline void shadow_soft_size(float value);
	inline bool use_contact_shadow(void);
	inline void use_contact_shadow(bool value);
	inline float contact_shadow_distance(void);
	inline void contact_shadow_distance(float value);
	inline float contact_shadow_bias(void);
	inline void contact_shadow_bias(float value);
	inline float contact_shadow_thickness(void);
	inline void contact_shadow_thickness(float value);
	inline float shadow_softness_factor(void);
	inline void shadow_softness_factor(float value);
	inline float shadow_cascade_max_distance(void);
	inline void shadow_cascade_max_distance(float value);
	inline int shadow_cascade_count(void);
	inline void shadow_cascade_count(int value);
	inline float shadow_cascade_exponent(void);
	inline void shadow_cascade_exponent(float value);
	inline float shadow_cascade_fade(void);
	inline void shadow_cascade_fade(float value);
	inline float shadow_trace_distance(void);
	inline void shadow_trace_distance(float value);

};

/**************** Lattice ****************/

class Lattice : public ID {
public:
	Lattice(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		points(ptr_arg)
		{}

	inline int points_u(void);
	inline void points_u(int value);
	inline int points_v(void);
	inline void points_v(int value);
	inline int points_w(void);
	inline void points_w(int value);
	enum interpolation_type_u_enum {
		interpolation_type_u_KEY_LINEAR = 0,
		interpolation_type_u_KEY_CARDINAL = 1,
		interpolation_type_u_KEY_CATMULL_ROM = 3,
		interpolation_type_u_KEY_BSPLINE = 2,
	};
	inline interpolation_type_u_enum interpolation_type_u(void);
	inline void interpolation_type_u(interpolation_type_u_enum value);
	enum interpolation_type_v_enum {
		interpolation_type_v_KEY_LINEAR = 0,
		interpolation_type_v_KEY_CARDINAL = 1,
		interpolation_type_v_KEY_CATMULL_ROM = 3,
		interpolation_type_v_KEY_BSPLINE = 2,
	};
	inline interpolation_type_v_enum interpolation_type_v(void);
	inline void interpolation_type_v(interpolation_type_v_enum value);
	enum interpolation_type_w_enum {
		interpolation_type_w_KEY_LINEAR = 0,
		interpolation_type_w_KEY_CARDINAL = 1,
		interpolation_type_w_KEY_CATMULL_ROM = 3,
		interpolation_type_w_KEY_BSPLINE = 2,
	};
	inline interpolation_type_w_enum interpolation_type_w(void);
	inline void interpolation_type_w(interpolation_type_w_enum value);
	inline bool use_outside(void);
	inline void use_outside(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline Key shape_keys(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, LatticePoint, Lattice, points, false, false, false)
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);

	inline void transform(float matrix[16], bool shape_keys);
	inline void update_gpu_tag();
};

/**************** LatticePoint ****************/

class LatticePoint : public Pointer {
public:
	LatticePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		groups(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool select(void);
	inline void select(bool value);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> co_deform(void);
	inline void co_deform(float values[3]);
	inline float weight_softbody(void);
	inline void weight_softbody(float value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, VertexGroupElement, LatticePoint, groups, false, false, false)

};

/**************** View Layer ****************/

class ViewLayer : public Pointer {
public:
	ViewLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		aovs(ptr_arg),
		lightgroups(ptr_arg),
		objects(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Material material_override(void);
	inline int samples(void);
	inline void samples(int value);
	inline float pass_alpha_threshold(void);
	inline void pass_alpha_threshold(float value);
	inline ViewLayerEEVEE eevee(void);
	COLLECTION_PROPERTY(AOVs, AOV, ViewLayer, aovs, false, true, true)
	inline AOV active_aov(void);
	inline int active_aov_index(void);
	inline void active_aov_index(int value);
	COLLECTION_PROPERTY(Lightgroups, Lightgroup, ViewLayer, lightgroups, false, true, true)
	inline Lightgroup active_lightgroup(void);
	inline int active_lightgroup_index(void);
	inline void active_lightgroup_index(int value);
	inline bool use_pass_cryptomatte_object(void);
	inline void use_pass_cryptomatte_object(bool value);
	inline bool use_pass_cryptomatte_material(void);
	inline void use_pass_cryptomatte_material(bool value);
	inline bool use_pass_cryptomatte_asset(void);
	inline void use_pass_cryptomatte_asset(bool value);
	inline int pass_cryptomatte_depth(void);
	inline void pass_cryptomatte_depth(int value);
	inline bool use_pass_cryptomatte_accurate(void);
	inline void use_pass_cryptomatte_accurate(bool value);
	inline bool use_solid(void);
	inline void use_solid(bool value);
	inline bool use_sky(void);
	inline void use_sky(bool value);
	inline bool use_ao(void);
	inline void use_ao(bool value);
	inline bool use_strand(void);
	inline void use_strand(bool value);
	inline bool use_volumes(void);
	inline void use_volumes(bool value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline bool use_pass_combined(void);
	inline void use_pass_combined(bool value);
	inline bool use_pass_z(void);
	inline void use_pass_z(bool value);
	inline bool use_pass_vector(void);
	inline void use_pass_vector(bool value);
	inline bool use_pass_position(void);
	inline void use_pass_position(bool value);
	inline bool use_pass_normal(void);
	inline void use_pass_normal(bool value);
	inline bool use_pass_uv(void);
	inline void use_pass_uv(bool value);
	inline bool use_pass_mist(void);
	inline void use_pass_mist(bool value);
	inline bool use_pass_object_index(void);
	inline void use_pass_object_index(bool value);
	inline bool use_pass_material_index(void);
	inline void use_pass_material_index(bool value);
	inline bool use_pass_shadow(void);
	inline void use_pass_shadow(bool value);
	inline bool use_pass_ambient_occlusion(void);
	inline void use_pass_ambient_occlusion(bool value);
	inline bool use_pass_emit(void);
	inline void use_pass_emit(bool value);
	inline bool use_pass_environment(void);
	inline void use_pass_environment(bool value);
	inline bool use_pass_diffuse_direct(void);
	inline void use_pass_diffuse_direct(bool value);
	inline bool use_pass_diffuse_indirect(void);
	inline void use_pass_diffuse_indirect(bool value);
	inline bool use_pass_diffuse_color(void);
	inline void use_pass_diffuse_color(bool value);
	inline bool use_pass_glossy_direct(void);
	inline void use_pass_glossy_direct(bool value);
	inline bool use_pass_glossy_indirect(void);
	inline void use_pass_glossy_indirect(bool value);
	inline bool use_pass_glossy_color(void);
	inline void use_pass_glossy_color(bool value);
	inline bool use_pass_transmission_direct(void);
	inline void use_pass_transmission_direct(bool value);
	inline bool use_pass_transmission_indirect(void);
	inline void use_pass_transmission_indirect(bool value);
	inline bool use_pass_transmission_color(void);
	inline void use_pass_transmission_color(bool value);
	inline bool use_pass_subsurface_direct(void);
	inline void use_pass_subsurface_direct(bool value);
	inline bool use_pass_subsurface_indirect(void);
	inline void use_pass_subsurface_indirect(bool value);
	inline bool use_pass_subsurface_color(void);
	inline void use_pass_subsurface_color(bool value);
	inline LayerCollection layer_collection(void);
	inline LayerCollection active_layer_collection(void);
	COLLECTION_PROPERTY(LayerObjects, Object, ViewLayer, objects, false, true, true)
	inline bool use(void);
	inline void use(bool value);
	inline bool use_freestyle(void);
	inline void use_freestyle(bool value);
	inline FreestyleSettings freestyle_settings(void);
	inline Depsgraph depsgraph(void);

	inline void update_render_passes();
	inline void update(void *main);
};

/**************** Freestyle Line Set ****************/

class FreestyleLineSet : public Pointer {
public:
	FreestyleLineSet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline FreestyleLineStyle linestyle(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool select_by_visibility(void);
	inline void select_by_visibility(bool value);
	inline bool select_by_edge_types(void);
	inline void select_by_edge_types(bool value);
	inline bool select_by_collection(void);
	inline void select_by_collection(bool value);
	inline bool select_by_image_border(void);
	inline void select_by_image_border(bool value);
	inline bool select_by_face_marks(void);
	inline void select_by_face_marks(bool value);
	enum edge_type_negation_enum {
		edge_type_negation_INCLUSIVE = 0,
		edge_type_negation_EXCLUSIVE = 4,
	};
	inline edge_type_negation_enum edge_type_negation(void);
	inline void edge_type_negation(edge_type_negation_enum value);
	enum edge_type_combination_enum {
		edge_type_combination_OR = 0,
		edge_type_combination_AND = 8,
	};
	inline edge_type_combination_enum edge_type_combination(void);
	inline void edge_type_combination(edge_type_combination_enum value);
	inline Collection collection(void);
	enum collection_negation_enum {
		collection_negation_INCLUSIVE = 0,
		collection_negation_EXCLUSIVE = 16,
	};
	inline collection_negation_enum collection_negation(void);
	inline void collection_negation(collection_negation_enum value);
	enum face_mark_negation_enum {
		face_mark_negation_INCLUSIVE = 0,
		face_mark_negation_EXCLUSIVE = 32,
	};
	inline face_mark_negation_enum face_mark_negation(void);
	inline void face_mark_negation(face_mark_negation_enum value);
	enum face_mark_condition_enum {
		face_mark_condition_ONE = 0,
		face_mark_condition_BOTH = 64,
	};
	inline face_mark_condition_enum face_mark_condition(void);
	inline void face_mark_condition(face_mark_condition_enum value);
	inline bool select_silhouette(void);
	inline void select_silhouette(bool value);
	inline bool select_border(void);
	inline void select_border(bool value);
	inline bool select_crease(void);
	inline void select_crease(bool value);
	inline bool select_ridge_valley(void);
	inline void select_ridge_valley(bool value);
	inline bool select_suggestive_contour(void);
	inline void select_suggestive_contour(bool value);
	inline bool select_material_boundary(void);
	inline void select_material_boundary(bool value);
	inline bool select_contour(void);
	inline void select_contour(bool value);
	inline bool select_external_contour(void);
	inline void select_external_contour(bool value);
	inline bool select_edge_mark(void);
	inline void select_edge_mark(bool value);
	inline bool exclude_silhouette(void);
	inline void exclude_silhouette(bool value);
	inline bool exclude_border(void);
	inline void exclude_border(bool value);
	inline bool exclude_crease(void);
	inline void exclude_crease(bool value);
	inline bool exclude_ridge_valley(void);
	inline void exclude_ridge_valley(bool value);
	inline bool exclude_suggestive_contour(void);
	inline void exclude_suggestive_contour(bool value);
	inline bool exclude_material_boundary(void);
	inline void exclude_material_boundary(bool value);
	inline bool exclude_contour(void);
	inline void exclude_contour(bool value);
	inline bool exclude_external_contour(void);
	inline void exclude_external_contour(bool value);
	inline bool exclude_edge_mark(void);
	inline void exclude_edge_mark(bool value);
	enum visibility_enum {
		visibility_VISIBLE = 1,
		visibility_HIDDEN = 2,
		visibility_RANGE = 3,
	};
	inline visibility_enum visibility(void);
	inline void visibility(visibility_enum value);
	inline int qi_start(void);
	inline void qi_start(int value);
	inline int qi_end(void);
	inline void qi_end(int value);

};

/**************** Freestyle Module ****************/

class FreestyleModuleSettings : public Pointer {
public:
	FreestyleModuleSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Text script(void);
	inline bool use(void);
	inline void use(bool value);

};

/**************** Freestyle Settings ****************/

class FreestyleSettings : public Pointer {
public:
	FreestyleSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		modules(ptr_arg),
		linesets(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(FreestyleModules, FreestyleModuleSettings, FreestyleSettings, modules, false, true, false)
	enum mode_enum {
		mode_SCRIPT = 1,
		mode_EDITOR = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool use_culling(void);
	inline void use_culling(bool value);
	inline bool use_suggestive_contours(void);
	inline void use_suggestive_contours(bool value);
	inline bool use_ridges_and_valleys(void);
	inline void use_ridges_and_valleys(bool value);
	inline bool use_material_boundaries(void);
	inline void use_material_boundaries(bool value);
	inline bool use_smoothness(void);
	inline void use_smoothness(bool value);
	inline bool use_view_map_cache(void);
	inline void use_view_map_cache(bool value);
	inline bool as_render_pass(void);
	inline void as_render_pass(bool value);
	inline float sphere_radius(void);
	inline void sphere_radius(float value);
	inline float kr_derivative_epsilon(void);
	inline void kr_derivative_epsilon(float value);
	inline float crease_angle(void);
	inline void crease_angle(float value);
	COLLECTION_PROPERTY(Linesets, FreestyleLineSet, FreestyleSettings, linesets, false, true, true)

};

/**************** Layer Collection ****************/

class LayerCollection : public Pointer {
public:
	LayerCollection(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		children(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Collection collection(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, LayerCollection, LayerCollection, children, false, true, true)
	inline bool exclude(void);
	inline void exclude(bool value);
	inline bool holdout(void);
	inline void holdout(bool value);
	inline bool indirect_only(void);
	inline void indirect_only(bool value);
	inline bool hide_viewport(void);
	inline void hide_viewport(bool value);
	inline bool is_visible(void);
	inline void is_visible(bool value);

	inline bool visible_get(Context C);
	inline bool has_objects();
	inline bool has_selected_objects(void *main, ViewLayer& view_layer);
};

/**************** Object Base ****************/

class ObjectBase : public Pointer {
public:
	ObjectBase(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object object(void);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide_viewport(void);
	inline void hide_viewport(bool value);

};

/**************** Line Style Modifier ****************/

class LineStyleModifier : public Pointer {
public:
	LineStyleModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Line Style Color Modifier ****************/

class LineStyleColorModifier : public LineStyleModifier {
public:
	LineStyleColorModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}

	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Along Stroke ****************/

class LineStyleColorModifier_AlongStroke : public LineStyleColorModifier {
public:
	LineStyleColorModifier_AlongStroke(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);

};

/**************** Distance from Camera ****************/

class LineStyleColorModifier_DistanceFromCamera : public LineStyleColorModifier {
public:
	LineStyleColorModifier_DistanceFromCamera(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);

};

/**************** Distance from Object ****************/

class LineStyleColorModifier_DistanceFromObject : public LineStyleColorModifier {
public:
	LineStyleColorModifier_DistanceFromObject(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline Object target(void);

};

/**************** Material ****************/

class LineStyleColorModifier_Material : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Material(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};
	inline material_attribute_enum material_attribute(void);
	inline void material_attribute(material_attribute_enum value);
	inline ColorRamp color_ramp(void);
	inline bool use_ramp(void);
	inline void use_ramp(bool value);

};

/**************** Tangent ****************/

class LineStyleColorModifier_Tangent : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Tangent(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);

};

/**************** Noise ****************/

class LineStyleColorModifier_Noise : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Noise(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Crease Angle ****************/

class LineStyleColorModifier_CreaseAngle : public LineStyleColorModifier {
public:
	LineStyleColorModifier_CreaseAngle(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline float angle_max(void);
	inline void angle_max(float value);

};

/**************** Curvature 3D ****************/

class LineStyleColorModifier_Curvature_3D : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Curvature_3D(const PointerRNA &ptr_arg) :
		LineStyleColorModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_DARKEN = 7,
		blend_MULTIPLY = 2,
		blend_BURN = 11,
		blend_LIGHTEN = 8,
		blend_SCREEN = 4,
		blend_DODGE = 10,
		blend_ADD = 1,
		blend_OVERLAY = 9,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
		blend_DIFFERENCE = 6,
		blend_EXCLUSION = 18,
		blend_SUBTRACT = 3,
		blend_DIVIDE = 5,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_COLOR = 15,
		blend_VALUE = 14,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline ColorRamp color_ramp(void);
	inline float curvature_min(void);
	inline void curvature_min(float value);
	inline float curvature_max(void);
	inline void curvature_max(float value);

};

/**************** Line Style Alpha Modifier ****************/

class LineStyleAlphaModifier : public LineStyleModifier {
public:
	LineStyleAlphaModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}

	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Along Stroke ****************/

class LineStyleAlphaModifier_AlongStroke : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_AlongStroke(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);

};

/**************** Distance from Camera ****************/

class LineStyleAlphaModifier_DistanceFromCamera : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_DistanceFromCamera(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);

};

/**************** Distance from Object ****************/

class LineStyleAlphaModifier_DistanceFromObject : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_DistanceFromObject(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline Object target(void);

};

/**************** Material ****************/

class LineStyleAlphaModifier_Material : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Material(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};
	inline material_attribute_enum material_attribute(void);
	inline void material_attribute(material_attribute_enum value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);

};

/**************** Tangent ****************/

class LineStyleAlphaModifier_Tangent : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Tangent(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);

};

/**************** Noise ****************/

class LineStyleAlphaModifier_Noise : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Noise(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Crease Angle ****************/

class LineStyleAlphaModifier_CreaseAngle : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_CreaseAngle(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline float angle_max(void);
	inline void angle_max(float value);

};

/**************** Curvature 3D ****************/

class LineStyleAlphaModifier_Curvature_3D : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Curvature_3D(const PointerRNA &ptr_arg) :
		LineStyleAlphaModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float curvature_min(void);
	inline void curvature_min(float value);
	inline float curvature_max(void);
	inline void curvature_max(float value);

};

/**************** Line Style Thickness Modifier ****************/

class LineStyleThicknessModifier : public LineStyleModifier {
public:
	LineStyleThicknessModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}

	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Tangent ****************/

class LineStyleThicknessModifier_Tangent : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Tangent(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);

};

/**************** Along Stroke ****************/

class LineStyleThicknessModifier_AlongStroke : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_AlongStroke(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);

};

/**************** Distance from Camera ****************/

class LineStyleThicknessModifier_DistanceFromCamera : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_DistanceFromCamera(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);

};

/**************** Distance from Object ****************/

class LineStyleThicknessModifier_DistanceFromObject : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_DistanceFromObject(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float range_min(void);
	inline void range_min(float value);
	inline float range_max(void);
	inline void range_max(float value);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);
	inline Object target(void);

};

/**************** Material ****************/

class LineStyleThicknessModifier_Material : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Material(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};
	inline material_attribute_enum material_attribute(void);
	inline void material_attribute(material_attribute_enum value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float value_min(void);
	inline void value_min(float value);
	inline float value_max(void);
	inline void value_max(float value);

};

/**************** Calligraphy ****************/

class LineStyleThicknessModifier_Calligraphy : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Calligraphy(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float orientation(void);
	inline void orientation(float value);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);

};

/**************** Noise ****************/

class LineStyleThicknessModifier_Noise : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Noise(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline int seed(void);
	inline void seed(int value);
	inline bool use_asymmetric(void);
	inline void use_asymmetric(bool value);

};

/**************** Curvature 3D ****************/

class LineStyleThicknessModifier_Curvature_3D : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Curvature_3D(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);
	inline float curvature_min(void);
	inline void curvature_min(float value);
	inline float curvature_max(void);
	inline void curvature_max(float value);

};

/**************** Crease Angle ****************/

class LineStyleThicknessModifier_CreaseAngle : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_CreaseAngle(const PointerRNA &ptr_arg) :
		LineStyleThicknessModifier(ptr_arg)
		{}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_CREASE_ANGLE = 21,
		type_CURVATURE_3D = 23,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
		type_NOISE = 20,
		type_TANGENT = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MINIMUM = 6,
		blend_MAXIMUM = 7,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline float influence(void);
	inline void influence(float value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	inline CurveMapping curve(void);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline float angle_max(void);
	inline void angle_max(float value);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);

};

/**************** Line Style Geometry Modifier ****************/

class LineStyleGeometryModifier : public LineStyleModifier {
public:
	LineStyleGeometryModifier(const PointerRNA &ptr_arg) :
		LineStyleModifier(ptr_arg)
		{}

	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Sampling ****************/

class LineStyleGeometryModifier_Sampling : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Sampling(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float sampling(void);
	inline void sampling(float value);

};

/**************** Bezier Curve ****************/

class LineStyleGeometryModifier_BezierCurve : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_BezierCurve(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float error(void);
	inline void error(float value);

};

/**************** Sinus Displacement ****************/

class LineStyleGeometryModifier_SinusDisplacement : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_SinusDisplacement(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float wavelength(void);
	inline void wavelength(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float phase(void);
	inline void phase(float value);

};

/**************** Spatial Noise ****************/

class LineStyleGeometryModifier_SpatialNoise : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_SpatialNoise(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float scale(void);
	inline void scale(float value);
	inline int octaves(void);
	inline void octaves(int value);
	inline bool smooth(void);
	inline void smooth(bool value);
	inline bool use_pure_random(void);
	inline void use_pure_random(bool value);

};

/**************** Perlin Noise 1D ****************/

class LineStyleGeometryModifier_PerlinNoise1D : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_PerlinNoise1D(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float frequency(void);
	inline void frequency(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline int octaves(void);
	inline void octaves(int value);
	inline float angle(void);
	inline void angle(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Perlin Noise 2D ****************/

class LineStyleGeometryModifier_PerlinNoise2D : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_PerlinNoise2D(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float frequency(void);
	inline void frequency(float value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline int octaves(void);
	inline void octaves(int value);
	inline float angle(void);
	inline void angle(float value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Backbone Stretcher ****************/

class LineStyleGeometryModifier_BackboneStretcher : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_BackboneStretcher(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float backbone_length(void);
	inline void backbone_length(float value);

};

/**************** Tip Remover ****************/

class LineStyleGeometryModifier_TipRemover : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_TipRemover(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float tip_length(void);
	inline void tip_length(float value);

};

/**************** Polygonalization ****************/

class LineStyleGeometryModifier_Polygonalization : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Polygonalization(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float error(void);
	inline void error(float value);

};

/**************** Guiding Lines ****************/

class LineStyleGeometryModifier_GuidingLines : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_GuidingLines(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float offset(void);
	inline void offset(float value);

};

/**************** Blueprint ****************/

class LineStyleGeometryModifier_Blueprint : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Blueprint(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum shape_enum {
		shape_CIRCLES = 1,
		shape_ELLIPSES = 2,
		shape_SQUARES = 4,
	};
	inline shape_enum shape(void);
	inline void shape(shape_enum value);
	inline int rounds(void);
	inline void rounds(int value);
	inline float backbone_length(void);
	inline void backbone_length(float value);
	inline int random_radius(void);
	inline void random_radius(int value);
	inline int random_center(void);
	inline void random_center(int value);
	inline int random_backbone(void);
	inline void random_backbone(int value);

};

/**************** 2D Offset ****************/

class LineStyleGeometryModifier_2DOffset : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_2DOffset(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float start(void);
	inline void start(float value);
	inline float end(void);
	inline void end(float value);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);

};

/**************** 2D Transform ****************/

class LineStyleGeometryModifier_2DTransform : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_2DTransform(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	enum pivot_enum {
		pivot_CENTER = 1,
		pivot_START = 2,
		pivot_END = 3,
		pivot_PARAM = 4,
		pivot_ABSOLUTE = 5,
	};
	inline pivot_enum pivot(void);
	inline void pivot(pivot_enum value);
	inline float scale_x(void);
	inline void scale_x(float value);
	inline float scale_y(void);
	inline void scale_y(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float pivot_u(void);
	inline void pivot_u(float value);
	inline float pivot_x(void);
	inline void pivot_x(float value);
	inline float pivot_y(void);
	inline void pivot_y(float value);

};

/**************** Simplification ****************/

class LineStyleGeometryModifier_Simplification : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Simplification(const PointerRNA &ptr_arg) :
		LineStyleGeometryModifier(ptr_arg)
		{}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SIMPLIFICATION = 22,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool use(void);
	inline void use(bool value);
	inline bool expanded(void);
	inline void expanded(bool value);
	inline float tolerance(void);
	inline void tolerance(float value);

};

/**************** Freestyle Line Style ****************/

class FreestyleLineStyle : public ID {
public:
	FreestyleLineStyle(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		texture_slots(ptr_arg),
		color_modifiers(ptr_arg),
		alpha_modifiers(ptr_arg),
		thickness_modifiers(ptr_arg),
		geometry_modifiers(ptr_arg)
		{}

	COLLECTION_PROPERTY(LineStyleTextureSlots, LineStyleTextureSlot, FreestyleLineStyle, texture_slots, false, false, false)
	inline Texture active_texture(void);
	inline int active_texture_index(void);
	inline void active_texture_index(int value);
	enum panel_enum {
		panel_STROKES = 1,
		panel_COLOR = 2,
		panel_ALPHA = 3,
		panel_THICKNESS = 4,
		panel_GEOMETRY = 5,
		panel_TEXTURE = 6,
	};
	inline panel_enum panel(void);
	inline void panel(panel_enum value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float alpha(void);
	inline void alpha(float value);
	inline float thickness(void);
	inline void thickness(float value);
	enum thickness_position_enum {
		thickness_position_CENTER = 1,
		thickness_position_INSIDE = 2,
		thickness_position_OUTSIDE = 3,
		thickness_position_RELATIVE = 4,
	};
	inline thickness_position_enum thickness_position(void);
	inline void thickness_position(thickness_position_enum value);
	inline float thickness_ratio(void);
	inline void thickness_ratio(float value);
	COLLECTION_PROPERTY(LineStyleColorModifiers, LineStyleColorModifier, FreestyleLineStyle, color_modifiers, false, true, true)
	COLLECTION_PROPERTY(LineStyleAlphaModifiers, LineStyleAlphaModifier, FreestyleLineStyle, alpha_modifiers, false, true, true)
	COLLECTION_PROPERTY(LineStyleThicknessModifiers, LineStyleThicknessModifier, FreestyleLineStyle, thickness_modifiers, false, true, true)
	COLLECTION_PROPERTY(LineStyleGeometryModifiers, LineStyleGeometryModifier, FreestyleLineStyle, geometry_modifiers, false, true, true)
	inline bool use_chaining(void);
	inline void use_chaining(bool value);
	enum chaining_enum {
		chaining_PLAIN = 1,
		chaining_SKETCHY = 2,
	};
	inline chaining_enum chaining(void);
	inline void chaining(chaining_enum value);
	inline int rounds(void);
	inline void rounds(int value);
	inline bool use_same_object(void);
	inline void use_same_object(bool value);
	inline bool use_split_length(void);
	inline void use_split_length(bool value);
	inline float split_length(void);
	inline void split_length(float value);
	inline bool use_angle_min(void);
	inline void use_angle_min(bool value);
	inline float angle_min(void);
	inline void angle_min(float value);
	inline bool use_angle_max(void);
	inline void use_angle_max(bool value);
	inline float angle_max(void);
	inline void angle_max(float value);
	inline bool use_length_min(void);
	inline void use_length_min(bool value);
	inline float length_min(void);
	inline void length_min(float value);
	inline bool use_length_max(void);
	inline void use_length_max(bool value);
	inline float length_max(void);
	inline void length_max(float value);
	inline bool use_chain_count(void);
	inline void use_chain_count(bool value);
	inline int chain_count(void);
	inline void chain_count(int value);
	inline bool use_split_pattern(void);
	inline void use_split_pattern(bool value);
	inline int split_dash1(void);
	inline void split_dash1(int value);
	inline int split_gap1(void);
	inline void split_gap1(int value);
	inline int split_dash2(void);
	inline void split_dash2(int value);
	inline int split_gap2(void);
	inline void split_gap2(int value);
	inline int split_dash3(void);
	inline void split_dash3(int value);
	inline int split_gap3(void);
	inline void split_gap3(int value);
	inline bool material_boundary(void);
	inline void material_boundary(bool value);
	inline bool use_sorting(void);
	inline void use_sorting(bool value);
	enum sort_key_enum {
		sort_key_DISTANCE_FROM_CAMERA = 1,
		sort_key_2D_LENGTH = 2,
		sort_key_PROJECTED_X = 3,
		sort_key_PROJECTED_Y = 4,
	};
	inline sort_key_enum sort_key(void);
	inline void sort_key(sort_key_enum value);
	enum sort_order_enum {
		sort_order_DEFAULT = 0,
		sort_order_REVERSE = 4096,
	};
	inline sort_order_enum sort_order(void);
	inline void sort_order(sort_order_enum value);
	enum integration_type_enum {
		integration_type_MEAN = 1,
		integration_type_MIN = 2,
		integration_type_MAX = 3,
		integration_type_FIRST = 4,
		integration_type_LAST = 5,
	};
	inline integration_type_enum integration_type(void);
	inline void integration_type(integration_type_enum value);
	inline bool use_dashed_line(void);
	inline void use_dashed_line(bool value);
	enum caps_enum {
		caps_BUTT = 1,
		caps_ROUND = 2,
		caps_SQUARE = 3,
	};
	inline caps_enum caps(void);
	inline void caps(caps_enum value);
	inline int dash1(void);
	inline void dash1(int value);
	inline int gap1(void);
	inline void gap1(int value);
	inline int dash2(void);
	inline void dash2(int value);
	inline int gap2(void);
	inline void gap2(int value);
	inline int dash3(void);
	inline void dash3(int value);
	inline int gap3(void);
	inline void gap3(int value);
	inline bool use_texture(void);
	inline void use_texture(bool value);
	inline float texture_spacing(void);
	inline void texture_spacing(float value);
	inline AnimData animation_data(void);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);

};

/**************** LineStyle Texture Slot ****************/

class LineStyleTextureSlot : public TextureSlot {
public:
	LineStyleTextureSlot(const PointerRNA &ptr_arg) :
		TextureSlot(ptr_arg)
		{}

	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};
	inline mapping_x_enum mapping_x(void);
	inline void mapping_x(mapping_x_enum value);
	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};
	inline mapping_y_enum mapping_y(void);
	inline void mapping_y(mapping_y_enum value);
	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};
	inline mapping_z_enum mapping_z(void);
	inline void mapping_z(mapping_z_enum value);
	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool use_map_color_diffuse(void);
	inline void use_map_color_diffuse(bool value);
	inline bool use_map_alpha(void);
	inline void use_map_alpha(bool value);
	enum texture_coords_enum {
		texture_coords_WINDOW = 1024,
		texture_coords_GLOBAL = 8,
		texture_coords_ALONG_STROKE = 16,
		texture_coords_ORCO = 1,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline float alpha_factor(void);
	inline void alpha_factor(float value);
	inline float diffuse_color_factor(void);
	inline void diffuse_color_factor(float value);

};

/**************** Blend-File Data ****************/

class BlendData : public Pointer {
public:
	BlendData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		cameras(ptr_arg),
		scenes(ptr_arg),
		objects(ptr_arg),
		materials(ptr_arg),
		node_groups(ptr_arg),
		meshes(ptr_arg),
		lights(ptr_arg),
		libraries(ptr_arg),
		screens(ptr_arg),
		window_managers(ptr_arg),
		images(ptr_arg),
		lattices(ptr_arg),
		curves(ptr_arg),
		metaballs(ptr_arg),
		fonts(ptr_arg),
		textures(ptr_arg),
		brushes(ptr_arg),
		worlds(ptr_arg),
		collections(ptr_arg),
		shape_keys(ptr_arg),
		texts(ptr_arg),
		speakers(ptr_arg),
		sounds(ptr_arg),
		armatures(ptr_arg),
		actions(ptr_arg),
		particles(ptr_arg),
		palettes(ptr_arg),
		grease_pencils(ptr_arg),
		grease_pencils_v3(ptr_arg),
		movieclips(ptr_arg),
		masks(ptr_arg),
		linestyles(ptr_arg),
		cache_files(ptr_arg),
		paint_curves(ptr_arg),
		workspaces(ptr_arg),
		lightprobes(ptr_arg),
		hair_curves(ptr_arg),
		pointclouds(ptr_arg),
		volumes(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool is_dirty(void);
	inline void is_dirty(bool value);
	inline bool is_saved(void);
	inline void is_saved(bool value);
	inline bool use_autopack(void);
	inline void use_autopack(bool value);
	inline Array<int, 3> version(void);
	inline void version(int values[3]);
	COLLECTION_PROPERTY(BlendDataCameras, Camera, BlendData, cameras, false, false, false)
	COLLECTION_PROPERTY(BlendDataScenes, Scene, BlendData, scenes, false, false, false)
	COLLECTION_PROPERTY(BlendDataObjects, Object, BlendData, objects, false, false, false)
	COLLECTION_PROPERTY(BlendDataMaterials, Material, BlendData, materials, false, false, false)
	COLLECTION_PROPERTY(BlendDataNodeTrees, NodeTree, BlendData, node_groups, false, false, false)
	COLLECTION_PROPERTY(BlendDataMeshes, Mesh, BlendData, meshes, false, false, false)
	COLLECTION_PROPERTY(BlendDataLights, Light, BlendData, lights, false, false, false)
	COLLECTION_PROPERTY(BlendDataLibraries, Library, BlendData, libraries, false, false, false)
	COLLECTION_PROPERTY(BlendDataScreens, Screen, BlendData, screens, false, false, false)
	COLLECTION_PROPERTY(BlendDataWindowManagers, WindowManager, BlendData, window_managers, false, false, false)
	COLLECTION_PROPERTY(BlendDataImages, Image, BlendData, images, false, false, false)
	COLLECTION_PROPERTY(BlendDataLattices, Lattice, BlendData, lattices, false, false, false)
	COLLECTION_PROPERTY(BlendDataCurves, Curve, BlendData, curves, false, false, false)
	COLLECTION_PROPERTY(BlendDataMetaBalls, MetaBall, BlendData, metaballs, false, false, false)
	COLLECTION_PROPERTY(BlendDataFonts, VectorFont, BlendData, fonts, false, false, false)
	COLLECTION_PROPERTY(BlendDataTextures, Texture, BlendData, textures, false, false, false)
	COLLECTION_PROPERTY(BlendDataBrushes, Brush, BlendData, brushes, false, false, false)
	COLLECTION_PROPERTY(BlendDataWorlds, World, BlendData, worlds, false, false, false)
	COLLECTION_PROPERTY(BlendDataCollections, Collection, BlendData, collections, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Key, BlendData, shape_keys, false, false, false)
	COLLECTION_PROPERTY(BlendDataTexts, Text, BlendData, texts, false, false, false)
	COLLECTION_PROPERTY(BlendDataSpeakers, Speaker, BlendData, speakers, false, false, false)
	COLLECTION_PROPERTY(BlendDataSounds, Sound, BlendData, sounds, false, false, false)
	COLLECTION_PROPERTY(BlendDataArmatures, Armature, BlendData, armatures, false, false, false)
	COLLECTION_PROPERTY(BlendDataActions, Action, BlendData, actions, false, false, false)
	COLLECTION_PROPERTY(BlendDataParticles, ParticleSettings, BlendData, particles, false, false, false)
	COLLECTION_PROPERTY(BlendDataPalettes, Palette, BlendData, palettes, false, false, false)
	COLLECTION_PROPERTY(BlendDataGreasePencils, GreasePencil, BlendData, grease_pencils, false, false, false)
	COLLECTION_PROPERTY(BlendDataGreasePencilsV3, GreasePencilv3, BlendData, grease_pencils_v3, false, false, false)
	COLLECTION_PROPERTY(BlendDataMovieClips, MovieClip, BlendData, movieclips, false, false, false)
	COLLECTION_PROPERTY(BlendDataMasks, Mask, BlendData, masks, false, false, false)
	COLLECTION_PROPERTY(BlendDataLineStyles, FreestyleLineStyle, BlendData, linestyles, false, false, false)
	COLLECTION_PROPERTY(BlendDataCacheFiles, CacheFile, BlendData, cache_files, false, false, false)
	COLLECTION_PROPERTY(BlendDataPaintCurves, PaintCurve, BlendData, paint_curves, false, false, false)
	COLLECTION_PROPERTY(BlendDataWorkSpaces, WorkSpace, BlendData, workspaces, false, false, false)
	COLLECTION_PROPERTY(BlendDataProbes, LightProbe, BlendData, lightprobes, false, false, false)
	COLLECTION_PROPERTY(BlendDataHairCurves, Curves, BlendData, hair_curves, false, false, false)
	COLLECTION_PROPERTY(BlendDataPointClouds, PointCloud, BlendData, pointclouds, false, false, false)
	COLLECTION_PROPERTY(BlendDataVolumes, Volume, BlendData, volumes, false, false, false)

};

/**************** Domain Settings ****************/

class FluidDomainSettings : public Pointer {
public:
	FluidDomainSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline EffectorWeights effector_weights(void);
	inline Collection effector_group(void);
	inline Collection fluid_group(void);
	inline Collection force_collection(void);
	inline Array<float, 32> density_grid(void);
	inline void density_grid(float values[32]);
	inline Array<float, 32> velocity_grid(void);
	inline void velocity_grid(float values[32]);
	inline Array<float, 32> flame_grid(void);
	inline void flame_grid(float values[32]);
	inline Array<float, 32> color_grid(void);
	inline void color_grid(float values[32]);
	inline Array<float, 32> heat_grid(void);
	inline void heat_grid(float values[32]);
	inline Array<float, 32> temperature_grid(void);
	inline void temperature_grid(float values[32]);
	inline Array<float, 3> start_point(void);
	inline void start_point(float values[3]);
	inline Array<float, 3> cell_size(void);
	inline void cell_size(float values[3]);
	inline Array<int, 3> domain_resolution(void);
	inline void domain_resolution(int values[3]);
	inline int additional_res(void);
	inline void additional_res(int value);
	inline int adapt_margin(void);
	inline void adapt_margin(int value);
	inline float adapt_threshold(void);
	inline void adapt_threshold(float value);
	inline bool use_adaptive_domain(void);
	inline void use_adaptive_domain(bool value);
	inline int resolution_max(void);
	inline void resolution_max(int value);
	inline bool use_collision_border_front(void);
	inline void use_collision_border_front(bool value);
	inline bool use_collision_border_back(void);
	inline void use_collision_border_back(bool value);
	inline bool use_collision_border_right(void);
	inline void use_collision_border_right(bool value);
	inline bool use_collision_border_left(void);
	inline void use_collision_border_left(bool value);
	inline bool use_collision_border_top(void);
	inline void use_collision_border_top(bool value);
	inline bool use_collision_border_bottom(void);
	inline void use_collision_border_bottom(bool value);
	inline Array<float, 3> gravity(void);
	inline void gravity(float values[3]);
	enum domain_type_enum {
		domain_type_GAS = 0,
		domain_type_LIQUID = 1,
	};
	inline domain_type_enum domain_type(void);
	inline void domain_type(domain_type_enum value);
	inline bool delete_in_obstacle(void);
	inline void delete_in_obstacle(bool value);
	inline float alpha(void);
	inline void alpha(float value);
	inline float beta(void);
	inline void beta(float value);
	inline int dissolve_speed(void);
	inline void dissolve_speed(int value);
	inline float vorticity(void);
	inline void vorticity(float value);
	enum highres_sampling_enum {
		highres_sampling_FULLSAMPLE = 2,
		highres_sampling_LINEAR = 1,
		highres_sampling_NEAREST = 0,
	};
	inline highres_sampling_enum highres_sampling(void);
	inline void highres_sampling(highres_sampling_enum value);
	inline bool use_dissolve_smoke(void);
	inline void use_dissolve_smoke(bool value);
	inline bool use_dissolve_smoke_log(void);
	inline void use_dissolve_smoke_log(bool value);
	inline float burning_rate(void);
	inline void burning_rate(float value);
	inline float flame_smoke(void);
	inline void flame_smoke(float value);
	inline float flame_vorticity(void);
	inline void flame_vorticity(float value);
	inline float flame_ignition(void);
	inline void flame_ignition(float value);
	inline float flame_max_temp(void);
	inline void flame_max_temp(float value);
	inline Array<float, 3> flame_smoke_color(void);
	inline void flame_smoke_color(float values[3]);
	inline float noise_strength(void);
	inline void noise_strength(float value);
	inline float noise_pos_scale(void);
	inline void noise_pos_scale(float value);
	inline float noise_time_anim(void);
	inline void noise_time_anim(float value);
	inline int noise_scale(void);
	inline void noise_scale(int value);
	inline bool use_noise(void);
	inline void use_noise(bool value);
	enum simulation_method_enum {
		simulation_method_FLIP = 1,
		simulation_method_APIC = 2,
	};
	inline simulation_method_enum simulation_method(void);
	inline void simulation_method(simulation_method_enum value);
	inline float flip_ratio(void);
	inline void flip_ratio(float value);
	inline float particle_randomness(void);
	inline void particle_randomness(float value);
	inline int particle_number(void);
	inline void particle_number(int value);
	inline int particle_min(void);
	inline void particle_min(int value);
	inline int particle_max(void);
	inline void particle_max(int value);
	inline float particle_radius(void);
	inline void particle_radius(float value);
	inline float particle_band_width(void);
	inline void particle_band_width(float value);
	inline bool use_flip_particles(void);
	inline void use_flip_particles(bool value);
	inline bool use_fractions(void);
	inline void use_fractions(bool value);
	inline float fractions_threshold(void);
	inline void fractions_threshold(float value);
	inline float fractions_distance(void);
	inline void fractions_distance(float value);
	inline int sys_particle_maximum(void);
	inline void sys_particle_maximum(int value);
	inline bool use_viscosity(void);
	inline void use_viscosity(bool value);
	inline float viscosity_value(void);
	inline void viscosity_value(float value);
	inline bool use_diffusion(void);
	inline void use_diffusion(bool value);
	inline float surface_tension(void);
	inline void surface_tension(float value);
	inline float viscosity_base(void);
	inline void viscosity_base(float value);
	inline int viscosity_exponent(void);
	inline void viscosity_exponent(int value);
	inline float mesh_concave_upper(void);
	inline void mesh_concave_upper(float value);
	inline float mesh_concave_lower(void);
	inline void mesh_concave_lower(float value);
	inline int mesh_smoothen_pos(void);
	inline void mesh_smoothen_pos(int value);
	inline int mesh_smoothen_neg(void);
	inline void mesh_smoothen_neg(int value);
	inline int mesh_scale(void);
	inline void mesh_scale(int value);
	enum mesh_generator_enum {
		mesh_generator_IMPROVED = 0,
		mesh_generator_UNION = 1,
	};
	inline mesh_generator_enum mesh_generator(void);
	inline void mesh_generator(mesh_generator_enum value);
	inline bool use_mesh(void);
	inline void use_mesh(bool value);
	inline bool use_speed_vectors(void);
	inline void use_speed_vectors(bool value);
	inline float mesh_particle_radius(void);
	inline void mesh_particle_radius(float value);
	inline float sndparticle_potential_min_wavecrest(void);
	inline void sndparticle_potential_min_wavecrest(float value);
	inline float sndparticle_potential_max_wavecrest(void);
	inline void sndparticle_potential_max_wavecrest(float value);
	inline float sndparticle_potential_min_trappedair(void);
	inline void sndparticle_potential_min_trappedair(float value);
	inline float sndparticle_potential_max_trappedair(void);
	inline void sndparticle_potential_max_trappedair(float value);
	inline float sndparticle_potential_min_energy(void);
	inline void sndparticle_potential_min_energy(float value);
	inline float sndparticle_potential_max_energy(void);
	inline void sndparticle_potential_max_energy(float value);
	inline int sndparticle_sampling_wavecrest(void);
	inline void sndparticle_sampling_wavecrest(int value);
	inline int sndparticle_sampling_trappedair(void);
	inline void sndparticle_sampling_trappedair(int value);
	inline float sndparticle_bubble_buoyancy(void);
	inline void sndparticle_bubble_buoyancy(float value);
	inline float sndparticle_bubble_drag(void);
	inline void sndparticle_bubble_drag(float value);
	inline float sndparticle_life_min(void);
	inline void sndparticle_life_min(float value);
	inline float sndparticle_life_max(void);
	inline void sndparticle_life_max(float value);
	enum sndparticle_boundary_enum {
		sndparticle_boundary_DELETE = 0,
		sndparticle_boundary_PUSHOUT = 1,
	};
	inline sndparticle_boundary_enum sndparticle_boundary(void);
	inline void sndparticle_boundary(sndparticle_boundary_enum value);
	enum sndparticle_combined_export_enum {
		sndparticle_combined_export_OFF = 0,
		sndparticle_combined_export_SPRAY_FOAM = 1,
		sndparticle_combined_export_SPRAY_BUBBLES = 2,
		sndparticle_combined_export_FOAM_BUBBLES = 3,
		sndparticle_combined_export_SPRAY_FOAM_BUBBLES = 4,
	};
	inline sndparticle_combined_export_enum sndparticle_combined_export(void);
	inline void sndparticle_combined_export(sndparticle_combined_export_enum value);
	inline int sndparticle_potential_radius(void);
	inline void sndparticle_potential_radius(int value);
	inline int sndparticle_update_radius(void);
	inline void sndparticle_update_radius(int value);
	inline int particle_scale(void);
	inline void particle_scale(int value);
	inline bool use_spray_particles(void);
	inline void use_spray_particles(bool value);
	inline bool use_bubble_particles(void);
	inline void use_bubble_particles(bool value);
	inline bool use_foam_particles(void);
	inline void use_foam_particles(bool value);
	inline bool use_tracer_particles(void);
	inline void use_tracer_particles(bool value);
	inline float guide_alpha(void);
	inline void guide_alpha(float value);
	inline int guide_beta(void);
	inline void guide_beta(int value);
	inline float guide_vel_factor(void);
	inline void guide_vel_factor(float value);
	enum guide_source_enum {
		guide_source_DOMAIN = 0,
		guide_source_EFFECTOR = 1,
	};
	inline guide_source_enum guide_source(void);
	inline void guide_source(guide_source_enum value);
	inline Object guide_parent(void);
	inline bool use_guide(void);
	inline void use_guide(bool value);
	inline int cache_frame_start(void);
	inline void cache_frame_start(int value);
	inline int cache_frame_end(void);
	inline void cache_frame_end(int value);
	inline int cache_frame_offset(void);
	inline void cache_frame_offset(int value);
	inline int cache_frame_pause_data(void);
	inline void cache_frame_pause_data(int value);
	inline int cache_frame_pause_noise(void);
	inline void cache_frame_pause_noise(int value);
	inline int cache_frame_pause_mesh(void);
	inline void cache_frame_pause_mesh(int value);
	inline int cache_frame_pause_particles(void);
	inline void cache_frame_pause_particles(int value);
	inline int cache_frame_pause_guide(void);
	inline void cache_frame_pause_guide(int value);
	enum cache_mesh_format_enum {
		cache_mesh_format_NONE = 0,
	};
	inline cache_mesh_format_enum cache_mesh_format(void);
	inline void cache_mesh_format(cache_mesh_format_enum value);
	enum cache_data_format_enum {
		cache_data_format_NONE = 0,
	};
	inline cache_data_format_enum cache_data_format(void);
	inline void cache_data_format(cache_data_format_enum value);
	enum cache_particle_format_enum {
		cache_particle_format_NONE = 0,
	};
	inline cache_particle_format_enum cache_particle_format(void);
	inline void cache_particle_format(cache_particle_format_enum value);
	enum cache_noise_format_enum {
		cache_noise_format_NONE = 0,
	};
	inline cache_noise_format_enum cache_noise_format(void);
	inline void cache_noise_format(cache_noise_format_enum value);
	enum cache_type_enum {
		cache_type_REPLAY = 0,
		cache_type_MODULAR = 1,
		cache_type_ALL = 2,
	};
	inline cache_type_enum cache_type(void);
	inline void cache_type(cache_type_enum value);
	inline bool cache_resumable(void);
	inline void cache_resumable(bool value);
	inline std::string cache_directory(void);
	inline void cache_directory(const std::string& value);
	inline bool is_cache_baking_data(void);
	inline void is_cache_baking_data(bool value);
	inline bool has_cache_baked_data(void);
	inline void has_cache_baked_data(bool value);
	inline bool is_cache_baking_noise(void);
	inline void is_cache_baking_noise(bool value);
	inline bool has_cache_baked_noise(void);
	inline void has_cache_baked_noise(bool value);
	inline bool is_cache_baking_mesh(void);
	inline void is_cache_baking_mesh(bool value);
	inline bool has_cache_baked_mesh(void);
	inline void has_cache_baked_mesh(bool value);
	inline bool is_cache_baking_particles(void);
	inline void is_cache_baking_particles(bool value);
	inline bool has_cache_baked_particles(void);
	inline void has_cache_baked_particles(bool value);
	inline bool is_cache_baking_guide(void);
	inline void is_cache_baking_guide(bool value);
	inline bool has_cache_baked_guide(void);
	inline void has_cache_baked_guide(bool value);
	inline bool is_cache_baking_any(void);
	inline void is_cache_baking_any(bool value);
	inline bool has_cache_baked_any(void);
	inline void has_cache_baked_any(bool value);
	inline bool export_manta_script(void);
	inline void export_manta_script(bool value);
	enum openvdb_cache_compress_type_enum {
		openvdb_cache_compress_type_ZIP = 1,
		openvdb_cache_compress_type_BLOSC = 0,
		openvdb_cache_compress_type_NONE = 2,
	};
	inline openvdb_cache_compress_type_enum openvdb_cache_compress_type(void);
	inline void openvdb_cache_compress_type(openvdb_cache_compress_type_enum value);
	enum openvdb_data_depth_enum {
		openvdb_data_depth_NONE = 0,
	};
	inline openvdb_data_depth_enum openvdb_data_depth(void);
	inline void openvdb_data_depth(openvdb_data_depth_enum value);
	inline float time_scale(void);
	inline void time_scale(float value);
	inline float cfl_condition(void);
	inline void cfl_condition(float value);
	inline bool use_adaptive_timesteps(void);
	inline void use_adaptive_timesteps(bool value);
	inline int timesteps_min(void);
	inline void timesteps_min(int value);
	inline int timesteps_max(void);
	inline void timesteps_max(int value);
	inline bool use_slice(void);
	inline void use_slice(bool value);
	enum slice_axis_enum {
		slice_axis_AUTO = 0,
		slice_axis_X = 1,
		slice_axis_Y = 2,
		slice_axis_Z = 3,
	};
	inline slice_axis_enum slice_axis(void);
	inline void slice_axis(slice_axis_enum value);
	inline float slice_per_voxel(void);
	inline void slice_per_voxel(float value);
	inline float slice_depth(void);
	inline void slice_depth(float value);
	inline float display_thickness(void);
	inline void display_thickness(float value);
	enum display_interpolation_enum {
		display_interpolation_LINEAR = 0,
		display_interpolation_CUBIC = 1,
		display_interpolation_CLOSEST = 2,
	};
	inline display_interpolation_enum display_interpolation(void);
	inline void display_interpolation(display_interpolation_enum value);
	inline bool show_gridlines(void);
	inline void show_gridlines(bool value);
	inline bool show_velocity(void);
	inline void show_velocity(bool value);
	enum vector_display_type_enum {
		vector_display_type_NEEDLE = 0,
		vector_display_type_STREAMLINE = 1,
		vector_display_type_MAC = 2,
	};
	inline vector_display_type_enum vector_display_type(void);
	inline void vector_display_type(vector_display_type_enum value);
	enum vector_field_enum {
		vector_field_FLUID_VELOCITY = 0,
		vector_field_GUIDE_VELOCITY = 1,
		vector_field_FORCE = 2,
	};
	inline vector_field_enum vector_field(void);
	inline void vector_field(vector_field_enum value);
	inline bool vector_scale_with_magnitude(void);
	inline void vector_scale_with_magnitude(bool value);
	inline bool vector_show_mac_x(void);
	inline void vector_show_mac_x(bool value);
	inline bool vector_show_mac_y(void);
	inline void vector_show_mac_y(bool value);
	inline bool vector_show_mac_z(void);
	inline void vector_show_mac_z(bool value);
	inline float vector_scale(void);
	inline void vector_scale(float value);
	inline bool use_color_ramp(void);
	inline void use_color_ramp(bool value);
	enum color_ramp_field_enum {
		color_ramp_field_NONE = 0,
	};
	inline color_ramp_field_enum color_ramp_field(void);
	inline void color_ramp_field(color_ramp_field_enum value);
	inline float color_ramp_field_scale(void);
	inline void color_ramp_field_scale(float value);
	inline ColorRamp color_ramp(void);
	inline float clipping(void);
	inline void clipping(float value);
	enum gridlines_color_field_enum {
		gridlines_color_field_NONE = 0,
		gridlines_color_field_FLAGS = 1,
		gridlines_color_field_RANGE = 2,
	};
	inline gridlines_color_field_enum gridlines_color_field(void);
	inline void gridlines_color_field(gridlines_color_field_enum value);
	inline float gridlines_lower_bound(void);
	inline void gridlines_lower_bound(float value);
	inline float gridlines_upper_bound(void);
	inline void gridlines_upper_bound(float value);
	inline Array<float, 4> gridlines_range_color(void);
	inline void gridlines_range_color(float values[4]);
	enum gridlines_cell_filter_enum {
		gridlines_cell_filter_NONE = 0,
		gridlines_cell_filter_FLUID = 1,
		gridlines_cell_filter_OBSTACLE = 2,
		gridlines_cell_filter_EMPTY = 4,
		gridlines_cell_filter_INFLOW = 8,
		gridlines_cell_filter_OUTFLOW = 16,
	};
	inline gridlines_cell_filter_enum gridlines_cell_filter(void);
	inline void gridlines_cell_filter(gridlines_cell_filter_enum value);
	inline float velocity_scale(void);
	inline void velocity_scale(float value);

};

/**************** Flow Settings ****************/

class FluidFlowSettings : public Pointer {
public:
	FluidFlowSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float density(void);
	inline void density(float value);
	inline Array<float, 3> smoke_color(void);
	inline void smoke_color(float values[3]);
	inline float fuel_amount(void);
	inline void fuel_amount(float value);
	inline float temperature(void);
	inline void temperature(float value);
	inline ParticleSystem particle_system(void);
	enum flow_type_enum {
		flow_type_SMOKE = 1,
		flow_type_BOTH = 3,
		flow_type_FIRE = 2,
		flow_type_LIQUID = 4,
	};
	inline flow_type_enum flow_type(void);
	inline void flow_type(flow_type_enum value);
	enum flow_behavior_enum {
		flow_behavior_INFLOW = 0,
		flow_behavior_OUTFLOW = 1,
		flow_behavior_GEOMETRY = 2,
	};
	inline flow_behavior_enum flow_behavior(void);
	inline void flow_behavior(flow_behavior_enum value);
	enum flow_source_enum {
		flow_source_NONE = 0,
	};
	inline flow_source_enum flow_source(void);
	inline void flow_source(flow_source_enum value);
	inline bool use_absolute(void);
	inline void use_absolute(bool value);
	inline bool use_initial_velocity(void);
	inline void use_initial_velocity(bool value);
	inline float velocity_factor(void);
	inline void velocity_factor(float value);
	inline float velocity_normal(void);
	inline void velocity_normal(float value);
	inline float velocity_random(void);
	inline void velocity_random(float value);
	inline Array<float, 3> velocity_coord(void);
	inline void velocity_coord(float values[3]);
	inline float volume_density(void);
	inline void volume_density(float value);
	inline float surface_distance(void);
	inline void surface_distance(float value);
	inline bool use_plane_init(void);
	inline void use_plane_init(bool value);
	inline float particle_size(void);
	inline void particle_size(float value);
	inline bool use_particle_size(void);
	inline void use_particle_size(bool value);
	inline bool use_inflow(void);
	inline void use_inflow(bool value);
	inline int subframes(void);
	inline void subframes(int value);
	inline std::string density_vertex_group(void);
	inline void density_vertex_group(const std::string& value);
	inline bool use_texture(void);
	inline void use_texture(bool value);
	enum texture_map_type_enum {
		texture_map_type_AUTO = 0,
		texture_map_type_UV = 1,
	};
	inline texture_map_type_enum texture_map_type(void);
	inline void texture_map_type(texture_map_type_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Texture noise_texture(void);
	inline float texture_size(void);
	inline void texture_size(float value);
	inline float texture_offset(void);
	inline void texture_offset(float value);

};

/**************** Effector Settings ****************/

class FluidEffectorSettings : public Pointer {
public:
	FluidEffectorSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum effector_type_enum {
		effector_type_COLLISION = 0,
		effector_type_GUIDE = 1,
	};
	inline effector_type_enum effector_type(void);
	inline void effector_type(effector_type_enum value);
	inline float surface_distance(void);
	inline void surface_distance(float value);
	inline bool use_plane_init(void);
	inline void use_plane_init(bool value);
	inline float velocity_factor(void);
	inline void velocity_factor(float value);
	enum guide_mode_enum {
		guide_mode_MAXIMUM = 0,
		guide_mode_MINIMUM = 1,
		guide_mode_OVERRIDE = 2,
		guide_mode_AVERAGED = 3,
	};
	inline guide_mode_enum guide_mode(void);
	inline void guide_mode(guide_mode_enum value);
	inline bool use_effector(void);
	inline void use_effector(bool value);
	inline int subframes(void);
	inline void subframes(int value);

};

/**************** Material ****************/

class Material : public ID {
public:
	Material(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		texture_paint_images(ptr_arg),
		texture_paint_slots(ptr_arg)
		{}

	enum surface_render_method_enum {
		surface_render_method_DITHERED = 0,
		surface_render_method_BLENDED = 1,
	};
	inline surface_render_method_enum surface_render_method(void);
	inline void surface_render_method(surface_render_method_enum value);
	enum blend_method_enum {
		blend_method_OPAQUE = 0,
		blend_method_CLIP = 3,
		blend_method_HASHED = 4,
		blend_method_BLEND = 5,
	};
	inline blend_method_enum blend_method(void);
	inline void blend_method(blend_method_enum value);
	enum shadow_method_enum {
		shadow_method_NONE = 0,
		shadow_method_OPAQUE = 1,
		shadow_method_CLIP = 2,
		shadow_method_HASHED = 3,
	};
	inline shadow_method_enum shadow_method(void);
	inline void shadow_method(shadow_method_enum value);
	inline float alpha_threshold(void);
	inline void alpha_threshold(float value);
	inline bool show_transparent_back(void);
	inline void show_transparent_back(bool value);
	inline bool use_backface_culling(void);
	inline void use_backface_culling(bool value);
	inline bool use_backface_culling_shadow(void);
	inline void use_backface_culling_shadow(bool value);
	inline bool use_transparent_shadow(void);
	inline void use_transparent_shadow(bool value);
	inline bool lightprobe_volume_single_sided(void);
	inline void lightprobe_volume_single_sided(bool value);
	inline bool use_screen_refraction(void);
	inline void use_screen_refraction(bool value);
	inline bool use_sss_translucency(void);
	inline void use_sss_translucency(bool value);
	inline float refraction_depth(void);
	inline void refraction_depth(float value);
	enum volume_intersection_method_enum {
		volume_intersection_method_FAST = 0,
		volume_intersection_method_ACCURATE = 1,
	};
	inline volume_intersection_method_enum volume_intersection_method(void);
	inline void volume_intersection_method(volume_intersection_method_enum value);
	inline float max_vertex_displacement(void);
	inline void max_vertex_displacement(float value);
	enum preview_render_type_enum {
		preview_render_type_FLAT = 0,
		preview_render_type_SPHERE = 1,
		preview_render_type_CUBE = 2,
		preview_render_type_HAIR = 10,
		preview_render_type_SHADERBALL = 3,
		preview_render_type_CLOTH = 12,
		preview_render_type_FLUID = 13,
	};
	inline preview_render_type_enum preview_render_type(void);
	inline void preview_render_type(preview_render_type_enum value);
	inline bool use_preview_world(void);
	inline void use_preview_world(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Image, Material, texture_paint_images, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TexPaintSlot, Material, texture_paint_slots, false, false, false)
	inline int paint_active_slot(void);
	inline void paint_active_slot(int value);
	inline int paint_clone_slot(void);
	inline void paint_clone_slot(int value);
	inline Array<float, 4> diffuse_color(void);
	inline void diffuse_color(float values[4]);
	inline Array<float, 3> specular_color(void);
	inline void specular_color(float values[3]);
	inline float roughness(void);
	inline void roughness(float value);
	inline float specular_intensity(void);
	inline void specular_intensity(float value);
	inline float metallic(void);
	inline void metallic(float value);
	inline Array<float, 4> line_color(void);
	inline void line_color(float values[4]);
	inline int line_priority(void);
	inline void line_priority(int value);
	inline MaterialGPencilStyle grease_pencil(void);
	inline bool is_grease_pencil(void);
	inline void is_grease_pencil(bool value);
	inline MaterialLineArt lineart(void);

};

/**************** Texture Paint Slot ****************/

class TexPaintSlot : public Pointer {
public:
	TexPaintSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int icon_value(void);
	inline void icon_value(int value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline bool is_valid(void);
	inline void is_valid(bool value);

};

/**************** Grease Pencil Color ****************/

class MaterialGPencilStyle : public Pointer {
public:
	MaterialGPencilStyle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline Array<float, 4> fill_color(void);
	inline void fill_color(float values[4]);
	inline Array<float, 4> mix_color(void);
	inline void mix_color(float values[4]);
	inline float mix_factor(void);
	inline void mix_factor(float value);
	inline float mix_stroke_factor(void);
	inline void mix_stroke_factor(float value);
	inline float texture_angle(void);
	inline void texture_angle(float value);
	inline Array<float, 2> texture_scale(void);
	inline void texture_scale(float values[2]);
	inline Array<float, 2> texture_offset(void);
	inline void texture_offset(float values[2]);
	inline float pixel_size(void);
	inline void pixel_size(float value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool ghost(void);
	inline void ghost(bool value);
	inline bool texture_clamp(void);
	inline void texture_clamp(bool value);
	inline bool flip(void);
	inline void flip(bool value);
	inline bool use_overlap_strokes(void);
	inline void use_overlap_strokes(bool value);
	inline bool use_stroke_holdout(void);
	inline void use_stroke_holdout(bool value);
	inline bool use_fill_holdout(void);
	inline void use_fill_holdout(bool value);
	inline bool show_stroke(void);
	inline void show_stroke(bool value);
	inline bool show_fill(void);
	inline void show_fill(bool value);
	enum alignment_mode_enum {
		alignment_mode_PATH = 0,
		alignment_mode_OBJECT = 1,
		alignment_mode_FIXED = 2,
	};
	inline alignment_mode_enum alignment_mode(void);
	inline void alignment_mode(alignment_mode_enum value);
	inline float alignment_rotation(void);
	inline void alignment_rotation(float value);
	inline int pass_index(void);
	inline void pass_index(int value);
	enum mode_enum {
		mode_LINE = 0,
		mode_DOTS = 1,
		mode_BOX = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum stroke_style_enum {
		stroke_style_SOLID = 0,
		stroke_style_TEXTURE = 1,
	};
	inline stroke_style_enum stroke_style(void);
	inline void stroke_style(stroke_style_enum value);
	inline Image stroke_image(void);
	enum fill_style_enum {
		fill_style_SOLID = 0,
		fill_style_GRADIENT = 1,
		fill_style_TEXTURE = 3,
	};
	inline fill_style_enum fill_style(void);
	inline void fill_style(fill_style_enum value);
	enum gradient_type_enum {
		gradient_type_LINEAR = 0,
		gradient_type_RADIAL = 1,
	};
	inline gradient_type_enum gradient_type(void);
	inline void gradient_type(gradient_type_enum value);
	inline Image fill_image(void);
	inline bool is_stroke_visible(void);
	inline void is_stroke_visible(bool value);
	inline bool is_fill_visible(void);
	inline void is_fill_visible(bool value);

};

/**************** Material Line Art ****************/

class MaterialLineArt : public Pointer {
public:
	MaterialLineArt(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_material_mask(void);
	inline void use_material_mask(bool value);
	inline Array<bool, 8> use_material_mask_bits(void);
	inline void use_material_mask_bits(bool values[8]);
	inline int mat_occlusion(void);
	inline void mat_occlusion(int value);
	inline int intersection_priority(void);
	inline void intersection_priority(int value);
	inline bool use_intersection_priority_override(void);
	inline void use_intersection_priority_override(bool value);

};

/**************** Mesh ****************/

class Mesh : public ID {
public:
	Mesh(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		vertices(ptr_arg),
		edges(ptr_arg),
		loops(ptr_arg),
		polygons(ptr_arg),
		vertex_normals(ptr_arg),
		polygon_normals(ptr_arg),
		corner_normals(ptr_arg),
		loop_triangles(ptr_arg),
		loop_triangle_polygons(ptr_arg),
		uv_layers(ptr_arg),
		vertex_colors(ptr_arg),
		skin_vertices(ptr_arg),
		vertex_paint_masks(ptr_arg),
		attributes(ptr_arg),
		color_attributes(ptr_arg),
		materials(ptr_arg)
		{}

	COLLECTION_PROPERTY(MeshVertices, MeshVertex, Mesh, vertices, true, true, false)
	COLLECTION_PROPERTY(MeshEdges, MeshEdge, Mesh, edges, true, true, false)
	COLLECTION_PROPERTY(MeshLoops, MeshLoop, Mesh, loops, true, true, false)
	COLLECTION_PROPERTY(MeshPolygons, MeshPolygon, Mesh, polygons, true, true, false)
	enum normals_domain_enum {
		normals_domain_POINT = 1,
		normals_domain_FACE = 0,
		normals_domain_CORNER = 2,
	};
	inline normals_domain_enum normals_domain(void);
	inline void normals_domain(normals_domain_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshNormalValue, Mesh, vertex_normals, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshNormalValue, Mesh, polygon_normals, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshNormalValue, Mesh, corner_normals, true, true, false)
	COLLECTION_PROPERTY(MeshLoopTriangles, MeshLoopTriangle, Mesh, loop_triangles, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ReadOnlyInteger, Mesh, loop_triangle_polygons, true, true, false)
	inline Mesh texture_mesh(void);
	COLLECTION_PROPERTY(UVLoopLayers, MeshUVLoopLayer, Mesh, uv_layers, true, true, true)
	inline MeshUVLoopLayer uv_layer_clone(void);
	inline int uv_layer_clone_index(void);
	inline void uv_layer_clone_index(int value);
	inline MeshUVLoopLayer uv_layer_stencil(void);
	inline int uv_layer_stencil_index(void);
	inline void uv_layer_stencil_index(int value);
	COLLECTION_PROPERTY(LoopColors, MeshLoopColorLayer, Mesh, vertex_colors, true, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshSkinVertexLayer, Mesh, skin_vertices, true, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshPaintMaskLayer, Mesh, vertex_paint_masks, true, true, false)
	COLLECTION_PROPERTY(AttributeGroup, Attribute, Mesh, attributes, true, false, false)
	COLLECTION_PROPERTY(AttributeGroup, Attribute, Mesh, color_attributes, true, false, false)
	inline float remesh_voxel_size(void);
	inline void remesh_voxel_size(float value);
	inline float remesh_voxel_adaptivity(void);
	inline void remesh_voxel_adaptivity(float value);
	inline bool use_remesh_fix_poles(void);
	inline void use_remesh_fix_poles(bool value);
	inline bool use_remesh_preserve_volume(void);
	inline void use_remesh_preserve_volume(bool value);
	inline bool use_remesh_preserve_paint_mask(void);
	inline void use_remesh_preserve_paint_mask(bool value);
	inline bool use_remesh_preserve_sculpt_face_sets(void);
	inline void use_remesh_preserve_sculpt_face_sets(bool value);
	inline bool use_remesh_preserve_vertex_colors(void);
	inline void use_remesh_preserve_vertex_colors(bool value);
	enum remesh_mode_enum {
		remesh_mode_VOXEL = 0,
		remesh_mode_QUAD = 1,
	};
	inline remesh_mode_enum remesh_mode(void);
	inline void remesh_mode(remesh_mode_enum value);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool use_mirror_y(void);
	inline void use_mirror_y(bool value);
	inline bool use_mirror_z(void);
	inline void use_mirror_z(bool value);
	inline bool use_mirror_vertex_groups(void);
	inline void use_mirror_vertex_groups(bool value);
	inline bool has_custom_normals(void);
	inline void has_custom_normals(bool value);
	inline Mesh texco_mesh(void);
	inline Key shape_keys(void);
	inline bool use_auto_texspace(void);
	inline void use_auto_texspace(bool value);
	inline bool use_mirror_topology(void);
	inline void use_mirror_topology(bool value);
	inline bool use_paint_mask(void);
	inline void use_paint_mask(bool value);
	inline bool use_paint_mask_vertex(void);
	inline void use_paint_mask_vertex(bool value);
	inline int total_vert_sel(void);
	inline void total_vert_sel(int value);
	inline int total_edge_sel(void);
	inline void total_edge_sel(int value);
	inline int total_face_sel(void);
	inline void total_face_sel(int value);
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);
	inline bool auto_texspace(void);
	inline void auto_texspace(bool value);
	inline Array<float, 3> texspace_location(void);
	inline void texspace_location(float values[3]);
	inline Array<float, 3> texspace_size(void);
	inline void texspace_size(float values[3]);
	COLLECTION_PROPERTY(IDMaterials, Material, Mesh, materials, true, true, true)

	inline void transform(float matrix[16], bool shape_keys);
	inline void flip_normals();
	inline void set_sharp_from_angle(float angle);
	inline void split_faces();
	inline void calc_tangents(const char * uvmap);
	inline void free_tangents();
	inline void calc_loop_triangles();
	inline void calc_smooth_groups(bool use_bitflags, int *poly_groups_len, int **poly_groups, int *groups);
	inline void normals_split_custom_set(int normals_len, float *normals);
	inline void normals_split_custom_set_from_vertices(int normals_len, float *normals);
	inline void update(Context C, bool calc_edges, bool calc_edges_loose);
	inline void update_gpu_tag();
	inline const char * unit_test_compare(Mesh& mesh, float threshold);
	inline void clear_geometry();
	inline bool validate(bool verbose, bool clean_customdata);
	inline bool validate_material_indices();
	inline void count_selected_items(int result[3]);
};

/**************** Mesh Normal Vector ****************/

class MeshNormalValue : public Pointer {
public:
	MeshNormalValue(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> vector(void);
	inline void vector(float values[3]);

};

/**************** Read-only Integer ****************/

class ReadOnlyInteger : public Pointer {
public:
	ReadOnlyInteger(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int value(void);
	inline void value(int value);

};

/**************** Mesh Skin Vertex Layer ****************/

class MeshSkinVertexLayer : public Pointer {
public:
	MeshSkinVertexLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshSkinVertex, MeshSkinVertexLayer, data, true, true, false)

};

/**************** Skin Vertex ****************/

class MeshSkinVertex : public Pointer {
public:
	MeshSkinVertex(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> radius(void);
	inline void radius(float values[2]);
	inline bool use_root(void);
	inline void use_root(bool value);
	inline bool use_loose(void);
	inline void use_loose(bool value);

};

/**************** Mesh Paint Mask Layer ****************/

class MeshPaintMaskLayer : public Pointer {
public:
	MeshPaintMaskLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshPaintMaskProperty, MeshPaintMaskLayer, data, true, true, false)

};

/**************** Mesh Paint Mask Property ****************/

class MeshPaintMaskProperty : public Pointer {
public:
	MeshPaintMaskProperty(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float value(void);
	inline void value(float value);

};

/**************** Mesh Vertex ****************/

class MeshVertex : public Pointer {
public:
	MeshVertex(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		groups(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, VertexGroupElement, MeshVertex, groups, false, false, false)
	inline int index(void);
	inline void index(int value);
	inline Array<float, 3> undeformed_co(void);
	inline void undeformed_co(float values[3]);

};

/**************** Vertex Group Element ****************/

class VertexGroupElement : public Pointer {
public:
	VertexGroupElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int group(void);
	inline void group(int value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Mesh Edge ****************/

class MeshEdge : public Pointer {
public:
	MeshEdge(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<int, 2> vertices(void);
	inline void vertices(int values[2]);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool use_seam(void);
	inline void use_seam(bool value);
	inline bool use_edge_sharp(void);
	inline void use_edge_sharp(bool value);
	inline bool is_loose(void);
	inline void is_loose(bool value);
	inline bool use_freestyle_mark(void);
	inline void use_freestyle_mark(bool value);
	inline int index(void);
	inline void index(int value);

};

/**************** Mesh Loop Triangle ****************/

class MeshLoopTriangle : public Pointer {
public:
	MeshLoopTriangle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<int, 3> vertices(void);
	inline void vertices(int values[3]);
	inline Array<int, 3> loops(void);
	inline void loops(int values[3]);
	inline int polygon_index(void);
	inline void polygon_index(int value);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 9> split_normals(void);
	inline void split_normals(float values[9]);
	inline float area(void);
	inline void area(float value);
	inline int index(void);
	inline void index(int value);
	inline int material_index(void);
	inline void material_index(int value);
	inline bool use_smooth(void);
	inline void use_smooth(bool value);

};

/**************** Mesh Loop ****************/

class MeshLoop : public Pointer {
public:
	MeshLoop(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int vertex_index(void);
	inline void vertex_index(int value);
	inline int edge_index(void);
	inline void edge_index(int value);
	inline int index(void);
	inline void index(int value);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> tangent(void);
	inline void tangent(float values[3]);
	inline float bitangent_sign(void);
	inline void bitangent_sign(float value);
	inline Array<float, 3> bitangent(void);
	inline void bitangent(float values[3]);

};

/**************** Mesh Polygon ****************/

class MeshPolygon : public Pointer {
public:
	MeshPolygon(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<int, 3> vertices(void);
	inline void vertices(int values[3]);
	inline int loop_start(void);
	inline void loop_start(int value);
	inline int loop_total(void);
	inline void loop_total(int value);
	inline int material_index(void);
	inline void material_index(int value);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool use_smooth(void);
	inline void use_smooth(bool value);
	inline bool use_freestyle_mark(void);
	inline void use_freestyle_mark(bool value);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> center(void);
	inline void center(float values[3]);
	inline float area(void);
	inline void area(float value);
	inline int index(void);
	inline void index(int value);

	inline void flip();
};

/**************** MeshUVLoopLayer ****************/

class MeshUVLoopLayer : public Pointer {
public:
	MeshUVLoopLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg),
		uv(ptr_arg),
		vertex_selection(ptr_arg),
		edge_selection(ptr_arg),
		pin(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshUVLoop, MeshUVLoopLayer, data, true, true, false)
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool active(void);
	inline void active(bool value);
	inline bool active_render(void);
	inline void active_render(bool value);
	inline bool active_clone(void);
	inline void active_clone(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Float2AttributeValue, MeshUVLoopLayer, uv, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoolAttributeValue, MeshUVLoopLayer, vertex_selection, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoolAttributeValue, MeshUVLoopLayer, edge_selection, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, BoolAttributeValue, MeshUVLoopLayer, pin, true, true, false)

};

/**************** Mesh UV Layer ****************/

class MeshUVLoop : public Pointer {
public:
	MeshUVLoop(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> uv(void);
	inline void uv(float values[2]);
	inline bool pin_uv(void);
	inline void pin_uv(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_edge(void);
	inline void select_edge(bool value);

};

/**************** Mesh Vertex Color Layer ****************/

class MeshLoopColorLayer : public Pointer {
public:
	MeshLoopColorLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		data(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool active(void);
	inline void active(bool value);
	inline bool active_render(void);
	inline void active_render(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MeshLoopColor, MeshLoopColorLayer, data, true, true, false)

};

/**************** Mesh Vertex Color ****************/

class MeshLoopColor : public Pointer {
public:
	MeshLoopColor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);

};

/**************** Metaball Element ****************/

class MetaElement : public Pointer {
public:
	MetaElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_BALL = 0,
		type_CAPSULE = 4,
		type_PLANE = 5,
		type_ELLIPSOID = 6,
		type_CUBE = 7,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 4> rotation(void);
	inline void rotation(float values[4]);
	inline float radius(void);
	inline void radius(float value);
	inline float size_x(void);
	inline void size_x(float value);
	inline float size_y(void);
	inline void size_y(float value);
	inline float size_z(void);
	inline void size_z(float value);
	inline float stiffness(void);
	inline void stiffness(float value);
	inline bool use_negative(void);
	inline void use_negative(bool value);
	inline bool use_scale_stiffness(void);
	inline void use_scale_stiffness(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool hide(void);
	inline void hide(bool value);

};

/**************** MetaBall ****************/

class MetaBall : public ID {
public:
	MetaBall(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		elements(ptr_arg),
		materials(ptr_arg)
		{}

	COLLECTION_PROPERTY(MetaBallElements, MetaElement, MetaBall, elements, false, true, false)
	enum update_method_enum {
		update_method_UPDATE_ALWAYS = 0,
		update_method_HALFRES = 1,
		update_method_FAST = 2,
		update_method_NEVER = 3,
	};
	inline update_method_enum update_method(void);
	inline void update_method(update_method_enum value);
	inline float resolution(void);
	inline void resolution(float value);
	inline float render_resolution(void);
	inline void render_resolution(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline bool use_auto_texspace(void);
	inline void use_auto_texspace(bool value);
	inline Array<float, 3> texspace_location(void);
	inline void texspace_location(float values[3]);
	inline Array<float, 3> texspace_size(void);
	inline void texspace_size(float values[3]);
	COLLECTION_PROPERTY(IDMaterials, Material, MetaBall, materials, true, true, true)
	inline bool is_editmode(void);
	inline void is_editmode(bool value);
	inline AnimData animation_data(void);

	inline void transform(float matrix[16]);
	inline void update_gpu_tag();
};

/**************** Modifier ****************/

class Modifier : public Pointer {
public:
	Modifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_DATA_TRANSFER = 49,
		type_MESH_CACHE = 46,
		type_MESH_SEQUENCE_CACHE = 52,
		type_NORMAL_EDIT = 50,
		type_WEIGHTED_NORMAL = 54,
		type_UV_PROJECT = 15,
		type_UV_WARP = 45,
		type_VERTEX_WEIGHT_EDIT = 36,
		type_VERTEX_WEIGHT_MIX = 37,
		type_VERTEX_WEIGHT_PROXIMITY = 38,
		type_ARRAY = 12,
		type_BEVEL = 24,
		type_BOOLEAN = 11,
		type_BUILD = 4,
		type_DECIMATE = 6,
		type_EDGE_SPLIT = 13,
		type_NODES = 57,
		type_MASK = 27,
		type_MIRROR = 5,
		type_MESH_TO_VOLUME = 58,
		type_MULTIRES = 29,
		type_REMESH = 41,
		type_SCREW = 34,
		type_SKIN = 42,
		type_SOLIDIFY = 33,
		type_SUBSURF = 1,
		type_TRIANGULATE = 44,
		type_VOLUME_TO_MESH = 60,
		type_WELD = 55,
		type_WIREFRAME = 48,
		type_ARMATURE = 8,
		type_CAST = 17,
		type_CURVE = 3,
		type_DISPLACE = 14,
		type_HOOK = 9,
		type_LAPLACIANDEFORM = 47,
		type_LATTICE = 2,
		type_MESH_DEFORM = 18,
		type_SHRINKWRAP = 25,
		type_SIMPLE_DEFORM = 28,
		type_SMOOTH = 16,
		type_CORRECTIVE_SMOOTH = 51,
		type_LAPLACIANSMOOTH = 43,
		type_SURFACE_DEFORM = 53,
		type_WARP = 35,
		type_WAVE = 7,
		type_VOLUME_DISPLACE = 59,
		type_CLOTH = 22,
		type_COLLISION = 23,
		type_DYNAMIC_PAINT = 40,
		type_EXPLODE = 21,
		type_FLUID = 56,
		type_OCEAN = 39,
		type_PARTICLE_INSTANCE = 20,
		type_PARTICLE_SYSTEM = 19,
		type_SOFT_BODY = 10,
		type_SURFACE = 30,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_viewport(void);
	inline void show_viewport(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_in_editmode(void);
	inline void show_in_editmode(bool value);
	inline bool show_on_cage(void);
	inline void show_on_cage(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool is_active(void);
	inline void is_active(bool value);
	inline bool is_override_data(void);
	inline void is_override_data(bool value);
	inline bool use_apply_on_spline(void);
	inline void use_apply_on_spline(bool value);
	inline float execution_time(void);
	inline void execution_time(float value);

};

/**************** Subdivision Surface Modifier ****************/

class SubsurfModifier : public Modifier {
public:
	SubsurfModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum uv_smooth_enum {
		uv_smooth_NONE = 0,
		uv_smooth_PRESERVE_CORNERS = 1,
		uv_smooth_PRESERVE_CORNERS_AND_JUNCTIONS = 2,
		uv_smooth_PRESERVE_CORNERS_JUNCTIONS_AND_CONCAVE = 3,
		uv_smooth_PRESERVE_BOUNDARIES = 4,
		uv_smooth_SMOOTH_ALL = 5,
	};
	inline uv_smooth_enum uv_smooth(void);
	inline void uv_smooth(uv_smooth_enum value);
	inline int quality(void);
	inline void quality(int value);
	enum boundary_smooth_enum {
		boundary_smooth_PRESERVE_CORNERS = 1,
		boundary_smooth_ALL = 0,
	};
	inline boundary_smooth_enum boundary_smooth(void);
	inline void boundary_smooth(boundary_smooth_enum value);
	enum subdivision_type_enum {
		subdivision_type_CATMULL_CLARK = 0,
		subdivision_type_SIMPLE = 1,
	};
	inline subdivision_type_enum subdivision_type(void);
	inline void subdivision_type(subdivision_type_enum value);
	inline int levels(void);
	inline void levels(int value);
	inline int render_levels(void);
	inline void render_levels(int value);
	inline bool show_only_control_edges(void);
	inline void show_only_control_edges(bool value);
	inline bool use_creases(void);
	inline void use_creases(bool value);
	inline bool use_custom_normals(void);
	inline void use_custom_normals(bool value);
	inline bool use_limit_surface(void);
	inline void use_limit_surface(bool value);

};

/**************** Lattice Modifier ****************/

class LatticeModifier : public Modifier {
public:
	LatticeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline float strength(void);
	inline void strength(float value);

};

/**************** Curve Modifier ****************/

class CurveModifier : public Modifier {
public:
	CurveModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	enum deform_axis_enum {
		deform_axis_POS_X = 1,
		deform_axis_POS_Y = 2,
		deform_axis_POS_Z = 3,
		deform_axis_NEG_X = 4,
		deform_axis_NEG_Y = 5,
		deform_axis_NEG_Z = 6,
	};
	inline deform_axis_enum deform_axis(void);
	inline void deform_axis(deform_axis_enum value);

};

/**************** Build Modifier ****************/

class BuildModifier : public Modifier {
public:
	BuildModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_duration(void);
	inline void frame_duration(float value);
	inline bool use_reverse(void);
	inline void use_reverse(bool value);
	inline bool use_random_order(void);
	inline void use_random_order(bool value);
	inline int seed(void);
	inline void seed(int value);

};

/**************** Mirror Modifier ****************/

class MirrorModifier : public Modifier {
public:
	MirrorModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Array<bool, 3> use_axis(void);
	inline void use_axis(bool values[3]);
	inline Array<bool, 3> use_bisect_axis(void);
	inline void use_bisect_axis(bool values[3]);
	inline Array<bool, 3> use_bisect_flip_axis(void);
	inline void use_bisect_flip_axis(bool values[3]);
	inline bool use_clip(void);
	inline void use_clip(bool value);
	inline bool use_mirror_vertex_groups(void);
	inline void use_mirror_vertex_groups(bool value);
	inline bool use_mirror_merge(void);
	inline void use_mirror_merge(bool value);
	inline bool use_mirror_u(void);
	inline void use_mirror_u(bool value);
	inline bool use_mirror_v(void);
	inline void use_mirror_v(bool value);
	inline bool use_mirror_udim(void);
	inline void use_mirror_udim(bool value);
	inline float mirror_offset_u(void);
	inline void mirror_offset_u(float value);
	inline float mirror_offset_v(void);
	inline void mirror_offset_v(float value);
	inline float offset_u(void);
	inline void offset_u(float value);
	inline float offset_v(void);
	inline void offset_v(float value);
	inline float merge_threshold(void);
	inline void merge_threshold(float value);
	inline float bisect_threshold(void);
	inline void bisect_threshold(float value);
	inline Object mirror_object(void);

};

/**************** Decimate Modifier ****************/

class DecimateModifier : public Modifier {
public:
	DecimateModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum decimate_type_enum {
		decimate_type_COLLAPSE = 0,
		decimate_type_UNSUBDIV = 1,
		decimate_type_DISSOLVE = 2,
	};
	inline decimate_type_enum decimate_type(void);
	inline void decimate_type(decimate_type_enum value);
	inline float ratio(void);
	inline void ratio(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline float angle_limit(void);
	inline void angle_limit(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_collapse_triangulate(void);
	inline void use_collapse_triangulate(bool value);
	inline bool use_symmetry(void);
	inline void use_symmetry(bool value);
	enum symmetry_axis_enum {
		symmetry_axis_X = 0,
		symmetry_axis_Y = 1,
		symmetry_axis_Z = 2,
	};
	inline symmetry_axis_enum symmetry_axis(void);
	inline void symmetry_axis(symmetry_axis_enum value);
	inline float vertex_group_factor(void);
	inline void vertex_group_factor(float value);
	inline bool use_dissolve_boundaries(void);
	inline void use_dissolve_boundaries(bool value);
	enum delimit_enum {
		delimit_NORMAL = 1,
		delimit_MATERIAL = 2,
		delimit_SEAM = 4,
		delimit_SHARP = 8,
		delimit_UV = 16,
	};
	inline delimit_enum delimit(void);
	inline void delimit(delimit_enum value);
	inline int face_count(void);
	inline void face_count(int value);

};

/**************** Wave Modifier ****************/

class WaveModifier : public Modifier {
public:
	WaveModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool use_normal(void);
	inline void use_normal(bool value);
	inline bool use_normal_x(void);
	inline void use_normal_x(bool value);
	inline bool use_normal_y(void);
	inline void use_normal_y(bool value);
	inline bool use_normal_z(void);
	inline void use_normal_z(bool value);
	inline float time_offset(void);
	inline void time_offset(float value);
	inline float lifetime(void);
	inline void lifetime(float value);
	inline float damping_time(void);
	inline void damping_time(float value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline float start_position_x(void);
	inline void start_position_x(float value);
	inline float start_position_y(void);
	inline void start_position_y(float value);
	inline Object start_position_object(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline float speed(void);
	inline void speed(float value);
	inline float height(void);
	inline void height(float value);
	inline float width(void);
	inline void width(float value);
	inline float narrowness(void);
	inline void narrowness(float value);
	inline Texture texture(void);
	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Object texture_coords_object(void);
	inline std::string texture_coords_bone(void);
	inline void texture_coords_bone(const std::string& value);

};

/**************** Armature Modifier ****************/

class ArmatureModifier : public Modifier {
public:
	ArmatureModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_bone_envelopes(void);
	inline void use_bone_envelopes(bool value);
	inline bool use_vertex_groups(void);
	inline void use_vertex_groups(bool value);
	inline bool use_deform_preserve_volume(void);
	inline void use_deform_preserve_volume(bool value);
	inline bool use_multi_modifier(void);
	inline void use_multi_modifier(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Hook Modifier ****************/

class HookModifier : public Modifier {
public:
	HookModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float strength(void);
	inline void strength(float value);
	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline CurveMapping falloff_curve(void);
	inline Array<float, 3> center(void);
	inline void center(float values[3]);
	inline Array<float, 16> matrix_inverse(void);
	inline void matrix_inverse(float values[16]);
	inline Object object(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline bool use_falloff_uniform(void);
	inline void use_falloff_uniform(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline Array<int, 32> vertex_indices(void);
	inline void vertex_indices(int values[32]);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

	inline void vertex_indices_set(int indices_len, int *indices);
};

/**************** Soft Body Modifier ****************/

class SoftBodyModifier : public Modifier {
public:
	SoftBodyModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline SoftBodySettings settings(void);
	inline PointCache point_cache(void);

};

/**************** Boolean Modifier ****************/

class BooleanModifier : public Modifier {
public:
	BooleanModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline Collection collection(void);
	enum operation_enum {
		operation_INTERSECT = 0,
		operation_UNION = 1,
		operation_DIFFERENCE = 2,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	enum operand_type_enum {
		operand_type_OBJECT = 2,
		operand_type_COLLECTION = 4,
	};
	inline operand_type_enum operand_type(void);
	inline void operand_type(operand_type_enum value);
	inline float double_threshold(void);
	inline void double_threshold(float value);
	enum solver_enum {
		solver_FAST = 0,
		solver_EXACT = 1,
	};
	inline solver_enum solver(void);
	inline void solver(solver_enum value);
	inline bool use_self(void);
	inline void use_self(bool value);
	inline bool use_hole_tolerant(void);
	inline void use_hole_tolerant(bool value);
	enum material_mode_enum {
		material_mode_INDEX = 0,
		material_mode_TRANSFER = 1,
	};
	inline material_mode_enum material_mode(void);
	inline void material_mode(material_mode_enum value);
	enum debug_options_enum {
		debug_options_SEPARATE = 1,
		debug_options_NO_DISSOLVE = 2,
		debug_options_NO_CONNECT_REGIONS = 4,
	};
	inline debug_options_enum debug_options(void);
	inline void debug_options(debug_options_enum value);

};

/**************** Array Modifier ****************/

class ArrayModifier : public Modifier {
public:
	ArrayModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum fit_type_enum {
		fit_type_FIXED_COUNT = 0,
		fit_type_FIT_LENGTH = 1,
		fit_type_FIT_CURVE = 2,
	};
	inline fit_type_enum fit_type(void);
	inline void fit_type(fit_type_enum value);
	inline int count(void);
	inline void count(int value);
	inline float fit_length(void);
	inline void fit_length(float value);
	inline Object curve(void);
	inline bool use_constant_offset(void);
	inline void use_constant_offset(bool value);
	inline Array<float, 3> constant_offset_displace(void);
	inline void constant_offset_displace(float values[3]);
	inline bool use_relative_offset(void);
	inline void use_relative_offset(bool value);
	inline Array<float, 3> relative_offset_displace(void);
	inline void relative_offset_displace(float values[3]);
	inline bool use_merge_vertices(void);
	inline void use_merge_vertices(bool value);
	inline bool use_merge_vertices_cap(void);
	inline void use_merge_vertices_cap(bool value);
	inline float merge_threshold(void);
	inline void merge_threshold(float value);
	inline bool use_object_offset(void);
	inline void use_object_offset(bool value);
	inline Object offset_object(void);
	inline Object start_cap(void);
	inline Object end_cap(void);
	inline float offset_u(void);
	inline void offset_u(float value);
	inline float offset_v(void);
	inline void offset_v(float value);

};

/**************** EdgeSplit Modifier ****************/

class EdgeSplitModifier : public Modifier {
public:
	EdgeSplitModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float split_angle(void);
	inline void split_angle(float value);
	inline bool use_edge_angle(void);
	inline void use_edge_angle(bool value);
	inline bool use_edge_sharp(void);
	inline void use_edge_sharp(bool value);

};

/**************** Displace Modifier ****************/

class DisplaceModifier : public Modifier {
public:
	DisplaceModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float mid_level(void);
	inline void mid_level(float value);
	inline float strength(void);
	inline void strength(float value);
	enum direction_enum {
		direction_X = 0,
		direction_Y = 1,
		direction_Z = 2,
		direction_NORMAL = 3,
		direction_CUSTOM_NORMAL = 5,
		direction_RGB_TO_XYZ = 4,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	enum space_enum {
		space_LOCAL = 0,
		space_GLOBAL = 1,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline Texture texture(void);
	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Object texture_coords_object(void);
	inline std::string texture_coords_bone(void);
	inline void texture_coords_bone(const std::string& value);

};

/**************** UV Project Modifier ****************/

class UVProjectModifier : public Modifier {
public:
	UVProjectModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg),
		projectors(ptr_arg)
		{}

	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline int projector_count(void);
	inline void projector_count(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UVProjector, UVProjectModifier, projectors, false, true, false)
	inline float aspect_x(void);
	inline void aspect_x(float value);
	inline float aspect_y(void);
	inline void aspect_y(float value);
	inline float scale_x(void);
	inline void scale_x(float value);
	inline float scale_y(void);
	inline void scale_y(float value);

};

/**************** UVProjector ****************/

class UVProjector : public Pointer {
public:
	UVProjector(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object object(void);

};

/**************** Smooth Modifier ****************/

class SmoothModifier : public Modifier {
public:
	SmoothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline float factor(void);
	inline void factor(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Corrective Smooth Modifier ****************/

class CorrectiveSmoothModifier : public Modifier {
public:
	CorrectiveSmoothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float factor(void);
	inline void factor(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline float scale(void);
	inline void scale(float value);
	enum rest_source_enum {
		rest_source_ORCO = 0,
		rest_source_BIND = 1,
	};
	inline rest_source_enum rest_source(void);
	inline void rest_source(rest_source_enum value);
	enum smooth_type_enum {
		smooth_type_SIMPLE = 0,
		smooth_type_LENGTH_WEIGHTED = 1,
	};
	inline smooth_type_enum smooth_type(void);
	inline void smooth_type(smooth_type_enum value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool is_bind(void);
	inline void is_bind(bool value);
	inline bool use_only_smooth(void);
	inline void use_only_smooth(bool value);
	inline bool use_pin_boundary(void);
	inline void use_pin_boundary(bool value);

};

/**************** Cast Modifier ****************/

class CastModifier : public Modifier {
public:
	CastModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum cast_type_enum {
		cast_type_SPHERE = 0,
		cast_type_CYLINDER = 1,
		cast_type_CUBOID = 2,
	};
	inline cast_type_enum cast_type(void);
	inline void cast_type(cast_type_enum value);
	inline Object object(void);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool use_radius_as_size(void);
	inline void use_radius_as_size(bool value);
	inline bool use_transform(void);
	inline void use_transform(bool value);
	inline float factor(void);
	inline void factor(float value);
	inline float radius(void);
	inline void radius(float value);
	inline float size(void);
	inline void size(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);

};

/**************** MeshDeform Modifier ****************/

class MeshDeformModifier : public Modifier {
public:
	MeshDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool is_bound(void);
	inline void is_bound(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int precision(void);
	inline void precision(int value);
	inline bool use_dynamic_bind(void);
	inline void use_dynamic_bind(bool value);

};

/**************** ParticleSystem Modifier ****************/

class ParticleSystemModifier : public Modifier {
public:
	ParticleSystemModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline ParticleSystem particle_system(void);

};

/**************** ParticleInstance Modifier ****************/

class ParticleInstanceModifier : public Modifier {
public:
	ParticleInstanceModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline int particle_system_index(void);
	inline void particle_system_index(int value);
	inline ParticleSystem particle_system(void);
	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	enum space_enum {
		space_LOCAL = 1,
		space_WORLD = 0,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline bool use_normal(void);
	inline void use_normal(bool value);
	inline bool use_children(void);
	inline void use_children(bool value);
	inline bool use_path(void);
	inline void use_path(bool value);
	inline bool show_unborn(void);
	inline void show_unborn(bool value);
	inline bool show_alive(void);
	inline void show_alive(bool value);
	inline bool show_dead(void);
	inline void show_dead(bool value);
	inline bool use_preserve_shape(void);
	inline void use_preserve_shape(bool value);
	inline bool use_size(void);
	inline void use_size(bool value);
	inline float position(void);
	inline void position(float value);
	inline float random_position(void);
	inline void random_position(float value);
	inline float rotation(void);
	inline void rotation(float value);
	inline float random_rotation(void);
	inline void random_rotation(float value);
	inline float particle_amount(void);
	inline void particle_amount(float value);
	inline float particle_offset(void);
	inline void particle_offset(float value);
	inline std::string index_layer_name(void);
	inline void index_layer_name(const std::string& value);
	inline std::string value_layer_name(void);
	inline void value_layer_name(const std::string& value);

};

/**************** Explode Modifier ****************/

class ExplodeModifier : public Modifier {
public:
	ExplodeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float protect(void);
	inline void protect(float value);
	inline bool use_edge_cut(void);
	inline void use_edge_cut(bool value);
	inline bool show_unborn(void);
	inline void show_unborn(bool value);
	inline bool show_alive(void);
	inline void show_alive(bool value);
	inline bool show_dead(void);
	inline void show_dead(bool value);
	inline bool use_size(void);
	inline void use_size(bool value);
	inline std::string particle_uv(void);
	inline void particle_uv(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Cloth Modifier ****************/

class ClothModifier : public Modifier {
public:
	ClothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline ClothSettings settings(void);
	inline ClothCollisionSettings collision_settings(void);
	inline ClothSolverResult solver_result(void);
	inline PointCache point_cache(void);
	inline Array<float, 3> hair_grid_min(void);
	inline void hair_grid_min(float values[3]);
	inline Array<float, 3> hair_grid_max(void);
	inline void hair_grid_max(float values[3]);
	inline Array<int, 3> hair_grid_resolution(void);
	inline void hair_grid_resolution(int values[3]);

};

/**************** Collision Modifier ****************/

class CollisionModifier : public Modifier {
public:
	CollisionModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline CollisionSettings settings(void);

};

/**************** Bevel Modifier ****************/

class BevelModifier : public Modifier {
public:
	BevelModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float width(void);
	inline void width(float value);
	inline float width_pct(void);
	inline void width_pct(float value);
	inline int segments(void);
	inline void segments(int value);
	enum affect_enum {
		affect_VERTICES = 0,
		affect_EDGES = 1,
	};
	inline affect_enum affect(void);
	inline void affect(affect_enum value);
	enum limit_method_enum {
		limit_method_NONE = 0,
		limit_method_ANGLE = 8,
		limit_method_WEIGHT = 16,
		limit_method_VGROUP = 32,
	};
	inline limit_method_enum limit_method(void);
	inline void limit_method(limit_method_enum value);
	inline float angle_limit(void);
	inline void angle_limit(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_clamp_overlap(void);
	inline void use_clamp_overlap(bool value);
	enum offset_type_enum {
		offset_type_OFFSET = 0,
		offset_type_WIDTH = 1,
		offset_type_DEPTH = 2,
		offset_type_PERCENT = 3,
		offset_type_ABSOLUTE = 4,
	};
	inline offset_type_enum offset_type(void);
	inline void offset_type(offset_type_enum value);
	enum profile_type_enum {
		profile_type_SUPERELLIPSE = 0,
		profile_type_CUSTOM = 1,
	};
	inline profile_type_enum profile_type(void);
	inline void profile_type(profile_type_enum value);
	inline float profile(void);
	inline void profile(float value);
	inline int material(void);
	inline void material(int value);
	inline bool loop_slide(void);
	inline void loop_slide(bool value);
	inline bool mark_seam(void);
	inline void mark_seam(bool value);
	inline bool mark_sharp(void);
	inline void mark_sharp(bool value);
	inline bool harden_normals(void);
	inline void harden_normals(bool value);
	enum face_strength_mode_enum {
		face_strength_mode_FSTR_NONE = 0,
		face_strength_mode_FSTR_NEW = 1,
		face_strength_mode_FSTR_AFFECTED = 2,
		face_strength_mode_FSTR_ALL = 3,
	};
	inline face_strength_mode_enum face_strength_mode(void);
	inline void face_strength_mode(face_strength_mode_enum value);
	enum miter_outer_enum {
		miter_outer_MITER_SHARP = 0,
		miter_outer_MITER_PATCH = 1,
		miter_outer_MITER_ARC = 2,
	};
	inline miter_outer_enum miter_outer(void);
	inline void miter_outer(miter_outer_enum value);
	enum miter_inner_enum {
		miter_inner_MITER_SHARP = 0,
		miter_inner_MITER_ARC = 2,
	};
	inline miter_inner_enum miter_inner(void);
	inline void miter_inner(miter_inner_enum value);
	inline float spread(void);
	inline void spread(float value);
	inline CurveProfile custom_profile(void);
	enum vmesh_method_enum {
		vmesh_method_ADJ = 0,
		vmesh_method_CUTOFF = 1,
	};
	inline vmesh_method_enum vmesh_method(void);
	inline void vmesh_method(vmesh_method_enum value);

};

/**************** Shrinkwrap Modifier ****************/

class ShrinkwrapModifier : public Modifier {
public:
	ShrinkwrapModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum wrap_method_enum {
		wrap_method_NEAREST_SURFACEPOINT = 0,
		wrap_method_PROJECT = 1,
		wrap_method_NEAREST_VERTEX = 2,
		wrap_method_TARGET_PROJECT = 3,
	};
	inline wrap_method_enum wrap_method(void);
	inline void wrap_method(wrap_method_enum value);
	enum wrap_mode_enum {
		wrap_mode_ON_SURFACE = 0,
		wrap_mode_INSIDE = 1,
		wrap_mode_OUTSIDE = 2,
		wrap_mode_OUTSIDE_SURFACE = 3,
		wrap_mode_ABOVE_SURFACE = 4,
	};
	inline wrap_mode_enum wrap_mode(void);
	inline void wrap_mode(wrap_mode_enum value);
	enum cull_face_enum {
		cull_face_OFF = 0,
		cull_face_FRONT = 8,
		cull_face_BACK = 16,
	};
	inline cull_face_enum cull_face(void);
	inline void cull_face(cull_face_enum value);
	inline Object target(void);
	inline Object auxiliary_target(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float offset(void);
	inline void offset(float value);
	inline float project_limit(void);
	inline void project_limit(float value);
	inline bool use_project_x(void);
	inline void use_project_x(bool value);
	inline bool use_project_y(void);
	inline void use_project_y(bool value);
	inline bool use_project_z(void);
	inline void use_project_z(bool value);
	inline int subsurf_levels(void);
	inline void subsurf_levels(int value);
	inline bool use_negative_direction(void);
	inline void use_negative_direction(bool value);
	inline bool use_positive_direction(void);
	inline void use_positive_direction(bool value);
	inline bool use_invert_cull(void);
	inline void use_invert_cull(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Mask Modifier ****************/

class MaskModifier : public Modifier {
public:
	MaskModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum mode_enum {
		mode_VERTEX_GROUP = 0,
		mode_ARMATURE = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Object armature(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_smooth(void);
	inline void use_smooth(bool value);
	inline float threshold(void);
	inline void threshold(float value);

};

/**************** SimpleDeform Modifier ****************/

class SimpleDeformModifier : public Modifier {
public:
	SimpleDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum deform_method_enum {
		deform_method_TWIST = 1,
		deform_method_BEND = 2,
		deform_method_TAPER = 3,
		deform_method_STRETCH = 4,
	};
	inline deform_method_enum deform_method(void);
	inline void deform_method(deform_method_enum value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	enum deform_axis_enum {
		deform_axis_X = 0,
		deform_axis_Y = 1,
		deform_axis_Z = 2,
	};
	inline deform_axis_enum deform_axis(void);
	inline void deform_axis(deform_axis_enum value);
	inline Object origin(void);
	inline float factor(void);
	inline void factor(float value);
	inline float angle(void);
	inline void angle(float value);
	inline Array<float, 2> limits(void);
	inline void limits(float values[2]);
	inline bool lock_x(void);
	inline void lock_x(bool value);
	inline bool lock_y(void);
	inline void lock_y(bool value);
	inline bool lock_z(void);
	inline void lock_z(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Warp Modifier ****************/

class WarpModifier : public Modifier {
public:
	WarpModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object_from(void);
	inline std::string bone_from(void);
	inline void bone_from(const std::string& value);
	inline Object object_to(void);
	inline std::string bone_to(void);
	inline void bone_to(const std::string& value);
	inline float strength(void);
	inline void strength(float value);
	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline CurveMapping falloff_curve(void);
	inline bool use_volume_preserve(void);
	inline void use_volume_preserve(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline Texture texture(void);
	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	inline Object texture_coords_object(void);
	inline std::string texture_coords_bone(void);
	inline void texture_coords_bone(const std::string& value);

};

/**************** Multires Modifier ****************/

class MultiresModifier : public Modifier {
public:
	MultiresModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum uv_smooth_enum {
		uv_smooth_NONE = 0,
		uv_smooth_PRESERVE_CORNERS = 1,
		uv_smooth_PRESERVE_CORNERS_AND_JUNCTIONS = 2,
		uv_smooth_PRESERVE_CORNERS_JUNCTIONS_AND_CONCAVE = 3,
		uv_smooth_PRESERVE_BOUNDARIES = 4,
		uv_smooth_SMOOTH_ALL = 5,
	};
	inline uv_smooth_enum uv_smooth(void);
	inline void uv_smooth(uv_smooth_enum value);
	inline int quality(void);
	inline void quality(int value);
	enum boundary_smooth_enum {
		boundary_smooth_PRESERVE_CORNERS = 1,
		boundary_smooth_ALL = 0,
	};
	inline boundary_smooth_enum boundary_smooth(void);
	inline void boundary_smooth(boundary_smooth_enum value);
	inline int levels(void);
	inline void levels(int value);
	inline int sculpt_levels(void);
	inline void sculpt_levels(int value);
	inline int render_levels(void);
	inline void render_levels(int value);
	inline int total_levels(void);
	inline void total_levels(int value);
	inline bool is_external(void);
	inline void is_external(bool value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool show_only_control_edges(void);
	inline void show_only_control_edges(bool value);
	inline bool use_creases(void);
	inline void use_creases(bool value);
	inline bool use_custom_normals(void);
	inline void use_custom_normals(bool value);
	inline bool use_sculpt_base_mesh(void);
	inline void use_sculpt_base_mesh(bool value);

};

/**************** Surface Modifier ****************/

class SurfaceModifier : public Modifier {
public:
	SurfaceModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}


};

/**************** Fluid Modifier ****************/

class FluidModifier : public Modifier {
public:
	FluidModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline FluidDomainSettings domain_settings(void);
	inline FluidFlowSettings flow_settings(void);
	inline FluidEffectorSettings effector_settings(void);
	enum fluid_type_enum {
		fluid_type_NONE = 0,
		fluid_type_DOMAIN = 1,
		fluid_type_FLOW = 2,
		fluid_type_EFFECTOR = 4,
	};
	inline fluid_type_enum fluid_type(void);
	inline void fluid_type(fluid_type_enum value);

};

/**************** Solidify Modifier ****************/

class SolidifyModifier : public Modifier {
public:
	SolidifyModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum solidify_mode_enum {
		solidify_mode_EXTRUDE = 0,
		solidify_mode_NON_MANIFOLD = 1,
	};
	inline solidify_mode_enum solidify_mode(void);
	inline void solidify_mode(solidify_mode_enum value);
	inline float thickness(void);
	inline void thickness(float value);
	inline float thickness_clamp(void);
	inline void thickness_clamp(float value);
	inline bool use_thickness_angle_clamp(void);
	inline void use_thickness_angle_clamp(bool value);
	inline float thickness_vertex_group(void);
	inline void thickness_vertex_group(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float edge_crease_inner(void);
	inline void edge_crease_inner(float value);
	inline float edge_crease_outer(void);
	inline void edge_crease_outer(float value);
	inline float edge_crease_rim(void);
	inline void edge_crease_rim(float value);
	inline int material_offset(void);
	inline void material_offset(int value);
	inline int material_offset_rim(void);
	inline void material_offset_rim(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline std::string shell_vertex_group(void);
	inline void shell_vertex_group(const std::string& value);
	inline std::string rim_vertex_group(void);
	inline void rim_vertex_group(const std::string& value);
	inline bool use_rim(void);
	inline void use_rim(bool value);
	inline bool use_even_offset(void);
	inline void use_even_offset(bool value);
	inline bool use_quality_normals(void);
	inline void use_quality_normals(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_flat_faces(void);
	inline void use_flat_faces(bool value);
	inline bool use_flip_normals(void);
	inline void use_flip_normals(bool value);
	inline bool use_rim_only(void);
	inline void use_rim_only(bool value);
	enum nonmanifold_thickness_mode_enum {
		nonmanifold_thickness_mode_FIXED = 0,
		nonmanifold_thickness_mode_EVEN = 1,
		nonmanifold_thickness_mode_CONSTRAINTS = 2,
	};
	inline nonmanifold_thickness_mode_enum nonmanifold_thickness_mode(void);
	inline void nonmanifold_thickness_mode(nonmanifold_thickness_mode_enum value);
	enum nonmanifold_boundary_mode_enum {
		nonmanifold_boundary_mode_NONE = 0,
		nonmanifold_boundary_mode_ROUND = 1,
		nonmanifold_boundary_mode_FLAT = 2,
	};
	inline nonmanifold_boundary_mode_enum nonmanifold_boundary_mode(void);
	inline void nonmanifold_boundary_mode(nonmanifold_boundary_mode_enum value);
	inline float nonmanifold_merge_threshold(void);
	inline void nonmanifold_merge_threshold(float value);
	inline float bevel_convex(void);
	inline void bevel_convex(float value);

};

/**************** Screw Modifier ****************/

class ScrewModifier : public Modifier {
public:
	ScrewModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline int steps(void);
	inline void steps(int value);
	inline int render_steps(void);
	inline void render_steps(int value);
	inline int iterations(void);
	inline void iterations(int value);
	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	inline float angle(void);
	inline void angle(float value);
	inline float screw_offset(void);
	inline void screw_offset(float value);
	inline float merge_threshold(void);
	inline void merge_threshold(float value);
	inline bool use_normal_flip(void);
	inline void use_normal_flip(bool value);
	inline bool use_normal_calculate(void);
	inline void use_normal_calculate(bool value);
	inline bool use_object_screw_offset(void);
	inline void use_object_screw_offset(bool value);
	inline bool use_merge_vertices(void);
	inline void use_merge_vertices(bool value);
	inline bool use_smooth_shade(void);
	inline void use_smooth_shade(bool value);
	inline bool use_stretch_u(void);
	inline void use_stretch_u(bool value);
	inline bool use_stretch_v(void);
	inline void use_stretch_v(bool value);

};

/**************** UVWarp Modifier ****************/

class UVWarpModifier : public Modifier {
public:
	UVWarpModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum axis_u_enum {
		axis_u_X = 0,
		axis_u_Y = 1,
		axis_u_Z = 2,
	};
	inline axis_u_enum axis_u(void);
	inline void axis_u(axis_u_enum value);
	enum axis_v_enum {
		axis_v_X = 0,
		axis_v_Y = 1,
		axis_v_Z = 2,
	};
	inline axis_v_enum axis_v(void);
	inline void axis_v(axis_v_enum value);
	inline Array<float, 2> center(void);
	inline void center(float values[2]);
	inline Array<float, 2> offset(void);
	inline void offset(float values[2]);
	inline Array<float, 2> scale(void);
	inline void scale(float values[2]);
	inline float rotation(void);
	inline void rotation(float value);
	inline Object object_from(void);
	inline std::string bone_from(void);
	inline void bone_from(const std::string& value);
	inline Object object_to(void);
	inline std::string bone_to(void);
	inline void bone_to(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);

};

/**************** WeightVG Edit Modifier ****************/

class VertexWeightEditModifier : public Modifier {
public:
	VertexWeightEditModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	enum falloff_type_enum {
		falloff_type_LINEAR = 0,
		falloff_type_CURVE = 1,
		falloff_type_SHARP = 2,
		falloff_type_SMOOTH = 3,
		falloff_type_ROOT = 4,
		falloff_type_ICON_SPHERECURVE = 7,
		falloff_type_RANDOM = 8,
		falloff_type_STEP = 9,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline bool invert_falloff(void);
	inline void invert_falloff(bool value);
	inline bool normalize(void);
	inline void normalize(bool value);
	inline CurveMapping map_curve(void);
	inline bool use_add(void);
	inline void use_add(bool value);
	inline bool use_remove(void);
	inline void use_remove(bool value);
	inline float default_weight(void);
	inline void default_weight(float value);
	inline float add_threshold(void);
	inline void add_threshold(float value);
	inline float remove_threshold(void);
	inline void remove_threshold(float value);
	inline float mask_constant(void);
	inline void mask_constant(float value);
	inline std::string mask_vertex_group(void);
	inline void mask_vertex_group(const std::string& value);
	inline bool invert_mask_vertex_group(void);
	inline void invert_mask_vertex_group(bool value);
	inline Texture mask_texture(void);
	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};
	inline mask_tex_use_channel_enum mask_tex_use_channel(void);
	inline void mask_tex_use_channel(mask_tex_use_channel_enum value);
	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};
	inline mask_tex_mapping_enum mask_tex_mapping(void);
	inline void mask_tex_mapping(mask_tex_mapping_enum value);
	inline std::string mask_tex_uv_layer(void);
	inline void mask_tex_uv_layer(const std::string& value);
	inline Object mask_tex_map_object(void);
	inline std::string mask_tex_map_bone(void);
	inline void mask_tex_map_bone(const std::string& value);

};

/**************** WeightVG Mix Modifier ****************/

class VertexWeightMixModifier : public Modifier {
public:
	VertexWeightMixModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group_a(void);
	inline void vertex_group_a(const std::string& value);
	inline std::string vertex_group_b(void);
	inline void vertex_group_b(const std::string& value);
	inline bool invert_vertex_group_a(void);
	inline void invert_vertex_group_a(bool value);
	inline bool invert_vertex_group_b(void);
	inline void invert_vertex_group_b(bool value);
	inline float default_weight_a(void);
	inline void default_weight_a(float value);
	inline float default_weight_b(void);
	inline void default_weight_b(float value);
	enum mix_mode_enum {
		mix_mode_SET = 1,
		mix_mode_ADD = 2,
		mix_mode_SUB = 3,
		mix_mode_MUL = 4,
		mix_mode_DIV = 5,
		mix_mode_DIF = 6,
		mix_mode_AVG = 7,
		mix_mode_MIN = 8,
		mix_mode_MAX = 9,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	enum mix_set_enum {
		mix_set_ALL = 1,
		mix_set_A = 2,
		mix_set_B = 3,
		mix_set_OR = 4,
		mix_set_AND = 5,
	};
	inline mix_set_enum mix_set(void);
	inline void mix_set(mix_set_enum value);
	inline bool normalize(void);
	inline void normalize(bool value);
	inline float mask_constant(void);
	inline void mask_constant(float value);
	inline std::string mask_vertex_group(void);
	inline void mask_vertex_group(const std::string& value);
	inline bool invert_mask_vertex_group(void);
	inline void invert_mask_vertex_group(bool value);
	inline Texture mask_texture(void);
	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};
	inline mask_tex_use_channel_enum mask_tex_use_channel(void);
	inline void mask_tex_use_channel(mask_tex_use_channel_enum value);
	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};
	inline mask_tex_mapping_enum mask_tex_mapping(void);
	inline void mask_tex_mapping(mask_tex_mapping_enum value);
	inline std::string mask_tex_uv_layer(void);
	inline void mask_tex_uv_layer(const std::string& value);
	inline Object mask_tex_map_object(void);
	inline std::string mask_tex_map_bone(void);
	inline void mask_tex_map_bone(const std::string& value);

};

/**************** WeightVG Proximity Modifier ****************/

class VertexWeightProximityModifier : public Modifier {
public:
	VertexWeightProximityModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	enum proximity_mode_enum {
		proximity_mode_OBJECT = 1,
		proximity_mode_GEOMETRY = 2,
	};
	inline proximity_mode_enum proximity_mode(void);
	inline void proximity_mode(proximity_mode_enum value);
	enum proximity_geometry_enum {
		proximity_geometry_VERTEX = 1,
		proximity_geometry_EDGE = 2,
		proximity_geometry_FACE = 4,
	};
	inline proximity_geometry_enum proximity_geometry(void);
	inline void proximity_geometry(proximity_geometry_enum value);
	inline Object target(void);
	inline float min_dist(void);
	inline void min_dist(float value);
	inline float max_dist(void);
	inline void max_dist(float value);
	enum falloff_type_enum {
		falloff_type_LINEAR = 0,
		falloff_type_CURVE = 1,
		falloff_type_SHARP = 2,
		falloff_type_SMOOTH = 3,
		falloff_type_ROOT = 4,
		falloff_type_ICON_SPHERECURVE = 7,
		falloff_type_RANDOM = 8,
		falloff_type_STEP = 9,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline bool invert_falloff(void);
	inline void invert_falloff(bool value);
	inline bool normalize(void);
	inline void normalize(bool value);
	inline CurveMapping map_curve(void);
	inline float mask_constant(void);
	inline void mask_constant(float value);
	inline std::string mask_vertex_group(void);
	inline void mask_vertex_group(const std::string& value);
	inline bool invert_mask_vertex_group(void);
	inline void invert_mask_vertex_group(bool value);
	inline Texture mask_texture(void);
	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};
	inline mask_tex_use_channel_enum mask_tex_use_channel(void);
	inline void mask_tex_use_channel(mask_tex_use_channel_enum value);
	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};
	inline mask_tex_mapping_enum mask_tex_mapping(void);
	inline void mask_tex_mapping(mask_tex_mapping_enum value);
	inline std::string mask_tex_uv_layer(void);
	inline void mask_tex_uv_layer(const std::string& value);
	inline Object mask_tex_map_object(void);
	inline std::string mask_tex_map_bone(void);
	inline void mask_tex_map_bone(const std::string& value);

};

/**************** Dynamic Paint Modifier ****************/

class DynamicPaintModifier : public Modifier {
public:
	DynamicPaintModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline DynamicPaintCanvasSettings canvas_settings(void);
	inline DynamicPaintBrushSettings brush_settings(void);
	enum ui_type_enum {
		ui_type_CANVAS = 1,
		ui_type_BRUSH = 2,
	};
	inline ui_type_enum ui_type(void);
	inline void ui_type(ui_type_enum value);

};

/**************** Ocean Modifier ****************/

class OceanModifier : public Modifier {
public:
	OceanModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum geometry_mode_enum {
		geometry_mode_GENERATE = 0,
		geometry_mode_DISPLACE = 1,
	};
	inline geometry_mode_enum geometry_mode(void);
	inline void geometry_mode(geometry_mode_enum value);
	inline float size(void);
	inline void size(float value);
	inline int repeat_x(void);
	inline void repeat_x(int value);
	inline int repeat_y(void);
	inline void repeat_y(int value);
	inline bool use_normals(void);
	inline void use_normals(bool value);
	inline bool use_foam(void);
	inline void use_foam(bool value);
	inline bool use_spray(void);
	inline void use_spray(bool value);
	inline bool invert_spray(void);
	inline void invert_spray(bool value);
	inline std::string spray_layer_name(void);
	inline void spray_layer_name(const std::string& value);
	inline int resolution(void);
	inline void resolution(int value);
	inline int viewport_resolution(void);
	inline void viewport_resolution(int value);
	inline int spatial_size(void);
	inline void spatial_size(int value);
	inline float wind_velocity(void);
	inline void wind_velocity(float value);
	inline float damping(void);
	inline void damping(float value);
	inline float wave_scale_min(void);
	inline void wave_scale_min(float value);
	inline float wave_alignment(void);
	inline void wave_alignment(float value);
	inline float wave_direction(void);
	inline void wave_direction(float value);
	inline float wave_scale(void);
	inline void wave_scale(float value);
	inline float depth(void);
	inline void depth(float value);
	inline float foam_coverage(void);
	inline void foam_coverage(float value);
	inline float bake_foam_fade(void);
	inline void bake_foam_fade(float value);
	inline std::string foam_layer_name(void);
	inline void foam_layer_name(const std::string& value);
	inline float choppiness(void);
	inline void choppiness(float value);
	inline float time(void);
	inline void time(float value);
	enum spectrum_enum {
		spectrum_PHILLIPS = 0,
		spectrum_PIERSON_MOSKOWITZ = 1,
		spectrum_JONSWAP = 2,
		spectrum_TEXEL_MARSEN_ARSLOE = 3,
	};
	inline spectrum_enum spectrum(void);
	inline void spectrum(spectrum_enum value);
	inline float fetch_jonswap(void);
	inline void fetch_jonswap(float value);
	inline float sharpen_peak_jonswap(void);
	inline void sharpen_peak_jonswap(float value);
	inline int random_seed(void);
	inline void random_seed(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline bool is_cached(void);
	inline void is_cached(bool value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);

};

/**************** Remesh Modifier ****************/

class RemeshModifier : public Modifier {
public:
	RemeshModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum mode_enum {
		mode_BLOCKS = 0,
		mode_SMOOTH = 1,
		mode_SHARP = 2,
		mode_VOXEL = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float scale(void);
	inline void scale(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline int octree_depth(void);
	inline void octree_depth(int value);
	inline float sharpness(void);
	inline void sharpness(float value);
	inline float voxel_size(void);
	inline void voxel_size(float value);
	inline float adaptivity(void);
	inline void adaptivity(float value);
	inline bool use_remove_disconnected(void);
	inline void use_remove_disconnected(bool value);
	inline bool use_smooth_shade(void);
	inline void use_smooth_shade(bool value);

};

/**************** Skin Modifier ****************/

class SkinModifier : public Modifier {
public:
	SkinModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float branch_smoothing(void);
	inline void branch_smoothing(float value);
	inline bool use_smooth_shade(void);
	inline void use_smooth_shade(bool value);
	inline bool use_x_symmetry(void);
	inline void use_x_symmetry(bool value);
	inline bool use_y_symmetry(void);
	inline void use_y_symmetry(bool value);
	inline bool use_z_symmetry(void);
	inline void use_z_symmetry(bool value);

};

/**************** Laplacian Smooth Modifier ****************/

class LaplacianSmoothModifier : public Modifier {
public:
	LaplacianSmoothModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline bool use_x(void);
	inline void use_x(bool value);
	inline bool use_y(void);
	inline void use_y(bool value);
	inline bool use_z(void);
	inline void use_z(bool value);
	inline bool use_volume_preserve(void);
	inline void use_volume_preserve(bool value);
	inline bool use_normalized(void);
	inline void use_normalized(bool value);
	inline float lambda_factor(void);
	inline void lambda_factor(float value);
	inline float lambda_border(void);
	inline void lambda_border(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Triangulate Modifier ****************/

class TriangulateModifier : public Modifier {
public:
	TriangulateModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum quad_method_enum {
		quad_method_BEAUTY = 0,
		quad_method_FIXED = 1,
		quad_method_FIXED_ALTERNATE = 2,
		quad_method_SHORTEST_DIAGONAL = 3,
		quad_method_LONGEST_DIAGONAL = 4,
	};
	inline quad_method_enum quad_method(void);
	inline void quad_method(quad_method_enum value);
	enum ngon_method_enum {
		ngon_method_BEAUTY = 0,
		ngon_method_CLIP = 1,
	};
	inline ngon_method_enum ngon_method(void);
	inline void ngon_method(ngon_method_enum value);
	inline int min_vertices(void);
	inline void min_vertices(int value);
	inline bool keep_custom_normals(void);
	inline void keep_custom_normals(bool value);

};

/**************** Cache Modifier ****************/

class MeshCacheModifier : public Modifier {
public:
	MeshCacheModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum cache_format_enum {
		cache_format_MDD = 1,
		cache_format_PC2 = 2,
	};
	inline cache_format_enum cache_format(void);
	inline void cache_format(cache_format_enum value);
	enum interpolation_enum {
		interpolation_NONE = 0,
		interpolation_LINEAR = 1,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum time_mode_enum {
		time_mode_FRAME = 0,
		time_mode_TIME = 1,
		time_mode_FACTOR = 2,
	};
	inline time_mode_enum time_mode(void);
	inline void time_mode(time_mode_enum value);
	enum play_mode_enum {
		play_mode_SCENE = 0,
		play_mode_CUSTOM = 1,
	};
	inline play_mode_enum play_mode(void);
	inline void play_mode(play_mode_enum value);
	enum deform_mode_enum {
		deform_mode_OVERWRITE = 0,
		deform_mode_INTEGRATE = 1,
	};
	inline deform_mode_enum deform_mode(void);
	inline void deform_mode(deform_mode_enum value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	enum forward_axis_enum {
		forward_axis_POS_X = 0,
		forward_axis_POS_Y = 1,
		forward_axis_POS_Z = 2,
		forward_axis_NEG_X = 3,
		forward_axis_NEG_Y = 4,
		forward_axis_NEG_Z = 5,
	};
	inline forward_axis_enum forward_axis(void);
	inline void forward_axis(forward_axis_enum value);
	enum up_axis_enum {
		up_axis_POS_X = 0,
		up_axis_POS_Y = 1,
		up_axis_POS_Z = 2,
		up_axis_NEG_X = 3,
		up_axis_NEG_Y = 4,
		up_axis_NEG_Z = 5,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	enum flip_axis_enum {
		flip_axis_X = 1,
		flip_axis_Y = 2,
		flip_axis_Z = 4,
	};
	inline flip_axis_enum flip_axis(void);
	inline void flip_axis(flip_axis_enum value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_scale(void);
	inline void frame_scale(float value);
	inline float eval_frame(void);
	inline void eval_frame(float value);
	inline float eval_time(void);
	inline void eval_time(float value);
	inline float eval_factor(void);
	inline void eval_factor(float value);

};

/**************** Laplacian Deform Modifier ****************/

class LaplacianDeformModifier : public Modifier {
public:
	LaplacianDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int iterations(void);
	inline void iterations(int value);
	inline bool is_bind(void);
	inline void is_bind(bool value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Weld Modifier ****************/

class WeldModifier : public Modifier {
public:
	WeldModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum mode_enum {
		mode_ALL = 0,
		mode_CONNECTED = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float merge_threshold(void);
	inline void merge_threshold(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool loose_edges(void);
	inline void loose_edges(bool value);

};

/**************** Wireframe Modifier ****************/

class WireframeModifier : public Modifier {
public:
	WireframeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float thickness(void);
	inline void thickness(float value);
	inline float thickness_vertex_group(void);
	inline void thickness_vertex_group(float value);
	inline float offset(void);
	inline void offset(float value);
	inline bool use_replace(void);
	inline void use_replace(bool value);
	inline bool use_boundary(void);
	inline void use_boundary(bool value);
	inline bool use_even_offset(void);
	inline void use_even_offset(bool value);
	inline bool use_relative_offset(void);
	inline void use_relative_offset(bool value);
	inline bool use_crease(void);
	inline void use_crease(bool value);
	inline float crease_weight(void);
	inline void crease_weight(float value);
	inline int material_offset(void);
	inline void material_offset(int value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Data Transfer Modifier ****************/

class DataTransferModifier : public Modifier {
public:
	DataTransferModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_object_transform(void);
	inline void use_object_transform(bool value);
	inline bool use_vert_data(void);
	inline void use_vert_data(bool value);
	inline bool use_edge_data(void);
	inline void use_edge_data(bool value);
	inline bool use_loop_data(void);
	inline void use_loop_data(bool value);
	inline bool use_poly_data(void);
	inline void use_poly_data(bool value);
	enum data_types_verts_enum {
		data_types_verts_VGROUP_WEIGHTS = 1,
		data_types_verts_BEVEL_WEIGHT_VERT = 8,
		data_types_verts_COLOR_VERTEX = 134283264,
	};
	inline data_types_verts_enum data_types_verts(void);
	inline void data_types_verts(data_types_verts_enum value);
	enum data_types_edges_enum {
		data_types_edges_SHARP_EDGE = 256,
		data_types_edges_SEAM = 512,
		data_types_edges_CREASE = 1024,
		data_types_edges_BEVEL_WEIGHT_EDGE = 2048,
		data_types_edges_FREESTYLE_EDGE = 4096,
	};
	inline data_types_edges_enum data_types_edges(void);
	inline void data_types_edges(data_types_edges_enum value);
	enum data_types_loops_enum {
		data_types_loops_CUSTOM_NORMAL = 131072,
		data_types_loops_COLOR_CORNER = 805306368,
		data_types_loops_UV = 16777216,
	};
	inline data_types_loops_enum data_types_loops(void);
	inline void data_types_loops(data_types_loops_enum value);
	enum data_types_polys_enum {
		data_types_polys_SMOOTH = 33554432,
		data_types_polys_FREESTYLE_FACE = 67108864,
	};
	inline data_types_polys_enum data_types_polys(void);
	inline void data_types_polys(data_types_polys_enum value);
	enum vert_mapping_enum {
		vert_mapping_TOPOLOGY = 251658240,
		vert_mapping_NEAREST = 16777488,
		vert_mapping_EDGE_NEAREST = 16777504,
		vert_mapping_EDGEINTERP_NEAREST = 16778528,
		vert_mapping_POLY_NEAREST = 16777600,
		vert_mapping_POLYINTERP_NEAREST = 16778624,
		vert_mapping_POLYINTERP_VNORPROJ = 16778880,
	};
	inline vert_mapping_enum vert_mapping(void);
	inline void vert_mapping(vert_mapping_enum value);
	enum edge_mapping_enum {
		edge_mapping_TOPOLOGY = 251658240,
		edge_mapping_VERT_NEAREST = 33554704,
		edge_mapping_NEAREST = 33554720,
		edge_mapping_POLY_NEAREST = 33554816,
		edge_mapping_EDGEINTERP_VNORPROJ = 33555984,
	};
	inline edge_mapping_enum edge_mapping(void);
	inline void edge_mapping(edge_mapping_enum value);
	enum loop_mapping_enum {
		loop_mapping_TOPOLOGY = 251658240,
		loop_mapping_NEAREST_NORMAL = 67111248,
		loop_mapping_NEAREST_POLYNOR = 67111312,
		loop_mapping_NEAREST_POLY = 67109248,
		loop_mapping_POLYINTERP_NEAREST = 67110272,
		loop_mapping_POLYINTERP_LNORPROJ = 67110528,
	};
	inline loop_mapping_enum loop_mapping(void);
	inline void loop_mapping(loop_mapping_enum value);
	enum poly_mapping_enum {
		poly_mapping_TOPOLOGY = 251658240,
		poly_mapping_NEAREST = 134218112,
		poly_mapping_NORMAL = 134219904,
		poly_mapping_POLYINTERP_PNORPROJ = 134219392,
	};
	inline poly_mapping_enum poly_mapping(void);
	inline void poly_mapping(poly_mapping_enum value);
	inline bool use_max_distance(void);
	inline void use_max_distance(bool value);
	inline float max_distance(void);
	inline void max_distance(float value);
	inline float ray_radius(void);
	inline void ray_radius(float value);
	inline float islands_precision(void);
	inline void islands_precision(float value);
	enum layers_vgroup_select_src_enum {
		layers_vgroup_select_src_ACTIVE = -1,
		layers_vgroup_select_src_ALL = -2,
		layers_vgroup_select_src_BONE_SELECT = -257,
		layers_vgroup_select_src_BONE_DEFORM = -258,
	};
	inline layers_vgroup_select_src_enum layers_vgroup_select_src(void);
	inline void layers_vgroup_select_src(layers_vgroup_select_src_enum value);
	enum layers_vcol_vert_select_src_enum {
		layers_vcol_vert_select_src_ACTIVE = -1,
		layers_vcol_vert_select_src_ALL = -2,
		layers_vcol_vert_select_src_BONE_SELECT = -257,
		layers_vcol_vert_select_src_BONE_DEFORM = -258,
	};
	inline layers_vcol_vert_select_src_enum layers_vcol_vert_select_src(void);
	inline void layers_vcol_vert_select_src(layers_vcol_vert_select_src_enum value);
	enum layers_vcol_loop_select_src_enum {
		layers_vcol_loop_select_src_ACTIVE = -1,
		layers_vcol_loop_select_src_ALL = -2,
		layers_vcol_loop_select_src_BONE_SELECT = -257,
		layers_vcol_loop_select_src_BONE_DEFORM = -258,
	};
	inline layers_vcol_loop_select_src_enum layers_vcol_loop_select_src(void);
	inline void layers_vcol_loop_select_src(layers_vcol_loop_select_src_enum value);
	enum layers_uv_select_src_enum {
		layers_uv_select_src_ACTIVE = -1,
		layers_uv_select_src_ALL = -2,
		layers_uv_select_src_BONE_SELECT = -257,
		layers_uv_select_src_BONE_DEFORM = -258,
	};
	inline layers_uv_select_src_enum layers_uv_select_src(void);
	inline void layers_uv_select_src(layers_uv_select_src_enum value);
	enum layers_vgroup_select_dst_enum {
		layers_vgroup_select_dst_ACTIVE = -1,
		layers_vgroup_select_dst_NAME = -2,
		layers_vgroup_select_dst_INDEX = -3,
	};
	inline layers_vgroup_select_dst_enum layers_vgroup_select_dst(void);
	inline void layers_vgroup_select_dst(layers_vgroup_select_dst_enum value);
	enum layers_vcol_vert_select_dst_enum {
		layers_vcol_vert_select_dst_ACTIVE = -1,
		layers_vcol_vert_select_dst_NAME = -2,
		layers_vcol_vert_select_dst_INDEX = -3,
	};
	inline layers_vcol_vert_select_dst_enum layers_vcol_vert_select_dst(void);
	inline void layers_vcol_vert_select_dst(layers_vcol_vert_select_dst_enum value);
	enum layers_vcol_loop_select_dst_enum {
		layers_vcol_loop_select_dst_ACTIVE = -1,
		layers_vcol_loop_select_dst_NAME = -2,
		layers_vcol_loop_select_dst_INDEX = -3,
	};
	inline layers_vcol_loop_select_dst_enum layers_vcol_loop_select_dst(void);
	inline void layers_vcol_loop_select_dst(layers_vcol_loop_select_dst_enum value);
	enum layers_uv_select_dst_enum {
		layers_uv_select_dst_ACTIVE = -1,
		layers_uv_select_dst_NAME = -2,
		layers_uv_select_dst_INDEX = -3,
	};
	inline layers_uv_select_dst_enum layers_uv_select_dst(void);
	inline void layers_uv_select_dst(layers_uv_select_dst_enum value);
	enum mix_mode_enum {
		mix_mode_REPLACE = 0,
		mix_mode_ABOVE_THRESHOLD = 1,
		mix_mode_BELOW_THRESHOLD = 2,
		mix_mode_MIX = 16,
		mix_mode_ADD = 17,
		mix_mode_SUB = 18,
		mix_mode_MUL = 19,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	inline float mix_factor(void);
	inline void mix_factor(float value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Normal Edit Modifier ****************/

class NormalEditModifier : public Modifier {
public:
	NormalEditModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	enum mode_enum {
		mode_RADIAL = 0,
		mode_DIRECTIONAL = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	enum mix_mode_enum {
		mix_mode_COPY = 0,
		mix_mode_ADD = 1,
		mix_mode_SUB = 2,
		mix_mode_MUL = 3,
	};
	inline mix_mode_enum mix_mode(void);
	inline void mix_mode(mix_mode_enum value);
	inline float mix_factor(void);
	inline void mix_factor(float value);
	inline float mix_limit(void);
	inline void mix_limit(float value);
	inline bool no_polynors_fix(void);
	inline void no_polynors_fix(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline Object target(void);
	inline bool use_direction_parallel(void);
	inline void use_direction_parallel(bool value);

};

/**************** Cache Modifier ****************/

class MeshSequenceCacheModifier : public Modifier {
public:
	MeshSequenceCacheModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline CacheFile cache_file(void);
	inline std::string object_path(void);
	inline void object_path(const std::string& value);
	enum read_data_enum {
		read_data_VERT = 1,
		read_data_POLY = 2,
		read_data_UV = 4,
		read_data_COLOR = 8,
	};
	inline read_data_enum read_data(void);
	inline void read_data(read_data_enum value);
	inline bool use_vertex_interpolation(void);
	inline void use_vertex_interpolation(bool value);
	inline float velocity_scale(void);
	inline void velocity_scale(float value);

};

/**************** SurfaceDeform Modifier ****************/

class SurfaceDeformModifier : public Modifier {
public:
	SurfaceDeformModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object target(void);
	inline float falloff(void);
	inline void falloff(float value);
	inline bool is_bound(void);
	inline void is_bound(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_sparse_bind(void);
	inline void use_sparse_bind(bool value);
	inline float strength(void);
	inline void strength(float value);

};

/**************** WeightedNormal Modifier ****************/

class WeightedNormalModifier : public Modifier {
public:
	WeightedNormalModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline int weight(void);
	inline void weight(int value);
	enum mode_enum {
		mode_FACE_AREA = 0,
		mode_CORNER_ANGLE = 1,
		mode_FACE_AREA_WITH_ANGLE = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float thresh(void);
	inline void thresh(float value);
	inline bool keep_sharp(void);
	inline void keep_sharp(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);
	inline bool use_face_influence(void);
	inline void use_face_influence(bool value);

};

/**************** Nodes Modifier Bake ****************/

class NodesModifierBake : public Pointer {
public:
	NodesModifierBake(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string directory(void);
	inline void directory(const std::string& value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline bool use_custom_simulation_frame_range(void);
	inline void use_custom_simulation_frame_range(bool value);
	inline bool use_custom_path(void);
	inline void use_custom_path(bool value);

};

/**************** Nodes Modifier ****************/

class NodesModifier : public Modifier {
public:
	NodesModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg),
		bakes(ptr_arg)
		{}

	inline NodeTree node_group(void);
	inline std::string simulation_bake_directory(void);
	inline void simulation_bake_directory(const std::string& value);
	COLLECTION_PROPERTY(NodesModifierBakes, NodesModifierBake, NodesModifier, bakes, true, true, false)
	inline bool show_group_selector(void);
	inline void show_group_selector(bool value);

};

/**************** Mesh to Volume Modifier ****************/

class MeshToVolumeModifier : public Modifier {
public:
	MeshToVolumeModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	enum resolution_mode_enum {
		resolution_mode_VOXEL_AMOUNT = 0,
		resolution_mode_VOXEL_SIZE = 1,
	};
	inline resolution_mode_enum resolution_mode(void);
	inline void resolution_mode(resolution_mode_enum value);
	inline float voxel_size(void);
	inline void voxel_size(float value);
	inline int voxel_amount(void);
	inline void voxel_amount(int value);
	inline float interior_band_width(void);
	inline void interior_band_width(float value);
	inline float density(void);
	inline void density(float value);

};

/**************** Volume Displace Modifier ****************/

class VolumeDisplaceModifier : public Modifier {
public:
	VolumeDisplaceModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline float strength(void);
	inline void strength(float value);
	inline Texture texture(void);
	enum texture_map_mode_enum {
		texture_map_mode_LOCAL = 0,
		texture_map_mode_GLOBAL = 1,
		texture_map_mode_OBJECT = 2,
	};
	inline texture_map_mode_enum texture_map_mode(void);
	inline void texture_map_mode(texture_map_mode_enum value);
	inline Object texture_map_object(void);
	inline Array<float, 3> texture_mid_level(void);
	inline void texture_mid_level(float values[3]);
	inline float texture_sample_radius(void);
	inline void texture_sample_radius(float value);

};

/**************** Volume to Mesh Modifier ****************/

class VolumeToMeshModifier : public Modifier {
public:
	VolumeToMeshModifier(const PointerRNA &ptr_arg) :
		Modifier(ptr_arg)
		{}

	inline Object object(void);
	inline float threshold(void);
	inline void threshold(float value);
	inline float adaptivity(void);
	inline void adaptivity(float value);
	inline bool use_smooth_shade(void);
	inline void use_smooth_shade(bool value);
	inline std::string grid_name(void);
	inline void grid_name(const std::string& value);
	enum resolution_mode_enum {
		resolution_mode_GRID = 0,
		resolution_mode_VOXEL_AMOUNT = 1,
		resolution_mode_VOXEL_SIZE = 2,
	};
	inline resolution_mode_enum resolution_mode(void);
	inline void resolution_mode(resolution_mode_enum value);
	inline float voxel_size(void);
	inline void voxel_size(float value);
	inline int voxel_amount(void);
	inline void voxel_amount(int value);

};

/**************** GpencilModifier ****************/

class GpencilModifier : public Pointer {
public:
	GpencilModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_GP_TEXTURE = 18,
		type_GP_TIME = 16,
		type_GP_WEIGHT_ANGLE = 23,
		type_GP_WEIGHT_PROXIMITY = 21,
		type_GP_ARRAY = 5,
		type_GP_BUILD = 6,
		type_GP_DASH = 22,
		type_GP_ENVELOPE = 25,
		type_GP_LENGTH = 20,
		type_GP_LINEART = 19,
		type_GP_MIRROR = 14,
		type_GP_MULTIPLY = 17,
		type_GP_OUTLINE = 26,
		type_GP_SIMPLIFY = 10,
		type_GP_SUBDIV = 2,
		type_GP_ARMATURE = 15,
		type_GP_HOOK = 12,
		type_GP_LATTICE = 9,
		type_GP_NOISE = 1,
		type_GP_OFFSET = 13,
		type_SHRINKWRAP = 24,
		type_GP_SMOOTH = 11,
		type_GP_THICK = 3,
		type_GP_COLOR = 8,
		type_GP_OPACITY = 7,
		type_GP_TINT = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_viewport(void);
	inline void show_viewport(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_in_editmode(void);
	inline void show_in_editmode(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool is_override_data(void);
	inline void is_override_data(bool value);

};

/**************** Noise Modifier ****************/

class NoiseGpencilModifier : public GpencilModifier {
public:
	NoiseGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline float factor_strength(void);
	inline void factor_strength(float value);
	inline float factor_thickness(void);
	inline void factor_thickness(float value);
	inline float factor_uvs(void);
	inline void factor_uvs(float value);
	inline bool use_random(void);
	inline void use_random(bool value);
	inline int seed(void);
	inline void seed(int value);
	inline float noise_scale(void);
	inline void noise_scale(float value);
	inline float noise_offset(void);
	inline void noise_offset(float value);
	inline bool use_custom_curve(void);
	inline void use_custom_curve(bool value);
	inline CurveMapping curve(void);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline int step(void);
	inline void step(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	enum random_mode_enum {
		random_mode_STEP = 0,
		random_mode_KEYFRAME = 1,
	};
	inline random_mode_enum random_mode(void);
	inline void random_mode(random_mode_enum value);

};

/**************** Smooth Modifier ****************/

class SmoothGpencilModifier : public GpencilModifier {
public:
	SmoothGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline bool use_edit_position(void);
	inline void use_edit_position(bool value);
	inline bool use_edit_strength(void);
	inline void use_edit_strength(bool value);
	inline bool use_edit_thickness(void);
	inline void use_edit_thickness(bool value);
	inline bool use_edit_uv(void);
	inline void use_edit_uv(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline int step(void);
	inline void step(int value);
	inline bool use_keep_shape(void);
	inline void use_keep_shape(bool value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool use_custom_curve(void);
	inline void use_custom_curve(bool value);
	inline CurveMapping curve(void);

};

/**************** Subdivision Modifier ****************/

class SubdivGpencilModifier : public GpencilModifier {
public:
	SubdivGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline int level(void);
	inline void level(int value);
	enum subdivision_type_enum {
		subdivision_type_CATMULL_CLARK = 0,
		subdivision_type_SIMPLE = 1,
	};
	inline subdivision_type_enum subdivision_type(void);
	inline void subdivision_type(subdivision_type_enum value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Simplify Modifier ****************/

class SimplifyGpencilModifier : public GpencilModifier {
public:
	SimplifyGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline float factor(void);
	inline void factor(float value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	enum mode_enum {
		mode_FIXED = 0,
		mode_ADAPTIVE = 1,
		mode_SAMPLE = 2,
		mode_MERGE = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline int step(void);
	inline void step(int value);
	inline float length(void);
	inline void length(float value);
	inline float sharp_threshold(void);
	inline void sharp_threshold(float value);
	inline float distance(void);
	inline void distance(float value);

};

/**************** Thick Modifier ****************/

class ThickGpencilModifier : public GpencilModifier {
public:
	ThickGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int thickness(void);
	inline void thickness(int value);
	inline float thickness_factor(void);
	inline void thickness_factor(float value);
	inline bool use_weight_factor(void);
	inline void use_weight_factor(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool use_custom_curve(void);
	inline void use_custom_curve(bool value);
	inline bool use_normalized_thickness(void);
	inline void use_normalized_thickness(bool value);
	inline CurveMapping curve(void);

};

/**************** Offset Modifier ****************/

class OffsetGpencilModifier : public GpencilModifier {
public:
	OffsetGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum mode_enum {
		mode_RANDOM = 0,
		mode_LAYER = 1,
		mode_STROKE = 3,
		mode_MATERIAL = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> rotation(void);
	inline void rotation(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> random_offset(void);
	inline void random_offset(float values[3]);
	inline Array<float, 3> random_rotation(void);
	inline void random_rotation(float values[3]);
	inline Array<float, 3> random_scale(void);
	inline void random_scale(float values[3]);
	inline int seed(void);
	inline void seed(int value);
	inline int stroke_step(void);
	inline void stroke_step(int value);
	inline int stroke_start_offset(void);
	inline void stroke_start_offset(int value);
	inline bool use_uniform_random_scale(void);
	inline void use_uniform_random_scale(bool value);

};

/**************** Tint Modifier ****************/

class TintGpencilModifier : public GpencilModifier {
public:
	TintGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline Object object(void);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline float factor(void);
	inline void factor(float value);
	inline bool use_weight_factor(void);
	inline void use_weight_factor(bool value);
	inline float radius(void);
	inline void radius(float value);
	enum vertex_mode_enum {
		vertex_mode_STROKE = 0,
		vertex_mode_FILL = 1,
		vertex_mode_BOTH = 2,
	};
	inline vertex_mode_enum vertex_mode(void);
	inline void vertex_mode(vertex_mode_enum value);
	enum tint_type_enum {
		tint_type_UNIFORM = 0,
		tint_type_GRADIENT = 1,
	};
	inline tint_type_enum tint_type(void);
	inline void tint_type(tint_type_enum value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline ColorRamp colors(void);
	inline bool use_custom_curve(void);
	inline void use_custom_curve(bool value);
	inline CurveMapping curve(void);

};

/**************** Time Modifier Segment ****************/

class TimeGpencilModifierSegment : public Pointer {
public:
	TimeGpencilModifierSegment(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int seg_start(void);
	inline void seg_start(int value);
	inline int seg_end(void);
	inline void seg_end(int value);
	inline int seg_repeat(void);
	inline void seg_repeat(int value);
	enum seg_mode_enum {
		seg_mode_NORMAL = 0,
		seg_mode_REVERSE = 1,
		seg_mode_PINGPONG = 2,
	};
	inline seg_mode_enum seg_mode(void);
	inline void seg_mode(seg_mode_enum value);

};

/**************** Time Offset Modifier ****************/

class TimeGpencilModifier : public GpencilModifier {
public:
	TimeGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg),
		segments(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, TimeGpencilModifierSegment, TimeGpencilModifier, segments, false, true, true)
	inline int segment_active_index(void);
	inline void segment_active_index(int value);
	enum mode_enum {
		mode_NORMAL = 0,
		mode_REVERSE = 1,
		mode_FIX = 2,
		mode_PINGPONG = 3,
		mode_CHAIN = 4,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline int offset(void);
	inline void offset(int value);
	inline float frame_scale(void);
	inline void frame_scale(float value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline bool use_keep_loop(void);
	inline void use_keep_loop(bool value);
	inline bool use_custom_frame_range(void);
	inline void use_custom_frame_range(bool value);

};

/**************** Hue/Saturation Modifier ****************/

class ColorGpencilModifier : public GpencilModifier {
public:
	ColorGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum modify_color_enum {
		modify_color_BOTH = 0,
		modify_color_STROKE = 1,
		modify_color_FILL = 2,
	};
	inline modify_color_enum modify_color(void);
	inline void modify_color(modify_color_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline float hue(void);
	inline void hue(float value);
	inline float saturation(void);
	inline void saturation(float value);
	inline float value(void);
	inline void value(float value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool use_custom_curve(void);
	inline void use_custom_curve(bool value);
	inline CurveMapping curve(void);

};

/**************** Instance Modifier ****************/

class ArrayGpencilModifier : public GpencilModifier {
public:
	ArrayGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline int count(void);
	inline void count(int value);
	inline Object offset_object(void);
	inline Array<float, 3> constant_offset(void);
	inline void constant_offset(float values[3]);
	inline Array<float, 3> relative_offset(void);
	inline void relative_offset(float values[3]);
	inline Array<float, 3> random_offset(void);
	inline void random_offset(float values[3]);
	inline Array<float, 3> random_rotation(void);
	inline void random_rotation(float values[3]);
	inline Array<float, 3> random_scale(void);
	inline void random_scale(float values[3]);
	inline int seed(void);
	inline void seed(int value);
	inline int replace_material(void);
	inline void replace_material(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool use_constant_offset(void);
	inline void use_constant_offset(bool value);
	inline bool use_object_offset(void);
	inline void use_object_offset(bool value);
	inline bool use_relative_offset(void);
	inline void use_relative_offset(bool value);
	inline bool use_uniform_random_scale(void);
	inline void use_uniform_random_scale(bool value);

};

/**************** Build Modifier ****************/

class BuildGpencilModifier : public GpencilModifier {
public:
	BuildGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum mode_enum {
		mode_SEQUENTIAL = 0,
		mode_CONCURRENT = 1,
		mode_ADDITIVE = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum transition_enum {
		transition_GROW = 0,
		transition_SHRINK = 1,
		transition_FADE = 2,
	};
	inline transition_enum transition(void);
	inline void transition(transition_enum value);
	inline float start_delay(void);
	inline void start_delay(float value);
	inline float length(void);
	inline void length(float value);
	enum concurrent_time_alignment_enum {
		concurrent_time_alignment_START = 0,
		concurrent_time_alignment_END = 1,
	};
	inline concurrent_time_alignment_enum concurrent_time_alignment(void);
	inline void concurrent_time_alignment(concurrent_time_alignment_enum value);
	enum time_mode_enum {
		time_mode_DRAWSPEED = 2,
		time_mode_FRAMES = 0,
		time_mode_PERCENTAGE = 1,
	};
	inline time_mode_enum time_mode(void);
	inline void time_mode(time_mode_enum value);
	inline float speed_factor(void);
	inline void speed_factor(float value);
	inline float speed_maxgap(void);
	inline void speed_maxgap(float value);
	inline bool use_restrict_frame_range(void);
	inline void use_restrict_frame_range(bool value);
	inline bool use_percentage(void);
	inline void use_percentage(bool value);
	inline float percentage_factor(void);
	inline void percentage_factor(float value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline bool use_fading(void);
	inline void use_fading(bool value);
	inline float fade_factor(void);
	inline void fade_factor(float value);
	inline std::string target_vertex_group(void);
	inline void target_vertex_group(const std::string& value);
	inline float fade_opacity_strength(void);
	inline void fade_opacity_strength(float value);
	inline float fade_thickness_strength(void);
	inline void fade_thickness_strength(float value);
	inline Object object(void);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Opacity Modifier ****************/

class OpacityGpencilModifier : public GpencilModifier {
public:
	OpacityGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum modify_color_enum {
		modify_color_BOTH = 0,
		modify_color_STROKE = 1,
		modify_color_FILL = 2,
		modify_color_HARDNESS = 3,
	};
	inline modify_color_enum modify_color(void);
	inline void modify_color(modify_color_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float factor(void);
	inline void factor(float value);
	inline float hardness(void);
	inline void hardness(float value);
	inline bool use_weight_factor(void);
	inline void use_weight_factor(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool use_normalized_opacity(void);
	inline void use_normalized_opacity(bool value);
	inline bool use_custom_curve(void);
	inline void use_custom_curve(bool value);
	inline CurveMapping curve(void);

};

/**************** Outline Modifier ****************/

class OutlineGpencilModifier : public GpencilModifier {
public:
	OutlineGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline int thickness(void);
	inline void thickness(int value);
	inline float sample_length(void);
	inline void sample_length(float value);
	inline int subdivision(void);
	inline void subdivision(int value);
	inline bool use_keep_shape(void);
	inline void use_keep_shape(bool value);
	inline Material outline_material(void);
	inline Object object(void);

};

/**************** Lattice Modifier ****************/

class LatticeGpencilModifier : public GpencilModifier {
public:
	LatticeGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline Object object(void);
	inline float strength(void);
	inline void strength(float value);

};

/**************** Mirror Modifier ****************/

class MirrorGpencilModifier : public GpencilModifier {
public:
	MirrorGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline Object object(void);
	inline bool use_clip(void);
	inline void use_clip(bool value);
	inline bool use_axis_x(void);
	inline void use_axis_x(bool value);
	inline bool use_axis_y(void);
	inline void use_axis_y(bool value);
	inline bool use_axis_z(void);
	inline void use_axis_z(bool value);

};

/**************** Hook Modifier ****************/

class HookGpencilModifier : public GpencilModifier {
public:
	HookGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline Object object(void);
	inline std::string subtarget(void);
	inline void subtarget(const std::string& value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline float strength(void);
	inline void strength(float value);
	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	inline float falloff_radius(void);
	inline void falloff_radius(float value);
	inline CurveMapping falloff_curve(void);
	inline Array<float, 3> center(void);
	inline void center(float values[3]);
	inline Array<float, 16> matrix_inverse(void);
	inline void matrix_inverse(float values[16]);
	inline bool use_falloff_uniform(void);
	inline void use_falloff_uniform(bool value);

};

/**************** Armature Modifier ****************/

class ArmatureGpencilModifier : public GpencilModifier {
public:
	ArmatureGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline Object object(void);
	inline bool use_bone_envelopes(void);
	inline void use_bone_envelopes(bool value);
	inline bool use_vertex_groups(void);
	inline void use_vertex_groups(bool value);
	inline bool use_deform_preserve_volume(void);
	inline void use_deform_preserve_volume(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex_group(void);
	inline void invert_vertex_group(bool value);

};

/**************** Multiply Modifier ****************/

class MultiplyGpencilModifier : public GpencilModifier {
public:
	MultiplyGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline bool use_fade(void);
	inline void use_fade(bool value);
	inline int duplicates(void);
	inline void duplicates(int value);
	inline float distance(void);
	inline void distance(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float fading_thickness(void);
	inline void fading_thickness(float value);
	inline float fading_opacity(void);
	inline void fading_opacity(float value);
	inline float fading_center(void);
	inline void fading_center(float value);

};

/**************** Texture Modifier ****************/

class TextureGpencilModifier : public GpencilModifier {
public:
	TextureGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline Material material(void);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline float uv_offset(void);
	inline void uv_offset(float value);
	inline float uv_scale(void);
	inline void uv_scale(float value);
	inline float alignment_rotation(void);
	inline void alignment_rotation(float value);
	inline float fill_rotation(void);
	inline void fill_rotation(float value);
	inline Array<float, 2> fill_offset(void);
	inline void fill_offset(float values[2]);
	inline float fill_scale(void);
	inline void fill_scale(float value);
	enum fit_method_enum {
		fit_method_CONSTANT_LENGTH = 1,
		fit_method_FIT_STROKE = 0,
	};
	inline fit_method_enum fit_method(void);
	inline void fit_method(fit_method_enum value);
	enum mode_enum {
		mode_STROKE = 0,
		mode_FILL = 1,
		mode_STROKE_AND_FILL = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

};

/**************** Weight Modifier Angle ****************/

class WeightAngleGpencilModifier : public GpencilModifier {
public:
	WeightAngleGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string target_vertex_group(void);
	inline void target_vertex_group(const std::string& value);
	inline bool use_multiply(void);
	inline void use_multiply(bool value);
	inline bool use_invert_output(void);
	inline void use_invert_output(bool value);
	inline float angle(void);
	inline void angle(float value);
	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	enum space_enum {
		space_LOCAL = 0,
		space_WORLD = 1,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline float minimum_weight(void);
	inline void minimum_weight(float value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Weight Modifier Proximity ****************/

class WeightProxGpencilModifier : public GpencilModifier {
public:
	WeightProxGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string target_vertex_group(void);
	inline void target_vertex_group(const std::string& value);
	inline bool use_multiply(void);
	inline void use_multiply(bool value);
	inline bool use_invert_output(void);
	inline void use_invert_output(bool value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline Object object(void);
	inline float distance_start(void);
	inline void distance_start(float value);
	inline float minimum_weight(void);
	inline void minimum_weight(float value);
	inline float distance_end(void);
	inline void distance_end(float value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Line Art Modifier ****************/

class LineartGpencilModifier : public GpencilModifier {
public:
	LineartGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline bool use_custom_camera(void);
	inline void use_custom_camera(bool value);
	inline bool use_fuzzy_intersections(void);
	inline void use_fuzzy_intersections(bool value);
	inline bool use_fuzzy_all(void);
	inline void use_fuzzy_all(bool value);
	inline bool use_object_instances(void);
	inline void use_object_instances(bool value);
	inline bool use_edge_overlap(void);
	inline void use_edge_overlap(bool value);
	inline bool use_clip_plane_boundaries(void);
	inline void use_clip_plane_boundaries(bool value);
	inline float crease_threshold(void);
	inline void crease_threshold(float value);
	inline float split_angle(void);
	inline void split_angle(float value);
	inline float smooth_tolerance(void);
	inline void smooth_tolerance(float value);
	inline bool use_loose_as_contour(void);
	inline void use_loose_as_contour(bool value);
	inline bool invert_source_vertex_group(void);
	inline void invert_source_vertex_group(bool value);
	inline bool use_output_vertex_group_match_by_name(void);
	inline void use_output_vertex_group_match_by_name(bool value);
	inline bool use_face_mark(void);
	inline void use_face_mark(bool value);
	inline bool use_face_mark_invert(void);
	inline void use_face_mark_invert(bool value);
	inline bool use_face_mark_boundaries(void);
	inline void use_face_mark_boundaries(bool value);
	inline bool use_face_mark_keep_contour(void);
	inline void use_face_mark_keep_contour(bool value);
	inline float chaining_image_threshold(void);
	inline void chaining_image_threshold(float value);
	inline bool use_loose_edge_chain(void);
	inline void use_loose_edge_chain(bool value);
	inline bool use_geometry_space_chain(void);
	inline void use_geometry_space_chain(bool value);
	inline bool use_detail_preserve(void);
	inline void use_detail_preserve(bool value);
	inline bool use_overlap_edge_type_support(void);
	inline void use_overlap_edge_type_support(bool value);
	inline float stroke_depth_offset(void);
	inline void stroke_depth_offset(float value);
	inline bool use_offset_towards_custom_camera(void);
	inline void use_offset_towards_custom_camera(bool value);
	inline Object source_camera(void);
	inline Object light_contour_object(void);
	enum source_type_enum {
		source_type_COLLECTION = 0,
		source_type_OBJECT = 1,
		source_type_SCENE = 2,
	};
	inline source_type_enum source_type(void);
	inline void source_type(source_type_enum value);
	inline Object source_object(void);
	inline Collection source_collection(void);
	inline bool use_contour(void);
	inline void use_contour(bool value);
	inline bool use_loose(void);
	inline void use_loose(bool value);
	inline bool use_crease(void);
	inline void use_crease(bool value);
	inline bool use_material(void);
	inline void use_material(bool value);
	inline bool use_edge_mark(void);
	inline void use_edge_mark(bool value);
	inline bool use_intersection(void);
	inline void use_intersection(bool value);
	inline bool use_light_contour(void);
	inline void use_light_contour(bool value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	enum shadow_region_filtering_enum {
		shadow_region_filtering_NONE = 0,
		shadow_region_filtering_ILLUMINATED = 1,
		shadow_region_filtering_SHADED = 2,
		shadow_region_filtering_ILLUMINATED_ENCLOSED = 3,
	};
	inline shadow_region_filtering_enum shadow_region_filtering(void);
	inline void shadow_region_filtering(shadow_region_filtering_enum value);
	enum silhouette_filtering_enum {
		silhouette_filtering_NONE = 0,
		silhouette_filtering_GROUP = 1,
		silhouette_filtering_INDIVIDUAL = 2,
	};
	inline silhouette_filtering_enum silhouette_filtering(void);
	inline void silhouette_filtering(silhouette_filtering_enum value);
	inline bool use_multiple_levels(void);
	inline void use_multiple_levels(bool value);
	inline int level_start(void);
	inline void level_start(int value);
	inline int level_end(void);
	inline void level_end(int value);
	inline Material target_material(void);
	inline std::string target_layer(void);
	inline void target_layer(const std::string& value);
	inline std::string source_vertex_group(void);
	inline void source_vertex_group(const std::string& value);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline bool is_baked(void);
	inline void is_baked(bool value);
	inline bool use_cache(void);
	inline void use_cache(bool value);
	inline float overscan(void);
	inline void overscan(float value);
	inline int thickness(void);
	inline void thickness(int value);
	inline float opacity(void);
	inline void opacity(float value);
	inline bool use_material_mask(void);
	inline void use_material_mask(bool value);
	inline bool use_material_mask_match(void);
	inline void use_material_mask_match(bool value);
	inline Array<bool, 8> use_material_mask_bits(void);
	inline void use_material_mask_bits(bool values[8]);
	inline bool use_intersection_match(void);
	inline void use_intersection_match(bool value);
	inline Array<bool, 8> use_intersection_mask(void);
	inline void use_intersection_mask(bool values[8]);
	inline bool use_crease_on_smooth(void);
	inline void use_crease_on_smooth(bool value);
	inline bool use_crease_on_sharp(void);
	inline void use_crease_on_sharp(bool value);
	inline bool use_image_boundary_trimming(void);
	inline void use_image_boundary_trimming(bool value);
	inline bool use_back_face_culling(void);
	inline void use_back_face_culling(bool value);
	inline float shadow_camera_near(void);
	inline void shadow_camera_near(float value);
	inline float shadow_camera_far(void);
	inline void shadow_camera_far(float value);
	inline float shadow_camera_size(void);
	inline void shadow_camera_size(float value);
	inline bool use_invert_collection(void);
	inline void use_invert_collection(bool value);
	inline bool use_invert_silhouette(void);
	inline void use_invert_silhouette(bool value);

};

/**************** Length Modifier ****************/

class LengthGpencilModifier : public GpencilModifier {
public:
	LengthGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline float start_factor(void);
	inline void start_factor(float value);
	inline float end_factor(void);
	inline void end_factor(float value);
	inline float start_length(void);
	inline void start_length(float value);
	inline float end_length(void);
	inline void end_length(float value);
	inline float random_start_factor(void);
	inline void random_start_factor(float value);
	inline float random_end_factor(void);
	inline void random_end_factor(float value);
	inline float random_offset(void);
	inline void random_offset(float value);
	inline bool use_random(void);
	inline void use_random(bool value);
	inline int seed(void);
	inline void seed(int value);
	inline int step(void);
	inline void step(int value);
	inline float overshoot_factor(void);
	inline void overshoot_factor(float value);
	enum mode_enum {
		mode_RELATIVE = 0,
		mode_ABSOLUTE = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool use_curvature(void);
	inline void use_curvature(bool value);
	inline bool invert_curvature(void);
	inline void invert_curvature(bool value);
	inline float point_density(void);
	inline void point_density(float value);
	inline float segment_influence(void);
	inline void segment_influence(float value);
	inline float max_angle(void);
	inline void max_angle(float value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Dash Modifier Segment ****************/

class DashGpencilModifierSegment : public Pointer {
public:
	DashGpencilModifierSegment(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int dash(void);
	inline void dash(int value);
	inline int gap(void);
	inline void gap(int value);
	inline float radius(void);
	inline void radius(float value);
	inline float opacity(void);
	inline void opacity(float value);
	inline int material_index(void);
	inline void material_index(int value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);

};

/**************** Dash Modifier ****************/

class DashGpencilModifierData : public GpencilModifier {
public:
	DashGpencilModifierData(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg),
		segments(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, DashGpencilModifierSegment, DashGpencilModifierData, segments, false, true, true)
	inline int segment_active_index(void);
	inline void segment_active_index(int value);
	inline int dash_offset(void);
	inline void dash_offset(int value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** Shrinkwrap Modifier ****************/

class ShrinkwrapGpencilModifier : public GpencilModifier {
public:
	ShrinkwrapGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	enum wrap_method_enum {
		wrap_method_NEAREST_SURFACEPOINT = 0,
		wrap_method_PROJECT = 1,
		wrap_method_NEAREST_VERTEX = 2,
		wrap_method_TARGET_PROJECT = 3,
	};
	inline wrap_method_enum wrap_method(void);
	inline void wrap_method(wrap_method_enum value);
	enum wrap_mode_enum {
		wrap_mode_ON_SURFACE = 0,
		wrap_mode_INSIDE = 1,
		wrap_mode_OUTSIDE = 2,
		wrap_mode_OUTSIDE_SURFACE = 3,
		wrap_mode_ABOVE_SURFACE = 4,
	};
	inline wrap_mode_enum wrap_mode(void);
	inline void wrap_mode(wrap_mode_enum value);
	enum cull_face_enum {
		cull_face_OFF = 0,
		cull_face_FRONT = 8,
		cull_face_BACK = 16,
	};
	inline cull_face_enum cull_face(void);
	inline void cull_face(cull_face_enum value);
	inline Object target(void);
	inline Object auxiliary_target(void);
	inline float offset(void);
	inline void offset(float value);
	inline float project_limit(void);
	inline void project_limit(float value);
	inline bool use_project_x(void);
	inline void use_project_x(bool value);
	inline bool use_project_y(void);
	inline void use_project_y(bool value);
	inline bool use_project_z(void);
	inline void use_project_z(bool value);
	inline int subsurf_levels(void);
	inline void subsurf_levels(int value);
	inline bool use_negative_direction(void);
	inline void use_negative_direction(bool value);
	inline bool use_positive_direction(void);
	inline void use_positive_direction(bool value);
	inline bool use_invert_cull(void);
	inline void use_invert_cull(bool value);
	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);
	inline float smooth_factor(void);
	inline void smooth_factor(float value);
	inline int smooth_step(void);
	inline void smooth_step(int value);

};

/**************** Envelope Modifier ****************/

class EnvelopeGpencilModifier : public GpencilModifier {
public:
	EnvelopeGpencilModifier(const PointerRNA &ptr_arg) :
		GpencilModifier(ptr_arg)
		{}

	inline std::string layer(void);
	inline void layer(const std::string& value);
	inline Material material(void);
	inline std::string vertex_group(void);
	inline void vertex_group(const std::string& value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline int spread(void);
	inline void spread(int value);
	enum mode_enum {
		mode_DEFORM = 0,
		mode_SEGMENTS = 1,
		mode_FILLS = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline int mat_nr(void);
	inline void mat_nr(int value);
	inline float thickness(void);
	inline void thickness(float value);
	inline float strength(void);
	inline void strength(float value);
	inline int skip(void);
	inline void skip(int value);
	inline bool invert_layers(void);
	inline void invert_layers(bool value);
	inline bool invert_materials(void);
	inline void invert_materials(bool value);
	inline bool invert_material_pass(void);
	inline void invert_material_pass(bool value);
	inline bool invert_vertex(void);
	inline void invert_vertex(bool value);
	inline int layer_pass(void);
	inline void layer_pass(int value);
	inline bool invert_layer_pass(void);
	inline void invert_layer_pass(bool value);

};

/**************** ShaderFx ****************/

class ShaderFx : public Pointer {
public:
	ShaderFx(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_FX_BLUR = 1,
		type_FX_COLORIZE = 8,
		type_FX_FLIP = 2,
		type_FX_GLOW = 10,
		type_FX_PIXEL = 4,
		type_FX_RIM = 7,
		type_FX_SHADOW = 9,
		type_FX_SWIRL = 5,
		type_FX_WAVE = 6,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_viewport(void);
	inline void show_viewport(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_in_editmode(void);
	inline void show_in_editmode(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);

};

/**************** Gaussian Blur Effect ****************/

class ShaderFxBlur : public ShaderFx {
public:
	ShaderFxBlur(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<float, 2> size(void);
	inline void size(float values[2]);
	inline int samples(void);
	inline void samples(int value);
	inline float rotation(void);
	inline void rotation(float value);
	inline bool use_dof_mode(void);
	inline void use_dof_mode(bool value);

};

/**************** Colorize Effect ****************/

class ShaderFxColorize : public ShaderFx {
public:
	ShaderFxColorize(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline float factor(void);
	inline void factor(float value);
	inline Array<float, 4> low_color(void);
	inline void low_color(float values[4]);
	inline Array<float, 4> high_color(void);
	inline void high_color(float values[4]);
	enum mode_enum {
		mode_GRAYSCALE = 0,
		mode_SEPIA = 1,
		mode_DUOTONE = 2,
		mode_TRANSPARENT = 4,
		mode_CUSTOM = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

};

/**************** Wave Deformation Effect ****************/

class ShaderFxWave : public ShaderFx {
public:
	ShaderFxWave(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	enum orientation_enum {
		orientation_HORIZONTAL = 0,
		orientation_VERTICAL = 1,
	};
	inline orientation_enum orientation(void);
	inline void orientation(orientation_enum value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline float phase(void);
	inline void phase(float value);

};

/**************** Pixelate Effect ****************/

class ShaderFxPixel : public ShaderFx {
public:
	ShaderFxPixel(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<int, 2> size(void);
	inline void size(int values[2]);
	inline bool use_antialiasing(void);
	inline void use_antialiasing(bool value);

};

/**************** Rim Effect ****************/

class ShaderFxRim : public ShaderFx {
public:
	ShaderFxRim(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<int, 2> offset(void);
	inline void offset(int values[2]);
	inline Array<float, 3> rim_color(void);
	inline void rim_color(float values[3]);
	inline Array<float, 3> mask_color(void);
	inline void mask_color(float values[3]);
	enum mode_enum {
		mode_NORMAL = 0,
		mode_OVERLAY = 1,
		mode_ADD = 2,
		mode_SUBTRACT = 3,
		mode_MULTIPLY = 4,
		mode_DIVIDE = 5,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Array<int, 2> blur(void);
	inline void blur(int values[2]);
	inline int samples(void);
	inline void samples(int value);

};

/**************** Shadow Effect ****************/

class ShaderFxShadow : public ShaderFx {
public:
	ShaderFxShadow(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Object object(void);
	inline Array<int, 2> offset(void);
	inline void offset(int values[2]);
	inline Array<float, 2> scale(void);
	inline void scale(float values[2]);
	inline Array<float, 4> shadow_color(void);
	inline void shadow_color(float values[4]);
	enum orientation_enum {
		orientation_HORIZONTAL = 0,
		orientation_VERTICAL = 1,
	};
	inline orientation_enum orientation(void);
	inline void orientation(orientation_enum value);
	inline float amplitude(void);
	inline void amplitude(float value);
	inline float period(void);
	inline void period(float value);
	inline float phase(void);
	inline void phase(float value);
	inline float rotation(void);
	inline void rotation(float value);
	inline Array<int, 2> blur(void);
	inline void blur(int values[2]);
	inline int samples(void);
	inline void samples(int value);
	inline bool use_object(void);
	inline void use_object(bool value);
	inline bool use_wave(void);
	inline void use_wave(bool value);

};

/**************** Glow Effect ****************/

class ShaderFxGlow : public ShaderFx {
public:
	ShaderFxGlow(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline Array<float, 3> glow_color(void);
	inline void glow_color(float values[3]);
	inline float opacity(void);
	inline void opacity(float value);
	inline Array<float, 3> select_color(void);
	inline void select_color(float values[3]);
	enum mode_enum {
		mode_LUMINANCE = 0,
		mode_COLOR = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline float threshold(void);
	inline void threshold(float value);
	inline Array<float, 2> size(void);
	inline void size(float values[2]);
	inline int samples(void);
	inline void samples(int value);
	inline bool use_glow_under(void);
	inline void use_glow_under(bool value);
	inline float rotation(void);
	inline void rotation(float value);
	enum blend_mode_enum {
		blend_mode_REGULAR = 0,
		blend_mode_ADD = 2,
		blend_mode_SUBTRACT = 3,
		blend_mode_MULTIPLY = 4,
		blend_mode_DIVIDE = 5,
	};
	inline blend_mode_enum blend_mode(void);
	inline void blend_mode(blend_mode_enum value);

};

/**************** Swirl Effect ****************/

class ShaderFxSwirl : public ShaderFx {
public:
	ShaderFxSwirl(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline int radius(void);
	inline void radius(int value);
	inline float angle(void);
	inline void angle(float value);
	inline bool use_transparent(void);
	inline void use_transparent(bool value);
	inline Object object(void);

};

/**************** Flip Effect ****************/

class ShaderFxFlip : public ShaderFx {
public:
	ShaderFxFlip(const PointerRNA &ptr_arg) :
		ShaderFx(ptr_arg)
		{}

	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);

};

/**************** NLA Track ****************/

class NlaTrack : public Pointer {
public:
	NlaTrack(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		strips(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(NlaStrips, NlaStrip, NlaTrack, strips, false, true, true)
	inline bool is_override_data(void);
	inline void is_override_data(bool value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool active(void);
	inline void active(bool value);
	inline bool is_solo(void);
	inline void is_solo(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool lock(void);
	inline void lock(bool value);

};

/**************** NLA Strip ****************/

class NlaStrip : public Pointer {
public:
	NlaStrip(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		fcurves(ptr_arg),
		modifiers(ptr_arg),
		strips(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_CLIP = 0,
		type_TRANSITION = 1,
		type_META = 2,
		type_SOUND = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum extrapolation_enum {
		extrapolation_NOTHING = 2,
		extrapolation_HOLD = 0,
		extrapolation_HOLD_FORWARD = 1,
	};
	inline extrapolation_enum extrapolation(void);
	inline void extrapolation(extrapolation_enum value);
	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_COMBINE = 4,
		blend_type_ADD = 1,
		blend_type_SUBTRACT = 2,
		blend_type_MULTIPLY = 3,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline float frame_start_raw(void);
	inline void frame_start_raw(float value);
	inline float frame_end_raw(void);
	inline void frame_end_raw(float value);
	inline float frame_start_ui(void);
	inline void frame_start_ui(float value);
	inline float frame_end_ui(void);
	inline void frame_end_ui(float value);
	inline float blend_in(void);
	inline void blend_in(float value);
	inline float blend_out(void);
	inline void blend_out(float value);
	inline bool use_auto_blend(void);
	inline void use_auto_blend(bool value);
	inline Action action(void);
	inline float action_frame_start(void);
	inline void action_frame_start(float value);
	inline float action_frame_end(void);
	inline void action_frame_end(float value);
	inline float repeat(void);
	inline void repeat(float value);
	inline float scale(void);
	inline void scale(float value);
	COLLECTION_PROPERTY(NlaStripFCurves, FCurve, NlaStrip, fcurves, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FModifier, NlaStrip, modifiers, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, NlaStrip, NlaStrip, strips, false, true, true)
	inline float influence(void);
	inline void influence(float value);
	inline float strip_time(void);
	inline void strip_time(float value);
	inline bool use_animated_influence(void);
	inline void use_animated_influence(bool value);
	inline bool use_animated_time(void);
	inline void use_animated_time(bool value);
	inline bool use_animated_time_cyclic(void);
	inline void use_animated_time_cyclic(bool value);
	inline bool active(void);
	inline void active(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool use_reverse(void);
	inline void use_reverse(bool value);
	inline bool use_sync_length(void);
	inline void use_sync_length(bool value);

};

/**************** Node ****************/

class Node : public Pointer {
public:
	Node(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		inputs(ptr_arg),
		outputs(ptr_arg),
		internal_links(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_CUSTOM = -1,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline Array<float, 2> location(void);
	inline void location(float values[2]);
	inline float width(void);
	inline void width(float value);
	inline float height(void);
	inline void height(float value);
	inline Array<float, 2> dimensions(void);
	inline void dimensions(float values[2]);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string label(void);
	inline void label(const std::string& value);
	COLLECTION_PROPERTY(NodeInputs, NodeSocket, Node, inputs, false, true, true)
	COLLECTION_PROPERTY(NodeOutputs, NodeSocket, Node, outputs, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, NodeLink, Node, internal_links, false, false, false)
	inline Node parent(void);
	inline bool use_custom_color(void);
	inline void use_custom_color(bool value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline bool select(void);
	inline void select(bool value);
	inline bool show_options(void);
	inline void show_options(bool value);
	inline bool show_preview(void);
	inline void show_preview(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool show_texture(void);
	inline void show_texture(bool value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	enum bl_icon_enum {
		bl_icon_NONE = 0,
		bl_icon_QUESTION = 1,
		bl_icon_ERROR = 2,
		bl_icon_CANCEL = 3,
		bl_icon_TRIA_RIGHT = 4,
		bl_icon_TRIA_DOWN = 5,
		bl_icon_TRIA_LEFT = 6,
		bl_icon_TRIA_UP = 7,
		bl_icon_ARROW_LEFTRIGHT = 8,
		bl_icon_PLUS = 9,
		bl_icon_DISCLOSURE_TRI_RIGHT = 10,
		bl_icon_DISCLOSURE_TRI_DOWN = 11,
		bl_icon_RADIOBUT_OFF = 12,
		bl_icon_RADIOBUT_ON = 13,
		bl_icon_MENU_PANEL = 14,
		bl_icon_BLENDER = 15,
		bl_icon_GRIP = 16,
		bl_icon_DOT = 17,
		bl_icon_COLLAPSEMENU = 18,
		bl_icon_X = 19,
		bl_icon_DUPLICATE = 20,
		bl_icon_TRASH = 21,
		bl_icon_COLLECTION_NEW = 22,
		bl_icon_OPTIONS = 23,
		bl_icon_NODE = 24,
		bl_icon_NODE_SEL = 25,
		bl_icon_WINDOW = 26,
		bl_icon_WORKSPACE = 27,
		bl_icon_RIGHTARROW_THIN = 28,
		bl_icon_BORDERMOVE = 29,
		bl_icon_VIEWZOOM = 30,
		bl_icon_ADD = 31,
		bl_icon_REMOVE = 32,
		bl_icon_PANEL_CLOSE = 33,
		bl_icon_COPY_ID = 34,
		bl_icon_EYEDROPPER = 35,
		bl_icon_CHECKMARK = 36,
		bl_icon_AUTO = 37,
		bl_icon_CHECKBOX_DEHLT = 38,
		bl_icon_CHECKBOX_HLT = 39,
		bl_icon_UNLOCKED = 40,
		bl_icon_LOCKED = 41,
		bl_icon_UNPINNED = 42,
		bl_icon_PINNED = 43,
		bl_icon_SCREEN_BACK = 44,
		bl_icon_RIGHTARROW = 45,
		bl_icon_DOWNARROW_HLT = 46,
		bl_icon_FCURVE_SNAPSHOT = 47,
		bl_icon_OBJECT_HIDDEN = 48,
		bl_icon_TOPBAR = 49,
		bl_icon_STATUSBAR = 50,
		bl_icon_PLUGIN = 51,
		bl_icon_HELP = 52,
		bl_icon_GHOST_ENABLED = 53,
		bl_icon_COLOR = 54,
		bl_icon_UNLINKED = 55,
		bl_icon_LINKED = 56,
		bl_icon_HAND = 57,
		bl_icon_ZOOM_ALL = 58,
		bl_icon_ZOOM_SELECTED = 59,
		bl_icon_ZOOM_PREVIOUS = 60,
		bl_icon_ZOOM_IN = 61,
		bl_icon_ZOOM_OUT = 62,
		bl_icon_DRIVER_DISTANCE = 63,
		bl_icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		bl_icon_DRIVER_TRANSFORM = 65,
		bl_icon_FREEZE = 66,
		bl_icon_STYLUS_PRESSURE = 67,
		bl_icon_GHOST_DISABLED = 68,
		bl_icon_FILE_NEW = 69,
		bl_icon_FILE_TICK = 70,
		bl_icon_QUIT = 71,
		bl_icon_URL = 72,
		bl_icon_RECOVER_LAST = 73,
		bl_icon_THREE_DOTS = 74,
		bl_icon_FULLSCREEN_ENTER = 75,
		bl_icon_FULLSCREEN_EXIT = 76,
		bl_icon_BRUSHES_ALL = 77,
		bl_icon_LIGHT = 78,
		bl_icon_MATERIAL = 79,
		bl_icon_TEXTURE = 80,
		bl_icon_ANIM = 81,
		bl_icon_WORLD = 82,
		bl_icon_SCENE = 83,
		bl_icon_OUTPUT = 84,
		bl_icon_SCRIPT = 87,
		bl_icon_PARTICLES = 88,
		bl_icon_PHYSICS = 89,
		bl_icon_SPEAKER = 90,
		bl_icon_TOOL_SETTINGS = 92,
		bl_icon_SHADERFX = 93,
		bl_icon_MODIFIER = 94,
		bl_icon_BLANK1 = 101,
		bl_icon_FAKE_USER_OFF = 102,
		bl_icon_FAKE_USER_ON = 103,
		bl_icon_VIEW3D = 104,
		bl_icon_GRAPH = 105,
		bl_icon_OUTLINER = 106,
		bl_icon_PROPERTIES = 107,
		bl_icon_FILEBROWSER = 108,
		bl_icon_IMAGE = 109,
		bl_icon_INFO = 110,
		bl_icon_SEQUENCE = 111,
		bl_icon_TEXT = 112,
		bl_icon_SPREADSHEET = 113,
		bl_icon_SOUND = 114,
		bl_icon_ACTION = 115,
		bl_icon_NLA = 116,
		bl_icon_PREFERENCES = 117,
		bl_icon_TIME = 118,
		bl_icon_NODETREE = 119,
		bl_icon_GEOMETRY_NODES = 120,
		bl_icon_CONSOLE = 121,
		bl_icon_TRACKER = 123,
		bl_icon_ASSET_MANAGER = 124,
		bl_icon_NODE_COMPOSITING = 125,
		bl_icon_NODE_TEXTURE = 126,
		bl_icon_NODE_MATERIAL = 127,
		bl_icon_UV = 128,
		bl_icon_OBJECT_DATAMODE = 130,
		bl_icon_EDITMODE_HLT = 131,
		bl_icon_UV_DATA = 132,
		bl_icon_VPAINT_HLT = 133,
		bl_icon_TPAINT_HLT = 134,
		bl_icon_WPAINT_HLT = 135,
		bl_icon_SCULPTMODE_HLT = 136,
		bl_icon_POSE_HLT = 137,
		bl_icon_PARTICLEMODE = 138,
		bl_icon_TRACKING = 146,
		bl_icon_TRACKING_BACKWARDS = 147,
		bl_icon_TRACKING_FORWARDS = 148,
		bl_icon_TRACKING_BACKWARDS_SINGLE = 149,
		bl_icon_TRACKING_FORWARDS_SINGLE = 150,
		bl_icon_TRACKING_CLEAR_BACKWARDS = 151,
		bl_icon_TRACKING_CLEAR_FORWARDS = 152,
		bl_icon_TRACKING_REFINE_BACKWARDS = 153,
		bl_icon_TRACKING_REFINE_FORWARDS = 154,
		bl_icon_SCENE_DATA = 156,
		bl_icon_RENDERLAYERS = 157,
		bl_icon_WORLD_DATA = 158,
		bl_icon_OBJECT_DATA = 159,
		bl_icon_MESH_DATA = 160,
		bl_icon_CURVE_DATA = 161,
		bl_icon_META_DATA = 162,
		bl_icon_LATTICE_DATA = 163,
		bl_icon_LIGHT_DATA = 164,
		bl_icon_MATERIAL_DATA = 165,
		bl_icon_TEXTURE_DATA = 166,
		bl_icon_ANIM_DATA = 167,
		bl_icon_CAMERA_DATA = 168,
		bl_icon_PARTICLE_DATA = 169,
		bl_icon_LIBRARY_DATA_DIRECT = 170,
		bl_icon_GROUP = 171,
		bl_icon_ARMATURE_DATA = 172,
		bl_icon_COMMUNITY = 173,
		bl_icon_BONE_DATA = 174,
		bl_icon_CONSTRAINT = 175,
		bl_icon_SHAPEKEY_DATA = 176,
		bl_icon_CONSTRAINT_BONE = 177,
		bl_icon_CAMERA_STEREO = 178,
		bl_icon_PACKAGE = 179,
		bl_icon_UGLYPACKAGE = 180,
		bl_icon_EXPERIMENTAL = 181,
		bl_icon_BRUSH_DATA = 182,
		bl_icon_IMAGE_DATA = 183,
		bl_icon_FILE = 184,
		bl_icon_FCURVE = 185,
		bl_icon_FONT_DATA = 186,
		bl_icon_RENDER_RESULT = 187,
		bl_icon_SURFACE_DATA = 188,
		bl_icon_EMPTY_DATA = 189,
		bl_icon_PRESET = 190,
		bl_icon_RENDER_ANIMATION = 191,
		bl_icon_RENDER_STILL = 192,
		bl_icon_LIBRARY_DATA_BROKEN = 193,
		bl_icon_BOIDS = 194,
		bl_icon_STRANDS = 195,
		bl_icon_GREASEPENCIL = 197,
		bl_icon_LINE_DATA = 198,
		bl_icon_LIBRARY_DATA_OVERRIDE = 199,
		bl_icon_GROUP_BONE = 200,
		bl_icon_GROUP_VERTEX = 201,
		bl_icon_GROUP_VCOL = 202,
		bl_icon_GROUP_UVS = 203,
		bl_icon_FACE_MAPS = 204,
		bl_icon_RNA = 206,
		bl_icon_RNA_ADD = 207,
		bl_icon_MOUSE_LMB = 208,
		bl_icon_MOUSE_MMB = 209,
		bl_icon_MOUSE_RMB = 210,
		bl_icon_MOUSE_MOVE = 211,
		bl_icon_MOUSE_LMB_DRAG = 212,
		bl_icon_MOUSE_MMB_DRAG = 213,
		bl_icon_MOUSE_RMB_DRAG = 214,
		bl_icon_MEMORY = 215,
		bl_icon_PRESET_NEW = 216,
		bl_icon_DECORATE = 218,
		bl_icon_DECORATE_KEYFRAME = 219,
		bl_icon_DECORATE_ANIMATE = 220,
		bl_icon_DECORATE_DRIVER = 221,
		bl_icon_DECORATE_LINKED = 222,
		bl_icon_DECORATE_LIBRARY_OVERRIDE = 223,
		bl_icon_DECORATE_UNLOCKED = 224,
		bl_icon_DECORATE_LOCKED = 225,
		bl_icon_DECORATE_OVERRIDE = 226,
		bl_icon_FUND = 227,
		bl_icon_TRACKER_DATA = 228,
		bl_icon_HEART = 229,
		bl_icon_ORPHAN_DATA = 230,
		bl_icon_USER = 231,
		bl_icon_SYSTEM = 232,
		bl_icon_SETTINGS = 233,
		bl_icon_OUTLINER_OB_EMPTY = 234,
		bl_icon_OUTLINER_OB_MESH = 235,
		bl_icon_OUTLINER_OB_CURVE = 236,
		bl_icon_OUTLINER_OB_LATTICE = 237,
		bl_icon_OUTLINER_OB_META = 238,
		bl_icon_OUTLINER_OB_LIGHT = 239,
		bl_icon_OUTLINER_OB_CAMERA = 240,
		bl_icon_OUTLINER_OB_ARMATURE = 241,
		bl_icon_OUTLINER_OB_FONT = 242,
		bl_icon_OUTLINER_OB_SURFACE = 243,
		bl_icon_OUTLINER_OB_SPEAKER = 244,
		bl_icon_OUTLINER_OB_FORCE_FIELD = 245,
		bl_icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		bl_icon_OUTLINER_OB_GREASEPENCIL = 247,
		bl_icon_OUTLINER_OB_LIGHTPROBE = 248,
		bl_icon_OUTLINER_OB_IMAGE = 249,
		bl_icon_OUTLINER_COLLECTION = 250,
		bl_icon_RESTRICT_COLOR_OFF = 251,
		bl_icon_RESTRICT_COLOR_ON = 252,
		bl_icon_HIDE_ON = 253,
		bl_icon_HIDE_OFF = 254,
		bl_icon_RESTRICT_SELECT_ON = 255,
		bl_icon_RESTRICT_SELECT_OFF = 256,
		bl_icon_RESTRICT_RENDER_ON = 257,
		bl_icon_RESTRICT_RENDER_OFF = 258,
		bl_icon_RESTRICT_INSTANCED_OFF = 259,
		bl_icon_OUTLINER_DATA_EMPTY = 260,
		bl_icon_OUTLINER_DATA_MESH = 261,
		bl_icon_OUTLINER_DATA_CURVE = 262,
		bl_icon_OUTLINER_DATA_LATTICE = 263,
		bl_icon_OUTLINER_DATA_META = 264,
		bl_icon_OUTLINER_DATA_LIGHT = 265,
		bl_icon_OUTLINER_DATA_CAMERA = 266,
		bl_icon_OUTLINER_DATA_ARMATURE = 267,
		bl_icon_OUTLINER_DATA_FONT = 268,
		bl_icon_OUTLINER_DATA_SURFACE = 269,
		bl_icon_OUTLINER_DATA_SPEAKER = 270,
		bl_icon_OUTLINER_DATA_LIGHTPROBE = 271,
		bl_icon_OUTLINER_DATA_GP_LAYER = 272,
		bl_icon_OUTLINER_DATA_GREASEPENCIL = 273,
		bl_icon_GP_SELECT_POINTS = 274,
		bl_icon_GP_SELECT_STROKES = 275,
		bl_icon_GP_MULTIFRAME_EDITING = 276,
		bl_icon_GP_ONLY_SELECTED = 277,
		bl_icon_GP_SELECT_BETWEEN_STROKES = 278,
		bl_icon_MODIFIER_OFF = 279,
		bl_icon_MODIFIER_ON = 280,
		bl_icon_ONIONSKIN_OFF = 281,
		bl_icon_ONIONSKIN_ON = 282,
		bl_icon_RESTRICT_VIEW_ON = 283,
		bl_icon_RESTRICT_VIEW_OFF = 284,
		bl_icon_RESTRICT_INSTANCED_ON = 285,
		bl_icon_MESH_PLANE = 286,
		bl_icon_MESH_CUBE = 287,
		bl_icon_MESH_CIRCLE = 288,
		bl_icon_MESH_UVSPHERE = 289,
		bl_icon_MESH_ICOSPHERE = 290,
		bl_icon_MESH_GRID = 291,
		bl_icon_MESH_MONKEY = 292,
		bl_icon_MESH_CYLINDER = 293,
		bl_icon_MESH_TORUS = 294,
		bl_icon_MESH_CONE = 295,
		bl_icon_MESH_CAPSULE = 296,
		bl_icon_EMPTY_SINGLE_ARROW = 297,
		bl_icon_LIGHT_POINT = 298,
		bl_icon_LIGHT_SUN = 299,
		bl_icon_LIGHT_SPOT = 300,
		bl_icon_LIGHT_HEMI = 301,
		bl_icon_LIGHT_AREA = 302,
		bl_icon_CUBE = 303,
		bl_icon_SPHERE = 304,
		bl_icon_CONE = 305,
		bl_icon_META_PLANE = 306,
		bl_icon_META_CUBE = 307,
		bl_icon_META_BALL = 308,
		bl_icon_META_ELLIPSOID = 309,
		bl_icon_META_CAPSULE = 310,
		bl_icon_SURFACE_NCURVE = 312,
		bl_icon_SURFACE_NCIRCLE = 313,
		bl_icon_SURFACE_NSURFACE = 314,
		bl_icon_SURFACE_NCYLINDER = 315,
		bl_icon_SURFACE_NSPHERE = 316,
		bl_icon_SURFACE_NTORUS = 317,
		bl_icon_EMPTY_AXIS = 318,
		bl_icon_STROKE = 319,
		bl_icon_EMPTY_ARROWS = 320,
		bl_icon_CURVE_BEZCURVE = 321,
		bl_icon_CURVE_BEZCIRCLE = 322,
		bl_icon_CURVE_NCURVE = 323,
		bl_icon_CURVE_NCIRCLE = 324,
		bl_icon_CURVE_PATH = 325,
		bl_icon_LIGHTPROBE_SPHERE = 326,
		bl_icon_LIGHTPROBE_PLANE = 327,
		bl_icon_LIGHTPROBE_VOLUME = 328,
		bl_icon_COLOR_RED = 331,
		bl_icon_COLOR_GREEN = 332,
		bl_icon_COLOR_BLUE = 333,
		bl_icon_TRIA_RIGHT_BAR = 334,
		bl_icon_TRIA_DOWN_BAR = 335,
		bl_icon_TRIA_LEFT_BAR = 336,
		bl_icon_TRIA_UP_BAR = 337,
		bl_icon_FORCE_FORCE = 338,
		bl_icon_FORCE_WIND = 339,
		bl_icon_FORCE_VORTEX = 340,
		bl_icon_FORCE_MAGNETIC = 341,
		bl_icon_FORCE_HARMONIC = 342,
		bl_icon_FORCE_CHARGE = 343,
		bl_icon_FORCE_LENNARDJONES = 344,
		bl_icon_FORCE_TEXTURE = 345,
		bl_icon_FORCE_CURVE = 346,
		bl_icon_FORCE_BOID = 347,
		bl_icon_FORCE_TURBULENCE = 348,
		bl_icon_FORCE_DRAG = 349,
		bl_icon_FORCE_FLUIDFLOW = 350,
		bl_icon_RIGID_BODY = 353,
		bl_icon_RIGID_BODY_CONSTRAINT = 354,
		bl_icon_SPLIT_HORIZONTAL = 359,
		bl_icon_SPLIT_VERTICAL = 360,
		bl_icon_IMAGE_PLANE = 361,
		bl_icon_IMAGE_BACKGROUND = 362,
		bl_icon_IMAGE_REFERENCE = 363,
		bl_icon_NODE_INSERT_ON = 367,
		bl_icon_NODE_INSERT_OFF = 368,
		bl_icon_NODE_TOP = 369,
		bl_icon_NODE_SIDE = 370,
		bl_icon_NODE_CORNER = 371,
		bl_icon_ANCHOR_TOP = 372,
		bl_icon_ANCHOR_BOTTOM = 373,
		bl_icon_ANCHOR_LEFT = 374,
		bl_icon_ANCHOR_RIGHT = 375,
		bl_icon_ANCHOR_CENTER = 376,
		bl_icon_SELECT_SET = 385,
		bl_icon_SELECT_EXTEND = 386,
		bl_icon_SELECT_SUBTRACT = 387,
		bl_icon_SELECT_INTERSECT = 388,
		bl_icon_SELECT_DIFFERENCE = 389,
		bl_icon_ALIGN_LEFT = 390,
		bl_icon_ALIGN_CENTER = 391,
		bl_icon_ALIGN_RIGHT = 392,
		bl_icon_ALIGN_JUSTIFY = 393,
		bl_icon_ALIGN_FLUSH = 394,
		bl_icon_ALIGN_TOP = 395,
		bl_icon_ALIGN_MIDDLE = 396,
		bl_icon_ALIGN_BOTTOM = 397,
		bl_icon_BOLD = 398,
		bl_icon_ITALIC = 399,
		bl_icon_UNDERLINE = 400,
		bl_icon_SMALL_CAPS = 401,
		bl_icon_CON_ACTION = 404,
		bl_icon_MOD_ENVELOPE = 406,
		bl_icon_MOD_OUTLINE = 407,
		bl_icon_MOD_LENGTH = 408,
		bl_icon_MOD_DASH = 409,
		bl_icon_MOD_LINEART = 410,
		bl_icon_HOLDOUT_OFF = 412,
		bl_icon_HOLDOUT_ON = 413,
		bl_icon_INDIRECT_ONLY_OFF = 414,
		bl_icon_INDIRECT_ONLY_ON = 415,
		bl_icon_CON_CAMERASOLVER = 416,
		bl_icon_CON_FOLLOWTRACK = 417,
		bl_icon_CON_OBJECTSOLVER = 418,
		bl_icon_CON_LOCLIKE = 419,
		bl_icon_CON_ROTLIKE = 420,
		bl_icon_CON_SIZELIKE = 421,
		bl_icon_CON_TRANSLIKE = 422,
		bl_icon_CON_DISTLIMIT = 423,
		bl_icon_CON_LOCLIMIT = 424,
		bl_icon_CON_ROTLIMIT = 425,
		bl_icon_CON_SIZELIMIT = 426,
		bl_icon_CON_SAMEVOL = 427,
		bl_icon_CON_TRANSFORM = 428,
		bl_icon_CON_TRANSFORM_CACHE = 429,
		bl_icon_CON_CLAMPTO = 430,
		bl_icon_CON_KINEMATIC = 431,
		bl_icon_CON_LOCKTRACK = 432,
		bl_icon_CON_SPLINEIK = 433,
		bl_icon_CON_STRETCHTO = 434,
		bl_icon_CON_TRACKTO = 435,
		bl_icon_CON_ARMATURE = 436,
		bl_icon_CON_CHILDOF = 437,
		bl_icon_CON_FLOOR = 438,
		bl_icon_CON_FOLLOWPATH = 439,
		bl_icon_CON_PIVOT = 440,
		bl_icon_CON_SHRINKWRAP = 441,
		bl_icon_MODIFIER_DATA = 442,
		bl_icon_MOD_WAVE = 443,
		bl_icon_MOD_BUILD = 444,
		bl_icon_MOD_DECIM = 445,
		bl_icon_MOD_MIRROR = 446,
		bl_icon_MOD_SOFT = 447,
		bl_icon_MOD_SUBSURF = 448,
		bl_icon_HOOK = 449,
		bl_icon_MOD_PHYSICS = 450,
		bl_icon_MOD_PARTICLES = 451,
		bl_icon_MOD_BOOLEAN = 452,
		bl_icon_MOD_EDGESPLIT = 453,
		bl_icon_MOD_ARRAY = 454,
		bl_icon_MOD_UVPROJECT = 455,
		bl_icon_MOD_DISPLACE = 456,
		bl_icon_MOD_CURVE = 457,
		bl_icon_MOD_LATTICE = 458,
		bl_icon_MOD_TINT = 459,
		bl_icon_MOD_ARMATURE = 460,
		bl_icon_MOD_SHRINKWRAP = 461,
		bl_icon_MOD_CAST = 462,
		bl_icon_MOD_MESHDEFORM = 463,
		bl_icon_MOD_BEVEL = 464,
		bl_icon_MOD_SMOOTH = 465,
		bl_icon_MOD_SIMPLEDEFORM = 466,
		bl_icon_MOD_MASK = 467,
		bl_icon_MOD_CLOTH = 468,
		bl_icon_MOD_EXPLODE = 469,
		bl_icon_MOD_FLUIDSIM = 470,
		bl_icon_MOD_MULTIRES = 471,
		bl_icon_MOD_FLUID = 472,
		bl_icon_MOD_SOLIDIFY = 473,
		bl_icon_MOD_SCREW = 474,
		bl_icon_MOD_VERTEX_WEIGHT = 475,
		bl_icon_MOD_DYNAMICPAINT = 476,
		bl_icon_MOD_REMESH = 477,
		bl_icon_MOD_OCEAN = 478,
		bl_icon_MOD_WARP = 479,
		bl_icon_MOD_SKIN = 480,
		bl_icon_MOD_TRIANGULATE = 481,
		bl_icon_MOD_WIREFRAME = 482,
		bl_icon_MOD_DATA_TRANSFER = 483,
		bl_icon_MOD_NORMALEDIT = 484,
		bl_icon_MOD_PARTICLE_INSTANCE = 485,
		bl_icon_MOD_HUE_SATURATION = 486,
		bl_icon_MOD_NOISE = 487,
		bl_icon_MOD_OFFSET = 488,
		bl_icon_MOD_SIMPLIFY = 489,
		bl_icon_MOD_THICKNESS = 490,
		bl_icon_MOD_INSTANCE = 491,
		bl_icon_MOD_TIME = 492,
		bl_icon_MOD_OPACITY = 493,
		bl_icon_REC = 494,
		bl_icon_PLAY = 495,
		bl_icon_FF = 496,
		bl_icon_REW = 497,
		bl_icon_PAUSE = 498,
		bl_icon_PREV_KEYFRAME = 499,
		bl_icon_NEXT_KEYFRAME = 500,
		bl_icon_PLAY_SOUND = 501,
		bl_icon_PLAY_REVERSE = 502,
		bl_icon_PREVIEW_RANGE = 503,
		bl_icon_ACTION_TWEAK = 504,
		bl_icon_PMARKER_ACT = 505,
		bl_icon_PMARKER_SEL = 506,
		bl_icon_PMARKER = 507,
		bl_icon_MARKER_HLT = 508,
		bl_icon_MARKER = 509,
		bl_icon_KEYFRAME_HLT = 510,
		bl_icon_KEYFRAME = 511,
		bl_icon_KEYINGSET = 512,
		bl_icon_KEY_DEHLT = 513,
		bl_icon_KEY_HLT = 514,
		bl_icon_MUTE_IPO_OFF = 515,
		bl_icon_MUTE_IPO_ON = 516,
		bl_icon_DRIVER = 519,
		bl_icon_SOLO_OFF = 520,
		bl_icon_SOLO_ON = 521,
		bl_icon_FRAME_PREV = 522,
		bl_icon_FRAME_NEXT = 523,
		bl_icon_NLA_PUSHDOWN = 524,
		bl_icon_IPO_CONSTANT = 525,
		bl_icon_IPO_LINEAR = 526,
		bl_icon_IPO_BEZIER = 527,
		bl_icon_IPO_SINE = 528,
		bl_icon_IPO_QUAD = 529,
		bl_icon_IPO_CUBIC = 530,
		bl_icon_IPO_QUART = 531,
		bl_icon_IPO_QUINT = 532,
		bl_icon_IPO_EXPO = 533,
		bl_icon_IPO_CIRC = 534,
		bl_icon_IPO_BOUNCE = 535,
		bl_icon_IPO_ELASTIC = 536,
		bl_icon_IPO_BACK = 537,
		bl_icon_IPO_EASE_IN = 538,
		bl_icon_IPO_EASE_OUT = 539,
		bl_icon_IPO_EASE_IN_OUT = 540,
		bl_icon_NORMALIZE_FCURVES = 541,
		bl_icon_ORIENTATION_PARENT = 542,
		bl_icon_VERTEXSEL = 546,
		bl_icon_EDGESEL = 547,
		bl_icon_FACESEL = 548,
		bl_icon_CURSOR = 550,
		bl_icon_PIVOT_BOUNDBOX = 551,
		bl_icon_PIVOT_CURSOR = 552,
		bl_icon_PIVOT_INDIVIDUAL = 553,
		bl_icon_PIVOT_MEDIAN = 554,
		bl_icon_PIVOT_ACTIVE = 555,
		bl_icon_CENTER_ONLY = 556,
		bl_icon_ROOTCURVE = 557,
		bl_icon_SMOOTHCURVE = 558,
		bl_icon_SPHERECURVE = 559,
		bl_icon_INVERSESQUARECURVE = 560,
		bl_icon_SHARPCURVE = 561,
		bl_icon_LINCURVE = 562,
		bl_icon_NOCURVE = 563,
		bl_icon_RNDCURVE = 564,
		bl_icon_PROP_OFF = 565,
		bl_icon_PROP_ON = 566,
		bl_icon_PROP_CON = 567,
		bl_icon_PROP_PROJECTED = 568,
		bl_icon_PARTICLE_POINT = 569,
		bl_icon_PARTICLE_TIP = 570,
		bl_icon_PARTICLE_PATH = 571,
		bl_icon_SNAP_FACE_NEAREST = 572,
		bl_icon_SNAP_FACE_CENTER = 573,
		bl_icon_SNAP_PERPENDICULAR = 574,
		bl_icon_SNAP_MIDPOINT = 575,
		bl_icon_SNAP_OFF = 576,
		bl_icon_SNAP_ON = 577,
		bl_icon_SNAP_NORMAL = 578,
		bl_icon_SNAP_GRID = 579,
		bl_icon_SNAP_VERTEX = 580,
		bl_icon_SNAP_EDGE = 581,
		bl_icon_SNAP_FACE = 582,
		bl_icon_SNAP_VOLUME = 583,
		bl_icon_SNAP_INCREMENT = 584,
		bl_icon_STICKY_UVS_LOC = 585,
		bl_icon_STICKY_UVS_DISABLE = 586,
		bl_icon_STICKY_UVS_VERT = 587,
		bl_icon_CLIPUV_DEHLT = 588,
		bl_icon_CLIPUV_HLT = 589,
		bl_icon_SNAP_PEEL_OBJECT = 590,
		bl_icon_GRID = 591,
		bl_icon_OBJECT_ORIGIN = 592,
		bl_icon_ORIENTATION_GLOBAL = 593,
		bl_icon_ORIENTATION_GIMBAL = 594,
		bl_icon_ORIENTATION_LOCAL = 595,
		bl_icon_ORIENTATION_NORMAL = 596,
		bl_icon_ORIENTATION_VIEW = 597,
		bl_icon_COPYDOWN = 598,
		bl_icon_PASTEDOWN = 599,
		bl_icon_PASTEFLIPUP = 600,
		bl_icon_PASTEFLIPDOWN = 601,
		bl_icon_VIS_SEL_11 = 602,
		bl_icon_VIS_SEL_10 = 603,
		bl_icon_VIS_SEL_01 = 604,
		bl_icon_VIS_SEL_00 = 605,
		bl_icon_AUTOMERGE_OFF = 607,
		bl_icon_AUTOMERGE_ON = 608,
		bl_icon_UV_VERTEXSEL = 610,
		bl_icon_UV_EDGESEL = 611,
		bl_icon_UV_FACESEL = 612,
		bl_icon_UV_ISLANDSEL = 613,
		bl_icon_UV_SYNC_SELECT = 614,
		bl_icon_GP_CAPS_FLAT = 615,
		bl_icon_GP_CAPS_ROUND = 616,
		bl_icon_FIXED_SIZE = 617,
		bl_icon_TRANSFORM_ORIGINS = 618,
		bl_icon_GIZMO = 619,
		bl_icon_ORIENTATION_CURSOR = 620,
		bl_icon_NORMALS_VERTEX = 621,
		bl_icon_NORMALS_FACE = 622,
		bl_icon_NORMALS_VERTEX_FACE = 623,
		bl_icon_SHADING_BBOX = 624,
		bl_icon_SHADING_WIRE = 625,
		bl_icon_SHADING_SOLID = 626,
		bl_icon_SHADING_RENDERED = 627,
		bl_icon_SHADING_TEXTURE = 628,
		bl_icon_OVERLAY = 629,
		bl_icon_XRAY = 630,
		bl_icon_LOCKVIEW_OFF = 633,
		bl_icon_LOCKVIEW_ON = 634,
		bl_icon_AXIS_SIDE = 636,
		bl_icon_AXIS_FRONT = 637,
		bl_icon_AXIS_TOP = 638,
		bl_icon_LAYER_USED = 643,
		bl_icon_LAYER_ACTIVE = 644,
		bl_icon_OUTLINER_OB_CURVES = 650,
		bl_icon_OUTLINER_DATA_CURVES = 651,
		bl_icon_CURVES_DATA = 652,
		bl_icon_OUTLINER_OB_POINTCLOUD = 653,
		bl_icon_OUTLINER_DATA_POINTCLOUD = 654,
		bl_icon_POINTCLOUD_DATA = 655,
		bl_icon_OUTLINER_OB_VOLUME = 656,
		bl_icon_OUTLINER_DATA_VOLUME = 657,
		bl_icon_VOLUME_DATA = 658,
		bl_icon_CURRENT_FILE = 672,
		bl_icon_HOME = 673,
		bl_icon_DOCUMENTS = 674,
		bl_icon_TEMP = 675,
		bl_icon_SORTALPHA = 676,
		bl_icon_SORTBYEXT = 677,
		bl_icon_SORTTIME = 678,
		bl_icon_SORTSIZE = 679,
		bl_icon_SHORTDISPLAY = 680,
		bl_icon_LONGDISPLAY = 681,
		bl_icon_IMGDISPLAY = 683,
		bl_icon_BOOKMARKS = 686,
		bl_icon_FONTPREVIEW = 687,
		bl_icon_FILTER = 688,
		bl_icon_NEWFOLDER = 689,
		bl_icon_FOLDER_REDIRECT = 690,
		bl_icon_FILE_PARENT = 691,
		bl_icon_FILE_REFRESH = 692,
		bl_icon_FILE_FOLDER = 693,
		bl_icon_FILE_BLANK = 694,
		bl_icon_FILE_BLEND = 695,
		bl_icon_FILE_IMAGE = 696,
		bl_icon_FILE_MOVIE = 697,
		bl_icon_FILE_SCRIPT = 698,
		bl_icon_FILE_SOUND = 699,
		bl_icon_FILE_FONT = 700,
		bl_icon_FILE_TEXT = 701,
		bl_icon_SORT_DESC = 702,
		bl_icon_SORT_ASC = 703,
		bl_icon_LINK_BLEND = 704,
		bl_icon_APPEND_BLEND = 705,
		bl_icon_IMPORT = 706,
		bl_icon_EXPORT = 707,
		bl_icon_LOOP_BACK = 715,
		bl_icon_LOOP_FORWARDS = 716,
		bl_icon_BACK = 717,
		bl_icon_FORWARD = 718,
		bl_icon_FILE_ARCHIVE = 721,
		bl_icon_FILE_CACHE = 722,
		bl_icon_FILE_VOLUME = 723,
		bl_icon_FILE_3D = 724,
		bl_icon_FILE_HIDDEN = 725,
		bl_icon_FILE_BACKUP = 726,
		bl_icon_DISK_DRIVE = 727,
		bl_icon_MATPLANE = 728,
		bl_icon_MATSPHERE = 729,
		bl_icon_MATCUBE = 730,
		bl_icon_MONKEY = 731,
		bl_icon_CURVES = 732,
		bl_icon_ALIASED = 733,
		bl_icon_ANTIALIASED = 734,
		bl_icon_MAT_SPHERE_SKY = 735,
		bl_icon_MATSHADERBALL = 736,
		bl_icon_MATCLOTH = 737,
		bl_icon_MATFLUID = 738,
		bl_icon_WORDWRAP_OFF = 740,
		bl_icon_WORDWRAP_ON = 741,
		bl_icon_SYNTAX_OFF = 742,
		bl_icon_SYNTAX_ON = 743,
		bl_icon_LINENUMBERS_OFF = 744,
		bl_icon_LINENUMBERS_ON = 745,
		bl_icon_SCRIPTPLUGINS = 746,
		bl_icon_DISC = 750,
		bl_icon_DESKTOP = 751,
		bl_icon_EXTERNAL_DRIVE = 752,
		bl_icon_NETWORK_DRIVE = 753,
		bl_icon_SEQ_SEQUENCER = 754,
		bl_icon_SEQ_PREVIEW = 755,
		bl_icon_SEQ_LUMA_WAVEFORM = 756,
		bl_icon_SEQ_CHROMA_SCOPE = 757,
		bl_icon_SEQ_HISTOGRAM = 758,
		bl_icon_SEQ_SPLITVIEW = 759,
		bl_icon_SEQ_STRIP_META = 760,
		bl_icon_SEQ_STRIP_DUPLICATE = 761,
		bl_icon_IMAGE_RGB = 763,
		bl_icon_IMAGE_RGB_ALPHA = 764,
		bl_icon_IMAGE_ALPHA = 765,
		bl_icon_IMAGE_ZDEPTH = 766,
		bl_icon_HANDLE_AUTOCLAMPED = 767,
		bl_icon_HANDLE_AUTO = 768,
		bl_icon_HANDLE_ALIGNED = 769,
		bl_icon_HANDLE_VECTOR = 770,
		bl_icon_HANDLE_FREE = 771,
		bl_icon_VIEW_PERSPECTIVE = 775,
		bl_icon_VIEW_ORTHO = 776,
		bl_icon_VIEW_CAMERA = 777,
		bl_icon_VIEW_PAN = 778,
		bl_icon_VIEW_ZOOM = 779,
		bl_icon_BRUSH_BLOB = 780,
		bl_icon_BRUSH_BLUR = 781,
		bl_icon_BRUSH_CLAY = 782,
		bl_icon_BRUSH_CLAY_STRIPS = 783,
		bl_icon_BRUSH_CLONE = 784,
		bl_icon_BRUSH_CREASE = 785,
		bl_icon_BRUSH_FILL = 786,
		bl_icon_BRUSH_FLATTEN = 787,
		bl_icon_BRUSH_GRAB = 788,
		bl_icon_BRUSH_INFLATE = 789,
		bl_icon_BRUSH_LAYER = 790,
		bl_icon_BRUSH_MASK = 791,
		bl_icon_BRUSH_MIX = 792,
		bl_icon_BRUSH_NUDGE = 793,
		bl_icon_BRUSH_PAINT_SELECT = 794,
		bl_icon_BRUSH_PINCH = 795,
		bl_icon_BRUSH_SCRAPE = 796,
		bl_icon_BRUSH_SCULPT_DRAW = 797,
		bl_icon_BRUSH_SMEAR = 798,
		bl_icon_BRUSH_SMOOTH = 799,
		bl_icon_BRUSH_SNAKE_HOOK = 800,
		bl_icon_BRUSH_SOFTEN = 801,
		bl_icon_BRUSH_TEXDRAW = 802,
		bl_icon_BRUSH_TEXFILL = 803,
		bl_icon_BRUSH_TEXMASK = 804,
		bl_icon_BRUSH_THUMB = 805,
		bl_icon_BRUSH_ROTATE = 806,
		bl_icon_GPBRUSH_SMOOTH = 807,
		bl_icon_GPBRUSH_THICKNESS = 808,
		bl_icon_GPBRUSH_STRENGTH = 809,
		bl_icon_GPBRUSH_GRAB = 810,
		bl_icon_GPBRUSH_PUSH = 811,
		bl_icon_GPBRUSH_TWIST = 812,
		bl_icon_GPBRUSH_PINCH = 813,
		bl_icon_GPBRUSH_RANDOMIZE = 814,
		bl_icon_GPBRUSH_CLONE = 815,
		bl_icon_GPBRUSH_WEIGHT = 816,
		bl_icon_GPBRUSH_PENCIL = 817,
		bl_icon_GPBRUSH_PEN = 818,
		bl_icon_GPBRUSH_INK = 819,
		bl_icon_GPBRUSH_INKNOISE = 820,
		bl_icon_GPBRUSH_BLOCK = 821,
		bl_icon_GPBRUSH_MARKER = 822,
		bl_icon_GPBRUSH_FILL = 823,
		bl_icon_GPBRUSH_AIRBRUSH = 824,
		bl_icon_GPBRUSH_CHISEL = 825,
		bl_icon_GPBRUSH_ERASE_SOFT = 826,
		bl_icon_GPBRUSH_ERASE_HARD = 827,
		bl_icon_GPBRUSH_ERASE_STROKE = 828,
		bl_icon_BRUSH_CURVES_ADD = 829,
		bl_icon_BRUSH_CURVES_COMB = 830,
		bl_icon_BRUSH_CURVES_CUT = 831,
		bl_icon_BRUSH_CURVES_DELETE = 832,
		bl_icon_BRUSH_CURVES_DENSITY = 833,
		bl_icon_BRUSH_CURVES_GROW_SHRINK = 834,
		bl_icon_BRUSH_CURVES_PINCH = 835,
		bl_icon_BRUSH_CURVES_PUFF = 836,
		bl_icon_BRUSH_CURVES_SLIDE = 837,
		bl_icon_BRUSH_CURVES_SMOOTH = 838,
		bl_icon_BRUSH_CURVES_SNAKE_HOOK = 839,
		bl_icon_KEYTYPE_KEYFRAME_VEC = 840,
		bl_icon_KEYTYPE_BREAKDOWN_VEC = 841,
		bl_icon_KEYTYPE_EXTREME_VEC = 842,
		bl_icon_KEYTYPE_JITTER_VEC = 843,
		bl_icon_KEYTYPE_MOVING_HOLD_VEC = 844,
		bl_icon_HANDLETYPE_FREE_VEC = 845,
		bl_icon_HANDLETYPE_ALIGNED_VEC = 846,
		bl_icon_HANDLETYPE_VECTOR_VEC = 847,
		bl_icon_HANDLETYPE_AUTO_VEC = 848,
		bl_icon_HANDLETYPE_AUTO_CLAMP_VEC = 849,
		bl_icon_COLORSET_01_VEC = 850,
		bl_icon_COLORSET_02_VEC = 851,
		bl_icon_COLORSET_03_VEC = 852,
		bl_icon_COLORSET_04_VEC = 853,
		bl_icon_COLORSET_05_VEC = 854,
		bl_icon_COLORSET_06_VEC = 855,
		bl_icon_COLORSET_07_VEC = 856,
		bl_icon_COLORSET_08_VEC = 857,
		bl_icon_COLORSET_09_VEC = 858,
		bl_icon_COLORSET_10_VEC = 859,
		bl_icon_COLORSET_11_VEC = 860,
		bl_icon_COLORSET_12_VEC = 861,
		bl_icon_COLORSET_13_VEC = 862,
		bl_icon_COLORSET_14_VEC = 863,
		bl_icon_COLORSET_15_VEC = 864,
		bl_icon_COLORSET_16_VEC = 865,
		bl_icon_COLORSET_17_VEC = 866,
		bl_icon_COLORSET_18_VEC = 867,
		bl_icon_COLORSET_19_VEC = 868,
		bl_icon_COLORSET_20_VEC = 869,
		bl_icon_COLLECTION_COLOR_01 = 870,
		bl_icon_COLLECTION_COLOR_02 = 871,
		bl_icon_COLLECTION_COLOR_03 = 872,
		bl_icon_COLLECTION_COLOR_04 = 873,
		bl_icon_COLLECTION_COLOR_05 = 874,
		bl_icon_COLLECTION_COLOR_06 = 875,
		bl_icon_COLLECTION_COLOR_07 = 876,
		bl_icon_COLLECTION_COLOR_08 = 877,
		bl_icon_SEQUENCE_COLOR_01 = 878,
		bl_icon_SEQUENCE_COLOR_02 = 879,
		bl_icon_SEQUENCE_COLOR_03 = 880,
		bl_icon_SEQUENCE_COLOR_04 = 881,
		bl_icon_SEQUENCE_COLOR_05 = 882,
		bl_icon_SEQUENCE_COLOR_06 = 883,
		bl_icon_SEQUENCE_COLOR_07 = 884,
		bl_icon_SEQUENCE_COLOR_08 = 885,
		bl_icon_SEQUENCE_COLOR_09 = 886,
		bl_icon_LIBRARY_DATA_INDIRECT = 887,
		bl_icon_LIBRARY_DATA_OVERRIDE_NONEDITABLE = 888,
		bl_icon_EVENT_A = 889,
		bl_icon_EVENT_B = 890,
		bl_icon_EVENT_C = 891,
		bl_icon_EVENT_D = 892,
		bl_icon_EVENT_E = 893,
		bl_icon_EVENT_F = 894,
		bl_icon_EVENT_G = 895,
		bl_icon_EVENT_H = 896,
		bl_icon_EVENT_I = 897,
		bl_icon_EVENT_J = 898,
		bl_icon_EVENT_K = 899,
		bl_icon_EVENT_L = 900,
		bl_icon_EVENT_M = 901,
		bl_icon_EVENT_N = 902,
		bl_icon_EVENT_O = 903,
		bl_icon_EVENT_P = 904,
		bl_icon_EVENT_Q = 905,
		bl_icon_EVENT_R = 906,
		bl_icon_EVENT_S = 907,
		bl_icon_EVENT_T = 908,
		bl_icon_EVENT_U = 909,
		bl_icon_EVENT_V = 910,
		bl_icon_EVENT_W = 911,
		bl_icon_EVENT_X = 912,
		bl_icon_EVENT_Y = 913,
		bl_icon_EVENT_Z = 914,
		bl_icon_EVENT_SHIFT = 915,
		bl_icon_EVENT_CTRL = 916,
		bl_icon_EVENT_ALT = 917,
		bl_icon_EVENT_OS = 918,
		bl_icon_EVENT_F1 = 919,
		bl_icon_EVENT_F2 = 920,
		bl_icon_EVENT_F3 = 921,
		bl_icon_EVENT_F4 = 922,
		bl_icon_EVENT_F5 = 923,
		bl_icon_EVENT_F6 = 924,
		bl_icon_EVENT_F7 = 925,
		bl_icon_EVENT_F8 = 926,
		bl_icon_EVENT_F9 = 927,
		bl_icon_EVENT_F10 = 928,
		bl_icon_EVENT_F11 = 929,
		bl_icon_EVENT_F12 = 930,
		bl_icon_EVENT_ESC = 931,
		bl_icon_EVENT_TAB = 932,
		bl_icon_EVENT_PAGEUP = 933,
		bl_icon_EVENT_PAGEDOWN = 934,
		bl_icon_EVENT_RETURN = 935,
		bl_icon_EVENT_SPACEKEY = 936,
	};
	inline bl_icon_enum bl_icon(void);
	inline void bl_icon(bl_icon_enum value);
	enum bl_static_type_enum {
		bl_static_type_CUSTOM = -1,
	};
	inline bl_static_type_enum bl_static_type(void);
	inline void bl_static_type(bl_static_type_enum value);
	inline float bl_width_default(void);
	inline void bl_width_default(float value);
	inline float bl_width_min(void);
	inline void bl_width_min(float value);
	inline float bl_width_max(void);
	inline void bl_width_max(float value);
	inline float bl_height_default(void);
	inline void bl_height_default(float value);
	inline float bl_height_min(void);
	inline void bl_height_min(float value);
	inline float bl_height_max(void);
	inline void bl_height_max(float value);

	inline void socket_value_update(Context& context);
	inline bool is_registered_node_type();
};

/**************** NodeLink ****************/

class NodeLink : public Pointer {
public:
	NodeLink(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline bool is_muted(void);
	inline void is_muted(bool value);
	inline Node from_node(void);
	inline Node to_node(void);
	inline NodeSocket from_socket(void);
	inline NodeSocket to_socket(void);
	inline bool is_hidden(void);
	inline void is_hidden(bool value);

};

/**************** Socket Template ****************/

class NodeInternalSocketTemplate : public Pointer {
public:
	NodeInternalSocketTemplate(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_ROTATION = 14,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
		type_OBJECT = 8,
		type_IMAGE = 9,
		type_GEOMETRY = 10,
		type_COLLECTION = 11,
		type_TEXTURE = 12,
		type_MATERIAL = 13,
	};
	inline type_enum type(void);
	inline void type(type_enum value);

};

/**************** NodeInternal ****************/

class NodeInternal : public Node {
public:
	NodeInternal(const PointerRNA &ptr_arg) :
		Node(ptr_arg)
		{}


	inline bool poll(NodeTree& node_tree);
	inline bool poll_instance(NodeTree& node_tree);
	inline void update(void *main);
	inline void draw_buttons(Context& context, UILayout& layout);
	inline void draw_buttons_ext(Context& context, UILayout& layout);
};

/**************** Shader Node ****************/

class ShaderNode : public NodeInternal {
public:
	ShaderNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


};

/**************** Compositor Node ****************/

class CompositorNode : public NodeInternal {
public:
	CompositorNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


	inline void tag_need_exec();
};

/**************** CryptomatteEntry ****************/

class CryptomatteEntry : public Pointer {
public:
	CryptomatteEntry(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float encoded_hash(void);
	inline void encoded_hash(float value);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Texture Node ****************/

class TextureNode : public NodeInternal {
public:
	TextureNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


};

/**************** Geometry Node ****************/

class GeometryNode : public NodeInternal {
public:
	GeometryNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


};

/**************** Function Node ****************/

class FunctionNode : public NodeInternal {
public:
	FunctionNode(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


};

/**************** Node Tree ****************/

class NodeTree : public ID {
public:
	NodeTree(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		nodes(ptr_arg),
		links(ptr_arg)
		{}

	inline Array<float, 2> view_center(void);
	inline void view_center(float values[2]);
	inline AnimData animation_data(void);
	COLLECTION_PROPERTY(Nodes, Node, NodeTree, nodes, false, true, true)
	COLLECTION_PROPERTY(NodeLinks, NodeLink, NodeTree, links, false, true, false)
	inline GreasePencil grease_pencil(void);
	enum type_enum {
		type_UNDEFINED = -2,
		type_CUSTOM = -1,
		type_SHADER = 0,
		type_TEXTURE = 2,
		type_COMPOSITING = 1,
		type_GEOMETRY = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline NodeTreeInterface interface(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	enum bl_icon_enum {
		bl_icon_NONE = 0,
		bl_icon_QUESTION = 1,
		bl_icon_ERROR = 2,
		bl_icon_CANCEL = 3,
		bl_icon_TRIA_RIGHT = 4,
		bl_icon_TRIA_DOWN = 5,
		bl_icon_TRIA_LEFT = 6,
		bl_icon_TRIA_UP = 7,
		bl_icon_ARROW_LEFTRIGHT = 8,
		bl_icon_PLUS = 9,
		bl_icon_DISCLOSURE_TRI_RIGHT = 10,
		bl_icon_DISCLOSURE_TRI_DOWN = 11,
		bl_icon_RADIOBUT_OFF = 12,
		bl_icon_RADIOBUT_ON = 13,
		bl_icon_MENU_PANEL = 14,
		bl_icon_BLENDER = 15,
		bl_icon_GRIP = 16,
		bl_icon_DOT = 17,
		bl_icon_COLLAPSEMENU = 18,
		bl_icon_X = 19,
		bl_icon_DUPLICATE = 20,
		bl_icon_TRASH = 21,
		bl_icon_COLLECTION_NEW = 22,
		bl_icon_OPTIONS = 23,
		bl_icon_NODE = 24,
		bl_icon_NODE_SEL = 25,
		bl_icon_WINDOW = 26,
		bl_icon_WORKSPACE = 27,
		bl_icon_RIGHTARROW_THIN = 28,
		bl_icon_BORDERMOVE = 29,
		bl_icon_VIEWZOOM = 30,
		bl_icon_ADD = 31,
		bl_icon_REMOVE = 32,
		bl_icon_PANEL_CLOSE = 33,
		bl_icon_COPY_ID = 34,
		bl_icon_EYEDROPPER = 35,
		bl_icon_CHECKMARK = 36,
		bl_icon_AUTO = 37,
		bl_icon_CHECKBOX_DEHLT = 38,
		bl_icon_CHECKBOX_HLT = 39,
		bl_icon_UNLOCKED = 40,
		bl_icon_LOCKED = 41,
		bl_icon_UNPINNED = 42,
		bl_icon_PINNED = 43,
		bl_icon_SCREEN_BACK = 44,
		bl_icon_RIGHTARROW = 45,
		bl_icon_DOWNARROW_HLT = 46,
		bl_icon_FCURVE_SNAPSHOT = 47,
		bl_icon_OBJECT_HIDDEN = 48,
		bl_icon_TOPBAR = 49,
		bl_icon_STATUSBAR = 50,
		bl_icon_PLUGIN = 51,
		bl_icon_HELP = 52,
		bl_icon_GHOST_ENABLED = 53,
		bl_icon_COLOR = 54,
		bl_icon_UNLINKED = 55,
		bl_icon_LINKED = 56,
		bl_icon_HAND = 57,
		bl_icon_ZOOM_ALL = 58,
		bl_icon_ZOOM_SELECTED = 59,
		bl_icon_ZOOM_PREVIOUS = 60,
		bl_icon_ZOOM_IN = 61,
		bl_icon_ZOOM_OUT = 62,
		bl_icon_DRIVER_DISTANCE = 63,
		bl_icon_DRIVER_ROTATIONAL_DIFFERENCE = 64,
		bl_icon_DRIVER_TRANSFORM = 65,
		bl_icon_FREEZE = 66,
		bl_icon_STYLUS_PRESSURE = 67,
		bl_icon_GHOST_DISABLED = 68,
		bl_icon_FILE_NEW = 69,
		bl_icon_FILE_TICK = 70,
		bl_icon_QUIT = 71,
		bl_icon_URL = 72,
		bl_icon_RECOVER_LAST = 73,
		bl_icon_THREE_DOTS = 74,
		bl_icon_FULLSCREEN_ENTER = 75,
		bl_icon_FULLSCREEN_EXIT = 76,
		bl_icon_BRUSHES_ALL = 77,
		bl_icon_LIGHT = 78,
		bl_icon_MATERIAL = 79,
		bl_icon_TEXTURE = 80,
		bl_icon_ANIM = 81,
		bl_icon_WORLD = 82,
		bl_icon_SCENE = 83,
		bl_icon_OUTPUT = 84,
		bl_icon_SCRIPT = 87,
		bl_icon_PARTICLES = 88,
		bl_icon_PHYSICS = 89,
		bl_icon_SPEAKER = 90,
		bl_icon_TOOL_SETTINGS = 92,
		bl_icon_SHADERFX = 93,
		bl_icon_MODIFIER = 94,
		bl_icon_BLANK1 = 101,
		bl_icon_FAKE_USER_OFF = 102,
		bl_icon_FAKE_USER_ON = 103,
		bl_icon_VIEW3D = 104,
		bl_icon_GRAPH = 105,
		bl_icon_OUTLINER = 106,
		bl_icon_PROPERTIES = 107,
		bl_icon_FILEBROWSER = 108,
		bl_icon_IMAGE = 109,
		bl_icon_INFO = 110,
		bl_icon_SEQUENCE = 111,
		bl_icon_TEXT = 112,
		bl_icon_SPREADSHEET = 113,
		bl_icon_SOUND = 114,
		bl_icon_ACTION = 115,
		bl_icon_NLA = 116,
		bl_icon_PREFERENCES = 117,
		bl_icon_TIME = 118,
		bl_icon_NODETREE = 119,
		bl_icon_GEOMETRY_NODES = 120,
		bl_icon_CONSOLE = 121,
		bl_icon_TRACKER = 123,
		bl_icon_ASSET_MANAGER = 124,
		bl_icon_NODE_COMPOSITING = 125,
		bl_icon_NODE_TEXTURE = 126,
		bl_icon_NODE_MATERIAL = 127,
		bl_icon_UV = 128,
		bl_icon_OBJECT_DATAMODE = 130,
		bl_icon_EDITMODE_HLT = 131,
		bl_icon_UV_DATA = 132,
		bl_icon_VPAINT_HLT = 133,
		bl_icon_TPAINT_HLT = 134,
		bl_icon_WPAINT_HLT = 135,
		bl_icon_SCULPTMODE_HLT = 136,
		bl_icon_POSE_HLT = 137,
		bl_icon_PARTICLEMODE = 138,
		bl_icon_TRACKING = 146,
		bl_icon_TRACKING_BACKWARDS = 147,
		bl_icon_TRACKING_FORWARDS = 148,
		bl_icon_TRACKING_BACKWARDS_SINGLE = 149,
		bl_icon_TRACKING_FORWARDS_SINGLE = 150,
		bl_icon_TRACKING_CLEAR_BACKWARDS = 151,
		bl_icon_TRACKING_CLEAR_FORWARDS = 152,
		bl_icon_TRACKING_REFINE_BACKWARDS = 153,
		bl_icon_TRACKING_REFINE_FORWARDS = 154,
		bl_icon_SCENE_DATA = 156,
		bl_icon_RENDERLAYERS = 157,
		bl_icon_WORLD_DATA = 158,
		bl_icon_OBJECT_DATA = 159,
		bl_icon_MESH_DATA = 160,
		bl_icon_CURVE_DATA = 161,
		bl_icon_META_DATA = 162,
		bl_icon_LATTICE_DATA = 163,
		bl_icon_LIGHT_DATA = 164,
		bl_icon_MATERIAL_DATA = 165,
		bl_icon_TEXTURE_DATA = 166,
		bl_icon_ANIM_DATA = 167,
		bl_icon_CAMERA_DATA = 168,
		bl_icon_PARTICLE_DATA = 169,
		bl_icon_LIBRARY_DATA_DIRECT = 170,
		bl_icon_GROUP = 171,
		bl_icon_ARMATURE_DATA = 172,
		bl_icon_COMMUNITY = 173,
		bl_icon_BONE_DATA = 174,
		bl_icon_CONSTRAINT = 175,
		bl_icon_SHAPEKEY_DATA = 176,
		bl_icon_CONSTRAINT_BONE = 177,
		bl_icon_CAMERA_STEREO = 178,
		bl_icon_PACKAGE = 179,
		bl_icon_UGLYPACKAGE = 180,
		bl_icon_EXPERIMENTAL = 181,
		bl_icon_BRUSH_DATA = 182,
		bl_icon_IMAGE_DATA = 183,
		bl_icon_FILE = 184,
		bl_icon_FCURVE = 185,
		bl_icon_FONT_DATA = 186,
		bl_icon_RENDER_RESULT = 187,
		bl_icon_SURFACE_DATA = 188,
		bl_icon_EMPTY_DATA = 189,
		bl_icon_PRESET = 190,
		bl_icon_RENDER_ANIMATION = 191,
		bl_icon_RENDER_STILL = 192,
		bl_icon_LIBRARY_DATA_BROKEN = 193,
		bl_icon_BOIDS = 194,
		bl_icon_STRANDS = 195,
		bl_icon_GREASEPENCIL = 197,
		bl_icon_LINE_DATA = 198,
		bl_icon_LIBRARY_DATA_OVERRIDE = 199,
		bl_icon_GROUP_BONE = 200,
		bl_icon_GROUP_VERTEX = 201,
		bl_icon_GROUP_VCOL = 202,
		bl_icon_GROUP_UVS = 203,
		bl_icon_FACE_MAPS = 204,
		bl_icon_RNA = 206,
		bl_icon_RNA_ADD = 207,
		bl_icon_MOUSE_LMB = 208,
		bl_icon_MOUSE_MMB = 209,
		bl_icon_MOUSE_RMB = 210,
		bl_icon_MOUSE_MOVE = 211,
		bl_icon_MOUSE_LMB_DRAG = 212,
		bl_icon_MOUSE_MMB_DRAG = 213,
		bl_icon_MOUSE_RMB_DRAG = 214,
		bl_icon_MEMORY = 215,
		bl_icon_PRESET_NEW = 216,
		bl_icon_DECORATE = 218,
		bl_icon_DECORATE_KEYFRAME = 219,
		bl_icon_DECORATE_ANIMATE = 220,
		bl_icon_DECORATE_DRIVER = 221,
		bl_icon_DECORATE_LINKED = 222,
		bl_icon_DECORATE_LIBRARY_OVERRIDE = 223,
		bl_icon_DECORATE_UNLOCKED = 224,
		bl_icon_DECORATE_LOCKED = 225,
		bl_icon_DECORATE_OVERRIDE = 226,
		bl_icon_FUND = 227,
		bl_icon_TRACKER_DATA = 228,
		bl_icon_HEART = 229,
		bl_icon_ORPHAN_DATA = 230,
		bl_icon_USER = 231,
		bl_icon_SYSTEM = 232,
		bl_icon_SETTINGS = 233,
		bl_icon_OUTLINER_OB_EMPTY = 234,
		bl_icon_OUTLINER_OB_MESH = 235,
		bl_icon_OUTLINER_OB_CURVE = 236,
		bl_icon_OUTLINER_OB_LATTICE = 237,
		bl_icon_OUTLINER_OB_META = 238,
		bl_icon_OUTLINER_OB_LIGHT = 239,
		bl_icon_OUTLINER_OB_CAMERA = 240,
		bl_icon_OUTLINER_OB_ARMATURE = 241,
		bl_icon_OUTLINER_OB_FONT = 242,
		bl_icon_OUTLINER_OB_SURFACE = 243,
		bl_icon_OUTLINER_OB_SPEAKER = 244,
		bl_icon_OUTLINER_OB_FORCE_FIELD = 245,
		bl_icon_OUTLINER_OB_GROUP_INSTANCE = 246,
		bl_icon_OUTLINER_OB_GREASEPENCIL = 247,
		bl_icon_OUTLINER_OB_LIGHTPROBE = 248,
		bl_icon_OUTLINER_OB_IMAGE = 249,
		bl_icon_OUTLINER_COLLECTION = 250,
		bl_icon_RESTRICT_COLOR_OFF = 251,
		bl_icon_RESTRICT_COLOR_ON = 252,
		bl_icon_HIDE_ON = 253,
		bl_icon_HIDE_OFF = 254,
		bl_icon_RESTRICT_SELECT_ON = 255,
		bl_icon_RESTRICT_SELECT_OFF = 256,
		bl_icon_RESTRICT_RENDER_ON = 257,
		bl_icon_RESTRICT_RENDER_OFF = 258,
		bl_icon_RESTRICT_INSTANCED_OFF = 259,
		bl_icon_OUTLINER_DATA_EMPTY = 260,
		bl_icon_OUTLINER_DATA_MESH = 261,
		bl_icon_OUTLINER_DATA_CURVE = 262,
		bl_icon_OUTLINER_DATA_LATTICE = 263,
		bl_icon_OUTLINER_DATA_META = 264,
		bl_icon_OUTLINER_DATA_LIGHT = 265,
		bl_icon_OUTLINER_DATA_CAMERA = 266,
		bl_icon_OUTLINER_DATA_ARMATURE = 267,
		bl_icon_OUTLINER_DATA_FONT = 268,
		bl_icon_OUTLINER_DATA_SURFACE = 269,
		bl_icon_OUTLINER_DATA_SPEAKER = 270,
		bl_icon_OUTLINER_DATA_LIGHTPROBE = 271,
		bl_icon_OUTLINER_DATA_GP_LAYER = 272,
		bl_icon_OUTLINER_DATA_GREASEPENCIL = 273,
		bl_icon_GP_SELECT_POINTS = 274,
		bl_icon_GP_SELECT_STROKES = 275,
		bl_icon_GP_MULTIFRAME_EDITING = 276,
		bl_icon_GP_ONLY_SELECTED = 277,
		bl_icon_GP_SELECT_BETWEEN_STROKES = 278,
		bl_icon_MODIFIER_OFF = 279,
		bl_icon_MODIFIER_ON = 280,
		bl_icon_ONIONSKIN_OFF = 281,
		bl_icon_ONIONSKIN_ON = 282,
		bl_icon_RESTRICT_VIEW_ON = 283,
		bl_icon_RESTRICT_VIEW_OFF = 284,
		bl_icon_RESTRICT_INSTANCED_ON = 285,
		bl_icon_MESH_PLANE = 286,
		bl_icon_MESH_CUBE = 287,
		bl_icon_MESH_CIRCLE = 288,
		bl_icon_MESH_UVSPHERE = 289,
		bl_icon_MESH_ICOSPHERE = 290,
		bl_icon_MESH_GRID = 291,
		bl_icon_MESH_MONKEY = 292,
		bl_icon_MESH_CYLINDER = 293,
		bl_icon_MESH_TORUS = 294,
		bl_icon_MESH_CONE = 295,
		bl_icon_MESH_CAPSULE = 296,
		bl_icon_EMPTY_SINGLE_ARROW = 297,
		bl_icon_LIGHT_POINT = 298,
		bl_icon_LIGHT_SUN = 299,
		bl_icon_LIGHT_SPOT = 300,
		bl_icon_LIGHT_HEMI = 301,
		bl_icon_LIGHT_AREA = 302,
		bl_icon_CUBE = 303,
		bl_icon_SPHERE = 304,
		bl_icon_CONE = 305,
		bl_icon_META_PLANE = 306,
		bl_icon_META_CUBE = 307,
		bl_icon_META_BALL = 308,
		bl_icon_META_ELLIPSOID = 309,
		bl_icon_META_CAPSULE = 310,
		bl_icon_SURFACE_NCURVE = 312,
		bl_icon_SURFACE_NCIRCLE = 313,
		bl_icon_SURFACE_NSURFACE = 314,
		bl_icon_SURFACE_NCYLINDER = 315,
		bl_icon_SURFACE_NSPHERE = 316,
		bl_icon_SURFACE_NTORUS = 317,
		bl_icon_EMPTY_AXIS = 318,
		bl_icon_STROKE = 319,
		bl_icon_EMPTY_ARROWS = 320,
		bl_icon_CURVE_BEZCURVE = 321,
		bl_icon_CURVE_BEZCIRCLE = 322,
		bl_icon_CURVE_NCURVE = 323,
		bl_icon_CURVE_NCIRCLE = 324,
		bl_icon_CURVE_PATH = 325,
		bl_icon_LIGHTPROBE_SPHERE = 326,
		bl_icon_LIGHTPROBE_PLANE = 327,
		bl_icon_LIGHTPROBE_VOLUME = 328,
		bl_icon_COLOR_RED = 331,
		bl_icon_COLOR_GREEN = 332,
		bl_icon_COLOR_BLUE = 333,
		bl_icon_TRIA_RIGHT_BAR = 334,
		bl_icon_TRIA_DOWN_BAR = 335,
		bl_icon_TRIA_LEFT_BAR = 336,
		bl_icon_TRIA_UP_BAR = 337,
		bl_icon_FORCE_FORCE = 338,
		bl_icon_FORCE_WIND = 339,
		bl_icon_FORCE_VORTEX = 340,
		bl_icon_FORCE_MAGNETIC = 341,
		bl_icon_FORCE_HARMONIC = 342,
		bl_icon_FORCE_CHARGE = 343,
		bl_icon_FORCE_LENNARDJONES = 344,
		bl_icon_FORCE_TEXTURE = 345,
		bl_icon_FORCE_CURVE = 346,
		bl_icon_FORCE_BOID = 347,
		bl_icon_FORCE_TURBULENCE = 348,
		bl_icon_FORCE_DRAG = 349,
		bl_icon_FORCE_FLUIDFLOW = 350,
		bl_icon_RIGID_BODY = 353,
		bl_icon_RIGID_BODY_CONSTRAINT = 354,
		bl_icon_SPLIT_HORIZONTAL = 359,
		bl_icon_SPLIT_VERTICAL = 360,
		bl_icon_IMAGE_PLANE = 361,
		bl_icon_IMAGE_BACKGROUND = 362,
		bl_icon_IMAGE_REFERENCE = 363,
		bl_icon_NODE_INSERT_ON = 367,
		bl_icon_NODE_INSERT_OFF = 368,
		bl_icon_NODE_TOP = 369,
		bl_icon_NODE_SIDE = 370,
		bl_icon_NODE_CORNER = 371,
		bl_icon_ANCHOR_TOP = 372,
		bl_icon_ANCHOR_BOTTOM = 373,
		bl_icon_ANCHOR_LEFT = 374,
		bl_icon_ANCHOR_RIGHT = 375,
		bl_icon_ANCHOR_CENTER = 376,
		bl_icon_SELECT_SET = 385,
		bl_icon_SELECT_EXTEND = 386,
		bl_icon_SELECT_SUBTRACT = 387,
		bl_icon_SELECT_INTERSECT = 388,
		bl_icon_SELECT_DIFFERENCE = 389,
		bl_icon_ALIGN_LEFT = 390,
		bl_icon_ALIGN_CENTER = 391,
		bl_icon_ALIGN_RIGHT = 392,
		bl_icon_ALIGN_JUSTIFY = 393,
		bl_icon_ALIGN_FLUSH = 394,
		bl_icon_ALIGN_TOP = 395,
		bl_icon_ALIGN_MIDDLE = 396,
		bl_icon_ALIGN_BOTTOM = 397,
		bl_icon_BOLD = 398,
		bl_icon_ITALIC = 399,
		bl_icon_UNDERLINE = 400,
		bl_icon_SMALL_CAPS = 401,
		bl_icon_CON_ACTION = 404,
		bl_icon_MOD_ENVELOPE = 406,
		bl_icon_MOD_OUTLINE = 407,
		bl_icon_MOD_LENGTH = 408,
		bl_icon_MOD_DASH = 409,
		bl_icon_MOD_LINEART = 410,
		bl_icon_HOLDOUT_OFF = 412,
		bl_icon_HOLDOUT_ON = 413,
		bl_icon_INDIRECT_ONLY_OFF = 414,
		bl_icon_INDIRECT_ONLY_ON = 415,
		bl_icon_CON_CAMERASOLVER = 416,
		bl_icon_CON_FOLLOWTRACK = 417,
		bl_icon_CON_OBJECTSOLVER = 418,
		bl_icon_CON_LOCLIKE = 419,
		bl_icon_CON_ROTLIKE = 420,
		bl_icon_CON_SIZELIKE = 421,
		bl_icon_CON_TRANSLIKE = 422,
		bl_icon_CON_DISTLIMIT = 423,
		bl_icon_CON_LOCLIMIT = 424,
		bl_icon_CON_ROTLIMIT = 425,
		bl_icon_CON_SIZELIMIT = 426,
		bl_icon_CON_SAMEVOL = 427,
		bl_icon_CON_TRANSFORM = 428,
		bl_icon_CON_TRANSFORM_CACHE = 429,
		bl_icon_CON_CLAMPTO = 430,
		bl_icon_CON_KINEMATIC = 431,
		bl_icon_CON_LOCKTRACK = 432,
		bl_icon_CON_SPLINEIK = 433,
		bl_icon_CON_STRETCHTO = 434,
		bl_icon_CON_TRACKTO = 435,
		bl_icon_CON_ARMATURE = 436,
		bl_icon_CON_CHILDOF = 437,
		bl_icon_CON_FLOOR = 438,
		bl_icon_CON_FOLLOWPATH = 439,
		bl_icon_CON_PIVOT = 440,
		bl_icon_CON_SHRINKWRAP = 441,
		bl_icon_MODIFIER_DATA = 442,
		bl_icon_MOD_WAVE = 443,
		bl_icon_MOD_BUILD = 444,
		bl_icon_MOD_DECIM = 445,
		bl_icon_MOD_MIRROR = 446,
		bl_icon_MOD_SOFT = 447,
		bl_icon_MOD_SUBSURF = 448,
		bl_icon_HOOK = 449,
		bl_icon_MOD_PHYSICS = 450,
		bl_icon_MOD_PARTICLES = 451,
		bl_icon_MOD_BOOLEAN = 452,
		bl_icon_MOD_EDGESPLIT = 453,
		bl_icon_MOD_ARRAY = 454,
		bl_icon_MOD_UVPROJECT = 455,
		bl_icon_MOD_DISPLACE = 456,
		bl_icon_MOD_CURVE = 457,
		bl_icon_MOD_LATTICE = 458,
		bl_icon_MOD_TINT = 459,
		bl_icon_MOD_ARMATURE = 460,
		bl_icon_MOD_SHRINKWRAP = 461,
		bl_icon_MOD_CAST = 462,
		bl_icon_MOD_MESHDEFORM = 463,
		bl_icon_MOD_BEVEL = 464,
		bl_icon_MOD_SMOOTH = 465,
		bl_icon_MOD_SIMPLEDEFORM = 466,
		bl_icon_MOD_MASK = 467,
		bl_icon_MOD_CLOTH = 468,
		bl_icon_MOD_EXPLODE = 469,
		bl_icon_MOD_FLUIDSIM = 470,
		bl_icon_MOD_MULTIRES = 471,
		bl_icon_MOD_FLUID = 472,
		bl_icon_MOD_SOLIDIFY = 473,
		bl_icon_MOD_SCREW = 474,
		bl_icon_MOD_VERTEX_WEIGHT = 475,
		bl_icon_MOD_DYNAMICPAINT = 476,
		bl_icon_MOD_REMESH = 477,
		bl_icon_MOD_OCEAN = 478,
		bl_icon_MOD_WARP = 479,
		bl_icon_MOD_SKIN = 480,
		bl_icon_MOD_TRIANGULATE = 481,
		bl_icon_MOD_WIREFRAME = 482,
		bl_icon_MOD_DATA_TRANSFER = 483,
		bl_icon_MOD_NORMALEDIT = 484,
		bl_icon_MOD_PARTICLE_INSTANCE = 485,
		bl_icon_MOD_HUE_SATURATION = 486,
		bl_icon_MOD_NOISE = 487,
		bl_icon_MOD_OFFSET = 488,
		bl_icon_MOD_SIMPLIFY = 489,
		bl_icon_MOD_THICKNESS = 490,
		bl_icon_MOD_INSTANCE = 491,
		bl_icon_MOD_TIME = 492,
		bl_icon_MOD_OPACITY = 493,
		bl_icon_REC = 494,
		bl_icon_PLAY = 495,
		bl_icon_FF = 496,
		bl_icon_REW = 497,
		bl_icon_PAUSE = 498,
		bl_icon_PREV_KEYFRAME = 499,
		bl_icon_NEXT_KEYFRAME = 500,
		bl_icon_PLAY_SOUND = 501,
		bl_icon_PLAY_REVERSE = 502,
		bl_icon_PREVIEW_RANGE = 503,
		bl_icon_ACTION_TWEAK = 504,
		bl_icon_PMARKER_ACT = 505,
		bl_icon_PMARKER_SEL = 506,
		bl_icon_PMARKER = 507,
		bl_icon_MARKER_HLT = 508,
		bl_icon_MARKER = 509,
		bl_icon_KEYFRAME_HLT = 510,
		bl_icon_KEYFRAME = 511,
		bl_icon_KEYINGSET = 512,
		bl_icon_KEY_DEHLT = 513,
		bl_icon_KEY_HLT = 514,
		bl_icon_MUTE_IPO_OFF = 515,
		bl_icon_MUTE_IPO_ON = 516,
		bl_icon_DRIVER = 519,
		bl_icon_SOLO_OFF = 520,
		bl_icon_SOLO_ON = 521,
		bl_icon_FRAME_PREV = 522,
		bl_icon_FRAME_NEXT = 523,
		bl_icon_NLA_PUSHDOWN = 524,
		bl_icon_IPO_CONSTANT = 525,
		bl_icon_IPO_LINEAR = 526,
		bl_icon_IPO_BEZIER = 527,
		bl_icon_IPO_SINE = 528,
		bl_icon_IPO_QUAD = 529,
		bl_icon_IPO_CUBIC = 530,
		bl_icon_IPO_QUART = 531,
		bl_icon_IPO_QUINT = 532,
		bl_icon_IPO_EXPO = 533,
		bl_icon_IPO_CIRC = 534,
		bl_icon_IPO_BOUNCE = 535,
		bl_icon_IPO_ELASTIC = 536,
		bl_icon_IPO_BACK = 537,
		bl_icon_IPO_EASE_IN = 538,
		bl_icon_IPO_EASE_OUT = 539,
		bl_icon_IPO_EASE_IN_OUT = 540,
		bl_icon_NORMALIZE_FCURVES = 541,
		bl_icon_ORIENTATION_PARENT = 542,
		bl_icon_VERTEXSEL = 546,
		bl_icon_EDGESEL = 547,
		bl_icon_FACESEL = 548,
		bl_icon_CURSOR = 550,
		bl_icon_PIVOT_BOUNDBOX = 551,
		bl_icon_PIVOT_CURSOR = 552,
		bl_icon_PIVOT_INDIVIDUAL = 553,
		bl_icon_PIVOT_MEDIAN = 554,
		bl_icon_PIVOT_ACTIVE = 555,
		bl_icon_CENTER_ONLY = 556,
		bl_icon_ROOTCURVE = 557,
		bl_icon_SMOOTHCURVE = 558,
		bl_icon_SPHERECURVE = 559,
		bl_icon_INVERSESQUARECURVE = 560,
		bl_icon_SHARPCURVE = 561,
		bl_icon_LINCURVE = 562,
		bl_icon_NOCURVE = 563,
		bl_icon_RNDCURVE = 564,
		bl_icon_PROP_OFF = 565,
		bl_icon_PROP_ON = 566,
		bl_icon_PROP_CON = 567,
		bl_icon_PROP_PROJECTED = 568,
		bl_icon_PARTICLE_POINT = 569,
		bl_icon_PARTICLE_TIP = 570,
		bl_icon_PARTICLE_PATH = 571,
		bl_icon_SNAP_FACE_NEAREST = 572,
		bl_icon_SNAP_FACE_CENTER = 573,
		bl_icon_SNAP_PERPENDICULAR = 574,
		bl_icon_SNAP_MIDPOINT = 575,
		bl_icon_SNAP_OFF = 576,
		bl_icon_SNAP_ON = 577,
		bl_icon_SNAP_NORMAL = 578,
		bl_icon_SNAP_GRID = 579,
		bl_icon_SNAP_VERTEX = 580,
		bl_icon_SNAP_EDGE = 581,
		bl_icon_SNAP_FACE = 582,
		bl_icon_SNAP_VOLUME = 583,
		bl_icon_SNAP_INCREMENT = 584,
		bl_icon_STICKY_UVS_LOC = 585,
		bl_icon_STICKY_UVS_DISABLE = 586,
		bl_icon_STICKY_UVS_VERT = 587,
		bl_icon_CLIPUV_DEHLT = 588,
		bl_icon_CLIPUV_HLT = 589,
		bl_icon_SNAP_PEEL_OBJECT = 590,
		bl_icon_GRID = 591,
		bl_icon_OBJECT_ORIGIN = 592,
		bl_icon_ORIENTATION_GLOBAL = 593,
		bl_icon_ORIENTATION_GIMBAL = 594,
		bl_icon_ORIENTATION_LOCAL = 595,
		bl_icon_ORIENTATION_NORMAL = 596,
		bl_icon_ORIENTATION_VIEW = 597,
		bl_icon_COPYDOWN = 598,
		bl_icon_PASTEDOWN = 599,
		bl_icon_PASTEFLIPUP = 600,
		bl_icon_PASTEFLIPDOWN = 601,
		bl_icon_VIS_SEL_11 = 602,
		bl_icon_VIS_SEL_10 = 603,
		bl_icon_VIS_SEL_01 = 604,
		bl_icon_VIS_SEL_00 = 605,
		bl_icon_AUTOMERGE_OFF = 607,
		bl_icon_AUTOMERGE_ON = 608,
		bl_icon_UV_VERTEXSEL = 610,
		bl_icon_UV_EDGESEL = 611,
		bl_icon_UV_FACESEL = 612,
		bl_icon_UV_ISLANDSEL = 613,
		bl_icon_UV_SYNC_SELECT = 614,
		bl_icon_GP_CAPS_FLAT = 615,
		bl_icon_GP_CAPS_ROUND = 616,
		bl_icon_FIXED_SIZE = 617,
		bl_icon_TRANSFORM_ORIGINS = 618,
		bl_icon_GIZMO = 619,
		bl_icon_ORIENTATION_CURSOR = 620,
		bl_icon_NORMALS_VERTEX = 621,
		bl_icon_NORMALS_FACE = 622,
		bl_icon_NORMALS_VERTEX_FACE = 623,
		bl_icon_SHADING_BBOX = 624,
		bl_icon_SHADING_WIRE = 625,
		bl_icon_SHADING_SOLID = 626,
		bl_icon_SHADING_RENDERED = 627,
		bl_icon_SHADING_TEXTURE = 628,
		bl_icon_OVERLAY = 629,
		bl_icon_XRAY = 630,
		bl_icon_LOCKVIEW_OFF = 633,
		bl_icon_LOCKVIEW_ON = 634,
		bl_icon_AXIS_SIDE = 636,
		bl_icon_AXIS_FRONT = 637,
		bl_icon_AXIS_TOP = 638,
		bl_icon_LAYER_USED = 643,
		bl_icon_LAYER_ACTIVE = 644,
		bl_icon_OUTLINER_OB_CURVES = 650,
		bl_icon_OUTLINER_DATA_CURVES = 651,
		bl_icon_CURVES_DATA = 652,
		bl_icon_OUTLINER_OB_POINTCLOUD = 653,
		bl_icon_OUTLINER_DATA_POINTCLOUD = 654,
		bl_icon_POINTCLOUD_DATA = 655,
		bl_icon_OUTLINER_OB_VOLUME = 656,
		bl_icon_OUTLINER_DATA_VOLUME = 657,
		bl_icon_VOLUME_DATA = 658,
		bl_icon_CURRENT_FILE = 672,
		bl_icon_HOME = 673,
		bl_icon_DOCUMENTS = 674,
		bl_icon_TEMP = 675,
		bl_icon_SORTALPHA = 676,
		bl_icon_SORTBYEXT = 677,
		bl_icon_SORTTIME = 678,
		bl_icon_SORTSIZE = 679,
		bl_icon_SHORTDISPLAY = 680,
		bl_icon_LONGDISPLAY = 681,
		bl_icon_IMGDISPLAY = 683,
		bl_icon_BOOKMARKS = 686,
		bl_icon_FONTPREVIEW = 687,
		bl_icon_FILTER = 688,
		bl_icon_NEWFOLDER = 689,
		bl_icon_FOLDER_REDIRECT = 690,
		bl_icon_FILE_PARENT = 691,
		bl_icon_FILE_REFRESH = 692,
		bl_icon_FILE_FOLDER = 693,
		bl_icon_FILE_BLANK = 694,
		bl_icon_FILE_BLEND = 695,
		bl_icon_FILE_IMAGE = 696,
		bl_icon_FILE_MOVIE = 697,
		bl_icon_FILE_SCRIPT = 698,
		bl_icon_FILE_SOUND = 699,
		bl_icon_FILE_FONT = 700,
		bl_icon_FILE_TEXT = 701,
		bl_icon_SORT_DESC = 702,
		bl_icon_SORT_ASC = 703,
		bl_icon_LINK_BLEND = 704,
		bl_icon_APPEND_BLEND = 705,
		bl_icon_IMPORT = 706,
		bl_icon_EXPORT = 707,
		bl_icon_LOOP_BACK = 715,
		bl_icon_LOOP_FORWARDS = 716,
		bl_icon_BACK = 717,
		bl_icon_FORWARD = 718,
		bl_icon_FILE_ARCHIVE = 721,
		bl_icon_FILE_CACHE = 722,
		bl_icon_FILE_VOLUME = 723,
		bl_icon_FILE_3D = 724,
		bl_icon_FILE_HIDDEN = 725,
		bl_icon_FILE_BACKUP = 726,
		bl_icon_DISK_DRIVE = 727,
		bl_icon_MATPLANE = 728,
		bl_icon_MATSPHERE = 729,
		bl_icon_MATCUBE = 730,
		bl_icon_MONKEY = 731,
		bl_icon_CURVES = 732,
		bl_icon_ALIASED = 733,
		bl_icon_ANTIALIASED = 734,
		bl_icon_MAT_SPHERE_SKY = 735,
		bl_icon_MATSHADERBALL = 736,
		bl_icon_MATCLOTH = 737,
		bl_icon_MATFLUID = 738,
		bl_icon_WORDWRAP_OFF = 740,
		bl_icon_WORDWRAP_ON = 741,
		bl_icon_SYNTAX_OFF = 742,
		bl_icon_SYNTAX_ON = 743,
		bl_icon_LINENUMBERS_OFF = 744,
		bl_icon_LINENUMBERS_ON = 745,
		bl_icon_SCRIPTPLUGINS = 746,
		bl_icon_DISC = 750,
		bl_icon_DESKTOP = 751,
		bl_icon_EXTERNAL_DRIVE = 752,
		bl_icon_NETWORK_DRIVE = 753,
		bl_icon_SEQ_SEQUENCER = 754,
		bl_icon_SEQ_PREVIEW = 755,
		bl_icon_SEQ_LUMA_WAVEFORM = 756,
		bl_icon_SEQ_CHROMA_SCOPE = 757,
		bl_icon_SEQ_HISTOGRAM = 758,
		bl_icon_SEQ_SPLITVIEW = 759,
		bl_icon_SEQ_STRIP_META = 760,
		bl_icon_SEQ_STRIP_DUPLICATE = 761,
		bl_icon_IMAGE_RGB = 763,
		bl_icon_IMAGE_RGB_ALPHA = 764,
		bl_icon_IMAGE_ALPHA = 765,
		bl_icon_IMAGE_ZDEPTH = 766,
		bl_icon_HANDLE_AUTOCLAMPED = 767,
		bl_icon_HANDLE_AUTO = 768,
		bl_icon_HANDLE_ALIGNED = 769,
		bl_icon_HANDLE_VECTOR = 770,
		bl_icon_HANDLE_FREE = 771,
		bl_icon_VIEW_PERSPECTIVE = 775,
		bl_icon_VIEW_ORTHO = 776,
		bl_icon_VIEW_CAMERA = 777,
		bl_icon_VIEW_PAN = 778,
		bl_icon_VIEW_ZOOM = 779,
		bl_icon_BRUSH_BLOB = 780,
		bl_icon_BRUSH_BLUR = 781,
		bl_icon_BRUSH_CLAY = 782,
		bl_icon_BRUSH_CLAY_STRIPS = 783,
		bl_icon_BRUSH_CLONE = 784,
		bl_icon_BRUSH_CREASE = 785,
		bl_icon_BRUSH_FILL = 786,
		bl_icon_BRUSH_FLATTEN = 787,
		bl_icon_BRUSH_GRAB = 788,
		bl_icon_BRUSH_INFLATE = 789,
		bl_icon_BRUSH_LAYER = 790,
		bl_icon_BRUSH_MASK = 791,
		bl_icon_BRUSH_MIX = 792,
		bl_icon_BRUSH_NUDGE = 793,
		bl_icon_BRUSH_PAINT_SELECT = 794,
		bl_icon_BRUSH_PINCH = 795,
		bl_icon_BRUSH_SCRAPE = 796,
		bl_icon_BRUSH_SCULPT_DRAW = 797,
		bl_icon_BRUSH_SMEAR = 798,
		bl_icon_BRUSH_SMOOTH = 799,
		bl_icon_BRUSH_SNAKE_HOOK = 800,
		bl_icon_BRUSH_SOFTEN = 801,
		bl_icon_BRUSH_TEXDRAW = 802,
		bl_icon_BRUSH_TEXFILL = 803,
		bl_icon_BRUSH_TEXMASK = 804,
		bl_icon_BRUSH_THUMB = 805,
		bl_icon_BRUSH_ROTATE = 806,
		bl_icon_GPBRUSH_SMOOTH = 807,
		bl_icon_GPBRUSH_THICKNESS = 808,
		bl_icon_GPBRUSH_STRENGTH = 809,
		bl_icon_GPBRUSH_GRAB = 810,
		bl_icon_GPBRUSH_PUSH = 811,
		bl_icon_GPBRUSH_TWIST = 812,
		bl_icon_GPBRUSH_PINCH = 813,
		bl_icon_GPBRUSH_RANDOMIZE = 814,
		bl_icon_GPBRUSH_CLONE = 815,
		bl_icon_GPBRUSH_WEIGHT = 816,
		bl_icon_GPBRUSH_PENCIL = 817,
		bl_icon_GPBRUSH_PEN = 818,
		bl_icon_GPBRUSH_INK = 819,
		bl_icon_GPBRUSH_INKNOISE = 820,
		bl_icon_GPBRUSH_BLOCK = 821,
		bl_icon_GPBRUSH_MARKER = 822,
		bl_icon_GPBRUSH_FILL = 823,
		bl_icon_GPBRUSH_AIRBRUSH = 824,
		bl_icon_GPBRUSH_CHISEL = 825,
		bl_icon_GPBRUSH_ERASE_SOFT = 826,
		bl_icon_GPBRUSH_ERASE_HARD = 827,
		bl_icon_GPBRUSH_ERASE_STROKE = 828,
		bl_icon_BRUSH_CURVES_ADD = 829,
		bl_icon_BRUSH_CURVES_COMB = 830,
		bl_icon_BRUSH_CURVES_CUT = 831,
		bl_icon_BRUSH_CURVES_DELETE = 832,
		bl_icon_BRUSH_CURVES_DENSITY = 833,
		bl_icon_BRUSH_CURVES_GROW_SHRINK = 834,
		bl_icon_BRUSH_CURVES_PINCH = 835,
		bl_icon_BRUSH_CURVES_PUFF = 836,
		bl_icon_BRUSH_CURVES_SLIDE = 837,
		bl_icon_BRUSH_CURVES_SMOOTH = 838,
		bl_icon_BRUSH_CURVES_SNAKE_HOOK = 839,
		bl_icon_KEYTYPE_KEYFRAME_VEC = 840,
		bl_icon_KEYTYPE_BREAKDOWN_VEC = 841,
		bl_icon_KEYTYPE_EXTREME_VEC = 842,
		bl_icon_KEYTYPE_JITTER_VEC = 843,
		bl_icon_KEYTYPE_MOVING_HOLD_VEC = 844,
		bl_icon_HANDLETYPE_FREE_VEC = 845,
		bl_icon_HANDLETYPE_ALIGNED_VEC = 846,
		bl_icon_HANDLETYPE_VECTOR_VEC = 847,
		bl_icon_HANDLETYPE_AUTO_VEC = 848,
		bl_icon_HANDLETYPE_AUTO_CLAMP_VEC = 849,
		bl_icon_COLORSET_01_VEC = 850,
		bl_icon_COLORSET_02_VEC = 851,
		bl_icon_COLORSET_03_VEC = 852,
		bl_icon_COLORSET_04_VEC = 853,
		bl_icon_COLORSET_05_VEC = 854,
		bl_icon_COLORSET_06_VEC = 855,
		bl_icon_COLORSET_07_VEC = 856,
		bl_icon_COLORSET_08_VEC = 857,
		bl_icon_COLORSET_09_VEC = 858,
		bl_icon_COLORSET_10_VEC = 859,
		bl_icon_COLORSET_11_VEC = 860,
		bl_icon_COLORSET_12_VEC = 861,
		bl_icon_COLORSET_13_VEC = 862,
		bl_icon_COLORSET_14_VEC = 863,
		bl_icon_COLORSET_15_VEC = 864,
		bl_icon_COLORSET_16_VEC = 865,
		bl_icon_COLORSET_17_VEC = 866,
		bl_icon_COLORSET_18_VEC = 867,
		bl_icon_COLORSET_19_VEC = 868,
		bl_icon_COLORSET_20_VEC = 869,
		bl_icon_COLLECTION_COLOR_01 = 870,
		bl_icon_COLLECTION_COLOR_02 = 871,
		bl_icon_COLLECTION_COLOR_03 = 872,
		bl_icon_COLLECTION_COLOR_04 = 873,
		bl_icon_COLLECTION_COLOR_05 = 874,
		bl_icon_COLLECTION_COLOR_06 = 875,
		bl_icon_COLLECTION_COLOR_07 = 876,
		bl_icon_COLLECTION_COLOR_08 = 877,
		bl_icon_SEQUENCE_COLOR_01 = 878,
		bl_icon_SEQUENCE_COLOR_02 = 879,
		bl_icon_SEQUENCE_COLOR_03 = 880,
		bl_icon_SEQUENCE_COLOR_04 = 881,
		bl_icon_SEQUENCE_COLOR_05 = 882,
		bl_icon_SEQUENCE_COLOR_06 = 883,
		bl_icon_SEQUENCE_COLOR_07 = 884,
		bl_icon_SEQUENCE_COLOR_08 = 885,
		bl_icon_SEQUENCE_COLOR_09 = 886,
		bl_icon_LIBRARY_DATA_INDIRECT = 887,
		bl_icon_LIBRARY_DATA_OVERRIDE_NONEDITABLE = 888,
		bl_icon_EVENT_A = 889,
		bl_icon_EVENT_B = 890,
		bl_icon_EVENT_C = 891,
		bl_icon_EVENT_D = 892,
		bl_icon_EVENT_E = 893,
		bl_icon_EVENT_F = 894,
		bl_icon_EVENT_G = 895,
		bl_icon_EVENT_H = 896,
		bl_icon_EVENT_I = 897,
		bl_icon_EVENT_J = 898,
		bl_icon_EVENT_K = 899,
		bl_icon_EVENT_L = 900,
		bl_icon_EVENT_M = 901,
		bl_icon_EVENT_N = 902,
		bl_icon_EVENT_O = 903,
		bl_icon_EVENT_P = 904,
		bl_icon_EVENT_Q = 905,
		bl_icon_EVENT_R = 906,
		bl_icon_EVENT_S = 907,
		bl_icon_EVENT_T = 908,
		bl_icon_EVENT_U = 909,
		bl_icon_EVENT_V = 910,
		bl_icon_EVENT_W = 911,
		bl_icon_EVENT_X = 912,
		bl_icon_EVENT_Y = 913,
		bl_icon_EVENT_Z = 914,
		bl_icon_EVENT_SHIFT = 915,
		bl_icon_EVENT_CTRL = 916,
		bl_icon_EVENT_ALT = 917,
		bl_icon_EVENT_OS = 918,
		bl_icon_EVENT_F1 = 919,
		bl_icon_EVENT_F2 = 920,
		bl_icon_EVENT_F3 = 921,
		bl_icon_EVENT_F4 = 922,
		bl_icon_EVENT_F5 = 923,
		bl_icon_EVENT_F6 = 924,
		bl_icon_EVENT_F7 = 925,
		bl_icon_EVENT_F8 = 926,
		bl_icon_EVENT_F9 = 927,
		bl_icon_EVENT_F10 = 928,
		bl_icon_EVENT_F11 = 929,
		bl_icon_EVENT_F12 = 930,
		bl_icon_EVENT_ESC = 931,
		bl_icon_EVENT_TAB = 932,
		bl_icon_EVENT_PAGEUP = 933,
		bl_icon_EVENT_PAGEDOWN = 934,
		bl_icon_EVENT_RETURN = 935,
		bl_icon_EVENT_SPACEKEY = 936,
	};
	inline bl_icon_enum bl_icon(void);
	inline void bl_icon(bl_icon_enum value);

	inline void interface_update(Context& context);
	inline bool contains_tree(NodeTree& sub_tree);
};

/**************** Compositor Node Tree ****************/

class CompositorNodeTree : public NodeTree {
public:
	CompositorNodeTree(const PointerRNA &ptr_arg) :
		NodeTree(ptr_arg)
		{}

	enum precision_enum {
		precision_AUTO = 0,
		precision_FULL = 1,
	};
	inline precision_enum precision(void);
	inline void precision(precision_enum value);
	enum execution_mode_enum {
		execution_mode_TILED = 0,
		execution_mode_FULL_FRAME = 1,
		execution_mode_REALTIME = 2,
	};
	inline execution_mode_enum execution_mode(void);
	inline void execution_mode(execution_mode_enum value);
	enum render_quality_enum {
		render_quality_HIGH = 0,
		render_quality_MEDIUM = 1,
		render_quality_LOW = 2,
	};
	inline render_quality_enum render_quality(void);
	inline void render_quality(render_quality_enum value);
	enum edit_quality_enum {
		edit_quality_HIGH = 0,
		edit_quality_MEDIUM = 1,
		edit_quality_LOW = 2,
	};
	inline edit_quality_enum edit_quality(void);
	inline void edit_quality(edit_quality_enum value);
	enum chunk_size_enum {
		chunk_size_32 = 32,
		chunk_size_64 = 64,
		chunk_size_128 = 128,
		chunk_size_256 = 256,
		chunk_size_512 = 512,
		chunk_size_1024 = 1024,
	};
	inline chunk_size_enum chunk_size(void);
	inline void chunk_size(chunk_size_enum value);
	inline bool use_opencl(void);
	inline void use_opencl(bool value);
	inline bool use_groupnode_buffer(void);
	inline void use_groupnode_buffer(bool value);
	inline bool use_two_pass(void);
	inline void use_two_pass(bool value);
	inline bool use_viewer_border(void);
	inline void use_viewer_border(bool value);

};

/**************** Shader Node Tree ****************/

class ShaderNodeTree : public NodeTree {
public:
	ShaderNodeTree(const PointerRNA &ptr_arg) :
		NodeTree(ptr_arg)
		{}


	inline ShaderNode get_output_node(int target);
};

/**************** Texture Node Tree ****************/

class TextureNodeTree : public NodeTree {
public:
	TextureNodeTree(const PointerRNA &ptr_arg) :
		NodeTree(ptr_arg)
		{}


};

/**************** Geometry Node Tree ****************/

class GeometryNodeTree : public NodeTree {
public:
	GeometryNodeTree(const PointerRNA &ptr_arg) :
		NodeTree(ptr_arg)
		{}

	inline bool is_tool(void);
	inline void is_tool(bool value);
	inline bool is_modifier(void);
	inline void is_modifier(bool value);
	inline bool is_mode_object(void);
	inline void is_mode_object(bool value);
	inline bool is_mode_edit(void);
	inline void is_mode_edit(bool value);
	inline bool is_mode_sculpt(void);
	inline void is_mode_sculpt(bool value);
	inline bool is_type_mesh(void);
	inline void is_type_mesh(bool value);
	inline bool is_type_curve(void);
	inline void is_type_curve(bool value);
	inline bool is_type_point_cloud(void);
	inline void is_type_point_cloud(bool value);

};

/**************** Simulation Item ****************/

class SimulationStateItem : public Pointer {
public:
	SimulationStateItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum socket_type_enum {
		socket_type_FLOAT = 0,
		socket_type_INT = 6,
		socket_type_BOOLEAN = 4,
		socket_type_VECTOR = 1,
		socket_type_ROTATION = 14,
		socket_type_STRING = 7,
		socket_type_RGBA = 2,
		socket_type_OBJECT = 8,
		socket_type_IMAGE = 9,
		socket_type_GEOMETRY = 10,
		socket_type_COLLECTION = 11,
		socket_type_TEXTURE = 12,
		socket_type_MATERIAL = 13,
	};
	inline socket_type_enum socket_type(void);
	inline void socket_type(socket_type_enum value);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	enum attribute_domain_enum {
		attribute_domain_POINT = 0,
		attribute_domain_EDGE = 1,
		attribute_domain_FACE = 2,
		attribute_domain_CORNER = 3,
		attribute_domain_CURVE = 4,
		attribute_domain_INSTANCE = 5,
		attribute_domain_LAYER = 6,
	};
	inline attribute_domain_enum attribute_domain(void);
	inline void attribute_domain(attribute_domain_enum value);

};

/**************** Repeat Item ****************/

class RepeatItem : public Pointer {
public:
	RepeatItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum socket_type_enum {
		socket_type_FLOAT = 0,
		socket_type_INT = 6,
		socket_type_BOOLEAN = 4,
		socket_type_VECTOR = 1,
		socket_type_ROTATION = 14,
		socket_type_STRING = 7,
		socket_type_RGBA = 2,
		socket_type_OBJECT = 8,
		socket_type_IMAGE = 9,
		socket_type_GEOMETRY = 10,
		socket_type_COLLECTION = 11,
		socket_type_TEXTURE = 12,
		socket_type_MATERIAL = 13,
	};
	inline socket_type_enum socket_type(void);
	inline void socket_type(socket_type_enum value);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);

};

/**************** NodeFrame ****************/

class NodeFrame : public NodeInternal {
public:
	NodeFrame(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}

	inline Text text(void);
	inline bool shrink(void);
	inline void shrink(bool value);
	inline int label_size(void);
	inline void label_size(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** NodeGroup ****************/

class NodeGroup : public NodeInternal {
public:
	NodeGroup(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** NodeGroupInput ****************/

class NodeGroupInput : public NodeInternal {
public:
	NodeGroupInput(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** NodeGroupOutput ****************/

class NodeGroupOutput : public NodeInternal {
public:
	NodeGroupOutput(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** NodeReroute ****************/

class NodeReroute : public NodeInternal {
public:
	NodeReroute(const PointerRNA &ptr_arg) :
		NodeInternal(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeRGB ****************/

class ShaderNodeRGB : public ShaderNode {
public:
	ShaderNodeRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeValue ****************/

class ShaderNodeValue : public ShaderNode {
public:
	ShaderNodeValue(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeMixRGB ****************/

class ShaderNodeMixRGB : public ShaderNode {
public:
	ShaderNodeMixRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_EXCLUSION = 18,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeValToRGB ****************/

class ShaderNodeValToRGB : public ShaderNode {
public:
	ShaderNodeValToRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline ColorRamp color_ramp(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeRGBToBW ****************/

class ShaderNodeRGBToBW : public ShaderNode {
public:
	ShaderNodeRGBToBW(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeShaderToRGB ****************/

class ShaderNodeShaderToRGB : public ShaderNode {
public:
	ShaderNodeShaderToRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeNormal ****************/

class ShaderNodeNormal : public ShaderNode {
public:
	ShaderNodeNormal(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeGamma ****************/

class ShaderNodeGamma : public ShaderNode {
public:
	ShaderNodeGamma(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBrightContrast ****************/

class ShaderNodeBrightContrast : public ShaderNode {
public:
	ShaderNodeBrightContrast(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeMapping ****************/

class ShaderNodeMapping : public ShaderNode {
public:
	ShaderNodeMapping(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum vector_type_enum {
		vector_type_POINT = 0,
		vector_type_TEXTURE = 1,
		vector_type_VECTOR = 2,
		vector_type_NORMAL = 3,
	};
	inline vector_type_enum vector_type(void);
	inline void vector_type(vector_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVectorCurve ****************/

class ShaderNodeVectorCurve : public ShaderNode {
public:
	ShaderNodeVectorCurve(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeRGBCurve ****************/

class ShaderNodeRGBCurve : public ShaderNode {
public:
	ShaderNodeRGBCurve(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeCameraData ****************/

class ShaderNodeCameraData : public ShaderNode {
public:
	ShaderNodeCameraData(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeMapRange ****************/

class ShaderNodeMapRange : public ShaderNode {
public:
	ShaderNodeMapRange(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool clamp(void);
	inline void clamp(bool value);
	enum interpolation_type_enum {
		interpolation_type_LINEAR = 0,
		interpolation_type_STEPPED = 1,
		interpolation_type_SMOOTHSTEP = 2,
		interpolation_type_SMOOTHERSTEP = 3,
	};
	inline interpolation_type_enum interpolation_type(void);
	inline void interpolation_type(interpolation_type_enum value);
	enum data_type_enum {
		data_type_FLOAT = 10,
		data_type_FLOAT_VECTOR = 48,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeClamp ****************/

class ShaderNodeClamp : public ShaderNode {
public:
	ShaderNodeClamp(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum clamp_type_enum {
		clamp_type_MINMAX = 0,
		clamp_type_RANGE = 1,
	};
	inline clamp_type_enum clamp_type(void);
	inline void clamp_type(clamp_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeMath ****************/

class ShaderNodeMath : public ShaderNode {
public:
	ShaderNodeMath(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_MULTIPLY_ADD = 36,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_SQRT = 23,
		operation_INVERSE_SQRT = 24,
		operation_ABSOLUTE = 18,
		operation_EXPONENT = 26,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_SIGN = 25,
		operation_COMPARE = 35,
		operation_SMOOTH_MIN = 38,
		operation_SMOOTH_MAX = 39,
		operation_ROUND = 14,
		operation_FLOOR = 20,
		operation_CEIL = 21,
		operation_TRUNC = 32,
		operation_FRACT = 22,
		operation_MODULO = 17,
		operation_FLOORED_MODULO = 40,
		operation_WRAP = 34,
		operation_SNAP = 33,
		operation_PINGPONG = 37,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_ARCTAN2 = 19,
		operation_SINH = 29,
		operation_COSH = 30,
		operation_TANH = 31,
		operation_RADIANS = 27,
		operation_DEGREES = 28,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVectorMath ****************/

class ShaderNodeVectorMath : public ShaderNode {
public:
	ShaderNodeVectorMath(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_MULTIPLY_ADD = 26,
		operation_CROSS_PRODUCT = 4,
		operation_PROJECT = 5,
		operation_REFLECT = 6,
		operation_REFRACT = 24,
		operation_FACEFORWARD = 25,
		operation_DOT_PRODUCT = 7,
		operation_DISTANCE = 8,
		operation_LENGTH = 9,
		operation_SCALE = 10,
		operation_NORMALIZE = 11,
		operation_ABSOLUTE = 17,
		operation_MINIMUM = 18,
		operation_MAXIMUM = 19,
		operation_FLOOR = 13,
		operation_CEIL = 14,
		operation_FRACTION = 16,
		operation_MODULO = 15,
		operation_WRAP = 20,
		operation_SNAP = 12,
		operation_SINE = 21,
		operation_COSINE = 22,
		operation_TANGENT = 23,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeSqueeze ****************/

class ShaderNodeSqueeze : public ShaderNode {
public:
	ShaderNodeSqueeze(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeInvert ****************/

class ShaderNodeInvert : public ShaderNode {
public:
	ShaderNodeInvert(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeSeparateRGB ****************/

class ShaderNodeSeparateRGB : public ShaderNode {
public:
	ShaderNodeSeparateRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeCombineRGB ****************/

class ShaderNodeCombineRGB : public ShaderNode {
public:
	ShaderNodeCombineRGB(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeHueSaturation ****************/

class ShaderNodeHueSaturation : public ShaderNode {
public:
	ShaderNodeHueSaturation(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeOutputMaterial ****************/

class ShaderNodeOutputMaterial : public ShaderNode {
public:
	ShaderNodeOutputMaterial(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeEeveeSpecular ****************/

class ShaderNodeEeveeSpecular : public ShaderNode {
public:
	ShaderNodeEeveeSpecular(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeOutputLight ****************/

class ShaderNodeOutputLight : public ShaderNode {
public:
	ShaderNodeOutputLight(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeOutputWorld ****************/

class ShaderNodeOutputWorld : public ShaderNode {
public:
	ShaderNodeOutputWorld(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeOutputLineStyle ****************/

class ShaderNodeOutputLineStyle : public ShaderNode {
public:
	ShaderNodeOutputLineStyle(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool is_active_output(void);
	inline void is_active_output(bool value);
	enum target_enum {
		target_ALL = 0,
		target_EEVEE = 1,
		target_CYCLES = 2,
	};
	inline target_enum target(void);
	inline void target(target_enum value);
	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_EXCLUSION = 18,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeFresnel ****************/

class ShaderNodeFresnel : public ShaderNode {
public:
	ShaderNodeFresnel(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeLayerWeight ****************/

class ShaderNodeLayerWeight : public ShaderNode {
public:
	ShaderNodeLayerWeight(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeMixShader ****************/

class ShaderNodeMixShader : public ShaderNode {
public:
	ShaderNodeMixShader(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeAddShader ****************/

class ShaderNodeAddShader : public ShaderNode {
public:
	ShaderNodeAddShader(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeAttribute ****************/

class ShaderNodeAttribute : public ShaderNode {
public:
	ShaderNodeAttribute(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum attribute_type_enum {
		attribute_type_GEOMETRY = 0,
		attribute_type_OBJECT = 1,
		attribute_type_INSTANCER = 2,
		attribute_type_VIEW_LAYER = 3,
	};
	inline attribute_type_enum attribute_type(void);
	inline void attribute_type(attribute_type_enum value);
	inline std::string attribute_name(void);
	inline void attribute_name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeAmbientOcclusion ****************/

class ShaderNodeAmbientOcclusion : public ShaderNode {
public:
	ShaderNodeAmbientOcclusion(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline int samples(void);
	inline void samples(int value);
	inline bool inside(void);
	inline void inside(bool value);
	inline bool only_local(void);
	inline void only_local(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBackground ****************/

class ShaderNodeBackground : public ShaderNode {
public:
	ShaderNodeBackground(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeHoldout ****************/

class ShaderNodeHoldout : public ShaderNode {
public:
	ShaderNodeHoldout(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfDiffuse ****************/

class ShaderNodeBsdfDiffuse : public ShaderNode {
public:
	ShaderNodeBsdfDiffuse(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfPrincipled ****************/

class ShaderNodeBsdfPrincipled : public ShaderNode {
public:
	ShaderNodeBsdfPrincipled(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_GGX = 2,
		distribution_MULTI_GGX = 4,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);
	enum subsurface_method_enum {
		subsurface_method_BURLEY = 3,
		subsurface_method_RANDOM_WALK = 4,
		subsurface_method_RANDOM_WALK_SKIN = 5,
	};
	inline subsurface_method_enum subsurface_method(void);
	inline void subsurface_method(subsurface_method_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfAnisotropic ****************/

class ShaderNodeBsdfAnisotropic : public ShaderNode {
public:
	ShaderNodeBsdfAnisotropic(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
		distribution_ASHIKHMIN_SHIRLEY = 3,
		distribution_MULTI_GGX = 4,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfGlass ****************/

class ShaderNodeBsdfGlass : public ShaderNode {
public:
	ShaderNodeBsdfGlass(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
		distribution_MULTI_GGX = 4,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfRefraction ****************/

class ShaderNodeBsdfRefraction : public ShaderNode {
public:
	ShaderNodeBsdfRefraction(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfTranslucent ****************/

class ShaderNodeBsdfTranslucent : public ShaderNode {
public:
	ShaderNodeBsdfTranslucent(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfTransparent ****************/

class ShaderNodeBsdfTransparent : public ShaderNode {
public:
	ShaderNodeBsdfTransparent(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfSheen ****************/

class ShaderNodeBsdfSheen : public ShaderNode {
public:
	ShaderNodeBsdfSheen(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum distribution_enum {
		distribution_ASHIKHMIN = 0,
		distribution_MICROFIBER = 1,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfToon ****************/

class ShaderNodeBsdfToon : public ShaderNode {
public:
	ShaderNodeBsdfToon(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum component_enum {
		component_DIFFUSE = 0,
		component_GLOSSY = 1,
	};
	inline component_enum component(void);
	inline void component(component_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfHair ****************/

class ShaderNodeBsdfHair : public ShaderNode {
public:
	ShaderNodeBsdfHair(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum component_enum {
		component_Reflection = 0,
		component_Transmission = 1,
	};
	inline component_enum component(void);
	inline void component(component_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBsdfHairPrincipled ****************/

class ShaderNodeBsdfHairPrincipled : public ShaderNode {
public:
	ShaderNodeBsdfHairPrincipled(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum model_enum {
		model_CHIANG = 0,
		model_HUANG = 1,
	};
	inline model_enum model(void);
	inline void model(model_enum value);
	enum parametrization_enum {
		parametrization_ABSORPTION = 2,
		parametrization_MELANIN = 1,
		parametrization_COLOR = 0,
	};
	inline parametrization_enum parametrization(void);
	inline void parametrization(parametrization_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeSubsurfaceScattering ****************/

class ShaderNodeSubsurfaceScattering : public ShaderNode {
public:
	ShaderNodeSubsurfaceScattering(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum falloff_enum {
		falloff_BURLEY = 3,
		falloff_RANDOM_WALK = 4,
		falloff_RANDOM_WALK_SKIN = 5,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVolumeAbsorption ****************/

class ShaderNodeVolumeAbsorption : public ShaderNode {
public:
	ShaderNodeVolumeAbsorption(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVolumeScatter ****************/

class ShaderNodeVolumeScatter : public ShaderNode {
public:
	ShaderNodeVolumeScatter(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVolumePrincipled ****************/

class ShaderNodeVolumePrincipled : public ShaderNode {
public:
	ShaderNodeVolumePrincipled(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeEmission ****************/

class ShaderNodeEmission : public ShaderNode {
public:
	ShaderNodeEmission(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeNewGeometry ****************/

class ShaderNodeNewGeometry : public ShaderNode {
public:
	ShaderNodeNewGeometry(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeLightPath ****************/

class ShaderNodeLightPath : public ShaderNode {
public:
	ShaderNodeLightPath(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeLightFalloff ****************/

class ShaderNodeLightFalloff : public ShaderNode {
public:
	ShaderNodeLightFalloff(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeObjectInfo ****************/

class ShaderNodeObjectInfo : public ShaderNode {
public:
	ShaderNodeObjectInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeParticleInfo ****************/

class ShaderNodeParticleInfo : public ShaderNode {
public:
	ShaderNodeParticleInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeHairInfo ****************/

class ShaderNodeHairInfo : public ShaderNode {
public:
	ShaderNodeHairInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodePointInfo ****************/

class ShaderNodePointInfo : public ShaderNode {
public:
	ShaderNodePointInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVolumeInfo ****************/

class ShaderNodeVolumeInfo : public ShaderNode {
public:
	ShaderNodeVolumeInfo(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeWireframe ****************/

class ShaderNodeWireframe : public ShaderNode {
public:
	ShaderNodeWireframe(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool use_pixel_size(void);
	inline void use_pixel_size(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeWavelength ****************/

class ShaderNodeWavelength : public ShaderNode {
public:
	ShaderNodeWavelength(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBlackbody ****************/

class ShaderNodeBlackbody : public ShaderNode {
public:
	ShaderNodeBlackbody(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBump ****************/

class ShaderNodeBump : public ShaderNode {
public:
	ShaderNodeBump(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool invert(void);
	inline void invert(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeNormalMap ****************/

class ShaderNodeNormalMap : public ShaderNode {
public:
	ShaderNodeNormalMap(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum space_enum {
		space_TANGENT = 0,
		space_OBJECT = 1,
		space_WORLD = 2,
		space_BLENDER_OBJECT = 3,
		space_BLENDER_WORLD = 4,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline std::string uv_map(void);
	inline void uv_map(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTangent ****************/

class ShaderNodeTangent : public ShaderNode {
public:
	ShaderNodeTangent(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum direction_type_enum {
		direction_type_RADIAL = 0,
		direction_type_UV_MAP = 1,
	};
	inline direction_type_enum direction_type(void);
	inline void direction_type(direction_type_enum value);
	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	inline std::string uv_map(void);
	inline void uv_map(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeScript ****************/

class ShaderNodeScript : public ShaderNode {
public:
	ShaderNodeScript(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Text script(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	enum mode_enum {
		mode_INTERNAL = 0,
		mode_EXTERNAL = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool use_auto_update(void);
	inline void use_auto_update(bool value);
	inline std::string bytecode(void);
	inline void bytecode(const std::string& value);
	inline std::string bytecode_hash(void);
	inline void bytecode_hash(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexImage ****************/

class ShaderNodeTexImage : public ShaderNode {
public:
	ShaderNodeTexImage(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Image image(void);
	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum projection_enum {
		projection_FLAT = 0,
		projection_BOX = 1,
		projection_SPHERE = 2,
		projection_TUBE = 3,
	};
	inline projection_enum projection(void);
	inline void projection(projection_enum value);
	enum interpolation_enum {
		interpolation_Linear = 0,
		interpolation_Closest = 1,
		interpolation_Cubic = 2,
		interpolation_Smart = 3,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline float projection_blend(void);
	inline void projection_blend(float value);
	enum extension_enum {
		extension_REPEAT = 0,
		extension_EXTEND = 1,
		extension_CLIP = 2,
		extension_MIRROR = 3,
	};
	inline extension_enum extension(void);
	inline void extension(extension_enum value);
	inline ImageUser image_user(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexEnvironment ****************/

class ShaderNodeTexEnvironment : public ShaderNode {
public:
	ShaderNodeTexEnvironment(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Image image(void);
	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum projection_enum {
		projection_EQUIRECTANGULAR = 0,
		projection_MIRROR_BALL = 1,
	};
	inline projection_enum projection(void);
	inline void projection(projection_enum value);
	enum interpolation_enum {
		interpolation_Linear = 0,
		interpolation_Closest = 1,
		interpolation_Cubic = 2,
		interpolation_Smart = 3,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline ImageUser image_user(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexSky ****************/

class ShaderNodeTexSky : public ShaderNode {
public:
	ShaderNodeTexSky(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum sky_type_enum {
		sky_type_PREETHAM = 0,
		sky_type_HOSEK_WILKIE = 1,
		sky_type_NISHITA = 2,
	};
	inline sky_type_enum sky_type(void);
	inline void sky_type(sky_type_enum value);
	inline Array<float, 3> sun_direction(void);
	inline void sun_direction(float values[3]);
	inline float turbidity(void);
	inline void turbidity(float value);
	inline float ground_albedo(void);
	inline void ground_albedo(float value);
	inline bool sun_disc(void);
	inline void sun_disc(bool value);
	inline float sun_size(void);
	inline void sun_size(float value);
	inline float sun_intensity(void);
	inline void sun_intensity(float value);
	inline float sun_elevation(void);
	inline void sun_elevation(float value);
	inline float sun_rotation(void);
	inline void sun_rotation(float value);
	inline float altitude(void);
	inline void altitude(float value);
	inline float air_density(void);
	inline void air_density(float value);
	inline float dust_density(void);
	inline void dust_density(float value);
	inline float ozone_density(void);
	inline void ozone_density(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexGradient ****************/

class ShaderNodeTexGradient : public ShaderNode {
public:
	ShaderNodeTexGradient(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum gradient_type_enum {
		gradient_type_LINEAR = 0,
		gradient_type_QUADRATIC = 1,
		gradient_type_EASING = 2,
		gradient_type_DIAGONAL = 3,
		gradient_type_SPHERICAL = 6,
		gradient_type_QUADRATIC_SPHERE = 5,
		gradient_type_RADIAL = 4,
	};
	inline gradient_type_enum gradient_type(void);
	inline void gradient_type(gradient_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexNoise ****************/

class ShaderNodeTexNoise : public ShaderNode {
public:
	ShaderNodeTexNoise(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum noise_dimensions_enum {
		noise_dimensions_1D = 1,
		noise_dimensions_2D = 2,
		noise_dimensions_3D = 3,
		noise_dimensions_4D = 4,
	};
	inline noise_dimensions_enum noise_dimensions(void);
	inline void noise_dimensions(noise_dimensions_enum value);
	inline bool normalize(void);
	inline void normalize(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexMagic ****************/

class ShaderNodeTexMagic : public ShaderNode {
public:
	ShaderNodeTexMagic(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	inline int turbulence_depth(void);
	inline void turbulence_depth(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexWave ****************/

class ShaderNodeTexWave : public ShaderNode {
public:
	ShaderNodeTexWave(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum wave_type_enum {
		wave_type_BANDS = 0,
		wave_type_RINGS = 1,
	};
	inline wave_type_enum wave_type(void);
	inline void wave_type(wave_type_enum value);
	enum bands_direction_enum {
		bands_direction_X = 0,
		bands_direction_Y = 1,
		bands_direction_Z = 2,
		bands_direction_DIAGONAL = 3,
	};
	inline bands_direction_enum bands_direction(void);
	inline void bands_direction(bands_direction_enum value);
	enum rings_direction_enum {
		rings_direction_X = 0,
		rings_direction_Y = 1,
		rings_direction_Z = 2,
		rings_direction_SPHERICAL = 3,
	};
	inline rings_direction_enum rings_direction(void);
	inline void rings_direction(rings_direction_enum value);
	enum wave_profile_enum {
		wave_profile_SIN = 0,
		wave_profile_SAW = 1,
		wave_profile_TRI = 2,
	};
	inline wave_profile_enum wave_profile(void);
	inline void wave_profile(wave_profile_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexMusgrave ****************/

class ShaderNodeTexMusgrave : public ShaderNode {
public:
	ShaderNodeTexMusgrave(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum musgrave_dimensions_enum {
		musgrave_dimensions_1D = 1,
		musgrave_dimensions_2D = 2,
		musgrave_dimensions_3D = 3,
		musgrave_dimensions_4D = 4,
	};
	inline musgrave_dimensions_enum musgrave_dimensions(void);
	inline void musgrave_dimensions(musgrave_dimensions_enum value);
	enum musgrave_type_enum {
		musgrave_type_MULTIFRACTAL = 0,
		musgrave_type_RIDGED_MULTIFRACTAL = 3,
		musgrave_type_HYBRID_MULTIFRACTAL = 2,
		musgrave_type_FBM = 1,
		musgrave_type_HETERO_TERRAIN = 4,
	};
	inline musgrave_type_enum musgrave_type(void);
	inline void musgrave_type(musgrave_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexVoronoi ****************/

class ShaderNodeTexVoronoi : public ShaderNode {
public:
	ShaderNodeTexVoronoi(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	enum voronoi_dimensions_enum {
		voronoi_dimensions_1D = 1,
		voronoi_dimensions_2D = 2,
		voronoi_dimensions_3D = 3,
		voronoi_dimensions_4D = 4,
	};
	inline voronoi_dimensions_enum voronoi_dimensions(void);
	inline void voronoi_dimensions(voronoi_dimensions_enum value);
	enum distance_enum {
		distance_EUCLIDEAN = 0,
		distance_MANHATTAN = 1,
		distance_CHEBYCHEV = 2,
		distance_MINKOWSKI = 3,
	};
	inline distance_enum distance(void);
	inline void distance(distance_enum value);
	enum feature_enum {
		feature_F1 = 0,
		feature_F2 = 1,
		feature_SMOOTH_F1 = 2,
		feature_DISTANCE_TO_EDGE = 3,
		feature_N_SPHERE_RADIUS = 4,
	};
	inline feature_enum feature(void);
	inline void feature(feature_enum value);
	inline bool normalize(void);
	inline void normalize(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexChecker ****************/

class ShaderNodeTexChecker : public ShaderNode {
public:
	ShaderNodeTexChecker(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexBrick ****************/

class ShaderNodeTexBrick : public ShaderNode {
public:
	ShaderNodeTexBrick(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline TexMapping texture_mapping(void);
	inline ColorMapping color_mapping(void);
	inline int offset_frequency(void);
	inline void offset_frequency(int value);
	inline int squash_frequency(void);
	inline void squash_frequency(int value);
	inline float offset(void);
	inline void offset(float value);
	inline float squash(void);
	inline void squash(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexPointDensity ****************/

class ShaderNodeTexPointDensity : public ShaderNode {
public:
	ShaderNodeTexPointDensity(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Object object(void);
	enum point_source_enum {
		point_source_PARTICLE_SYSTEM = 0,
		point_source_OBJECT = 1,
	};
	inline point_source_enum point_source(void);
	inline void point_source(point_source_enum value);
	inline ParticleSystem particle_system(void);
	inline int resolution(void);
	inline void resolution(int value);
	inline float radius(void);
	inline void radius(float value);
	enum space_enum {
		space_OBJECT = 0,
		space_WORLD = 1,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	enum interpolation_enum {
		interpolation_Closest = 1,
		interpolation_Linear = 0,
		interpolation_Cubic = 2,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum particle_color_source_enum {
		particle_color_source_PARTICLE_AGE = 1,
		particle_color_source_PARTICLE_SPEED = 2,
		particle_color_source_PARTICLE_VELOCITY = 3,
	};
	inline particle_color_source_enum particle_color_source(void);
	inline void particle_color_source(particle_color_source_enum value);
	enum vertex_color_source_enum {
		vertex_color_source_VERTEX_COLOR = 0,
		vertex_color_source_VERTEX_WEIGHT = 1,
		vertex_color_source_VERTEX_NORMAL = 2,
	};
	inline vertex_color_source_enum vertex_color_source(void);
	inline void vertex_color_source(vertex_color_source_enum value);
	inline std::string vertex_attribute_name(void);
	inline void vertex_attribute_name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
	inline void cache_point_density(Depsgraph& depsgraph);
	inline void calc_point_density(Depsgraph& depsgraph, int *rgba_values_len, float **rgba_values);
	inline void calc_point_density_minmax(Depsgraph& depsgraph, float min[3], float max[3]);
};

/**************** ShaderNodeTexCoord ****************/

class ShaderNodeTexCoord : public ShaderNode {
public:
	ShaderNodeTexCoord(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Object object(void);
	inline bool from_instancer(void);
	inline void from_instancer(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVectorRotate ****************/

class ShaderNodeVectorRotate : public ShaderNode {
public:
	ShaderNodeVectorRotate(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum rotation_type_enum {
		rotation_type_AXIS_ANGLE = 0,
		rotation_type_X_AXIS = 1,
		rotation_type_Y_AXIS = 2,
		rotation_type_Z_AXIS = 3,
		rotation_type_EULER_XYZ = 4,
	};
	inline rotation_type_enum rotation_type(void);
	inline void rotation_type(rotation_type_enum value);
	inline bool invert(void);
	inline void invert(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVectorTransform ****************/

class ShaderNodeVectorTransform : public ShaderNode {
public:
	ShaderNodeVectorTransform(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum vector_type_enum {
		vector_type_POINT = 1,
		vector_type_VECTOR = 0,
		vector_type_NORMAL = 2,
	};
	inline vector_type_enum vector_type(void);
	inline void vector_type(vector_type_enum value);
	enum convert_from_enum {
		convert_from_WORLD = 0,
		convert_from_OBJECT = 1,
		convert_from_CAMERA = 2,
	};
	inline convert_from_enum convert_from(void);
	inline void convert_from(convert_from_enum value);
	enum convert_to_enum {
		convert_to_WORLD = 0,
		convert_to_OBJECT = 1,
		convert_to_CAMERA = 2,
	};
	inline convert_to_enum convert_to(void);
	inline void convert_to(convert_to_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeSeparateHSV ****************/

class ShaderNodeSeparateHSV : public ShaderNode {
public:
	ShaderNodeSeparateHSV(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeCombineHSV ****************/

class ShaderNodeCombineHSV : public ShaderNode {
public:
	ShaderNodeCombineHSV(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeUVMap ****************/

class ShaderNodeUVMap : public ShaderNode {
public:
	ShaderNodeUVMap(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool from_instancer(void);
	inline void from_instancer(bool value);
	inline std::string uv_map(void);
	inline void uv_map(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVertexColor ****************/

class ShaderNodeVertexColor : public ShaderNode {
public:
	ShaderNodeVertexColor(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline std::string layer_name(void);
	inline void layer_name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeUVAlongStroke ****************/

class ShaderNodeUVAlongStroke : public ShaderNode {
public:
	ShaderNodeUVAlongStroke(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline bool use_tips(void);
	inline void use_tips(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeSeparateXYZ ****************/

class ShaderNodeSeparateXYZ : public ShaderNode {
public:
	ShaderNodeSeparateXYZ(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeCombineXYZ ****************/

class ShaderNodeCombineXYZ : public ShaderNode {
public:
	ShaderNodeCombineXYZ(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeBevel ****************/

class ShaderNodeBevel : public ShaderNode {
public:
	ShaderNodeBevel(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline int samples(void);
	inline void samples(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeDisplacement ****************/

class ShaderNodeDisplacement : public ShaderNode {
public:
	ShaderNodeDisplacement(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum space_enum {
		space_OBJECT = 1,
		space_WORLD = 2,
	};
	inline space_enum space(void);
	inline void space(space_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeVectorDisplacement ****************/

class ShaderNodeVectorDisplacement : public ShaderNode {
public:
	ShaderNodeVectorDisplacement(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum space_enum {
		space_TANGENT = 0,
		space_OBJECT = 1,
		space_WORLD = 2,
	};
	inline space_enum space(void);
	inline void space(space_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexIES ****************/

class ShaderNodeTexIES : public ShaderNode {
public:
	ShaderNodeTexIES(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline Text ies(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	enum mode_enum {
		mode_INTERNAL = 0,
		mode_EXTERNAL = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeTexWhiteNoise ****************/

class ShaderNodeTexWhiteNoise : public ShaderNode {
public:
	ShaderNodeTexWhiteNoise(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum noise_dimensions_enum {
		noise_dimensions_1D = 1,
		noise_dimensions_2D = 2,
		noise_dimensions_3D = 3,
		noise_dimensions_4D = 4,
	};
	inline noise_dimensions_enum noise_dimensions(void);
	inline void noise_dimensions(noise_dimensions_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeOutputAOV ****************/

class ShaderNodeOutputAOV : public ShaderNode {
public:
	ShaderNodeOutputAOV(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline std::string name(void);
	inline void name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeFloatCurve ****************/

class ShaderNodeFloatCurve : public ShaderNode {
public:
	ShaderNodeFloatCurve(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeCombineColor ****************/

class ShaderNodeCombineColor : public ShaderNode {
public:
	ShaderNodeCombineColor(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum mode_enum {
		mode_RGB = 0,
		mode_HSV = 1,
		mode_HSL = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeSeparateColor ****************/

class ShaderNodeSeparateColor : public ShaderNode {
public:
	ShaderNodeSeparateColor(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum mode_enum {
		mode_RGB = 0,
		mode_HSV = 1,
		mode_HSL = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeMix ****************/

class ShaderNodeMix : public ShaderNode {
public:
	ShaderNodeMix(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	enum data_type_enum {
		data_type_FLOAT = 0,
		data_type_VECTOR = 1,
		data_type_RGBA = 2,
		data_type_ROTATION = 14,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);
	enum factor_mode_enum {
		factor_mode_UNIFORM = 0,
		factor_mode_NON_UNIFORM = 1,
	};
	inline factor_mode_enum factor_mode(void);
	inline void factor_mode(factor_mode_enum value);
	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_EXCLUSION = 18,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool clamp_factor(void);
	inline void clamp_factor(bool value);
	inline bool clamp_result(void);
	inline void clamp_result(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeViewer ****************/

class CompositorNodeViewer : public CompositorNode {
public:
	CompositorNodeViewer(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum tile_order_enum {
		tile_order_CENTEROUT = 0,
		tile_order_RANDOM = 1,
		tile_order_BOTTOMUP = 2,
		tile_order_RULE_OF_THIRDS = 3,
	};
	inline tile_order_enum tile_order(void);
	inline void tile_order(tile_order_enum value);
	inline float center_x(void);
	inline void center_x(float value);
	inline float center_y(void);
	inline void center_y(float value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeRGB ****************/

class CompositorNodeRGB : public CompositorNode {
public:
	CompositorNodeRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeValue ****************/

class CompositorNodeValue : public CompositorNode {
public:
	CompositorNodeValue(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMixRGB ****************/

class CompositorNodeMixRGB : public CompositorNode {
public:
	CompositorNodeMixRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_EXCLUSION = 18,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeValToRGB ****************/

class CompositorNodeValToRGB : public CompositorNode {
public:
	CompositorNodeValToRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline ColorRamp color_ramp(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeRGBToBW ****************/

class CompositorNodeRGBToBW : public CompositorNode {
public:
	CompositorNodeRGBToBW(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeNormal ****************/

class CompositorNodeNormal : public CompositorNode {
public:
	CompositorNodeNormal(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCurveVec ****************/

class CompositorNodeCurveVec : public CompositorNode {
public:
	CompositorNodeCurveVec(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCurveRGB ****************/

class CompositorNodeCurveRGB : public CompositorNode {
public:
	CompositorNodeCurveRGB(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeAlphaOver ****************/

class CompositorNodeAlphaOver : public CompositorNode {
public:
	CompositorNodeAlphaOver(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_premultiply(void);
	inline void use_premultiply(bool value);
	inline float premul(void);
	inline void premul(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeBlur ****************/

class CompositorNodeBlur : public CompositorNode {
public:
	CompositorNodeBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_variable_size(void);
	inline void use_variable_size(bool value);
	inline bool use_extended_bounds(void);
	inline void use_extended_bounds(bool value);
	inline int size_x(void);
	inline void size_x(int value);
	inline int size_y(void);
	inline void size_y(int value);
	inline bool use_relative(void);
	inline void use_relative(bool value);
	enum aspect_correction_enum {
		aspect_correction_NONE = 0,
		aspect_correction_Y = 1,
		aspect_correction_X = 2,
	};
	inline aspect_correction_enum aspect_correction(void);
	inline void aspect_correction(aspect_correction_enum value);
	inline float factor(void);
	inline void factor(float value);
	inline float factor_x(void);
	inline void factor_x(float value);
	inline float factor_y(void);
	inline void factor_y(float value);
	enum filter_type_enum {
		filter_type_FLAT = 0,
		filter_type_TENT = 1,
		filter_type_QUAD = 2,
		filter_type_CUBIC = 3,
		filter_type_GAUSS = 5,
		filter_type_FAST_GAUSS = 7,
		filter_type_CATROM = 4,
		filter_type_MITCH = 6,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline bool use_bokeh(void);
	inline void use_bokeh(bool value);
	inline bool use_gamma_correction(void);
	inline void use_gamma_correction(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeFilter ****************/

class CompositorNodeFilter : public CompositorNode {
public:
	CompositorNodeFilter(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_SOFTEN = 0,
		filter_type_SHARPEN = 1,
		filter_type_SHARPEN_DIAMOND = 7,
		filter_type_LAPLACE = 2,
		filter_type_SOBEL = 3,
		filter_type_PREWITT = 4,
		filter_type_KIRSCH = 5,
		filter_type_SHADOW = 6,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMapValue ****************/

class CompositorNodeMapValue : public CompositorNode {
public:
	CompositorNodeMapValue(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Array<float, 1> offset(void);
	inline void offset(float values[1]);
	inline Array<float, 1> size(void);
	inline void size(float values[1]);
	inline bool use_min(void);
	inline void use_min(bool value);
	inline bool use_max(void);
	inline void use_max(bool value);
	inline Array<float, 1> min(void);
	inline void min(float values[1]);
	inline Array<float, 1> max(void);
	inline void max(float values[1]);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMapRange ****************/

class CompositorNodeMapRange : public CompositorNode {
public:
	CompositorNodeMapRange(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeTime ****************/

class CompositorNodeTime : public CompositorNode {
public:
	CompositorNodeTime(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping curve(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeVecBlur ****************/

class CompositorNodeVecBlur : public CompositorNode {
public:
	CompositorNodeVecBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int samples(void);
	inline void samples(int value);
	inline int speed_min(void);
	inline void speed_min(int value);
	inline int speed_max(void);
	inline void speed_max(int value);
	inline float factor(void);
	inline void factor(float value);
	inline bool use_curved(void);
	inline void use_curved(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSepRGBA ****************/

class CompositorNodeSepRGBA : public CompositorNode {
public:
	CompositorNodeSepRGBA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSepHSVA ****************/

class CompositorNodeSepHSVA : public CompositorNode {
public:
	CompositorNodeSepHSVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSetAlpha ****************/

class CompositorNodeSetAlpha : public CompositorNode {
public:
	CompositorNodeSetAlpha(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_APPLY = 0,
		mode_REPLACE_ALPHA = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeHueSat ****************/

class CompositorNodeHueSat : public CompositorNode {
public:
	CompositorNodeHueSat(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeImage ****************/

class CompositorNodeImage : public CompositorNode {
public:
	CompositorNodeImage(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Image image(void);
	inline bool use_straight_alpha_output(void);
	inline void use_straight_alpha_output(bool value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool use_auto_refresh(void);
	inline void use_auto_refresh(bool value);
	enum layer_enum {
		layer_PLACEHOLDER = 0,
	};
	inline layer_enum layer(void);
	inline void layer(layer_enum value);
	inline bool has_layers(void);
	inline void has_layers(bool value);
	enum view_enum {
		view_ALL = 0,
	};
	inline view_enum view(void);
	inline void view(view_enum value);
	inline bool has_views(void);
	inline void has_views(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeRLayers ****************/

class CompositorNodeRLayers : public CompositorNode {
public:
	CompositorNodeRLayers(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Scene scene(void);
	enum layer_enum {
		layer_PLACEHOLDER = 0,
	};
	inline layer_enum layer(void);
	inline void layer(layer_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeComposite ****************/

class CompositorNodeComposite : public CompositorNode {
public:
	CompositorNodeComposite(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_alpha(void);
	inline void use_alpha(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeOutputFile ****************/

class CompositorNodeOutputFile : public CompositorNode {
public:
	CompositorNodeOutputFile(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg),
		file_slots(ptr_arg),
		layer_slots(ptr_arg)
		{}

	inline std::string base_path(void);
	inline void base_path(const std::string& value);
	inline int active_input_index(void);
	inline void active_input_index(int value);
	inline ImageFormatSettings format(void);
	COLLECTION_PROPERTY(CompositorNodeOutputFileFileSlots, NodeOutputFileSlotFile, CompositorNodeOutputFile, file_slots, false, false, false)
	COLLECTION_PROPERTY(CompositorNodeOutputFileLayerSlots, NodeOutputFileSlotLayer, CompositorNodeOutputFile, layer_slots, false, false, false)

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeTexture ****************/

class CompositorNodeTexture : public CompositorNode {
public:
	CompositorNodeTexture(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Texture texture(void);
	inline int node_output(void);
	inline void node_output(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeTranslate ****************/

class CompositorNodeTranslate : public CompositorNode {
public:
	CompositorNodeTranslate(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_relative(void);
	inline void use_relative(bool value);
	enum wrap_axis_enum {
		wrap_axis_NONE = 0,
		wrap_axis_XAXIS = 1,
		wrap_axis_YAXIS = 2,
		wrap_axis_BOTH = 3,
	};
	inline wrap_axis_enum wrap_axis(void);
	inline void wrap_axis(wrap_axis_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeZcombine ****************/

class CompositorNodeZcombine : public CompositorNode {
public:
	CompositorNodeZcombine(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_antialias_z(void);
	inline void use_antialias_z(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCombRGBA ****************/

class CompositorNodeCombRGBA : public CompositorNode {
public:
	CompositorNodeCombRGBA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDilateErode ****************/

class CompositorNodeDilateErode : public CompositorNode {
public:
	CompositorNodeDilateErode(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_STEP = 0,
		mode_THRESHOLD = 1,
		mode_DISTANCE = 2,
		mode_FEATHER = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline int distance(void);
	inline void distance(int value);
	inline float edge(void);
	inline void edge(float value);
	enum falloff_enum {
		falloff_SMOOTH = 0,
		falloff_SPHERE = 1,
		falloff_ROOT = 2,
		falloff_INVERSE_SQUARE = 7,
		falloff_SHARP = 3,
		falloff_LINEAR = 4,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeInpaint ****************/

class CompositorNodeInpaint : public CompositorNode {
public:
	CompositorNodeInpaint(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int distance(void);
	inline void distance(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDespeckle ****************/

class CompositorNodeDespeckle : public CompositorNode {
public:
	CompositorNodeDespeckle(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float threshold(void);
	inline void threshold(float value);
	inline float threshold_neighbor(void);
	inline void threshold_neighbor(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeRotate ****************/

class CompositorNodeRotate : public CompositorNode {
public:
	CompositorNodeRotate(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeScale ****************/

class CompositorNodeScale : public CompositorNode {
public:
	CompositorNodeScale(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum space_enum {
		space_RELATIVE = 0,
		space_ABSOLUTE = 1,
		space_SCENE_SIZE = 2,
		space_RENDER_SIZE = 3,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 1,
		frame_method_CROP = 2,
	};
	inline frame_method_enum frame_method(void);
	inline void frame_method(frame_method_enum value);
	inline float offset_x(void);
	inline void offset_x(float value);
	inline float offset_y(void);
	inline void offset_y(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSepYCCA ****************/

class CompositorNodeSepYCCA : public CompositorNode {
public:
	CompositorNodeSepYCCA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_ITUBT601 = 0,
		mode_ITUBT709 = 1,
		mode_JFIF = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCombYCCA ****************/

class CompositorNodeCombYCCA : public CompositorNode {
public:
	CompositorNodeCombYCCA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_ITUBT601 = 0,
		mode_ITUBT709 = 1,
		mode_JFIF = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSepYUVA ****************/

class CompositorNodeSepYUVA : public CompositorNode {
public:
	CompositorNodeSepYUVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCombYUVA ****************/

class CompositorNodeCombYUVA : public CompositorNode {
public:
	CompositorNodeCombYUVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDiffMatte ****************/

class CompositorNodeDiffMatte : public CompositorNode {
public:
	CompositorNodeDiffMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float tolerance(void);
	inline void tolerance(float value);
	inline float falloff(void);
	inline void falloff(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeColorSpill ****************/

class CompositorNodeColorSpill : public CompositorNode {
public:
	CompositorNodeColorSpill(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum channel_enum {
		channel_R = 1,
		channel_G = 2,
		channel_B = 3,
	};
	inline channel_enum channel(void);
	inline void channel(channel_enum value);
	enum limit_method_enum {
		limit_method_SIMPLE = 0,
		limit_method_AVERAGE = 1,
	};
	inline limit_method_enum limit_method(void);
	inline void limit_method(limit_method_enum value);
	enum limit_channel_enum {
		limit_channel_R = 0,
		limit_channel_G = 1,
		limit_channel_B = 2,
	};
	inline limit_channel_enum limit_channel(void);
	inline void limit_channel(limit_channel_enum value);
	inline float ratio(void);
	inline void ratio(float value);
	inline bool use_unspill(void);
	inline void use_unspill(bool value);
	inline float unspill_red(void);
	inline void unspill_red(float value);
	inline float unspill_green(void);
	inline void unspill_green(float value);
	inline float unspill_blue(void);
	inline void unspill_blue(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeChromaMatte ****************/

class CompositorNodeChromaMatte : public CompositorNode {
public:
	CompositorNodeChromaMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float tolerance(void);
	inline void tolerance(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline float lift(void);
	inline void lift(float value);
	inline float gain(void);
	inline void gain(float value);
	inline float shadow_adjust(void);
	inline void shadow_adjust(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeChannelMatte ****************/

class CompositorNodeChannelMatte : public CompositorNode {
public:
	CompositorNodeChannelMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum color_space_enum {
		color_space_RGB = 1,
		color_space_HSV = 2,
		color_space_YUV = 3,
		color_space_YCC = 4,
	};
	inline color_space_enum color_space(void);
	inline void color_space(color_space_enum value);
	enum matte_channel_enum {
		matte_channel_R = 1,
		matte_channel_G = 2,
		matte_channel_B = 3,
	};
	inline matte_channel_enum matte_channel(void);
	inline void matte_channel(matte_channel_enum value);
	enum limit_method_enum {
		limit_method_SINGLE = 0,
		limit_method_MAX = 1,
	};
	inline limit_method_enum limit_method(void);
	inline void limit_method(limit_method_enum value);
	enum limit_channel_enum {
		limit_channel_R = 1,
		limit_channel_G = 2,
		limit_channel_B = 3,
	};
	inline limit_channel_enum limit_channel(void);
	inline void limit_channel(limit_channel_enum value);
	inline float limit_max(void);
	inline void limit_max(float value);
	inline float limit_min(void);
	inline void limit_min(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeFlip ****************/

class CompositorNodeFlip : public CompositorNode {
public:
	CompositorNodeFlip(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_XY = 2,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSplitViewer ****************/

class CompositorNodeSplitViewer : public CompositorNode {
public:
	CompositorNodeSplitViewer(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
	};
	inline axis_enum axis(void);
	inline void axis(axis_enum value);
	inline int factor(void);
	inline void factor(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMapUV ****************/

class CompositorNodeMapUV : public CompositorNode {
public:
	CompositorNodeMapUV(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int alpha(void);
	inline void alpha(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeIDMask ****************/

class CompositorNodeIDMask : public CompositorNode {
public:
	CompositorNodeIDMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int index(void);
	inline void index(int value);
	inline bool use_antialiasing(void);
	inline void use_antialiasing(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDoubleEdgeMask ****************/

class CompositorNodeDoubleEdgeMask : public CompositorNode {
public:
	CompositorNodeDoubleEdgeMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum inner_mode_enum {
		inner_mode_ALL = 0,
		inner_mode_ADJACENT_ONLY = 1,
	};
	inline inner_mode_enum inner_mode(void);
	inline void inner_mode(inner_mode_enum value);
	enum edge_mode_enum {
		edge_mode_BLEED_OUT = 0,
		edge_mode_KEEP_IN = 1,
	};
	inline edge_mode_enum edge_mode(void);
	inline void edge_mode(edge_mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDefocus ****************/

class CompositorNodeDefocus : public CompositorNode {
public:
	CompositorNodeDefocus(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Scene scene(void);
	enum bokeh_enum {
		bokeh_OCTAGON = 8,
		bokeh_HEPTAGON = 7,
		bokeh_HEXAGON = 6,
		bokeh_PENTAGON = 5,
		bokeh_SQUARE = 4,
		bokeh_TRIANGLE = 3,
		bokeh_CIRCLE = 0,
	};
	inline bokeh_enum bokeh(void);
	inline void bokeh(bokeh_enum value);
	inline float angle(void);
	inline void angle(float value);
	inline bool use_gamma_correction(void);
	inline void use_gamma_correction(bool value);
	inline float f_stop(void);
	inline void f_stop(float value);
	inline float blur_max(void);
	inline void blur_max(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline bool use_preview(void);
	inline void use_preview(bool value);
	inline bool use_zbuffer(void);
	inline void use_zbuffer(bool value);
	inline float z_scale(void);
	inline void z_scale(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDisplace ****************/

class CompositorNodeDisplace : public CompositorNode {
public:
	CompositorNodeDisplace(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCombHSVA ****************/

class CompositorNodeCombHSVA : public CompositorNode {
public:
	CompositorNodeCombHSVA(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMath ****************/

class CompositorNodeMath : public CompositorNode {
public:
	CompositorNodeMath(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_MULTIPLY_ADD = 36,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_SQRT = 23,
		operation_INVERSE_SQRT = 24,
		operation_ABSOLUTE = 18,
		operation_EXPONENT = 26,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_SIGN = 25,
		operation_COMPARE = 35,
		operation_SMOOTH_MIN = 38,
		operation_SMOOTH_MAX = 39,
		operation_ROUND = 14,
		operation_FLOOR = 20,
		operation_CEIL = 21,
		operation_TRUNC = 32,
		operation_FRACT = 22,
		operation_MODULO = 17,
		operation_FLOORED_MODULO = 40,
		operation_WRAP = 34,
		operation_SNAP = 33,
		operation_PINGPONG = 37,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_ARCTAN2 = 19,
		operation_SINH = 29,
		operation_COSH = 30,
		operation_TANH = 31,
		operation_RADIANS = 27,
		operation_DEGREES = 28,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeLumaMatte ****************/

class CompositorNodeLumaMatte : public CompositorNode {
public:
	CompositorNodeLumaMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float limit_max(void);
	inline void limit_max(float value);
	inline float limit_min(void);
	inline void limit_min(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeBrightContrast ****************/

class CompositorNodeBrightContrast : public CompositorNode {
public:
	CompositorNodeBrightContrast(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_premultiply(void);
	inline void use_premultiply(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeGamma ****************/

class CompositorNodeGamma : public CompositorNode {
public:
	CompositorNodeGamma(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeInvert ****************/

class CompositorNodeInvert : public CompositorNode {
public:
	CompositorNodeInvert(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool invert_rgb(void);
	inline void invert_rgb(bool value);
	inline bool invert_alpha(void);
	inline void invert_alpha(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeNormalize ****************/

class CompositorNodeNormalize : public CompositorNode {
public:
	CompositorNodeNormalize(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCrop ****************/

class CompositorNodeCrop : public CompositorNode {
public:
	CompositorNodeCrop(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_crop_size(void);
	inline void use_crop_size(bool value);
	inline bool relative(void);
	inline void relative(bool value);
	inline int min_x(void);
	inline void min_x(int value);
	inline int max_x(void);
	inline void max_x(int value);
	inline int min_y(void);
	inline void min_y(int value);
	inline int max_y(void);
	inline void max_y(int value);
	inline float rel_min_x(void);
	inline void rel_min_x(float value);
	inline float rel_max_x(void);
	inline void rel_max_x(float value);
	inline float rel_min_y(void);
	inline void rel_min_y(float value);
	inline float rel_max_y(void);
	inline void rel_max_y(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDBlur ****************/

class CompositorNodeDBlur : public CompositorNode {
public:
	CompositorNodeDBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int iterations(void);
	inline void iterations(int value);
	inline float center_x(void);
	inline void center_x(float value);
	inline float center_y(void);
	inline void center_y(float value);
	inline float distance(void);
	inline void distance(float value);
	inline float angle(void);
	inline void angle(float value);
	inline float spin(void);
	inline void spin(float value);
	inline float zoom(void);
	inline void zoom(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeBilateralblur ****************/

class CompositorNodeBilateralblur : public CompositorNode {
public:
	CompositorNodeBilateralblur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline int iterations(void);
	inline void iterations(int value);
	inline float sigma_color(void);
	inline void sigma_color(float value);
	inline float sigma_space(void);
	inline void sigma_space(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodePremulKey ****************/

class CompositorNodePremulKey : public CompositorNode {
public:
	CompositorNodePremulKey(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mapping_enum {
		mapping_STRAIGHT_TO_PREMUL = 0,
		mapping_PREMUL_TO_STRAIGHT = 1,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeGlare ****************/

class CompositorNodeGlare : public CompositorNode {
public:
	CompositorNodeGlare(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum glare_type_enum {
		glare_type_GHOSTS = 3,
		glare_type_STREAKS = 2,
		glare_type_FOG_GLOW = 1,
		glare_type_SIMPLE_STAR = 0,
	};
	inline glare_type_enum glare_type(void);
	inline void glare_type(glare_type_enum value);
	enum quality_enum {
		quality_HIGH = 0,
		quality_MEDIUM = 1,
		quality_LOW = 2,
	};
	inline quality_enum quality(void);
	inline void quality(quality_enum value);
	inline int iterations(void);
	inline void iterations(int value);
	inline float color_modulation(void);
	inline void color_modulation(float value);
	inline float mix(void);
	inline void mix(float value);
	inline float threshold(void);
	inline void threshold(float value);
	inline int streaks(void);
	inline void streaks(int value);
	inline float angle_offset(void);
	inline void angle_offset(float value);
	inline float fade(void);
	inline void fade(float value);
	inline bool use_rotate_45(void);
	inline void use_rotate_45(bool value);
	inline int size(void);
	inline void size(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeTonemap ****************/

class CompositorNodeTonemap : public CompositorNode {
public:
	CompositorNodeTonemap(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum tonemap_type_enum {
		tonemap_type_RD_PHOTORECEPTOR = 1,
		tonemap_type_RH_SIMPLE = 0,
	};
	inline tonemap_type_enum tonemap_type(void);
	inline void tonemap_type(tonemap_type_enum value);
	inline float key(void);
	inline void key(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float gamma(void);
	inline void gamma(float value);
	inline float intensity(void);
	inline void intensity(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float adaptation(void);
	inline void adaptation(float value);
	inline float correction(void);
	inline void correction(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeLensdist ****************/

class CompositorNodeLensdist : public CompositorNode {
public:
	CompositorNodeLensdist(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_projector(void);
	inline void use_projector(bool value);
	inline bool use_jitter(void);
	inline void use_jitter(bool value);
	inline bool use_fit(void);
	inline void use_fit(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeLevels ****************/

class CompositorNodeLevels : public CompositorNode {
public:
	CompositorNodeLevels(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum channel_enum {
		channel_COMBINED_RGB = 1,
		channel_RED = 2,
		channel_GREEN = 3,
		channel_BLUE = 4,
		channel_LUMINANCE = 5,
	};
	inline channel_enum channel(void);
	inline void channel(channel_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeColorMatte ****************/

class CompositorNodeColorMatte : public CompositorNode {
public:
	CompositorNodeColorMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float color_hue(void);
	inline void color_hue(float value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float color_value(void);
	inline void color_value(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDistanceMatte ****************/

class CompositorNodeDistanceMatte : public CompositorNode {
public:
	CompositorNodeDistanceMatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum channel_enum {
		channel_RGB = 1,
		channel_YCC = 2,
	};
	inline channel_enum channel(void);
	inline void channel(channel_enum value);
	inline float tolerance(void);
	inline void tolerance(float value);
	inline float falloff(void);
	inline void falloff(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeColorBalance ****************/

class CompositorNodeColorBalance : public CompositorNode {
public:
	CompositorNodeColorBalance(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum correction_method_enum {
		correction_method_LIFT_GAMMA_GAIN = 0,
		correction_method_OFFSET_POWER_SLOPE = 1,
	};
	inline correction_method_enum correction_method(void);
	inline void correction_method(correction_method_enum value);
	inline Array<float, 3> lift(void);
	inline void lift(float values[3]);
	inline Array<float, 3> gamma(void);
	inline void gamma(float values[3]);
	inline Array<float, 3> gain(void);
	inline void gain(float values[3]);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	inline Array<float, 3> power(void);
	inline void power(float values[3]);
	inline Array<float, 3> slope(void);
	inline void slope(float values[3]);
	inline float offset_basis(void);
	inline void offset_basis(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeHueCorrect ****************/

class CompositorNodeHueCorrect : public CompositorNode {
public:
	CompositorNodeHueCorrect(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMovieClip ****************/

class CompositorNodeMovieClip : public CompositorNode {
public:
	CompositorNodeMovieClip(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeTransform ****************/

class CompositorNodeTransform : public CompositorNode {
public:
	CompositorNodeTransform(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeStabilize ****************/

class CompositorNodeStabilize : public CompositorNode {
public:
	CompositorNodeStabilize(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline bool invert(void);
	inline void invert(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMovieDistortion ****************/

class CompositorNodeMovieDistortion : public CompositorNode {
public:
	CompositorNodeMovieDistortion(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	enum distortion_type_enum {
		distortion_type_UNDISTORT = 0,
		distortion_type_DISTORT = 1,
	};
	inline distortion_type_enum distortion_type(void);
	inline void distortion_type(distortion_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeBoxMask ****************/

class CompositorNodeBoxMask : public CompositorNode {
public:
	CompositorNodeBoxMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mask_type_enum {
		mask_type_ADD = 0,
		mask_type_SUBTRACT = 1,
		mask_type_MULTIPLY = 2,
		mask_type_NOT = 3,
	};
	inline mask_type_enum mask_type(void);
	inline void mask_type(mask_type_enum value);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);
	inline float width(void);
	inline void width(float value);
	inline float height(void);
	inline void height(float value);
	inline float rotation(void);
	inline void rotation(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeEllipseMask ****************/

class CompositorNodeEllipseMask : public CompositorNode {
public:
	CompositorNodeEllipseMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mask_type_enum {
		mask_type_ADD = 0,
		mask_type_SUBTRACT = 1,
		mask_type_MULTIPLY = 2,
		mask_type_NOT = 3,
	};
	inline mask_type_enum mask_type(void);
	inline void mask_type(mask_type_enum value);
	inline float x(void);
	inline void x(float value);
	inline float y(void);
	inline void y(float value);
	inline float width(void);
	inline void width(float value);
	inline float height(void);
	inline void height(float value);
	inline float rotation(void);
	inline void rotation(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeBokehImage ****************/

class CompositorNodeBokehImage : public CompositorNode {
public:
	CompositorNodeBokehImage(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float angle(void);
	inline void angle(float value);
	inline int flaps(void);
	inline void flaps(int value);
	inline float rounding(void);
	inline void rounding(float value);
	inline float catadioptric(void);
	inline void catadioptric(float value);
	inline float shift(void);
	inline void shift(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeBokehBlur ****************/

class CompositorNodeBokehBlur : public CompositorNode {
public:
	CompositorNodeBokehBlur(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_variable_size(void);
	inline void use_variable_size(bool value);
	inline bool use_extended_bounds(void);
	inline void use_extended_bounds(bool value);
	inline float blur_max(void);
	inline void blur_max(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSwitch ****************/

class CompositorNodeSwitch : public CompositorNode {
public:
	CompositorNodeSwitch(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool check(void);
	inline void check(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSwitchView ****************/

class CompositorNodeSwitchView : public CompositorNode {
public:
	CompositorNodeSwitchView(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeColorCorrection ****************/

class CompositorNodeColorCorrection : public CompositorNode {
public:
	CompositorNodeColorCorrection(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool red(void);
	inline void red(bool value);
	inline bool green(void);
	inline void green(bool value);
	inline bool blue(void);
	inline void blue(bool value);
	inline float midtones_start(void);
	inline void midtones_start(float value);
	inline float midtones_end(void);
	inline void midtones_end(float value);
	inline float master_saturation(void);
	inline void master_saturation(float value);
	inline float master_contrast(void);
	inline void master_contrast(float value);
	inline float master_gamma(void);
	inline void master_gamma(float value);
	inline float master_gain(void);
	inline void master_gain(float value);
	inline float master_lift(void);
	inline void master_lift(float value);
	inline float shadows_saturation(void);
	inline void shadows_saturation(float value);
	inline float shadows_contrast(void);
	inline void shadows_contrast(float value);
	inline float shadows_gamma(void);
	inline void shadows_gamma(float value);
	inline float shadows_gain(void);
	inline void shadows_gain(float value);
	inline float shadows_lift(void);
	inline void shadows_lift(float value);
	inline float midtones_saturation(void);
	inline void midtones_saturation(float value);
	inline float midtones_contrast(void);
	inline void midtones_contrast(float value);
	inline float midtones_gamma(void);
	inline void midtones_gamma(float value);
	inline float midtones_gain(void);
	inline void midtones_gain(float value);
	inline float midtones_lift(void);
	inline void midtones_lift(float value);
	inline float highlights_saturation(void);
	inline void highlights_saturation(float value);
	inline float highlights_contrast(void);
	inline void highlights_contrast(float value);
	inline float highlights_gamma(void);
	inline void highlights_gamma(float value);
	inline float highlights_gain(void);
	inline void highlights_gain(float value);
	inline float highlights_lift(void);
	inline void highlights_lift(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeMask ****************/

class CompositorNodeMask : public CompositorNode {
public:
	CompositorNodeMask(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Mask mask(void);
	inline bool use_feather(void);
	inline void use_feather(bool value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline int motion_blur_samples(void);
	inline void motion_blur_samples(int value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);
	enum size_source_enum {
		size_source_SCENE = 0,
		size_source_FIXED = 256,
		size_source_FIXED_SCENE = 512,
	};
	inline size_source_enum size_source(void);
	inline void size_source(size_source_enum value);
	inline int size_x(void);
	inline void size_x(int value);
	inline int size_y(void);
	inline void size_y(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeKeyingScreen ****************/

class CompositorNodeKeyingScreen : public CompositorNode {
public:
	CompositorNodeKeyingScreen(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline std::string tracking_object(void);
	inline void tracking_object(const std::string& value);
	inline float smoothness(void);
	inline void smoothness(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeKeying ****************/

class CompositorNodeKeying : public CompositorNode {
public:
	CompositorNodeKeying(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float screen_balance(void);
	inline void screen_balance(float value);
	inline float despill_factor(void);
	inline void despill_factor(float value);
	inline float despill_balance(void);
	inline void despill_balance(float value);
	inline float clip_black(void);
	inline void clip_black(float value);
	inline float clip_white(void);
	inline void clip_white(float value);
	inline int blur_pre(void);
	inline void blur_pre(int value);
	inline int blur_post(void);
	inline void blur_post(int value);
	inline int dilate_distance(void);
	inline void dilate_distance(int value);
	inline int edge_kernel_radius(void);
	inline void edge_kernel_radius(int value);
	inline float edge_kernel_tolerance(void);
	inline void edge_kernel_tolerance(float value);
	enum feather_falloff_enum {
		feather_falloff_SMOOTH = 0,
		feather_falloff_SPHERE = 1,
		feather_falloff_ROOT = 2,
		feather_falloff_INVERSE_SQUARE = 7,
		feather_falloff_SHARP = 3,
		feather_falloff_LINEAR = 4,
	};
	inline feather_falloff_enum feather_falloff(void);
	inline void feather_falloff(feather_falloff_enum value);
	inline int feather_distance(void);
	inline void feather_distance(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeTrackPos ****************/

class CompositorNodeTrackPos : public CompositorNode {
public:
	CompositorNodeTrackPos(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	enum position_enum {
		position_ABSOLUTE = 0,
		position_RELATIVE_START = 1,
		position_RELATIVE_FRAME = 2,
		position_ABSOLUTE_FRAME = 3,
	};
	inline position_enum position(void);
	inline void position(position_enum value);
	inline int frame_relative(void);
	inline void frame_relative(int value);
	inline std::string tracking_object(void);
	inline void tracking_object(const std::string& value);
	inline std::string track_name(void);
	inline void track_name(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodePixelate ****************/

class CompositorNodePixelate : public CompositorNode {
public:
	CompositorNodePixelate(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodePlaneTrackDeform ****************/

class CompositorNodePlaneTrackDeform : public CompositorNode {
public:
	CompositorNodePlaneTrackDeform(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline MovieClip clip(void);
	inline std::string tracking_object(void);
	inline void tracking_object(const std::string& value);
	inline std::string plane_track_name(void);
	inline void plane_track_name(const std::string& value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline int motion_blur_samples(void);
	inline void motion_blur_samples(int value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCornerPin ****************/

class CompositorNodeCornerPin : public CompositorNode {
public:
	CompositorNodeCornerPin(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSunBeams ****************/

class CompositorNodeSunBeams : public CompositorNode {
public:
	CompositorNodeSunBeams(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline Array<float, 2> source(void);
	inline void source(float values[2]);
	inline float ray_length(void);
	inline void ray_length(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCryptomatteV2 ****************/

class CompositorNodeCryptomatteV2 : public CompositorNode {
public:
	CompositorNodeCryptomatteV2(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg),
		entries(ptr_arg)
		{}

	enum source_enum {
		source_RENDER = 0,
		source_IMAGE = 1,
	};
	inline source_enum source(void);
	inline void source(source_enum value);
	inline Scene scene(void);
	inline Image image(void);
	inline std::string matte_id(void);
	inline void matte_id(const std::string& value);
	inline Array<float, 3> add(void);
	inline void add(float values[3]);
	inline Array<float, 3> remove(void);
	inline void remove(float values[3]);
	enum layer_name_enum {
		layer_name_CryptoObject = 0,
		layer_name_CryptoMaterial = 1,
		layer_name_CryptoAsset = 2,
	};
	inline layer_name_enum layer_name(void);
	inline void layer_name(layer_name_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CryptomatteEntry, CompositorNodeCryptomatteV2, entries, false, true, true)
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool use_auto_refresh(void);
	inline void use_auto_refresh(bool value);
	enum layer_enum {
		layer_PLACEHOLDER = 0,
	};
	inline layer_enum layer(void);
	inline void layer(layer_enum value);
	inline bool has_layers(void);
	inline void has_layers(bool value);
	enum view_enum {
		view_ALL = 0,
	};
	inline view_enum view(void);
	inline void view(view_enum value);
	inline bool has_views(void);
	inline void has_views(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCryptomatte ****************/

class CompositorNodeCryptomatte : public CompositorNode {
public:
	CompositorNodeCryptomatte(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline std::string matte_id(void);
	inline void matte_id(const std::string& value);
	inline Array<float, 3> add(void);
	inline void add(float values[3]);
	inline Array<float, 3> remove(void);
	inline void remove(float values[3]);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeDenoise ****************/

class CompositorNodeDenoise : public CompositorNode {
public:
	CompositorNodeDenoise(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline bool use_hdr(void);
	inline void use_hdr(bool value);
	enum prefilter_enum {
		prefilter_NONE = 1,
		prefilter_FAST = 0,
		prefilter_ACCURATE = 2,
	};
	inline prefilter_enum prefilter(void);
	inline void prefilter(prefilter_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeExposure ****************/

class CompositorNodeExposure : public CompositorNode {
public:
	CompositorNodeExposure(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeAntiAliasing ****************/

class CompositorNodeAntiAliasing : public CompositorNode {
public:
	CompositorNodeAntiAliasing(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline float threshold(void);
	inline void threshold(float value);
	inline float contrast_limit(void);
	inline void contrast_limit(float value);
	inline float corner_rounding(void);
	inline void corner_rounding(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodePosterize ****************/

class CompositorNodePosterize : public CompositorNode {
public:
	CompositorNodePosterize(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeConvertColorSpace ****************/

class CompositorNodeConvertColorSpace : public CompositorNode {
public:
	CompositorNodeConvertColorSpace(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum from_color_space_enum {
		from_color_space_NONE = 0,
	};
	inline from_color_space_enum from_color_space(void);
	inline void from_color_space(from_color_space_enum value);
	enum to_color_space_enum {
		to_color_space_NONE = 0,
	};
	inline to_color_space_enum to_color_space(void);
	inline void to_color_space(to_color_space_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSceneTime ****************/

class CompositorNodeSceneTime : public CompositorNode {
public:
	CompositorNodeSceneTime(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCombineXYZ ****************/

class CompositorNodeCombineXYZ : public CompositorNode {
public:
	CompositorNodeCombineXYZ(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSeparateXYZ ****************/

class CompositorNodeSeparateXYZ : public CompositorNode {
public:
	CompositorNodeSeparateXYZ(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeSeparateColor ****************/

class CompositorNodeSeparateColor : public CompositorNode {
public:
	CompositorNodeSeparateColor(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_RGB = 0,
		mode_HSV = 1,
		mode_HSL = 2,
		mode_YCC = 3,
		mode_YUV = 4,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum ycc_mode_enum {
		ycc_mode_ITUBT601 = 0,
		ycc_mode_ITUBT709 = 1,
		ycc_mode_JFIF = 2,
	};
	inline ycc_mode_enum ycc_mode(void);
	inline void ycc_mode(ycc_mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeCombineColor ****************/

class CompositorNodeCombineColor : public CompositorNode {
public:
	CompositorNodeCombineColor(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum mode_enum {
		mode_RGB = 0,
		mode_HSV = 1,
		mode_HSL = 2,
		mode_YCC = 3,
		mode_YUV = 4,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum ycc_mode_enum {
		ycc_mode_ITUBT601 = 0,
		ycc_mode_ITUBT709 = 1,
		ycc_mode_JFIF = 2,
	};
	inline ycc_mode_enum ycc_mode(void);
	inline void ycc_mode(ycc_mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeKuwahara ****************/

class CompositorNodeKuwahara : public CompositorNode {
public:
	CompositorNodeKuwahara(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	enum variation_enum {
		variation_CLASSIC = 0,
		variation_ANISOTROPIC = 1,
	};
	inline variation_enum variation(void);
	inline void variation(variation_enum value);
	inline int uniformity(void);
	inline void uniformity(int value);
	inline float sharpness(void);
	inline void sharpness(float value);
	inline float eccentricity(void);
	inline void eccentricity(float value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeOutput ****************/

class TextureNodeOutput : public TextureNode {
public:
	TextureNodeOutput(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeChecker ****************/

class TextureNodeChecker : public TextureNode {
public:
	TextureNodeChecker(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexture ****************/

class TextureNodeTexture : public TextureNode {
public:
	TextureNodeTexture(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline Texture texture(void);
	inline int node_output(void);
	inline void node_output(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeBricks ****************/

class TextureNodeBricks : public TextureNode {
public:
	TextureNodeBricks(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline float offset(void);
	inline void offset(float value);
	inline int offset_frequency(void);
	inline void offset_frequency(int value);
	inline float squash(void);
	inline void squash(float value);
	inline int squash_frequency(void);
	inline void squash_frequency(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeMath ****************/

class TextureNodeMath : public TextureNode {
public:
	TextureNodeMath(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_MULTIPLY_ADD = 36,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_SQRT = 23,
		operation_INVERSE_SQRT = 24,
		operation_ABSOLUTE = 18,
		operation_EXPONENT = 26,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_SIGN = 25,
		operation_COMPARE = 35,
		operation_SMOOTH_MIN = 38,
		operation_SMOOTH_MAX = 39,
		operation_ROUND = 14,
		operation_FLOOR = 20,
		operation_CEIL = 21,
		operation_TRUNC = 32,
		operation_FRACT = 22,
		operation_MODULO = 17,
		operation_FLOORED_MODULO = 40,
		operation_WRAP = 34,
		operation_SNAP = 33,
		operation_PINGPONG = 37,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_ARCTAN2 = 19,
		operation_SINH = 29,
		operation_COSH = 30,
		operation_TANH = 31,
		operation_RADIANS = 27,
		operation_DEGREES = 28,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeMixRGB ****************/

class TextureNodeMixRGB : public TextureNode {
public:
	TextureNodeMixRGB(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_DARKEN = 7,
		blend_type_MULTIPLY = 2,
		blend_type_BURN = 11,
		blend_type_LIGHTEN = 8,
		blend_type_SCREEN = 4,
		blend_type_DODGE = 10,
		blend_type_ADD = 1,
		blend_type_OVERLAY = 9,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
		blend_type_DIFFERENCE = 6,
		blend_type_EXCLUSION = 18,
		blend_type_SUBTRACT = 3,
		blend_type_DIVIDE = 5,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_COLOR = 15,
		blend_type_VALUE = 14,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline bool use_alpha(void);
	inline void use_alpha(bool value);
	inline bool use_clamp(void);
	inline void use_clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeRGBToBW ****************/

class TextureNodeRGBToBW : public TextureNode {
public:
	TextureNodeRGBToBW(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeValToRGB ****************/

class TextureNodeValToRGB : public TextureNode {
public:
	TextureNodeValToRGB(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline ColorRamp color_ramp(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeImage ****************/

class TextureNodeImage : public TextureNode {
public:
	TextureNodeImage(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline Image image(void);
	inline ImageUser image_user(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeCurveRGB ****************/

class TextureNodeCurveRGB : public TextureNode {
public:
	TextureNodeCurveRGB(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline CurveMapping mapping(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeInvert ****************/

class TextureNodeInvert : public TextureNode {
public:
	TextureNodeInvert(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeHueSaturation ****************/

class TextureNodeHueSaturation : public TextureNode {
public:
	TextureNodeHueSaturation(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeCurveTime ****************/

class TextureNodeCurveTime : public TextureNode {
public:
	TextureNodeCurveTime(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline CurveMapping curve(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeRotate ****************/

class TextureNodeRotate : public TextureNode {
public:
	TextureNodeRotate(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeViewer ****************/

class TextureNodeViewer : public TextureNode {
public:
	TextureNodeViewer(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTranslate ****************/

class TextureNodeTranslate : public TextureNode {
public:
	TextureNodeTranslate(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeCoordinates ****************/

class TextureNodeCoordinates : public TextureNode {
public:
	TextureNodeCoordinates(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeDistance ****************/

class TextureNodeDistance : public TextureNode {
public:
	TextureNodeDistance(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeCompose ****************/

class TextureNodeCompose : public TextureNode {
public:
	TextureNodeCompose(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeDecompose ****************/

class TextureNodeDecompose : public TextureNode {
public:
	TextureNodeDecompose(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeValToNor ****************/

class TextureNodeValToNor : public TextureNode {
public:
	TextureNodeValToNor(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeScale ****************/

class TextureNodeScale : public TextureNode {
public:
	TextureNodeScale(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeAt ****************/

class TextureNodeAt : public TextureNode {
public:
	TextureNodeAt(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeCombineColor ****************/

class TextureNodeCombineColor : public TextureNode {
public:
	TextureNodeCombineColor(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	enum mode_enum {
		mode_RGB = 0,
		mode_HSV = 1,
		mode_HSL = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeSeparateColor ****************/

class TextureNodeSeparateColor : public TextureNode {
public:
	TextureNodeSeparateColor(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	enum mode_enum {
		mode_RGB = 0,
		mode_HSV = 1,
		mode_HSL = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexVoronoi ****************/

class TextureNodeTexVoronoi : public TextureNode {
public:
	TextureNodeTexVoronoi(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexBlend ****************/

class TextureNodeTexBlend : public TextureNode {
public:
	TextureNodeTexBlend(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexMagic ****************/

class TextureNodeTexMagic : public TextureNode {
public:
	TextureNodeTexMagic(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexMarble ****************/

class TextureNodeTexMarble : public TextureNode {
public:
	TextureNodeTexMarble(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexClouds ****************/

class TextureNodeTexClouds : public TextureNode {
public:
	TextureNodeTexClouds(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexWood ****************/

class TextureNodeTexWood : public TextureNode {
public:
	TextureNodeTexWood(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexMusgrave ****************/

class TextureNodeTexMusgrave : public TextureNode {
public:
	TextureNodeTexMusgrave(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexNoise ****************/

class TextureNodeTexNoise : public TextureNode {
public:
	TextureNodeTexNoise(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexStucci ****************/

class TextureNodeTexStucci : public TextureNode {
public:
	TextureNodeTexStucci(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeTexDistNoise ****************/

class TextureNodeTexDistNoise : public TextureNode {
public:
	TextureNodeTexDistNoise(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeAlignEulerToVector ****************/

class FunctionNodeAlignEulerToVector : public FunctionNode {
public:
	FunctionNodeAlignEulerToVector(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeAxisAngleToRotation ****************/

class FunctionNodeAxisAngleToRotation : public FunctionNode {
public:
	FunctionNodeAxisAngleToRotation(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeBooleanMath ****************/

class FunctionNodeBooleanMath : public FunctionNode {
public:
	FunctionNodeBooleanMath(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeCombineColor ****************/

class FunctionNodeCombineColor : public FunctionNode {
public:
	FunctionNodeCombineColor(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeQuaternionToRotation ****************/

class FunctionNodeQuaternionToRotation : public FunctionNode {
public:
	FunctionNodeQuaternionToRotation(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeCompare ****************/

class FunctionNodeCompare : public FunctionNode {
public:
	FunctionNodeCompare(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeEulerToRotation ****************/

class FunctionNodeEulerToRotation : public FunctionNode {
public:
	FunctionNodeEulerToRotation(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeFloatToInt ****************/

class FunctionNodeFloatToInt : public FunctionNode {
public:
	FunctionNodeFloatToInt(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	enum rounding_mode_enum {
		rounding_mode_ROUND = 0,
		rounding_mode_FLOOR = 1,
		rounding_mode_CEILING = 2,
		rounding_mode_TRUNCATE = 3,
	};
	inline rounding_mode_enum rounding_mode(void);
	inline void rounding_mode(rounding_mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeInputBool ****************/

class FunctionNodeInputBool : public FunctionNode {
public:
	FunctionNodeInputBool(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	inline bool boolean(void);
	inline void boolean(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeInputColor ****************/

class FunctionNodeInputColor : public FunctionNode {
public:
	FunctionNodeInputColor(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	inline Array<float, 4> color(void);
	inline void color(float values[4]);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeInputInt ****************/

class FunctionNodeInputInt : public FunctionNode {
public:
	FunctionNodeInputInt(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	inline int integer(void);
	inline void integer(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeInputSpecialCharacters ****************/

class FunctionNodeInputSpecialCharacters : public FunctionNode {
public:
	FunctionNodeInputSpecialCharacters(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeInputString ****************/

class FunctionNodeInputString : public FunctionNode {
public:
	FunctionNodeInputString(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	inline std::string string(void);
	inline void string(const std::string& value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeInputVector ****************/

class FunctionNodeInputVector : public FunctionNode {
public:
	FunctionNodeInputVector(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	inline Array<float, 3> vector(void);
	inline void vector(float values[3]);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeInvertRotation ****************/

class FunctionNodeInvertRotation : public FunctionNode {
public:
	FunctionNodeInvertRotation(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeRandomValue ****************/

class FunctionNodeRandomValue : public FunctionNode {
public:
	FunctionNodeRandomValue(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	enum data_type_enum {
		data_type_FLOAT = 10,
		data_type_INT = 11,
		data_type_FLOAT_VECTOR = 48,
		data_type_FLOAT_COLOR = 47,
		data_type_BYTE_COLOR = 17,
		data_type_STRING = 12,
		data_type_BOOLEAN = 50,
		data_type_FLOAT2 = 49,
		data_type_INT8 = 45,
		data_type_INT32_2D = 46,
		data_type_QUATERNION = 52,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeReplaceString ****************/

class FunctionNodeReplaceString : public FunctionNode {
public:
	FunctionNodeReplaceString(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeRotateEuler ****************/

class FunctionNodeRotateEuler : public FunctionNode {
public:
	FunctionNodeRotateEuler(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}

	enum type_enum {
		type_AXIS_ANGLE = 1,
		type_EULER = 0,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum space_enum {
		space_OBJECT = 0,
		space_LOCAL = 1,
	};
	inline space_enum space(void);
	inline void space(space_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeRotateVector ****************/

class FunctionNodeRotateVector : public FunctionNode {
public:
	FunctionNodeRotateVector(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeRotationToAxisAngle ****************/

class FunctionNodeRotationToAxisAngle : public FunctionNode {
public:
	FunctionNodeRotationToAxisAngle(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeRotationToEuler ****************/

class FunctionNodeRotationToEuler : public FunctionNode {
public:
	FunctionNodeRotationToEuler(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeSeparateColor ****************/

class FunctionNodeSeparateColor : public FunctionNode {
public:
	FunctionNodeSeparateColor(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeRotationToQuaternion ****************/

class FunctionNodeRotationToQuaternion : public FunctionNode {
public:
	FunctionNodeRotationToQuaternion(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeSliceString ****************/

class FunctionNodeSliceString : public FunctionNode {
public:
	FunctionNodeSliceString(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeStringLength ****************/

class FunctionNodeStringLength : public FunctionNode {
public:
	FunctionNodeStringLength(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** FunctionNodeValueToString ****************/

class FunctionNodeValueToString : public FunctionNode {
public:
	FunctionNodeValueToString(const PointerRNA &ptr_arg) :
		FunctionNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeAccumulateField ****************/

class GeometryNodeAccumulateField : public GeometryNode {
public:
	GeometryNodeAccumulateField(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeAttributeDomainSize ****************/

class GeometryNodeAttributeDomainSize : public GeometryNode {
public:
	GeometryNodeAttributeDomainSize(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeAttributeStatistic ****************/

class GeometryNodeAttributeStatistic : public GeometryNode {
public:
	GeometryNodeAttributeStatistic(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeBlurAttribute ****************/

class GeometryNodeBlurAttribute : public GeometryNode {
public:
	GeometryNodeBlurAttribute(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeBoundBox ****************/

class GeometryNodeBoundBox : public GeometryNode {
public:
	GeometryNodeBoundBox(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCaptureAttribute ****************/

class GeometryNodeCaptureAttribute : public GeometryNode {
public:
	GeometryNodeCaptureAttribute(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCollectionInfo ****************/

class GeometryNodeCollectionInfo : public GeometryNode {
public:
	GeometryNodeCollectionInfo(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeConvexHull ****************/

class GeometryNodeConvexHull : public GeometryNode {
public:
	GeometryNodeConvexHull(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveEndpointSelection ****************/

class GeometryNodeCurveEndpointSelection : public GeometryNode {
public:
	GeometryNodeCurveEndpointSelection(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveHandleTypeSelection ****************/

class GeometryNodeCurveHandleTypeSelection : public GeometryNode {
public:
	GeometryNodeCurveHandleTypeSelection(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	enum handle_type_enum {
		handle_type_FREE = 0,
		handle_type_AUTO = 1,
		handle_type_VECTOR = 2,
		handle_type_ALIGN = 3,
	};
	inline handle_type_enum handle_type(void);
	inline void handle_type(handle_type_enum value);
	enum mode_enum {
		mode_LEFT = 1,
		mode_RIGHT = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveLength ****************/

class GeometryNodeCurveLength : public GeometryNode {
public:
	GeometryNodeCurveLength(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveArc ****************/

class GeometryNodeCurveArc : public GeometryNode {
public:
	GeometryNodeCurveArc(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurvePrimitiveBezierSegment ****************/

class GeometryNodeCurvePrimitiveBezierSegment : public GeometryNode {
public:
	GeometryNodeCurvePrimitiveBezierSegment(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurvePrimitiveCircle ****************/

class GeometryNodeCurvePrimitiveCircle : public GeometryNode {
public:
	GeometryNodeCurvePrimitiveCircle(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurvePrimitiveLine ****************/

class GeometryNodeCurvePrimitiveLine : public GeometryNode {
public:
	GeometryNodeCurvePrimitiveLine(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveQuadraticBezier ****************/

class GeometryNodeCurveQuadraticBezier : public GeometryNode {
public:
	GeometryNodeCurveQuadraticBezier(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurvePrimitiveQuadrilateral ****************/

class GeometryNodeCurvePrimitiveQuadrilateral : public GeometryNode {
public:
	GeometryNodeCurvePrimitiveQuadrilateral(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveSpiral ****************/

class GeometryNodeCurveSpiral : public GeometryNode {
public:
	GeometryNodeCurveSpiral(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveStar ****************/

class GeometryNodeCurveStar : public GeometryNode {
public:
	GeometryNodeCurveStar(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveSetHandles ****************/

class GeometryNodeCurveSetHandles : public GeometryNode {
public:
	GeometryNodeCurveSetHandles(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	enum handle_type_enum {
		handle_type_FREE = 0,
		handle_type_AUTO = 1,
		handle_type_VECTOR = 2,
		handle_type_ALIGN = 3,
	};
	inline handle_type_enum handle_type(void);
	inline void handle_type(handle_type_enum value);
	enum mode_enum {
		mode_LEFT = 1,
		mode_RIGHT = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSplineParameter ****************/

class GeometryNodeSplineParameter : public GeometryNode {
public:
	GeometryNodeSplineParameter(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveSplineType ****************/

class GeometryNodeCurveSplineType : public GeometryNode {
public:
	GeometryNodeCurveSplineType(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveToMesh ****************/

class GeometryNodeCurveToMesh : public GeometryNode {
public:
	GeometryNodeCurveToMesh(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveToPoints ****************/

class GeometryNodeCurveToPoints : public GeometryNode {
public:
	GeometryNodeCurveToPoints(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCurveOfPoint ****************/

class GeometryNodeCurveOfPoint : public GeometryNode {
public:
	GeometryNodeCurveOfPoint(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodePointsOfCurve ****************/

class GeometryNodePointsOfCurve : public GeometryNode {
public:
	GeometryNodePointsOfCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeDeformCurvesOnSurface ****************/

class GeometryNodeDeformCurvesOnSurface : public GeometryNode {
public:
	GeometryNodeDeformCurvesOnSurface(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeDeleteGeometry ****************/

class GeometryNodeDeleteGeometry : public GeometryNode {
public:
	GeometryNodeDeleteGeometry(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeDistributePointsInVolume ****************/

class GeometryNodeDistributePointsInVolume : public GeometryNode {
public:
	GeometryNodeDistributePointsInVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeDistributePointsOnFaces ****************/

class GeometryNodeDistributePointsOnFaces : public GeometryNode {
public:
	GeometryNodeDistributePointsOnFaces(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	enum distribute_method_enum {
		distribute_method_RANDOM = 0,
		distribute_method_POISSON = 1,
	};
	inline distribute_method_enum distribute_method(void);
	inline void distribute_method(distribute_method_enum value);
	inline bool use_legacy_normal(void);
	inline void use_legacy_normal(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeDualMesh ****************/

class GeometryNodeDualMesh : public GeometryNode {
public:
	GeometryNodeDualMesh(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeDuplicateElements ****************/

class GeometryNodeDuplicateElements : public GeometryNode {
public:
	GeometryNodeDuplicateElements(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeEdgePathsToCurves ****************/

class GeometryNodeEdgePathsToCurves : public GeometryNode {
public:
	GeometryNodeEdgePathsToCurves(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeEdgePathsToSelection ****************/

class GeometryNodeEdgePathsToSelection : public GeometryNode {
public:
	GeometryNodeEdgePathsToSelection(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeEdgesToFaceGroups ****************/

class GeometryNodeEdgesToFaceGroups : public GeometryNode {
public:
	GeometryNodeEdgesToFaceGroups(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeFieldAtIndex ****************/

class GeometryNodeFieldAtIndex : public GeometryNode {
public:
	GeometryNodeFieldAtIndex(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeFieldOnDomain ****************/

class GeometryNodeFieldOnDomain : public GeometryNode {
public:
	GeometryNodeFieldOnDomain(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeExtrudeMesh ****************/

class GeometryNodeExtrudeMesh : public GeometryNode {
public:
	GeometryNodeExtrudeMesh(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeFillCurve ****************/

class GeometryNodeFillCurve : public GeometryNode {
public:
	GeometryNodeFillCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeFilletCurve ****************/

class GeometryNodeFilletCurve : public GeometryNode {
public:
	GeometryNodeFilletCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeFlipFaces ****************/

class GeometryNodeFlipFaces : public GeometryNode {
public:
	GeometryNodeFlipFaces(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeGeometryToInstance ****************/

class GeometryNodeGeometryToInstance : public GeometryNode {
public:
	GeometryNodeGeometryToInstance(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeImageInfo ****************/

class GeometryNodeImageInfo : public GeometryNode {
public:
	GeometryNodeImageInfo(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeImageTexture ****************/

class GeometryNodeImageTexture : public GeometryNode {
public:
	GeometryNodeImageTexture(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	enum interpolation_enum {
		interpolation_Linear = 0,
		interpolation_Closest = 1,
		interpolation_Cubic = 2,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	enum extension_enum {
		extension_REPEAT = 0,
		extension_EXTEND = 1,
		extension_CLIP = 2,
		extension_MIRROR = 3,
	};
	inline extension_enum extension(void);
	inline void extension(extension_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeIndexOfNearest ****************/

class GeometryNodeIndexOfNearest : public GeometryNode {
public:
	GeometryNodeIndexOfNearest(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputImage ****************/

class GeometryNodeInputImage : public GeometryNode {
public:
	GeometryNodeInputImage(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	inline Image image(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputCurveHandlePositions ****************/

class GeometryNodeInputCurveHandlePositions : public GeometryNode {
public:
	GeometryNodeInputCurveHandlePositions(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputCurveTilt ****************/

class GeometryNodeInputCurveTilt : public GeometryNode {
public:
	GeometryNodeInputCurveTilt(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputID ****************/

class GeometryNodeInputID : public GeometryNode {
public:
	GeometryNodeInputID(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputIndex ****************/

class GeometryNodeInputIndex : public GeometryNode {
public:
	GeometryNodeInputIndex(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputInstanceRotation ****************/

class GeometryNodeInputInstanceRotation : public GeometryNode {
public:
	GeometryNodeInputInstanceRotation(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputInstanceScale ****************/

class GeometryNodeInputInstanceScale : public GeometryNode {
public:
	GeometryNodeInputInstanceScale(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMaterialIndex ****************/

class GeometryNodeInputMaterialIndex : public GeometryNode {
public:
	GeometryNodeInputMaterialIndex(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMaterial ****************/

class GeometryNodeInputMaterial : public GeometryNode {
public:
	GeometryNodeInputMaterial(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	inline Material material(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshEdgeAngle ****************/

class GeometryNodeInputMeshEdgeAngle : public GeometryNode {
public:
	GeometryNodeInputMeshEdgeAngle(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshEdgeNeighbors ****************/

class GeometryNodeInputMeshEdgeNeighbors : public GeometryNode {
public:
	GeometryNodeInputMeshEdgeNeighbors(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshEdgeVertices ****************/

class GeometryNodeInputMeshEdgeVertices : public GeometryNode {
public:
	GeometryNodeInputMeshEdgeVertices(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshFaceArea ****************/

class GeometryNodeInputMeshFaceArea : public GeometryNode {
public:
	GeometryNodeInputMeshFaceArea(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshFaceIsPlanar ****************/

class GeometryNodeInputMeshFaceIsPlanar : public GeometryNode {
public:
	GeometryNodeInputMeshFaceIsPlanar(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshFaceNeighbors ****************/

class GeometryNodeInputMeshFaceNeighbors : public GeometryNode {
public:
	GeometryNodeInputMeshFaceNeighbors(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshIsland ****************/

class GeometryNodeInputMeshIsland : public GeometryNode {
public:
	GeometryNodeInputMeshIsland(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputMeshVertexNeighbors ****************/

class GeometryNodeInputMeshVertexNeighbors : public GeometryNode {
public:
	GeometryNodeInputMeshVertexNeighbors(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputNamedAttribute ****************/

class GeometryNodeInputNamedAttribute : public GeometryNode {
public:
	GeometryNodeInputNamedAttribute(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputNamedLayerSelection ****************/

class GeometryNodeInputNamedLayerSelection : public GeometryNode {
public:
	GeometryNodeInputNamedLayerSelection(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputNormal ****************/

class GeometryNodeInputNormal : public GeometryNode {
public:
	GeometryNodeInputNormal(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputPosition ****************/

class GeometryNodeInputPosition : public GeometryNode {
public:
	GeometryNodeInputPosition(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputRadius ****************/

class GeometryNodeInputRadius : public GeometryNode {
public:
	GeometryNodeInputRadius(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputSceneTime ****************/

class GeometryNodeInputSceneTime : public GeometryNode {
public:
	GeometryNodeInputSceneTime(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputShadeSmooth ****************/

class GeometryNodeInputShadeSmooth : public GeometryNode {
public:
	GeometryNodeInputShadeSmooth(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputShortestEdgePaths ****************/

class GeometryNodeInputShortestEdgePaths : public GeometryNode {
public:
	GeometryNodeInputShortestEdgePaths(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputSignedDistance ****************/

class GeometryNodeInputSignedDistance : public GeometryNode {
public:
	GeometryNodeInputSignedDistance(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputSplineCyclic ****************/

class GeometryNodeInputSplineCyclic : public GeometryNode {
public:
	GeometryNodeInputSplineCyclic(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSplineLength ****************/

class GeometryNodeSplineLength : public GeometryNode {
public:
	GeometryNodeSplineLength(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputSplineResolution ****************/

class GeometryNodeInputSplineResolution : public GeometryNode {
public:
	GeometryNodeInputSplineResolution(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputTangent ****************/

class GeometryNodeInputTangent : public GeometryNode {
public:
	GeometryNodeInputTangent(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInstanceOnPoints ****************/

class GeometryNodeInstanceOnPoints : public GeometryNode {
public:
	GeometryNodeInstanceOnPoints(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInstancesToPoints ****************/

class GeometryNodeInstancesToPoints : public GeometryNode {
public:
	GeometryNodeInstancesToPoints(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeIsViewport ****************/

class GeometryNodeIsViewport : public GeometryNode {
public:
	GeometryNodeIsViewport(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeJoinGeometry ****************/

class GeometryNodeJoinGeometry : public GeometryNode {
public:
	GeometryNodeJoinGeometry(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMaterialSelection ****************/

class GeometryNodeMaterialSelection : public GeometryNode {
public:
	GeometryNodeMaterialSelection(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeanFilterSDFVolume ****************/

class GeometryNodeMeanFilterSDFVolume : public GeometryNode {
public:
	GeometryNodeMeanFilterSDFVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMergeByDistance ****************/

class GeometryNodeMergeByDistance : public GeometryNode {
public:
	GeometryNodeMergeByDistance(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshBoolean ****************/

class GeometryNodeMeshBoolean : public GeometryNode {
public:
	GeometryNodeMeshBoolean(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshFaceSetBoundaries ****************/

class GeometryNodeMeshFaceSetBoundaries : public GeometryNode {
public:
	GeometryNodeMeshFaceSetBoundaries(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshCircle ****************/

class GeometryNodeMeshCircle : public GeometryNode {
public:
	GeometryNodeMeshCircle(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshCone ****************/

class GeometryNodeMeshCone : public GeometryNode {
public:
	GeometryNodeMeshCone(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshCube ****************/

class GeometryNodeMeshCube : public GeometryNode {
public:
	GeometryNodeMeshCube(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshCylinder ****************/

class GeometryNodeMeshCylinder : public GeometryNode {
public:
	GeometryNodeMeshCylinder(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshGrid ****************/

class GeometryNodeMeshGrid : public GeometryNode {
public:
	GeometryNodeMeshGrid(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshIcoSphere ****************/

class GeometryNodeMeshIcoSphere : public GeometryNode {
public:
	GeometryNodeMeshIcoSphere(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshLine ****************/

class GeometryNodeMeshLine : public GeometryNode {
public:
	GeometryNodeMeshLine(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshUVSphere ****************/

class GeometryNodeMeshUVSphere : public GeometryNode {
public:
	GeometryNodeMeshUVSphere(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshToCurve ****************/

class GeometryNodeMeshToCurve : public GeometryNode {
public:
	GeometryNodeMeshToCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshToPoints ****************/

class GeometryNodeMeshToPoints : public GeometryNode {
public:
	GeometryNodeMeshToPoints(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshToSDFVolume ****************/

class GeometryNodeMeshToSDFVolume : public GeometryNode {
public:
	GeometryNodeMeshToSDFVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeMeshToVolume ****************/

class GeometryNodeMeshToVolume : public GeometryNode {
public:
	GeometryNodeMeshToVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCornersOfEdge ****************/

class GeometryNodeCornersOfEdge : public GeometryNode {
public:
	GeometryNodeCornersOfEdge(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCornersOfFace ****************/

class GeometryNodeCornersOfFace : public GeometryNode {
public:
	GeometryNodeCornersOfFace(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeCornersOfVertex ****************/

class GeometryNodeCornersOfVertex : public GeometryNode {
public:
	GeometryNodeCornersOfVertex(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeEdgesOfCorner ****************/

class GeometryNodeEdgesOfCorner : public GeometryNode {
public:
	GeometryNodeEdgesOfCorner(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeEdgesOfVertex ****************/

class GeometryNodeEdgesOfVertex : public GeometryNode {
public:
	GeometryNodeEdgesOfVertex(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeFaceOfCorner ****************/

class GeometryNodeFaceOfCorner : public GeometryNode {
public:
	GeometryNodeFaceOfCorner(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeOffsetCornerInFace ****************/

class GeometryNodeOffsetCornerInFace : public GeometryNode {
public:
	GeometryNodeOffsetCornerInFace(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeVertexOfCorner ****************/

class GeometryNodeVertexOfCorner : public GeometryNode {
public:
	GeometryNodeVertexOfCorner(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeObjectInfo ****************/

class GeometryNodeObjectInfo : public GeometryNode {
public:
	GeometryNodeObjectInfo(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeOffsetPointInCurve ****************/

class GeometryNodeOffsetPointInCurve : public GeometryNode {
public:
	GeometryNodeOffsetPointInCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeOffsetSDFVolume ****************/

class GeometryNodeOffsetSDFVolume : public GeometryNode {
public:
	GeometryNodeOffsetSDFVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeToolFaceSet ****************/

class GeometryNodeToolFaceSet : public GeometryNode {
public:
	GeometryNodeToolFaceSet(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeTool3DCursor ****************/

class GeometryNodeTool3DCursor : public GeometryNode {
public:
	GeometryNodeTool3DCursor(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeToolSelection ****************/

class GeometryNodeToolSelection : public GeometryNode {
public:
	GeometryNodeToolSelection(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeToolSetSelection ****************/

class GeometryNodeToolSetSelection : public GeometryNode {
public:
	GeometryNodeToolSetSelection(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeToolSetFaceSet ****************/

class GeometryNodeToolSetFaceSet : public GeometryNode {
public:
	GeometryNodeToolSetFaceSet(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodePointsToSDFVolume ****************/

class GeometryNodePointsToSDFVolume : public GeometryNode {
public:
	GeometryNodePointsToSDFVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodePointsToVertices ****************/

class GeometryNodePointsToVertices : public GeometryNode {
public:
	GeometryNodePointsToVertices(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodePointsToVolume ****************/

class GeometryNodePointsToVolume : public GeometryNode {
public:
	GeometryNodePointsToVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodePoints ****************/

class GeometryNodePoints : public GeometryNode {
public:
	GeometryNodePoints(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeProximity ****************/

class GeometryNodeProximity : public GeometryNode {
public:
	GeometryNodeProximity(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeRaycast ****************/

class GeometryNodeRaycast : public GeometryNode {
public:
	GeometryNodeRaycast(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeRealizeInstances ****************/

class GeometryNodeRealizeInstances : public GeometryNode {
public:
	GeometryNodeRealizeInstances(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeRemoveAttribute ****************/

class GeometryNodeRemoveAttribute : public GeometryNode {
public:
	GeometryNodeRemoveAttribute(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeRepeatInput ****************/

class GeometryNodeRepeatInput : public GeometryNode {
public:
	GeometryNodeRepeatInput(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	inline Node paired_output(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
	inline bool pair_with_output(Context C, GeometryNode& output_node);
};

/**************** GeometryNodeRepeatOutput ****************/

class GeometryNodeRepeatOutput : public GeometryNode {
public:
	GeometryNodeRepeatOutput(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg),
		repeat_items(ptr_arg)
		{}

	COLLECTION_PROPERTY(NodeGeometryRepeatOutputItems, RepeatItem, GeometryNodeRepeatOutput, repeat_items, true, true, true)
	inline int active_index(void);
	inline void active_index(int value);
	inline RepeatItem active_item(void);
	inline int inspection_index(void);
	inline void inspection_index(int value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeReplaceMaterial ****************/

class GeometryNodeReplaceMaterial : public GeometryNode {
public:
	GeometryNodeReplaceMaterial(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeResampleCurve ****************/

class GeometryNodeResampleCurve : public GeometryNode {
public:
	GeometryNodeResampleCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeReverseCurve ****************/

class GeometryNodeReverseCurve : public GeometryNode {
public:
	GeometryNodeReverseCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeRotateInstances ****************/

class GeometryNodeRotateInstances : public GeometryNode {
public:
	GeometryNodeRotateInstances(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSampleCurve ****************/

class GeometryNodeSampleCurve : public GeometryNode {
public:
	GeometryNodeSampleCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	enum mode_enum {
		mode_FACTOR = 0,
		mode_LENGTH = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool use_all_curves(void);
	inline void use_all_curves(bool value);
	enum data_type_enum {
		data_type_FLOAT = 10,
		data_type_INT = 11,
		data_type_FLOAT_VECTOR = 48,
		data_type_FLOAT_COLOR = 47,
		data_type_BYTE_COLOR = 17,
		data_type_STRING = 12,
		data_type_BOOLEAN = 50,
		data_type_FLOAT2 = 49,
		data_type_INT8 = 45,
		data_type_INT32_2D = 46,
		data_type_QUATERNION = 52,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSampleIndex ****************/

class GeometryNodeSampleIndex : public GeometryNode {
public:
	GeometryNodeSampleIndex(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	enum data_type_enum {
		data_type_FLOAT = 10,
		data_type_INT = 11,
		data_type_FLOAT_VECTOR = 48,
		data_type_FLOAT_COLOR = 47,
		data_type_BYTE_COLOR = 17,
		data_type_STRING = 12,
		data_type_BOOLEAN = 50,
		data_type_FLOAT2 = 49,
		data_type_INT8 = 45,
		data_type_INT32_2D = 46,
		data_type_QUATERNION = 52,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);
	enum domain_enum {
		domain_POINT = 0,
		domain_EDGE = 1,
		domain_FACE = 2,
		domain_CORNER = 3,
		domain_CURVE = 4,
		domain_INSTANCE = 5,
		domain_LAYER = 6,
	};
	inline domain_enum domain(void);
	inline void domain(domain_enum value);
	inline bool clamp(void);
	inline void clamp(bool value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSampleNearestSurface ****************/

class GeometryNodeSampleNearestSurface : public GeometryNode {
public:
	GeometryNodeSampleNearestSurface(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSampleNearest ****************/

class GeometryNodeSampleNearest : public GeometryNode {
public:
	GeometryNodeSampleNearest(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSampleUVSurface ****************/

class GeometryNodeSampleUVSurface : public GeometryNode {
public:
	GeometryNodeSampleUVSurface(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSampleVolume ****************/

class GeometryNodeSampleVolume : public GeometryNode {
public:
	GeometryNodeSampleVolume(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeScaleElements ****************/

class GeometryNodeScaleElements : public GeometryNode {
public:
	GeometryNodeScaleElements(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeScaleInstances ****************/

class GeometryNodeScaleInstances : public GeometryNode {
public:
	GeometryNodeScaleInstances(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSDFVolumeSphere ****************/

class GeometryNodeSDFVolumeSphere : public GeometryNode {
public:
	GeometryNodeSDFVolumeSphere(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSelfObject ****************/

class GeometryNodeSelfObject : public GeometryNode {
public:
	GeometryNodeSelfObject(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSeparateComponents ****************/

class GeometryNodeSeparateComponents : public GeometryNode {
public:
	GeometryNodeSeparateComponents(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSeparateGeometry ****************/

class GeometryNodeSeparateGeometry : public GeometryNode {
public:
	GeometryNodeSeparateGeometry(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetCurveHandlePositions ****************/

class GeometryNodeSetCurveHandlePositions : public GeometryNode {
public:
	GeometryNodeSetCurveHandlePositions(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetCurveNormal ****************/

class GeometryNodeSetCurveNormal : public GeometryNode {
public:
	GeometryNodeSetCurveNormal(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetCurveRadius ****************/

class GeometryNodeSetCurveRadius : public GeometryNode {
public:
	GeometryNodeSetCurveRadius(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetCurveTilt ****************/

class GeometryNodeSetCurveTilt : public GeometryNode {
public:
	GeometryNodeSetCurveTilt(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetID ****************/

class GeometryNodeSetID : public GeometryNode {
public:
	GeometryNodeSetID(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetMaterialIndex ****************/

class GeometryNodeSetMaterialIndex : public GeometryNode {
public:
	GeometryNodeSetMaterialIndex(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetMaterial ****************/

class GeometryNodeSetMaterial : public GeometryNode {
public:
	GeometryNodeSetMaterial(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetPointRadius ****************/

class GeometryNodeSetPointRadius : public GeometryNode {
public:
	GeometryNodeSetPointRadius(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetPosition ****************/

class GeometryNodeSetPosition : public GeometryNode {
public:
	GeometryNodeSetPosition(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetShadeSmooth ****************/

class GeometryNodeSetShadeSmooth : public GeometryNode {
public:
	GeometryNodeSetShadeSmooth(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetSplineCyclic ****************/

class GeometryNodeSetSplineCyclic : public GeometryNode {
public:
	GeometryNodeSetSplineCyclic(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSetSplineResolution ****************/

class GeometryNodeSetSplineResolution : public GeometryNode {
public:
	GeometryNodeSetSplineResolution(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSimulationInput ****************/

class GeometryNodeSimulationInput : public GeometryNode {
public:
	GeometryNodeSimulationInput(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	inline Node paired_output(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
	inline bool pair_with_output(Context C, GeometryNode& output_node);
};

/**************** GeometryNodeSimulationOutput ****************/

class GeometryNodeSimulationOutput : public GeometryNode {
public:
	GeometryNodeSimulationOutput(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg),
		state_items(ptr_arg)
		{}

	COLLECTION_PROPERTY(NodeGeometrySimulationOutputItems, SimulationStateItem, GeometryNodeSimulationOutput, state_items, true, true, true)
	inline int active_index(void);
	inline void active_index(int value);
	inline SimulationStateItem active_item(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSplitToInstances ****************/

class GeometryNodeSplitToInstances : public GeometryNode {
public:
	GeometryNodeSplitToInstances(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSplitEdges ****************/

class GeometryNodeSplitEdges : public GeometryNode {
public:
	GeometryNodeSplitEdges(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeStoreNamedAttribute ****************/

class GeometryNodeStoreNamedAttribute : public GeometryNode {
public:
	GeometryNodeStoreNamedAttribute(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeStringJoin ****************/

class GeometryNodeStringJoin : public GeometryNode {
public:
	GeometryNodeStringJoin(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeStringToCurves ****************/

class GeometryNodeStringToCurves : public GeometryNode {
public:
	GeometryNodeStringToCurves(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	inline VectorFont font(void);
	enum overflow_enum {
		overflow_OVERFLOW = 0,
		overflow_SCALE_TO_FIT = 1,
		overflow_TRUNCATE = 2,
	};
	inline overflow_enum overflow(void);
	inline void overflow(overflow_enum value);
	enum align_x_enum {
		align_x_LEFT = 0,
		align_x_CENTER = 1,
		align_x_RIGHT = 2,
		align_x_JUSTIFY = 3,
		align_x_FLUSH = 4,
	};
	inline align_x_enum align_x(void);
	inline void align_x(align_x_enum value);
	enum align_y_enum {
		align_y_TOP = 1,
		align_y_TOP_BASELINE = 0,
		align_y_MIDDLE = 2,
		align_y_BOTTOM_BASELINE = 3,
		align_y_BOTTOM = 4,
	};
	inline align_y_enum align_y(void);
	inline void align_y(align_y_enum value);
	enum pivot_mode_enum {
		pivot_mode_MIDPOINT = 0,
		pivot_mode_TOP_LEFT = 1,
		pivot_mode_TOP_CENTER = 2,
		pivot_mode_TOP_RIGHT = 3,
		pivot_mode_BOTTOM_LEFT = 4,
		pivot_mode_BOTTOM_CENTER = 5,
		pivot_mode_BOTTOM_RIGHT = 6,
	};
	inline pivot_mode_enum pivot_mode(void);
	inline void pivot_mode(pivot_mode_enum value);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSubdivideCurve ****************/

class GeometryNodeSubdivideCurve : public GeometryNode {
public:
	GeometryNodeSubdivideCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSubdivideMesh ****************/

class GeometryNodeSubdivideMesh : public GeometryNode {
public:
	GeometryNodeSubdivideMesh(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSubdivisionSurface ****************/

class GeometryNodeSubdivisionSurface : public GeometryNode {
public:
	GeometryNodeSubdivisionSurface(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeSwitch ****************/

class GeometryNodeSwitch : public GeometryNode {
public:
	GeometryNodeSwitch(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeTransform ****************/

class GeometryNodeTransform : public GeometryNode {
public:
	GeometryNodeTransform(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeTranslateInstances ****************/

class GeometryNodeTranslateInstances : public GeometryNode {
public:
	GeometryNodeTranslateInstances(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeTriangulate ****************/

class GeometryNodeTriangulate : public GeometryNode {
public:
	GeometryNodeTriangulate(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeTrimCurve ****************/

class GeometryNodeTrimCurve : public GeometryNode {
public:
	GeometryNodeTrimCurve(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeUVPackIslands ****************/

class GeometryNodeUVPackIslands : public GeometryNode {
public:
	GeometryNodeUVPackIslands(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeUVUnwrap ****************/

class GeometryNodeUVUnwrap : public GeometryNode {
public:
	GeometryNodeUVUnwrap(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeViewer ****************/

class GeometryNodeViewer : public GeometryNode {
public:
	GeometryNodeViewer(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeVolumeCube ****************/

class GeometryNodeVolumeCube : public GeometryNode {
public:
	GeometryNodeVolumeCube(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeVolumeToMesh ****************/

class GeometryNodeVolumeToMesh : public GeometryNode {
public:
	GeometryNodeVolumeToMesh(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInterpolateCurves ****************/

class GeometryNodeInterpolateCurves : public GeometryNode {
public:
	GeometryNodeInterpolateCurves(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodePointsToCurves ****************/

class GeometryNodePointsToCurves : public GeometryNode {
public:
	GeometryNodePointsToCurves(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeInputEdgeSmooth ****************/

class GeometryNodeInputEdgeSmooth : public GeometryNode {
public:
	GeometryNodeInputEdgeSmooth(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}


	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** ShaderNodeGroup ****************/

class ShaderNodeGroup : public ShaderNode {
public:
	ShaderNodeGroup(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** CompositorNodeGroup ****************/

class CompositorNodeGroup : public CompositorNode {
public:
	CompositorNodeGroup(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** TextureNodeGroup ****************/

class TextureNodeGroup : public TextureNode {
public:
	TextureNodeGroup(const PointerRNA &ptr_arg) :
		TextureNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** GeometryNodeGroup ****************/

class GeometryNodeGroup : public GeometryNode {
public:
	GeometryNodeGroup(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

	inline bool is_registered_node_type();
	inline NodeInternalSocketTemplate input_template(int index);
	inline NodeInternalSocketTemplate output_template(int index);
};

/**************** Shader Custom Group ****************/

class ShaderNodeCustomGroup : public ShaderNode {
public:
	ShaderNodeCustomGroup(const PointerRNA &ptr_arg) :
		ShaderNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

};

/**************** Compositor Custom Group ****************/

class CompositorNodeCustomGroup : public CompositorNode {
public:
	CompositorNodeCustomGroup(const PointerRNA &ptr_arg) :
		CompositorNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

};

/**************** Custom Group ****************/

class NodeCustomGroup : public Node {
public:
	NodeCustomGroup(const PointerRNA &ptr_arg) :
		Node(ptr_arg)
		{}

	inline NodeTree node_tree(void);

};

/**************** Geometry Custom Group ****************/

class GeometryNodeCustomGroup : public GeometryNode {
public:
	GeometryNodeCustomGroup(const PointerRNA &ptr_arg) :
		GeometryNode(ptr_arg)
		{}

	inline NodeTree node_tree(void);

};

/**************** Output File Slot ****************/

class NodeOutputFileSlotFile : public Pointer {
public:
	NodeOutputFileSlotFile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_node_format(void);
	inline void use_node_format(bool value);
	inline bool save_as_render(void);
	inline void save_as_render(bool value);
	inline ImageFormatSettings format(void);
	inline std::string path(void);
	inline void path(const std::string& value);

};

/**************** Output File Layer Slot ****************/

class NodeOutputFileSlotLayer : public Pointer {
public:
	NodeOutputFileSlotLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Node Instance Hash ****************/

class NodeInstanceHash : public Pointer {
public:
	NodeInstanceHash(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Node Socket ****************/

class NodeSocket : public Pointer {
public:
	NodeSocket(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string label(void);
	inline void label(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline bool is_output(void);
	inline void is_output(bool value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline int link_limit(void);
	inline void link_limit(int value);
	inline bool is_linked(void);
	inline void is_linked(bool value);
	inline bool is_unavailable(void);
	inline void is_unavailable(bool value);
	inline bool is_multi_input(void);
	inline void is_multi_input(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline bool hide_value(void);
	inline void hide_value(bool value);
	inline Node node(void);
	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_ROTATION = 14,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
		type_OBJECT = 8,
		type_IMAGE = 9,
		type_GEOMETRY = 10,
		type_COLLECTION = 11,
		type_TEXTURE = 12,
		type_MATERIAL = 13,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum display_shape_enum {
		display_shape_CIRCLE = 0,
		display_shape_SQUARE = 1,
		display_shape_DIAMOND = 2,
		display_shape_CIRCLE_DOT = 3,
		display_shape_SQUARE_DOT = 4,
		display_shape_DIAMOND_DOT = 5,
	};
	inline display_shape_enum display_shape(void);
	inline void display_shape(display_shape_enum value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_subtype_label(void);
	inline void bl_subtype_label(const std::string& value);

};

/**************** NodeSocketStandard ****************/

class NodeSocketStandard : public NodeSocket {
public:
	NodeSocketStandard(const PointerRNA &ptr_arg) :
		NodeSocket(ptr_arg)
		{}


	inline void draw(Context& context, UILayout& layout, Node& node, const char * text);
	inline void draw_color(Context& context, Node& node, float color[4]);
	inline void draw_color_simple(float color[4]);
};

/**************** Float Node Socket ****************/

class NodeSocketFloat : public NodeSocketStandard {
public:
	NodeSocketFloat(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatUnsigned : public NodeSocketStandard {
public:
	NodeSocketFloatUnsigned(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatPercentage : public NodeSocketStandard {
public:
	NodeSocketFloatPercentage(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatFactor : public NodeSocketStandard {
public:
	NodeSocketFloatFactor(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatAngle : public NodeSocketStandard {
public:
	NodeSocketFloatAngle(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatTime : public NodeSocketStandard {
public:
	NodeSocketFloatTime(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatTimeAbsolute : public NodeSocketStandard {
public:
	NodeSocketFloatTimeAbsolute(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Float Node Socket ****************/

class NodeSocketFloatDistance : public NodeSocketStandard {
public:
	NodeSocketFloatDistance(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline float default_value(void);
	inline void default_value(float value);

};

/**************** Integer Node Socket ****************/

class NodeSocketInt : public NodeSocketStandard {
public:
	NodeSocketInt(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Integer Node Socket ****************/

class NodeSocketIntUnsigned : public NodeSocketStandard {
public:
	NodeSocketIntUnsigned(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Integer Node Socket ****************/

class NodeSocketIntPercentage : public NodeSocketStandard {
public:
	NodeSocketIntPercentage(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Integer Node Socket ****************/

class NodeSocketIntFactor : public NodeSocketStandard {
public:
	NodeSocketIntFactor(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline int default_value(void);
	inline void default_value(int value);

};

/**************** Boolean Node Socket ****************/

class NodeSocketBool : public NodeSocketStandard {
public:
	NodeSocketBool(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline bool default_value(void);
	inline void default_value(bool value);

};

/**************** Rotation Node Socket ****************/

class NodeSocketRotation : public NodeSocketStandard {
public:
	NodeSocketRotation(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket ****************/

class NodeSocketVector : public NodeSocketStandard {
public:
	NodeSocketVector(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorTranslation : public NodeSocketStandard {
public:
	NodeSocketVectorTranslation(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorDirection : public NodeSocketStandard {
public:
	NodeSocketVectorDirection(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorVelocity : public NodeSocketStandard {
public:
	NodeSocketVectorVelocity(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorAcceleration : public NodeSocketStandard {
public:
	NodeSocketVectorAcceleration(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorEuler : public NodeSocketStandard {
public:
	NodeSocketVectorEuler(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Vector Node Socket ****************/

class NodeSocketVectorXYZ : public NodeSocketStandard {
public:
	NodeSocketVectorXYZ(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

};

/**************** Color Node Socket ****************/

class NodeSocketColor : public NodeSocketStandard {
public:
	NodeSocketColor(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Array<float, 4> default_value(void);
	inline void default_value(float values[4]);

};

/**************** String Node Socket ****************/

class NodeSocketString : public NodeSocketStandard {
public:
	NodeSocketString(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline std::string default_value(void);
	inline void default_value(const std::string& value);

};

/**************** Shader Node Socket ****************/

class NodeSocketShader : public NodeSocketStandard {
public:
	NodeSocketShader(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}


};

/**************** Object Node Socket ****************/

class NodeSocketObject : public NodeSocketStandard {
public:
	NodeSocketObject(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Object default_value(void);

};

/**************** Image Node Socket ****************/

class NodeSocketImage : public NodeSocketStandard {
public:
	NodeSocketImage(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Image default_value(void);

};

/**************** Geometry Node Socket ****************/

class NodeSocketGeometry : public NodeSocketStandard {
public:
	NodeSocketGeometry(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}


};

/**************** Collection Node Socket ****************/

class NodeSocketCollection : public NodeSocketStandard {
public:
	NodeSocketCollection(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Collection default_value(void);

};

/**************** Texture Node Socket ****************/

class NodeSocketTexture : public NodeSocketStandard {
public:
	NodeSocketTexture(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Texture default_value(void);

};

/**************** Material Node Socket ****************/

class NodeSocketMaterial : public NodeSocketStandard {
public:
	NodeSocketMaterial(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}

	inline Material default_value(void);

};

/**************** Virtual Node Socket ****************/

class NodeSocketVirtual : public NodeSocketStandard {
public:
	NodeSocketVirtual(const PointerRNA &ptr_arg) :
		NodeSocketStandard(ptr_arg)
		{}


};

/**************** Node Tree Interface Item ****************/

class NodeTreeInterfaceItem : public Pointer {
public:
	NodeTreeInterfaceItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum item_type_enum {
		item_type_SOCKET = 1,
		item_type_PANEL = 0,
	};
	inline item_type_enum item_type(void);
	inline void item_type(item_type_enum value);
	inline NodeTreeInterfacePanel parent(void);
	inline int position(void);
	inline void position(int value);
	inline int index(void);
	inline void index(int value);

};

/**************** Node Tree Interface Socket ****************/

class NodeTreeInterfaceSocket : public NodeTreeInterfaceItem {
public:
	NodeTreeInterfaceSocket(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceItem(ptr_arg)
		{}

	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string identifier(void);
	inline void identifier(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	enum socket_type_enum {
		socket_type_DEFAULT = 0,
	};
	inline socket_type_enum socket_type(void);
	inline void socket_type(socket_type_enum value);
	enum in_out_enum {
		in_out_INPUT = 1,
		in_out_OUTPUT = 2,
	};
	inline in_out_enum in_out(void);
	inline void in_out(in_out_enum value);
	inline bool hide_value(void);
	inline void hide_value(bool value);
	inline bool hide_in_modifier(void);
	inline void hide_in_modifier(bool value);
	inline bool force_non_field(void);
	inline void force_non_field(bool value);
	inline bool layer_selection_field(void);
	inline void layer_selection_field(bool value);
	enum attribute_domain_enum {
		attribute_domain_POINT = 0,
		attribute_domain_EDGE = 1,
		attribute_domain_FACE = 2,
		attribute_domain_CORNER = 3,
		attribute_domain_CURVE = 4,
		attribute_domain_INSTANCE = 5,
		attribute_domain_LAYER = 6,
	};
	inline attribute_domain_enum attribute_domain(void);
	inline void attribute_domain(attribute_domain_enum value);
	inline std::string default_attribute_name(void);
	inline void default_attribute_name(const std::string& value);
	enum default_input_enum {
	};
	inline default_input_enum default_input(void);
	inline void default_input(default_input_enum value);
	inline std::string bl_socket_idname(void);
	inline void bl_socket_idname(const std::string& value);

};

/**************** Node Tree Interface Item ****************/

class NodeTreeInterfacePanel : public NodeTreeInterfaceItem {
public:
	NodeTreeInterfacePanel(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceItem(ptr_arg),
		interface_items(ptr_arg)
		{}

	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string description(void);
	inline void description(const std::string& value);
	inline bool default_closed(void);
	inline void default_closed(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, NodeTreeInterfaceItem, NodeTreeInterfacePanel, interface_items, true, true, false)

};

/**************** Node Tree Interface ****************/

class NodeTreeInterface : public Pointer {
public:
	NodeTreeInterface(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		items_tree(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, NodeTreeInterfaceItem, NodeTreeInterface, items_tree, true, true, true)
	inline int active_index(void);
	inline void active_index(int value);
	inline NodeTreeInterfaceItem active(void);

	inline NodeTreeInterfaceSocket new_socket(void *main, const char * name, const char * description, int in_out, int socket_type, NodeTreeInterfacePanel& parent);
	inline NodeTreeInterfacePanel new_panel(void *main, const char * name, const char * description, bool default_closed, NodeTreeInterfacePanel& parent);
	inline NodeTreeInterfaceItem copy(void *main, NodeTreeInterfaceItem& item);
	inline void remove(void *main, NodeTreeInterfaceItem& item, bool move_content_to_parent);
	inline void clear(void *main);
	inline void move(void *main, NodeTreeInterfaceItem& item, int to_position);
	inline void move_to_parent(void *main, NodeTreeInterfaceItem& item, NodeTreeInterfacePanel& parent, int to_position);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloat : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloat(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloatUnsigned : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloatUnsigned(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloatPercentage : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloatPercentage(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloatFactor : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloatFactor(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloatAngle : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloatAngle(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloatTime : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloatTime(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloatTimeAbsolute : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloatTimeAbsolute(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Float Node Socket Interface ****************/

class NodeTreeInterfaceSocketFloatDistance : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketFloatDistance(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline float default_value(void);
	inline void default_value(float value);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Integer Node Socket Interface ****************/

class NodeTreeInterfaceSocketInt : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketInt(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Integer Node Socket Interface ****************/

class NodeTreeInterfaceSocketIntUnsigned : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketIntUnsigned(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Integer Node Socket Interface ****************/

class NodeTreeInterfaceSocketIntPercentage : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketIntPercentage(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Integer Node Socket Interface ****************/

class NodeTreeInterfaceSocketIntFactor : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketIntFactor(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline int default_value(void);
	inline void default_value(int value);
	inline int min_value(void);
	inline void min_value(int value);
	inline int max_value(void);
	inline void max_value(int value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Boolean Node Socket Interface ****************/

class NodeTreeInterfaceSocketBool : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketBool(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline bool default_value(void);
	inline void default_value(bool value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Rotation Node Socket Interface ****************/

class NodeTreeInterfaceSocketRotation : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketRotation(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Vector Node Socket Interface ****************/

class NodeTreeInterfaceSocketVector : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketVector(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Vector Node Socket Interface ****************/

class NodeTreeInterfaceSocketVectorTranslation : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketVectorTranslation(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Vector Node Socket Interface ****************/

class NodeTreeInterfaceSocketVectorDirection : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketVectorDirection(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Vector Node Socket Interface ****************/

class NodeTreeInterfaceSocketVectorVelocity : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketVectorVelocity(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Vector Node Socket Interface ****************/

class NodeTreeInterfaceSocketVectorAcceleration : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketVectorAcceleration(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Vector Node Socket Interface ****************/

class NodeTreeInterfaceSocketVectorEuler : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketVectorEuler(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Vector Node Socket Interface ****************/

class NodeTreeInterfaceSocketVectorXYZ : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketVectorXYZ(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	enum subtype_enum {
		subtype_DEFAULT = 0,
	};
	inline subtype_enum subtype(void);
	inline void subtype(subtype_enum value);
	inline Array<float, 3> default_value(void);
	inline void default_value(float values[3]);
	inline float min_value(void);
	inline void min_value(float value);
	inline float max_value(void);
	inline void max_value(float value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Color Node Socket Interface ****************/

class NodeTreeInterfaceSocketColor : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketColor(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline Array<float, 4> default_value(void);
	inline void default_value(float values[4]);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** String Node Socket Interface ****************/

class NodeTreeInterfaceSocketString : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketString(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline std::string default_value(void);
	inline void default_value(const std::string& value);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Shader Node Socket Interface ****************/

class NodeTreeInterfaceSocketShader : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketShader(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}


	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Object Node Socket Interface ****************/

class NodeTreeInterfaceSocketObject : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketObject(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline Object default_value(void);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Image Node Socket Interface ****************/

class NodeTreeInterfaceSocketImage : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketImage(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline Image default_value(void);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Geometry Node Socket Interface ****************/

class NodeTreeInterfaceSocketGeometry : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketGeometry(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}


	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Collection Node Socket Interface ****************/

class NodeTreeInterfaceSocketCollection : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketCollection(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline Collection default_value(void);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Texture Node Socket Interface ****************/

class NodeTreeInterfaceSocketTexture : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketTexture(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline Texture default_value(void);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Material Node Socket Interface ****************/

class NodeTreeInterfaceSocketMaterial : public NodeTreeInterfaceSocket {
public:
	NodeTreeInterfaceSocketMaterial(const PointerRNA &ptr_arg) :
		NodeTreeInterfaceSocket(ptr_arg)
		{}

	inline Material default_value(void);

	inline void draw(Context& context, UILayout& layout);
	inline void init_socket(Node& node, NodeSocket& socket, const char * data_path);
	inline void from_socket(Node& node, NodeSocket& socket);
};

/**************** Object ****************/

class Object : public ID {
public:
	Object(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		material_slots(ptr_arg),
		modifiers(ptr_arg),
		grease_pencil_modifiers(ptr_arg),
		shader_effects(ptr_arg),
		constraints(ptr_arg),
		vertex_groups(ptr_arg),
		particle_systems(ptr_arg)
		{}

	inline ID data(void);
	enum type_enum {
		type_MESH = 1,
		type_CURVE = 2,
		type_SURFACE = 3,
		type_META = 5,
		type_FONT = 4,
		type_CURVES = 27,
		type_POINTCLOUD = 28,
		type_VOLUME = 29,
		type_GPENCIL = 26,
		type_GREASEPENCIL = 30,
		type_ARMATURE = 25,
		type_LATTICE = 22,
		type_EMPTY = 0,
		type_LIGHT = 10,
		type_LIGHT_PROBE = 13,
		type_CAMERA = 11,
		type_SPEAKER = 12,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum mode_enum {
		mode_OBJECT = 0,
		mode_EDIT = 1,
		mode_POSE = 64,
		mode_SCULPT = 2,
		mode_VERTEX_PAINT = 4,
		mode_WEIGHT_PAINT = 8,
		mode_TEXTURE_PAINT = 16,
		mode_PARTICLE_EDIT = 32,
		mode_EDIT_GPENCIL = 128,
		mode_SCULPT_GPENCIL = 512,
		mode_PAINT_GPENCIL = 256,
		mode_WEIGHT_GPENCIL = 1024,
		mode_VERTEX_GPENCIL = 2048,
		mode_SCULPT_CURVES = 4096,
		mode_PAINT_GREASE_PENCIL = 8192,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Array<float, 24> bound_box(void);
	inline void bound_box(float values[24]);
	inline Object parent(void);
	enum parent_type_enum {
		parent_type_OBJECT = 0,
		parent_type_ARMATURE = 4,
		parent_type_LATTICE = 4,
		parent_type_VERTEX = 5,
		parent_type_VERTEX_3 = 6,
		parent_type_BONE = 7,
	};
	inline parent_type_enum parent_type(void);
	inline void parent_type(parent_type_enum value);
	inline Array<int, 3> parent_vertices(void);
	inline void parent_vertices(int values[3]);
	inline std::string parent_bone(void);
	inline void parent_bone(const std::string& value);
	inline bool use_camera_lock_parent(void);
	inline void use_camera_lock_parent(bool value);
	enum track_axis_enum {
		track_axis_POS_X = 0,
		track_axis_POS_Y = 1,
		track_axis_POS_Z = 2,
		track_axis_NEG_X = 3,
		track_axis_NEG_Y = 4,
		track_axis_NEG_Z = 5,
	};
	inline track_axis_enum track_axis(void);
	inline void track_axis(track_axis_enum value);
	enum up_axis_enum {
		up_axis_X = 0,
		up_axis_Y = 1,
		up_axis_Z = 2,
	};
	inline up_axis_enum up_axis(void);
	inline void up_axis(up_axis_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MaterialSlot, Object, material_slots, true, false, false)
	inline Material active_material(void);
	inline int active_material_index(void);
	inline void active_material_index(int value);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 4> rotation_quaternion(void);
	inline void rotation_quaternion(float values[4]);
	inline Array<float, 4> rotation_axis_angle(void);
	inline void rotation_axis_angle(float values[4]);
	inline Array<float, 3> rotation_euler(void);
	inline void rotation_euler(float values[3]);
	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 3> dimensions(void);
	inline void dimensions(float values[3]);
	inline Array<float, 3> delta_location(void);
	inline void delta_location(float values[3]);
	inline Array<float, 3> delta_rotation_euler(void);
	inline void delta_rotation_euler(float values[3]);
	inline Array<float, 4> delta_rotation_quaternion(void);
	inline void delta_rotation_quaternion(float values[4]);
	inline Array<float, 3> delta_scale(void);
	inline void delta_scale(float values[3]);
	inline Array<bool, 3> lock_location(void);
	inline void lock_location(bool values[3]);
	inline Array<bool, 3> lock_rotation(void);
	inline void lock_rotation(bool values[3]);
	inline bool lock_rotation_w(void);
	inline void lock_rotation_w(bool value);
	inline bool lock_rotations_4d(void);
	inline void lock_rotations_4d(bool value);
	inline Array<bool, 3> lock_scale(void);
	inline void lock_scale(bool values[3]);
	inline Array<float, 16> matrix_world(void);
	inline void matrix_world(float values[16]);
	inline Array<float, 16> matrix_local(void);
	inline void matrix_local(float values[16]);
	inline Array<float, 16> matrix_basis(void);
	inline void matrix_basis(float values[16]);
	inline Array<float, 16> matrix_parent_inverse(void);
	inline void matrix_parent_inverse(float values[16]);
	COLLECTION_PROPERTY(ObjectModifiers, Modifier, Object, modifiers, false, true, true)
	COLLECTION_PROPERTY(ObjectGpencilModifiers, GpencilModifier, Object, grease_pencil_modifiers, false, true, true)
	COLLECTION_PROPERTY(ObjectShaderFx, ShaderFx, Object, shader_effects, false, true, true)
	COLLECTION_PROPERTY(ObjectConstraints, Constraint, Object, constraints, false, true, true)
	COLLECTION_PROPERTY(VertexGroups, VertexGroup, Object, vertex_groups, false, false, false)
	enum empty_display_type_enum {
		empty_display_type_PLAIN_AXES = 2,
		empty_display_type_ARROWS = 1,
		empty_display_type_SINGLE_ARROW = 4,
		empty_display_type_CIRCLE = 3,
		empty_display_type_CUBE = 5,
		empty_display_type_SPHERE = 6,
		empty_display_type_CONE = 7,
		empty_display_type_IMAGE = 8,
	};
	inline empty_display_type_enum empty_display_type(void);
	inline void empty_display_type(empty_display_type_enum value);
	inline float empty_display_size(void);
	inline void empty_display_size(float value);
	inline Array<float, 2> empty_image_offset(void);
	inline void empty_image_offset(float values[2]);
	inline ImageUser image_user(void);
	enum empty_image_depth_enum {
		empty_image_depth_DEFAULT = 0,
		empty_image_depth_FRONT = 1,
		empty_image_depth_BACK = 2,
	};
	inline empty_image_depth_enum empty_image_depth(void);
	inline void empty_image_depth(empty_image_depth_enum value);
	inline bool show_empty_image_perspective(void);
	inline void show_empty_image_perspective(bool value);
	inline bool show_empty_image_orthographic(void);
	inline void show_empty_image_orthographic(bool value);
	inline bool show_empty_image_only_axis_aligned(void);
	inline void show_empty_image_only_axis_aligned(bool value);
	inline bool use_empty_image_alpha(void);
	inline void use_empty_image_alpha(bool value);
	enum empty_image_side_enum {
		empty_image_side_DOUBLE_SIDED = 0,
		empty_image_side_FRONT = 4,
		empty_image_side_BACK = 8,
	};
	inline empty_image_side_enum empty_image_side(void);
	inline void empty_image_side(empty_image_side_enum value);
	inline bool add_rest_position_attribute(void);
	inline void add_rest_position_attribute(bool value);
	inline int pass_index(void);
	inline void pass_index(int value);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline FieldSettings field(void);
	inline CollisionSettings collision(void);
	inline SoftBodySettings soft_body(void);
	COLLECTION_PROPERTY(ParticleSystems, ParticleSystem, Object, particle_systems, false, true, true)
	inline RigidBodyObject rigid_body(void);
	inline RigidBodyConstraint rigid_body_constraint(void);
	inline bool use_simulation_cache(void);
	inline void use_simulation_cache(bool value);
	inline bool hide_viewport(void);
	inline void hide_viewport(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool hide_render(void);
	inline void hide_render(bool value);
	inline bool hide_probe_volume(void);
	inline void hide_probe_volume(bool value);
	inline bool hide_probe_cubemap(void);
	inline void hide_probe_cubemap(bool value);
	inline bool hide_probe_planar(void);
	inline void hide_probe_planar(bool value);
	inline bool show_instancer_for_render(void);
	inline void show_instancer_for_render(bool value);
	inline bool show_instancer_for_viewport(void);
	inline void show_instancer_for_viewport(bool value);
	inline bool visible_camera(void);
	inline void visible_camera(bool value);
	inline bool visible_diffuse(void);
	inline void visible_diffuse(bool value);
	inline bool visible_glossy(void);
	inline void visible_glossy(bool value);
	inline bool visible_transmission(void);
	inline void visible_transmission(bool value);
	inline bool visible_volume_scatter(void);
	inline void visible_volume_scatter(bool value);
	inline bool visible_shadow(void);
	inline void visible_shadow(bool value);
	inline bool is_holdout(void);
	inline void is_holdout(bool value);
	inline bool is_shadow_catcher(void);
	inline void is_shadow_catcher(bool value);
	enum instance_type_enum {
		instance_type_NONE = 0,
		instance_type_VERTS = 16,
		instance_type_FACES = 512,
		instance_type_COLLECTION = 256,
	};
	inline instance_type_enum instance_type(void);
	inline void instance_type(instance_type_enum value);
	inline bool use_instance_vertices_rotation(void);
	inline void use_instance_vertices_rotation(bool value);
	inline bool use_instance_faces_scale(void);
	inline void use_instance_faces_scale(bool value);
	inline float instance_faces_scale(void);
	inline void instance_faces_scale(float value);
	inline Collection instance_collection(void);
	inline bool is_instancer(void);
	inline void is_instancer(bool value);
	enum display_type_enum {
		display_type_BOUNDS = 1,
		display_type_WIRE = 2,
		display_type_SOLID = 3,
		display_type_TEXTURED = 5,
	};
	inline display_type_enum display_type(void);
	inline void display_type(display_type_enum value);
	inline bool show_bounds(void);
	inline void show_bounds(bool value);
	enum display_bounds_type_enum {
		display_bounds_type_BOX = 0,
		display_bounds_type_SPHERE = 1,
		display_bounds_type_CYLINDER = 2,
		display_bounds_type_CONE = 3,
		display_bounds_type_CAPSULE = 7,
	};
	inline display_bounds_type_enum display_bounds_type(void);
	inline void display_bounds_type(display_bounds_type_enum value);
	inline bool show_name(void);
	inline void show_name(bool value);
	inline bool show_axis(void);
	inline void show_axis(bool value);
	inline bool show_texture_space(void);
	inline void show_texture_space(bool value);
	inline bool show_wire(void);
	inline void show_wire(bool value);
	inline bool show_all_edges(void);
	inline void show_all_edges(bool value);
	inline bool use_grease_pencil_lights(void);
	inline void use_grease_pencil_lights(bool value);
	inline bool show_transparent(void);
	inline void show_transparent(bool value);
	inline bool show_in_front(void);
	inline void show_in_front(bool value);
	inline Pose pose(void);
	inline bool show_only_shape_key(void);
	inline void show_only_shape_key(bool value);
	inline bool use_shape_key_edit_mode(void);
	inline void use_shape_key_edit_mode(bool value);
	inline ShapeKey active_shape_key(void);
	inline int active_shape_key_index(void);
	inline void active_shape_key_index(int value);
	inline bool use_dynamic_topology_sculpting(void);
	inline void use_dynamic_topology_sculpting(bool value);
	inline bool is_from_instancer(void);
	inline void is_from_instancer(bool value);
	inline bool is_from_set(void);
	inline void is_from_set(bool value);
	inline ObjectDisplay display(void);
	inline ObjectLineArt lineart(void);
	inline bool use_mesh_mirror_x(void);
	inline void use_mesh_mirror_x(bool value);
	inline bool use_mesh_mirror_y(void);
	inline void use_mesh_mirror_y(bool value);
	inline bool use_mesh_mirror_z(void);
	inline void use_mesh_mirror_z(bool value);
	inline std::string lightgroup(void);
	inline void lightgroup(const std::string& value);
	inline ObjectLightLinking light_linking(void);
	inline AnimData animation_data(void);
	inline AnimViz animation_visualization(void);
	inline MotionPath motion_path(void);

	inline bool select_get(Context C, ViewLayer& view_layer);
	inline void select_set(Context C, bool state, ViewLayer& view_layer);
	inline bool hide_get(Context C, ViewLayer& view_layer);
	inline void hide_set(Context C, bool state, ViewLayer& view_layer);
	inline bool visible_get(Context C, ViewLayer& view_layer, SpaceView3D& viewport);
	inline bool holdout_get(Context C, ViewLayer& view_layer);
	inline bool indirect_only_get(Context C, ViewLayer& view_layer);
	inline bool local_view_get(SpaceView3D& viewport);
	inline void local_view_set(SpaceView3D& viewport, bool state);
	inline bool visible_in_viewport_get(SpaceView3D& viewport);
	inline void convert_space(PoseBone& pose_bone, float matrix[16], float matrix_return[16], int from_space, int to_space);
	inline void calc_matrix_camera(Depsgraph& depsgraph, float result[16], int x, int y, float scale_x, float scale_y);
	inline void camera_fit_coords(Depsgraph& depsgraph, int coordinates_len, float *coordinates, float coord_return[3], float *scale_return);
	inline void crazyspace_eval(Depsgraph& depsgraph, Scene& scene);
	inline void crazyspace_displacement_to_deformed(int vertex_index, float displacement[3], float displacement_deformed[3]);
	inline void crazyspace_displacement_to_original(int vertex_index, float displacement[3], float displacement_original[3]);
	inline void crazyspace_eval_clear();
	inline Mesh to_mesh(bool preserve_all_data_layers, Depsgraph& depsgraph);
	inline void to_mesh_clear();
	inline Curve to_curve(Depsgraph& depsgraph, bool apply_modifiers);
	inline void to_curve_clear();
	inline Object find_armature();
	inline ShapeKey shape_key_add(Context C, const char * name, bool from_mix);
	inline void shape_key_remove(void *main, ShapeKey& key);
	inline void shape_key_clear(void *main);
	inline void ray_cast(Context C, float origin[3], float direction[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index);
	inline void closest_point_on_mesh(Context C, float origin[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index);
	inline bool is_modified(Scene& scene, int settings);
	inline bool is_deform_modified(Scene& scene, int settings);
	inline void dm_info(Context C, int type, Depsgraph& depsgraph, char * result);
	inline bool update_from_editmode(void *main);
	inline void cache_release();
	inline bool generate_gpencil_strokes(Context C, Object& grease_pencil_object, bool use_collections, float scale_thickness, float sample);
};

/**************** Vertex Group ****************/

class VertexGroup : public Pointer {
public:
	VertexGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool lock_weight(void);
	inline void lock_weight(bool value);
	inline int index(void);
	inline void index(int value);

	inline void add(int index_len, int *index, float weight, int type);
	inline void remove(int index_len, int *index);
	inline float weight(int index);
};

/**************** Material Slot ****************/

class MaterialSlot : public Pointer {
public:
	MaterialSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum link_enum {
		link_OBJECT = 1,
		link_DATA = 0,
	};
	inline link_enum link(void);
	inline void link(link_enum value);
	inline Material material(void);
	inline int slot_index(void);
	inline void slot_index(int value);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Object Display ****************/

class ObjectDisplay : public Pointer {
public:
	ObjectDisplay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_shadows(void);
	inline void show_shadows(bool value);

};

/**************** Object Line Art ****************/

class ObjectLineArt : public Pointer {
public:
	ObjectLineArt(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum usage_enum {
		usage_INHERIT = 0,
		usage_INCLUDE = 1,
		usage_OCCLUSION_ONLY = 2,
		usage_EXCLUDE = 4,
		usage_INTERSECTION_ONLY = 8,
		usage_NO_INTERSECTION = 16,
		usage_FORCE_INTERSECTION = 32,
	};
	inline usage_enum usage(void);
	inline void usage(usage_enum value);
	inline bool use_crease_override(void);
	inline void use_crease_override(bool value);
	inline float crease_threshold(void);
	inline void crease_threshold(float value);
	inline bool use_intersection_priority_override(void);
	inline void use_intersection_priority_override(bool value);
	inline int intersection_priority(void);
	inline void intersection_priority(int value);

};

/**************** Object Light Linking ****************/

class ObjectLightLinking : public Pointer {
public:
	ObjectLightLinking(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Collection receiver_collection(void);
	inline Collection blocker_collection(void);

};

/**************** Active Point Cache ****************/

class PointCache : public Pointer {
public:
	PointCache(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		point_caches(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline int index(void);
	inline void index(int value);
	enum compression_enum {
		compression_NO = 0,
		compression_LIGHT = 1,
		compression_HEAVY = 2,
	};
	inline compression_enum compression(void);
	inline void compression(compression_enum value);
	inline bool is_baked(void);
	inline void is_baked(bool value);
	inline bool is_baking(void);
	inline void is_baking(bool value);
	inline bool use_disk_cache(void);
	inline void use_disk_cache(bool value);
	inline bool is_outdated(void);
	inline void is_outdated(bool value);
	inline bool is_frame_skip(void);
	inline void is_frame_skip(bool value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string info(void);
	inline void info(const std::string& value);
	inline bool use_external(void);
	inline void use_external(bool value);
	inline bool use_library_path(void);
	inline void use_library_path(bool value);
	COLLECTION_PROPERTY(PointCaches, PointCacheItem, PointCache, point_caches, false, false, false)

};

/**************** Point Cache ****************/

class PointCacheItem : public Pointer {
public:
	PointCacheItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline int index(void);
	inline void index(int value);
	enum compression_enum {
		compression_NO = 0,
		compression_LIGHT = 1,
		compression_HEAVY = 2,
	};
	inline compression_enum compression(void);
	inline void compression(compression_enum value);
	inline bool is_baked(void);
	inline void is_baked(bool value);
	inline bool is_baking(void);
	inline void is_baking(bool value);
	inline bool use_disk_cache(void);
	inline void use_disk_cache(bool value);
	inline bool is_outdated(void);
	inline void is_outdated(bool value);
	inline bool is_frame_skip(void);
	inline void is_frame_skip(bool value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline std::string info(void);
	inline void info(const std::string& value);
	inline bool use_external(void);
	inline void use_external(bool value);
	inline bool use_library_path(void);
	inline void use_library_path(bool value);

};

/**************** Collision Settings ****************/

class CollisionSettings : public Pointer {
public:
	CollisionSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use(void);
	inline void use(bool value);
	inline float damping_factor(void);
	inline void damping_factor(float value);
	inline float damping_random(void);
	inline void damping_random(float value);
	inline float friction_factor(void);
	inline void friction_factor(float value);
	inline float friction_random(void);
	inline void friction_random(float value);
	inline float permeability(void);
	inline void permeability(float value);
	inline bool use_particle_kill(void);
	inline void use_particle_kill(bool value);
	inline float stickiness(void);
	inline void stickiness(float value);
	inline float thickness_inner(void);
	inline void thickness_inner(float value);
	inline float thickness_outer(void);
	inline void thickness_outer(float value);
	inline float damping(void);
	inline void damping(float value);
	inline float absorption(void);
	inline void absorption(float value);
	inline float cloth_friction(void);
	inline void cloth_friction(float value);
	inline bool use_culling(void);
	inline void use_culling(bool value);
	inline bool use_normal(void);
	inline void use_normal(bool value);

};

/**************** Effector Weights ****************/

class EffectorWeights : public Pointer {
public:
	EffectorWeights(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool apply_to_hair_growing(void);
	inline void apply_to_hair_growing(bool value);
	inline Collection collection(void);
	inline float gravity(void);
	inline void gravity(float value);
	inline float all(void);
	inline void all(float value);
	inline float force(void);
	inline void force(float value);
	inline float vortex(void);
	inline void vortex(float value);
	inline float magnetic(void);
	inline void magnetic(float value);
	inline float wind(void);
	inline void wind(float value);
	inline float curve_guide(void);
	inline void curve_guide(float value);
	inline float texture(void);
	inline void texture(float value);
	inline float harmonic(void);
	inline void harmonic(float value);
	inline float charge(void);
	inline void charge(float value);
	inline float lennardjones(void);
	inline void lennardjones(float value);
	inline float boid(void);
	inline void boid(float value);
	inline float turbulence(void);
	inline void turbulence(float value);
	inline float drag(void);
	inline void drag(float value);
	inline float smokeflow(void);
	inline void smokeflow(float value);

};

/**************** Field Settings ****************/

class FieldSettings : public Pointer {
public:
	FieldSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_NONE = 0,
		type_BOID = 10,
		type_CHARGE = 8,
		type_GUIDE = 5,
		type_DRAG = 12,
		type_FLUID_FLOW = 13,
		type_FORCE = 1,
		type_HARMONIC = 7,
		type_LENNARDJ = 9,
		type_MAGNET = 3,
		type_TEXTURE = 6,
		type_TURBULENCE = 11,
		type_VORTEX = 2,
		type_WIND = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum shape_enum {
		shape_POINT = 0,
		shape_LINE = 4,
		shape_PLANE = 1,
		shape_SURFACE = 2,
		shape_POINTS = 3,
	};
	inline shape_enum shape(void);
	inline void shape(shape_enum value);
	enum falloff_type_enum {
		falloff_type_CONE = 2,
		falloff_type_SPHERE = 0,
		falloff_type_TUBE = 1,
	};
	inline falloff_type_enum falloff_type(void);
	inline void falloff_type(falloff_type_enum value);
	enum texture_mode_enum {
		texture_mode_CURL = 2,
		texture_mode_GRADIENT = 1,
		texture_mode_RGB = 0,
	};
	inline texture_mode_enum texture_mode(void);
	inline void texture_mode(texture_mode_enum value);
	enum z_direction_enum {
		z_direction_POSITIVE = 1,
		z_direction_NEGATIVE = 2,
		z_direction_BOTH = 0,
	};
	inline z_direction_enum z_direction(void);
	inline void z_direction(z_direction_enum value);
	inline float strength(void);
	inline void strength(float value);
	inline float linear_drag(void);
	inline void linear_drag(float value);
	inline float harmonic_damping(void);
	inline void harmonic_damping(float value);
	inline float quadratic_drag(void);
	inline void quadratic_drag(float value);
	inline float flow(void);
	inline void flow(float value);
	inline float wind_factor(void);
	inline void wind_factor(float value);
	inline float inflow(void);
	inline void inflow(float value);
	inline float size(void);
	inline void size(float value);
	inline float rest_length(void);
	inline void rest_length(float value);
	inline float falloff_power(void);
	inline void falloff_power(float value);
	inline float distance_min(void);
	inline void distance_min(float value);
	inline float distance_max(void);
	inline void distance_max(float value);
	inline float radial_min(void);
	inline void radial_min(float value);
	inline float radial_max(void);
	inline void radial_max(float value);
	inline float radial_falloff(void);
	inline void radial_falloff(float value);
	inline float texture_nabla(void);
	inline void texture_nabla(float value);
	inline float noise(void);
	inline void noise(float value);
	inline int seed(void);
	inline void seed(int value);
	inline bool use_min_distance(void);
	inline void use_min_distance(bool value);
	inline bool use_max_distance(void);
	inline void use_max_distance(bool value);
	inline bool use_radial_min(void);
	inline void use_radial_min(bool value);
	inline bool use_radial_max(void);
	inline void use_radial_max(bool value);
	inline bool use_object_coords(void);
	inline void use_object_coords(bool value);
	inline bool use_global_coords(void);
	inline void use_global_coords(bool value);
	inline bool use_2d_force(void);
	inline void use_2d_force(bool value);
	inline bool use_root_coords(void);
	inline void use_root_coords(bool value);
	inline bool apply_to_location(void);
	inline void apply_to_location(bool value);
	inline bool apply_to_rotation(void);
	inline void apply_to_rotation(bool value);
	inline bool use_absorption(void);
	inline void use_absorption(bool value);
	inline bool use_multiple_springs(void);
	inline void use_multiple_springs(bool value);
	inline bool use_smoke_density(void);
	inline void use_smoke_density(bool value);
	inline bool use_gravity_falloff(void);
	inline void use_gravity_falloff(bool value);
	inline Texture texture(void);
	inline Object source_object(void);
	inline float guide_minimum(void);
	inline void guide_minimum(float value);
	inline float guide_free(void);
	inline void guide_free(float value);
	inline bool use_guide_path_add(void);
	inline void use_guide_path_add(bool value);
	inline bool use_guide_path_weight(void);
	inline void use_guide_path_weight(bool value);
	inline float guide_clump_amount(void);
	inline void guide_clump_amount(float value);
	inline float guide_clump_shape(void);
	inline void guide_clump_shape(float value);
	enum guide_kink_type_enum {
		guide_kink_type_NONE = 0,
		guide_kink_type_BRAID = 4,
		guide_kink_type_CURL = 1,
		guide_kink_type_RADIAL = 2,
		guide_kink_type_ROLL = 6,
		guide_kink_type_ROTATION = 5,
		guide_kink_type_WAVE = 3,
	};
	inline guide_kink_type_enum guide_kink_type(void);
	inline void guide_kink_type(guide_kink_type_enum value);
	enum guide_kink_axis_enum {
		guide_kink_axis_X = 0,
		guide_kink_axis_Y = 1,
		guide_kink_axis_Z = 2,
	};
	inline guide_kink_axis_enum guide_kink_axis(void);
	inline void guide_kink_axis(guide_kink_axis_enum value);
	inline float guide_kink_frequency(void);
	inline void guide_kink_frequency(float value);
	inline float guide_kink_shape(void);
	inline void guide_kink_shape(float value);
	inline float guide_kink_amplitude(void);
	inline void guide_kink_amplitude(float value);

};

/**************** Soft Body Settings ****************/

class SoftBodySettings : public Pointer {
public:
	SoftBodySettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float friction(void);
	inline void friction(float value);
	inline float mass(void);
	inline void mass(float value);
	inline std::string vertex_group_mass(void);
	inline void vertex_group_mass(const std::string& value);
	inline float gravity(void);
	inline void gravity(float value);
	inline float speed(void);
	inline void speed(float value);
	inline std::string vertex_group_goal(void);
	inline void vertex_group_goal(const std::string& value);
	inline float goal_min(void);
	inline void goal_min(float value);
	inline float goal_max(void);
	inline void goal_max(float value);
	inline float goal_default(void);
	inline void goal_default(float value);
	inline float goal_spring(void);
	inline void goal_spring(float value);
	inline float goal_friction(void);
	inline void goal_friction(float value);
	inline float pull(void);
	inline void pull(float value);
	inline float push(void);
	inline void push(float value);
	inline float damping(void);
	inline void damping(float value);
	inline int spring_length(void);
	inline void spring_length(int value);
	inline int aero(void);
	inline void aero(int value);
	inline int plastic(void);
	inline void plastic(int value);
	inline float bend(void);
	inline void bend(float value);
	inline float shear(void);
	inline void shear(float value);
	inline std::string vertex_group_spring(void);
	inline void vertex_group_spring(const std::string& value);
	enum collision_type_enum {
		collision_type_MANUAL = 0,
		collision_type_AVERAGE = 1,
		collision_type_MINIMAL = 2,
		collision_type_MAXIMAL = 3,
		collision_type_MINMAX = 4,
	};
	inline collision_type_enum collision_type(void);
	inline void collision_type(collision_type_enum value);
	inline float ball_size(void);
	inline void ball_size(float value);
	inline float ball_stiff(void);
	inline void ball_stiff(float value);
	inline float ball_damp(void);
	inline void ball_damp(float value);
	inline float error_threshold(void);
	inline void error_threshold(float value);
	inline int step_min(void);
	inline void step_min(int value);
	inline int step_max(void);
	inline void step_max(int value);
	inline int choke(void);
	inline void choke(int value);
	inline int fuzzy(void);
	inline void fuzzy(int value);
	inline bool use_auto_step(void);
	inline void use_auto_step(bool value);
	inline bool use_diagnose(void);
	inline void use_diagnose(bool value);
	inline bool use_estimate_matrix(void);
	inline void use_estimate_matrix(bool value);
	inline Array<float, 3> location_mass_center(void);
	inline void location_mass_center(float values[3]);
	inline Array<float, 9> rotation_estimate(void);
	inline void rotation_estimate(float values[9]);
	inline Array<float, 9> scale_estimate(void);
	inline void scale_estimate(float values[9]);
	inline bool use_goal(void);
	inline void use_goal(bool value);
	inline bool use_edges(void);
	inline void use_edges(bool value);
	inline bool use_stiff_quads(void);
	inline void use_stiff_quads(bool value);
	inline bool use_edge_collision(void);
	inline void use_edge_collision(bool value);
	inline bool use_face_collision(void);
	inline void use_face_collision(bool value);
	enum aerodynamics_type_enum {
		aerodynamics_type_SIMPLE = 0,
		aerodynamics_type_LIFT_FORCE = 1,
	};
	inline aerodynamics_type_enum aerodynamics_type(void);
	inline void aerodynamics_type(aerodynamics_type_enum value);
	inline bool use_self_collision(void);
	inline void use_self_collision(bool value);
	inline Collection collision_collection(void);
	inline EffectorWeights effector_weights(void);

};

/**************** Dependency Graph Object Instance ****************/

class DepsgraphObjectInstance : public Pointer {
public:
	DepsgraphObjectInstance(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object object(void);
	inline bool show_self(void);
	inline void show_self(bool value);
	inline bool show_particles(void);
	inline void show_particles(bool value);
	inline bool is_instance(void);
	inline void is_instance(bool value);
	inline Object instance_object(void);
	inline Object parent(void);
	inline ParticleSystem particle_system(void);
	inline Array<int, 8> persistent_id(void);
	inline void persistent_id(int values[8]);
	inline int random_id(void);
	inline void random_id(int value);
	inline Array<float, 16> matrix_world(void);
	inline void matrix_world(float values[16]);
	inline Array<float, 3> orco(void);
	inline void orco(float values[3]);
	inline Array<float, 2> uv(void);
	inline void uv(float values[2]);

};

/**************** Dependency Graph Update ****************/

class DepsgraphUpdate : public Pointer {
public:
	DepsgraphUpdate(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	inline bool is_updated_transform(void);
	inline void is_updated_transform(bool value);
	inline bool is_updated_geometry(void);
	inline void is_updated_geometry(bool value);
	inline bool is_updated_shading(void);
	inline void is_updated_shading(bool value);

};

/**************** Dependency Graph ****************/

class Depsgraph : public Pointer {
public:
	Depsgraph(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		ids(ptr_arg),
		objects(ptr_arg),
		object_instances(ptr_arg),
		updates(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum mode_enum {
		mode_VIEWPORT = 0,
		mode_RENDER = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline Scene scene(void);
	inline ViewLayer view_layer(void);
	inline Scene scene_eval(void);
	inline ViewLayer view_layer_eval(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ID, Depsgraph, ids, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Object, Depsgraph, objects, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, DepsgraphObjectInstance, Depsgraph, object_instances, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, DepsgraphUpdate, Depsgraph, updates, false, false, false)

	inline void debug_relations_graphviz(const char * filepath);
	inline void debug_stats_gnuplot(const char * filepath, const char * output_filepath);
	inline void debug_tag_update();
	inline void debug_stats(char * result);
	inline void update(void *main);
	inline ID id_eval_get(ID& id);
	inline bool id_type_updated(int id_type);
};

/**************** Packed File ****************/

class PackedFile : public Pointer {
public:
	PackedFile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int size(void);
	inline void size(int value);
	inline std::string data(void);
	inline void data(const std::string& value);

};

/**************** Palette Color ****************/

class PaletteColor : public Pointer {
public:
	PaletteColor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float strength(void);
	inline void strength(float value);
	inline float weight(void);
	inline void weight(float value);

};

/**************** Palette ****************/

class Palette : public ID {
public:
	Palette(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		colors(ptr_arg)
		{}

	COLLECTION_PROPERTY(PaletteColors, PaletteColor, Palette, colors, false, true, false)

};

/**************** Particle Target ****************/

class ParticleTarget : public Pointer {
public:
	ParticleTarget(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline Object object(void);
	inline int system(void);
	inline void system(int value);
	inline float time(void);
	inline void time(float value);
	inline float duration(void);
	inline void duration(float value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	enum alliance_enum {
		alliance_FRIEND = 1,
		alliance_NEUTRAL = 0,
		alliance_ENEMY = 2,
	};
	inline alliance_enum alliance(void);
	inline void alliance(alliance_enum value);

};

/**************** SPH Fluid Settings ****************/

class SPHFluidSettings : public Pointer {
public:
	SPHFluidSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum solver_enum {
		solver_DDR = 0,
		solver_CLASSICAL = 1,
	};
	inline solver_enum solver(void);
	inline void solver(solver_enum value);
	inline float spring_force(void);
	inline void spring_force(float value);
	inline float fluid_radius(void);
	inline void fluid_radius(float value);
	inline float rest_length(void);
	inline void rest_length(float value);
	inline bool use_viscoelastic_springs(void);
	inline void use_viscoelastic_springs(bool value);
	inline bool use_initial_rest_length(void);
	inline void use_initial_rest_length(bool value);
	inline float plasticity(void);
	inline void plasticity(float value);
	inline float yield_ratio(void);
	inline void yield_ratio(float value);
	inline int spring_frames(void);
	inline void spring_frames(int value);
	inline float linear_viscosity(void);
	inline void linear_viscosity(float value);
	inline float stiff_viscosity(void);
	inline void stiff_viscosity(float value);
	inline float stiffness(void);
	inline void stiffness(float value);
	inline float repulsion(void);
	inline void repulsion(float value);
	inline float rest_density(void);
	inline void rest_density(float value);
	inline float buoyancy(void);
	inline void buoyancy(float value);
	inline bool use_factor_repulsion(void);
	inline void use_factor_repulsion(bool value);
	inline bool use_factor_density(void);
	inline void use_factor_density(bool value);
	inline bool use_factor_radius(void);
	inline void use_factor_radius(bool value);
	inline bool use_factor_stiff_viscosity(void);
	inline void use_factor_stiff_viscosity(bool value);
	inline bool use_factor_rest_length(void);
	inline void use_factor_rest_length(bool value);

};

/**************** Particle Hair Key ****************/

class ParticleHairKey : public Pointer {
public:
	ParticleHairKey(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float time(void);
	inline void time(float value);
	inline float weight(void);
	inline void weight(float value);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline Array<float, 3> co_local(void);
	inline void co_local(float values[3]);

	inline void co_object(Object& object, ParticleSystemModifier& modifier, Particle& particle, float co[3]);
	inline void co_object_set(Object& object, ParticleSystemModifier& modifier, Particle& particle, float co[3]);
};

/**************** Particle Key ****************/

class ParticleKey : public Pointer {
public:
	ParticleKey(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> velocity(void);
	inline void velocity(float values[3]);
	inline Array<float, 4> rotation(void);
	inline void rotation(float values[4]);
	inline Array<float, 3> angular_velocity(void);
	inline void angular_velocity(float values[3]);
	inline float time(void);
	inline void time(float value);

};

/**************** Child Particle ****************/

class ChildParticle : public Pointer {
public:
	ChildParticle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Particle ****************/

class Particle : public Pointer {
public:
	Particle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		hair_keys(ptr_arg),
		particle_keys(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> velocity(void);
	inline void velocity(float values[3]);
	inline Array<float, 3> angular_velocity(void);
	inline void angular_velocity(float values[3]);
	inline Array<float, 4> rotation(void);
	inline void rotation(float values[4]);
	inline Array<float, 3> prev_location(void);
	inline void prev_location(float values[3]);
	inline Array<float, 3> prev_velocity(void);
	inline void prev_velocity(float values[3]);
	inline Array<float, 3> prev_angular_velocity(void);
	inline void prev_angular_velocity(float values[3]);
	inline Array<float, 4> prev_rotation(void);
	inline void prev_rotation(float values[4]);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleHairKey, Particle, hair_keys, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleKey, Particle, particle_keys, true, true, false)
	inline float birth_time(void);
	inline void birth_time(float value);
	inline float lifetime(void);
	inline void lifetime(float value);
	inline float die_time(void);
	inline void die_time(float value);
	inline float size(void);
	inline void size(float value);
	inline bool is_exist(void);
	inline void is_exist(bool value);
	inline bool is_visible(void);
	inline void is_visible(bool value);
	enum alive_state_enum {
		alive_state_DEAD = 1,
		alive_state_UNBORN = 2,
		alive_state_ALIVE = 3,
		alive_state_DYING = 4,
	};
	inline alive_state_enum alive_state(void);
	inline void alive_state(alive_state_enum value);

	inline void uv_on_emitter(ParticleSystemModifier& modifier, float uv[2]);
};

/**************** Particle Instance Object Weight ****************/

class ParticleDupliWeight : public Pointer {
public:
	ParticleDupliWeight(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int count(void);
	inline void count(int value);

};

/**************** Particle System ****************/

class ParticleSystem : public Pointer {
public:
	ParticleSystem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		particles(ptr_arg),
		child_particles(ptr_arg),
		targets(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline ParticleSettings settings(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Particle, ParticleSystem, particles, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ChildParticle, ParticleSystem, child_particles, true, true, false)
	inline int seed(void);
	inline void seed(int value);
	inline int child_seed(void);
	inline void child_seed(int value);
	inline bool is_global_hair(void);
	inline void is_global_hair(bool value);
	inline bool use_hair_dynamics(void);
	inline void use_hair_dynamics(bool value);
	inline ClothModifier cloth(void);
	inline Object reactor_target_object(void);
	inline int reactor_target_particle_system(void);
	inline void reactor_target_particle_system(int value);
	inline bool use_keyed_timing(void);
	inline void use_keyed_timing(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleTarget, ParticleSystem, targets, false, true, true)
	inline ParticleTarget active_particle_target(void);
	inline int active_particle_target_index(void);
	inline void active_particle_target_index(int value);
	inline std::string vertex_group_density(void);
	inline void vertex_group_density(const std::string& value);
	inline bool invert_vertex_group_density(void);
	inline void invert_vertex_group_density(bool value);
	inline std::string vertex_group_velocity(void);
	inline void vertex_group_velocity(const std::string& value);
	inline bool invert_vertex_group_velocity(void);
	inline void invert_vertex_group_velocity(bool value);
	inline std::string vertex_group_length(void);
	inline void vertex_group_length(const std::string& value);
	inline bool invert_vertex_group_length(void);
	inline void invert_vertex_group_length(bool value);
	inline std::string vertex_group_clump(void);
	inline void vertex_group_clump(const std::string& value);
	inline bool invert_vertex_group_clump(void);
	inline void invert_vertex_group_clump(bool value);
	inline std::string vertex_group_kink(void);
	inline void vertex_group_kink(const std::string& value);
	inline bool invert_vertex_group_kink(void);
	inline void invert_vertex_group_kink(bool value);
	inline std::string vertex_group_roughness_1(void);
	inline void vertex_group_roughness_1(const std::string& value);
	inline bool invert_vertex_group_roughness_1(void);
	inline void invert_vertex_group_roughness_1(bool value);
	inline std::string vertex_group_roughness_2(void);
	inline void vertex_group_roughness_2(const std::string& value);
	inline bool invert_vertex_group_roughness_2(void);
	inline void invert_vertex_group_roughness_2(bool value);
	inline std::string vertex_group_roughness_end(void);
	inline void vertex_group_roughness_end(const std::string& value);
	inline bool invert_vertex_group_roughness_end(void);
	inline void invert_vertex_group_roughness_end(bool value);
	inline std::string vertex_group_size(void);
	inline void vertex_group_size(const std::string& value);
	inline bool invert_vertex_group_size(void);
	inline void invert_vertex_group_size(bool value);
	inline std::string vertex_group_tangent(void);
	inline void vertex_group_tangent(const std::string& value);
	inline bool invert_vertex_group_tangent(void);
	inline void invert_vertex_group_tangent(bool value);
	inline std::string vertex_group_rotation(void);
	inline void vertex_group_rotation(const std::string& value);
	inline bool invert_vertex_group_rotation(void);
	inline void invert_vertex_group_rotation(bool value);
	inline std::string vertex_group_field(void);
	inline void vertex_group_field(const std::string& value);
	inline bool invert_vertex_group_field(void);
	inline void invert_vertex_group_field(bool value);
	inline std::string vertex_group_twist(void);
	inline void vertex_group_twist(const std::string& value);
	inline bool invert_vertex_group_twist(void);
	inline void invert_vertex_group_twist(bool value);
	inline PointCache point_cache(void);
	inline bool has_multiple_caches(void);
	inline void has_multiple_caches(bool value);
	inline Object parent(void);
	inline bool is_editable(void);
	inline void is_editable(bool value);
	inline bool is_edited(void);
	inline void is_edited(bool value);
	inline float dt_frac(void);
	inline void dt_frac(float value);

	inline void co_hair(Object& object, int particle_no, int step, float co[3]);
	inline void uv_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int uv_no, float uv[2]);
	inline void mcol_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int vcol_no, float mcol[3]);
};

/**************** Particle Settings Texture Slot ****************/

class ParticleSettingsTextureSlot : public TextureSlot {
public:
	ParticleSettingsTextureSlot(const PointerRNA &ptr_arg) :
		TextureSlot(ptr_arg)
		{}

	enum texture_coords_enum {
		texture_coords_GLOBAL = 8,
		texture_coords_OBJECT = 32,
		texture_coords_UV = 16,
		texture_coords_ORCO = 1,
		texture_coords_STRAND = 8192,
	};
	inline texture_coords_enum texture_coords(void);
	inline void texture_coords(texture_coords_enum value);
	inline Object object(void);
	inline std::string uv_layer(void);
	inline void uv_layer(const std::string& value);
	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};
	inline mapping_x_enum mapping_x(void);
	inline void mapping_x(mapping_x_enum value);
	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};
	inline mapping_y_enum mapping_y(void);
	inline void mapping_y(mapping_y_enum value);
	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};
	inline mapping_z_enum mapping_z(void);
	inline void mapping_z(mapping_z_enum value);
	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};
	inline mapping_enum mapping(void);
	inline void mapping(mapping_enum value);
	inline bool use_map_time(void);
	inline void use_map_time(bool value);
	inline bool use_map_life(void);
	inline void use_map_life(bool value);
	inline bool use_map_density(void);
	inline void use_map_density(bool value);
	inline bool use_map_size(void);
	inline void use_map_size(bool value);
	inline bool use_map_velocity(void);
	inline void use_map_velocity(bool value);
	inline bool use_map_field(void);
	inline void use_map_field(bool value);
	inline bool use_map_gravity(void);
	inline void use_map_gravity(bool value);
	inline bool use_map_damp(void);
	inline void use_map_damp(bool value);
	inline bool use_map_clump(void);
	inline void use_map_clump(bool value);
	inline bool use_map_kink_amp(void);
	inline void use_map_kink_amp(bool value);
	inline bool use_map_kink_freq(void);
	inline void use_map_kink_freq(bool value);
	inline bool use_map_rough(void);
	inline void use_map_rough(bool value);
	inline bool use_map_length(void);
	inline void use_map_length(bool value);
	inline bool use_map_twist(void);
	inline void use_map_twist(bool value);
	inline float time_factor(void);
	inline void time_factor(float value);
	inline float life_factor(void);
	inline void life_factor(float value);
	inline float density_factor(void);
	inline void density_factor(float value);
	inline float size_factor(void);
	inline void size_factor(float value);
	inline float velocity_factor(void);
	inline void velocity_factor(float value);
	inline float field_factor(void);
	inline void field_factor(float value);
	inline float gravity_factor(void);
	inline void gravity_factor(float value);
	inline float damp_factor(void);
	inline void damp_factor(float value);
	inline float length_factor(void);
	inline void length_factor(float value);
	inline float clump_factor(void);
	inline void clump_factor(float value);
	inline float kink_amp_factor(void);
	inline void kink_amp_factor(float value);
	inline float kink_freq_factor(void);
	inline void kink_freq_factor(float value);
	inline float rough_factor(void);
	inline void rough_factor(float value);
	inline float twist_factor(void);
	inline void twist_factor(float value);

};

/**************** Particle Settings ****************/

class ParticleSettings : public ID {
public:
	ParticleSettings(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		texture_slots(ptr_arg),
		instance_weights(ptr_arg)
		{}

	COLLECTION_PROPERTY(ParticleSettingsTextureSlots, ParticleSettingsTextureSlot, ParticleSettings, texture_slots, false, false, false)
	inline Texture active_texture(void);
	inline int active_texture_index(void);
	inline void active_texture_index(int value);
	inline bool is_fluid(void);
	inline void is_fluid(bool value);
	inline bool use_react_start_end(void);
	inline void use_react_start_end(bool value);
	inline bool use_react_multiple(void);
	inline void use_react_multiple(bool value);
	inline bool use_regrow_hair(void);
	inline void use_regrow_hair(bool value);
	inline bool show_unborn(void);
	inline void show_unborn(bool value);
	inline bool use_dead(void);
	inline void use_dead(bool value);
	inline bool use_emit_random(void);
	inline void use_emit_random(bool value);
	inline bool use_even_distribution(void);
	inline void use_even_distribution(bool value);
	inline bool use_die_on_collision(void);
	inline void use_die_on_collision(bool value);
	inline bool use_size_deflect(void);
	inline void use_size_deflect(bool value);
	inline bool use_rotations(void);
	inline void use_rotations(bool value);
	inline bool use_dynamic_rotation(void);
	inline void use_dynamic_rotation(bool value);
	inline bool use_multiply_size_mass(void);
	inline void use_multiply_size_mass(bool value);
	inline bool use_advanced_hair(void);
	inline void use_advanced_hair(bool value);
	inline bool lock_boids_to_surface(void);
	inline void lock_boids_to_surface(bool value);
	inline bool use_hair_bspline(void);
	inline void use_hair_bspline(bool value);
	inline bool invert_grid(void);
	inline void invert_grid(bool value);
	inline bool hexagonal_grid(void);
	inline void hexagonal_grid(bool value);
	inline bool apply_effector_to_children(void);
	inline void apply_effector_to_children(bool value);
	inline bool create_long_hair_children(void);
	inline void create_long_hair_children(bool value);
	inline bool apply_guide_to_children(void);
	inline void apply_guide_to_children(bool value);
	inline bool use_self_effect(void);
	inline void use_self_effect(bool value);
	enum type_enum {
		type_EMITTER = 0,
		type_HAIR = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum emit_from_enum {
		emit_from_VERT = 0,
		emit_from_FACE = 1,
		emit_from_VOLUME = 2,
	};
	inline emit_from_enum emit_from(void);
	inline void emit_from(emit_from_enum value);
	enum distribution_enum {
		distribution_JIT = 0,
		distribution_RAND = 1,
		distribution_GRID = 2,
	};
	inline distribution_enum distribution(void);
	inline void distribution(distribution_enum value);
	enum physics_type_enum {
		physics_type_NO = 0,
		physics_type_NEWTON = 1,
		physics_type_KEYED = 2,
		physics_type_BOIDS = 3,
		physics_type_FLUID = 4,
	};
	inline physics_type_enum physics_type(void);
	inline void physics_type(physics_type_enum value);
	enum rotation_mode_enum {
		rotation_mode_NONE = 0,
		rotation_mode_NOR = 1,
		rotation_mode_NOR_TAN = 9,
		rotation_mode_VEL = 2,
		rotation_mode_GLOB_X = 3,
		rotation_mode_GLOB_Y = 4,
		rotation_mode_GLOB_Z = 5,
		rotation_mode_OB_X = 6,
		rotation_mode_OB_Y = 7,
		rotation_mode_OB_Z = 8,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	enum angular_velocity_mode_enum {
		angular_velocity_mode_NONE = 0,
		angular_velocity_mode_VELOCITY = 1,
		angular_velocity_mode_HORIZONTAL = 3,
		angular_velocity_mode_VERTICAL = 4,
		angular_velocity_mode_GLOBAL_X = 5,
		angular_velocity_mode_GLOBAL_Y = 6,
		angular_velocity_mode_GLOBAL_Z = 7,
		angular_velocity_mode_RAND = 2,
	};
	inline angular_velocity_mode_enum angular_velocity_mode(void);
	inline void angular_velocity_mode(angular_velocity_mode_enum value);
	enum react_event_enum {
		react_event_DEATH = 0,
		react_event_COLLIDE = 1,
		react_event_NEAR = 2,
	};
	inline react_event_enum react_event(void);
	inline void react_event(react_event_enum value);
	inline bool show_guide_hairs(void);
	inline void show_guide_hairs(bool value);
	inline bool show_hair_grid(void);
	inline void show_hair_grid(bool value);
	inline bool show_velocity(void);
	inline void show_velocity(bool value);
	inline bool show_size(void);
	inline void show_size(bool value);
	inline bool show_health(void);
	inline void show_health(bool value);
	inline bool use_absolute_path_time(void);
	inline void use_absolute_path_time(bool value);
	inline bool use_parent_particles(void);
	inline void use_parent_particles(bool value);
	inline bool show_number(void);
	inline void show_number(bool value);
	inline bool use_collection_pick_random(void);
	inline void use_collection_pick_random(bool value);
	inline bool use_collection_count(void);
	inline void use_collection_count(bool value);
	inline bool use_global_instance(void);
	inline void use_global_instance(bool value);
	inline bool use_rotation_instance(void);
	inline void use_rotation_instance(bool value);
	inline bool use_scale_instance(void);
	inline void use_scale_instance(bool value);
	inline bool use_render_adaptive(void);
	inline void use_render_adaptive(bool value);
	inline bool use_velocity_length(void);
	inline void use_velocity_length(bool value);
	inline bool use_whole_collection(void);
	inline void use_whole_collection(bool value);
	inline bool use_strand_primitive(void);
	inline void use_strand_primitive(bool value);
	enum display_method_enum {
		display_method_NONE = 0,
		display_method_RENDER = 10,
		display_method_DOT = 1,
		display_method_CIRC = 2,
		display_method_CROSS = 3,
		display_method_AXIS = 4,
	};
	inline display_method_enum display_method(void);
	inline void display_method(display_method_enum value);
	enum render_type_enum {
		render_type_NONE = 0,
		render_type_HALO = 1,
		render_type_LINE = 5,
		render_type_PATH = 6,
		render_type_OBJECT = 7,
		render_type_COLLECTION = 8,
	};
	inline render_type_enum render_type(void);
	inline void render_type(render_type_enum value);
	enum display_color_enum {
		display_color_NONE = 0,
		display_color_MATERIAL = 1,
		display_color_VELOCITY = 2,
		display_color_ACCELERATION = 3,
	};
	inline display_color_enum display_color(void);
	inline void display_color(display_color_enum value);
	inline float display_size(void);
	inline void display_size(float value);
	enum child_type_enum {
		child_type_NONE = 0,
		child_type_SIMPLE = 1,
		child_type_INTERPOLATED = 2,
	};
	inline child_type_enum child_type(void);
	inline void child_type(child_type_enum value);
	inline int display_step(void);
	inline void display_step(int value);
	inline int render_step(void);
	inline void render_step(int value);
	inline int hair_step(void);
	inline void hair_step(int value);
	inline float bending_random(void);
	inline void bending_random(float value);
	inline int keys_step(void);
	inline void keys_step(int value);
	inline int adaptive_angle(void);
	inline void adaptive_angle(int value);
	inline int adaptive_pixel(void);
	inline void adaptive_pixel(int value);
	inline int display_percentage(void);
	inline void display_percentage(int value);
	inline int material(void);
	inline void material(int value);
	enum material_slot_enum {
		material_slot_DUMMY = 0,
	};
	inline material_slot_enum material_slot(void);
	inline void material_slot(material_slot_enum value);
	enum integrator_enum {
		integrator_EULER = 0,
		integrator_VERLET = 3,
		integrator_MIDPOINT = 1,
		integrator_RK4 = 2,
	};
	inline integrator_enum integrator(void);
	inline void integrator(integrator_enum value);
	enum kink_enum {
		kink_NO = 0,
		kink_CURL = 1,
		kink_RADIAL = 2,
		kink_WAVE = 3,
		kink_BRAID = 4,
		kink_SPIRAL = 5,
	};
	inline kink_enum kink(void);
	inline void kink(kink_enum value);
	enum kink_axis_enum {
		kink_axis_X = 0,
		kink_axis_Y = 1,
		kink_axis_Z = 2,
	};
	inline kink_axis_enum kink_axis(void);
	inline void kink_axis(kink_axis_enum value);
	inline float color_maximum(void);
	inline void color_maximum(float value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline float frame_end(void);
	inline void frame_end(float value);
	inline float lifetime(void);
	inline void lifetime(float value);
	inline float lifetime_random(void);
	inline void lifetime_random(float value);
	inline float time_tweak(void);
	inline void time_tweak(float value);
	inline float timestep(void);
	inline void timestep(float value);
	inline bool use_adaptive_subframes(void);
	inline void use_adaptive_subframes(bool value);
	inline int subframes(void);
	inline void subframes(int value);
	inline float courant_target(void);
	inline void courant_target(float value);
	inline float jitter_factor(void);
	inline void jitter_factor(float value);
	inline float effect_hair(void);
	inline void effect_hair(float value);
	inline int count(void);
	inline void count(int value);
	inline int userjit(void);
	inline void userjit(int value);
	inline int grid_resolution(void);
	inline void grid_resolution(int value);
	inline float grid_random(void);
	inline void grid_random(float value);
	inline int effector_amount(void);
	inline void effector_amount(int value);
	inline float normal_factor(void);
	inline void normal_factor(float value);
	inline float object_factor(void);
	inline void object_factor(float value);
	inline float factor_random(void);
	inline void factor_random(float value);
	inline float particle_factor(void);
	inline void particle_factor(float value);
	inline float tangent_factor(void);
	inline void tangent_factor(float value);
	inline float tangent_phase(void);
	inline void tangent_phase(float value);
	inline float reactor_factor(void);
	inline void reactor_factor(float value);
	inline Array<float, 3> object_align_factor(void);
	inline void object_align_factor(float values[3]);
	inline float angular_velocity_factor(void);
	inline void angular_velocity_factor(float value);
	inline float phase_factor(void);
	inline void phase_factor(float value);
	inline float rotation_factor_random(void);
	inline void rotation_factor_random(float value);
	inline float phase_factor_random(void);
	inline void phase_factor_random(float value);
	inline float hair_length(void);
	inline void hair_length(float value);
	inline float mass(void);
	inline void mass(float value);
	inline float particle_size(void);
	inline void particle_size(float value);
	inline float size_random(void);
	inline void size_random(float value);
	inline Collection collision_collection(void);
	inline float drag_factor(void);
	inline void drag_factor(float value);
	inline float brownian_factor(void);
	inline void brownian_factor(float value);
	inline float damping(void);
	inline void damping(float value);
	inline float length_random(void);
	inline void length_random(float value);
	inline int child_percent(void);
	inline void child_percent(int value);
	inline int rendered_child_count(void);
	inline void rendered_child_count(int value);
	inline float virtual_parents(void);
	inline void virtual_parents(float value);
	inline float child_size(void);
	inline void child_size(float value);
	inline float child_size_random(void);
	inline void child_size_random(float value);
	inline float child_radius(void);
	inline void child_radius(float value);
	inline float child_roundness(void);
	inline void child_roundness(float value);
	inline float clump_factor(void);
	inline void clump_factor(float value);
	inline float clump_shape(void);
	inline void clump_shape(float value);
	inline bool use_clump_curve(void);
	inline void use_clump_curve(bool value);
	inline CurveMapping clump_curve(void);
	inline bool use_clump_noise(void);
	inline void use_clump_noise(bool value);
	inline float clump_noise_size(void);
	inline void clump_noise_size(float value);
	inline float kink_amplitude(void);
	inline void kink_amplitude(float value);
	inline float kink_amplitude_clump(void);
	inline void kink_amplitude_clump(float value);
	inline float kink_amplitude_random(void);
	inline void kink_amplitude_random(float value);
	inline float kink_frequency(void);
	inline void kink_frequency(float value);
	inline float kink_shape(void);
	inline void kink_shape(float value);
	inline float kink_flat(void);
	inline void kink_flat(float value);
	inline int kink_extra_steps(void);
	inline void kink_extra_steps(int value);
	inline float kink_axis_random(void);
	inline void kink_axis_random(float value);
	inline float roughness_1(void);
	inline void roughness_1(float value);
	inline float roughness_1_size(void);
	inline void roughness_1_size(float value);
	inline float roughness_2(void);
	inline void roughness_2(float value);
	inline float roughness_2_size(void);
	inline void roughness_2_size(float value);
	inline float roughness_2_threshold(void);
	inline void roughness_2_threshold(float value);
	inline float roughness_endpoint(void);
	inline void roughness_endpoint(float value);
	inline float roughness_end_shape(void);
	inline void roughness_end_shape(float value);
	inline bool use_roughness_curve(void);
	inline void use_roughness_curve(bool value);
	inline CurveMapping roughness_curve(void);
	inline float child_length(void);
	inline void child_length(float value);
	inline float child_length_threshold(void);
	inline void child_length_threshold(float value);
	inline float child_parting_factor(void);
	inline void child_parting_factor(float value);
	inline float child_parting_min(void);
	inline void child_parting_min(float value);
	inline float child_parting_max(void);
	inline void child_parting_max(float value);
	inline float branch_threshold(void);
	inline void branch_threshold(float value);
	inline float line_length_tail(void);
	inline void line_length_tail(float value);
	inline float line_length_head(void);
	inline void line_length_head(float value);
	inline float path_start(void);
	inline void path_start(float value);
	inline float path_end(void);
	inline void path_end(float value);
	inline int trail_count(void);
	inline void trail_count(int value);
	inline int keyed_loops(void);
	inline void keyed_loops(int value);
	inline bool use_modifier_stack(void);
	inline void use_modifier_stack(bool value);
	inline Collection instance_collection(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ParticleDupliWeight, ParticleSettings, instance_weights, false, true, true)
	inline ParticleDupliWeight active_instanceweight(void);
	inline int active_instanceweight_index(void);
	inline void active_instanceweight_index(int value);
	inline Object instance_object(void);
	inline BoidSettings boids(void);
	inline SPHFluidSettings fluid(void);
	inline EffectorWeights effector_weights(void);
	inline AnimData animation_data(void);
	inline FieldSettings force_field_1(void);
	inline FieldSettings force_field_2(void);
	inline float twist(void);
	inline void twist(float value);
	inline bool use_twist_curve(void);
	inline void use_twist_curve(bool value);
	inline CurveMapping twist_curve(void);
	inline bool use_close_tip(void);
	inline void use_close_tip(bool value);
	inline float shape(void);
	inline void shape(float value);
	inline float root_radius(void);
	inline void root_radius(float value);
	inline float tip_radius(void);
	inline void tip_radius(float value);
	inline float radius_scale(void);
	inline void radius_scale(float value);

};

/**************** Point ****************/

class Point : public Pointer {
public:
	Point(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> co(void);
	inline void co(float values[3]);
	inline float radius(void);
	inline void radius(float value);
	inline int index(void);
	inline void index(int value);

};

/**************** Point Cloud ****************/

class PointCloud : public ID {
public:
	PointCloud(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		points(ptr_arg),
		materials(ptr_arg),
		attributes(ptr_arg),
		color_attributes(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Point, PointCloud, points, true, true, false)
	COLLECTION_PROPERTY(IDMaterials, Material, PointCloud, materials, true, true, true)
	COLLECTION_PROPERTY(AttributeGroup, Attribute, PointCloud, attributes, true, false, false)
	COLLECTION_PROPERTY(AttributeGroup, Attribute, PointCloud, color_attributes, true, false, false)
	inline AnimData animation_data(void);

};

/**************** Pose ****************/

class Pose : public Pointer {
public:
	Pose(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		bones(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, PoseBone, Pose, bones, false, true, true)
	enum ik_solver_enum {
		ik_solver_LEGACY = 0,
		ik_solver_ITASC = 1,
	};
	inline ik_solver_enum ik_solver(void);
	inline void ik_solver(ik_solver_enum value);
	inline IKParam ik_param(void);
	inline bool use_mirror_x(void);
	inline void use_mirror_x(bool value);
	inline bool use_mirror_relative(void);
	inline void use_mirror_relative(bool value);
	inline bool use_auto_ik(void);
	inline void use_auto_ik(bool value);
	inline AnimViz animation_visualization(void);

	inline void apply_pose_from_action(Context C, Action& action, float evaluation_time);
	inline void blend_pose_from_action(Context C, Action& action, float blend_factor, float evaluation_time);
	inline void backup_create(Action& action);
	inline bool backup_restore(Context C);
	inline void backup_clear();
};

/**************** Pose Bone ****************/

class PoseBone : public Pointer {
public:
	PoseBone(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		constraints(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(PoseBoneConstraints, Constraint, PoseBone, constraints, false, true, true)
	inline std::string name(void);
	inline void name(const std::string& value);
	inline MotionPath motion_path(void);
	inline Bone bone(void);
	inline PoseBone parent(void);
	inline PoseBone child(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 3> scale(void);
	inline void scale(float values[3]);
	inline Array<float, 4> rotation_quaternion(void);
	inline void rotation_quaternion(float values[4]);
	inline Array<float, 4> rotation_axis_angle(void);
	inline void rotation_axis_angle(float values[4]);
	inline Array<float, 3> rotation_euler(void);
	inline void rotation_euler(float values[3]);
	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	inline float bbone_rollin(void);
	inline void bbone_rollin(float value);
	inline float bbone_rollout(void);
	inline void bbone_rollout(float value);
	inline float bbone_curveinx(void);
	inline void bbone_curveinx(float value);
	inline float bbone_curveinz(void);
	inline void bbone_curveinz(float value);
	inline float bbone_curveoutx(void);
	inline void bbone_curveoutx(float value);
	inline float bbone_curveoutz(void);
	inline void bbone_curveoutz(float value);
	inline float bbone_easein(void);
	inline void bbone_easein(float value);
	inline float bbone_easeout(void);
	inline void bbone_easeout(float value);
	inline Array<float, 3> bbone_scalein(void);
	inline void bbone_scalein(float values[3]);
	inline Array<float, 3> bbone_scaleout(void);
	inline void bbone_scaleout(float values[3]);
	inline PoseBone bbone_custom_handle_start(void);
	inline PoseBone bbone_custom_handle_end(void);
	inline Array<float, 16> matrix_channel(void);
	inline void matrix_channel(float values[16]);
	inline Array<float, 16> matrix_basis(void);
	inline void matrix_basis(float values[16]);
	inline Array<float, 16> matrix(void);
	inline void matrix(float values[16]);
	inline Array<float, 3> head(void);
	inline void head(float values[3]);
	inline Array<float, 3> tail(void);
	inline void tail(float values[3]);
	inline float length(void);
	inline void length(float value);
	inline bool is_in_ik_chain(void);
	inline void is_in_ik_chain(bool value);
	inline bool lock_ik_x(void);
	inline void lock_ik_x(bool value);
	inline bool lock_ik_y(void);
	inline void lock_ik_y(bool value);
	inline bool lock_ik_z(void);
	inline void lock_ik_z(bool value);
	inline bool use_ik_limit_x(void);
	inline void use_ik_limit_x(bool value);
	inline bool use_ik_limit_y(void);
	inline void use_ik_limit_y(bool value);
	inline bool use_ik_limit_z(void);
	inline void use_ik_limit_z(bool value);
	inline bool use_ik_rotation_control(void);
	inline void use_ik_rotation_control(bool value);
	inline bool use_ik_linear_control(void);
	inline void use_ik_linear_control(bool value);
	inline float ik_min_x(void);
	inline void ik_min_x(float value);
	inline float ik_max_x(void);
	inline void ik_max_x(float value);
	inline float ik_min_y(void);
	inline void ik_min_y(float value);
	inline float ik_max_y(void);
	inline void ik_max_y(float value);
	inline float ik_min_z(void);
	inline void ik_min_z(float value);
	inline float ik_max_z(void);
	inline void ik_max_z(float value);
	inline float ik_stiffness_x(void);
	inline void ik_stiffness_x(float value);
	inline float ik_stiffness_y(void);
	inline void ik_stiffness_y(float value);
	inline float ik_stiffness_z(void);
	inline void ik_stiffness_z(float value);
	inline float ik_stretch(void);
	inline void ik_stretch(float value);
	inline float ik_rotation_weight(void);
	inline void ik_rotation_weight(float value);
	inline float ik_linear_weight(void);
	inline void ik_linear_weight(float value);
	inline Object custom_shape(void);
	inline Array<float, 3> custom_shape_scale_xyz(void);
	inline void custom_shape_scale_xyz(float values[3]);
	inline Array<float, 3> custom_shape_translation(void);
	inline void custom_shape_translation(float values[3]);
	inline Array<float, 3> custom_shape_rotation_euler(void);
	inline void custom_shape_rotation_euler(float values[3]);
	inline bool use_custom_shape_bone_size(void);
	inline void use_custom_shape_bone_size(bool value);
	inline PoseBone custom_shape_transform(void);
	inline BoneColor color(void);
	inline Array<bool, 3> lock_location(void);
	inline void lock_location(bool values[3]);
	inline Array<bool, 3> lock_rotation(void);
	inline void lock_rotation(bool values[3]);
	inline bool lock_rotation_w(void);
	inline void lock_rotation_w(bool value);
	inline bool lock_rotations_4d(void);
	inline void lock_rotations_4d(bool value);
	inline Array<bool, 3> lock_scale(void);
	inline void lock_scale(bool values[3]);

	inline float evaluate_envelope(float point[3]);
	inline void bbone_segment_index(float point[3], int *index, float *blend_next);
	inline void bbone_segment_matrix(float matrix_return[16], int index, bool rest);
	inline void compute_bbone_handles(float handle1[3], float *roll1, float handle2[3], float *roll2, bool rest, bool ease, bool offsets);
};

/**************** IKParam ****************/

class IKParam : public Pointer {
public:
	IKParam(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum ik_solver_enum {
		ik_solver_LEGACY = 0,
		ik_solver_ITASC = 1,
	};
	inline ik_solver_enum ik_solver(void);
	inline void ik_solver(ik_solver_enum value);

};

/**************** bItasc ****************/

class Itasc : public IKParam {
public:
	Itasc(const PointerRNA &ptr_arg) :
		IKParam(ptr_arg)
		{}

	inline float precision(void);
	inline void precision(float value);
	inline int iterations(void);
	inline void iterations(int value);
	inline int step_count(void);
	inline void step_count(int value);
	inline bool translate_root_bones(void);
	inline void translate_root_bones(bool value);
	enum mode_enum {
		mode_ANIMATION = 0,
		mode_SIMULATION = 8,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum reiteration_method_enum {
		reiteration_method_NEVER = 0,
		reiteration_method_INITIAL = 2,
		reiteration_method_ALWAYS = 6,
	};
	inline reiteration_method_enum reiteration_method(void);
	inline void reiteration_method(reiteration_method_enum value);
	inline bool use_auto_step(void);
	inline void use_auto_step(bool value);
	inline float step_min(void);
	inline void step_min(float value);
	inline float step_max(void);
	inline void step_max(float value);
	inline float feedback(void);
	inline void feedback(float value);
	inline float velocity_max(void);
	inline void velocity_max(float value);
	enum solver_enum {
		solver_SDLS = 0,
		solver_DLS = 1,
	};
	inline solver_enum solver(void);
	inline void solver(solver_enum value);
	inline float damping_max(void);
	inline void damping_max(float value);
	inline float damping_epsilon(void);
	inline void damping_epsilon(float value);

};

/**************** CurveProfilePoint ****************/

class CurveProfilePoint : public Pointer {
public:
	CurveProfilePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> location(void);
	inline void location(float values[2]);
	enum handle_type_1_enum {
		handle_type_1_AUTO = 1,
		handle_type_1_VECTOR = 2,
		handle_type_1_FREE = 0,
		handle_type_1_ALIGN = 3,
	};
	inline handle_type_1_enum handle_type_1(void);
	inline void handle_type_1(handle_type_1_enum value);
	enum handle_type_2_enum {
		handle_type_2_AUTO = 1,
		handle_type_2_VECTOR = 2,
		handle_type_2_FREE = 0,
		handle_type_2_ALIGN = 3,
	};
	inline handle_type_2_enum handle_type_2(void);
	inline void handle_type_2(handle_type_2_enum value);
	inline bool select(void);
	inline void select(bool value);

};

/**************** CurveProfile ****************/

class CurveProfile : public Pointer {
public:
	CurveProfile(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg),
		segments(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum preset_enum {
		preset_LINE = 0,
		preset_SUPPORTS = 1,
		preset_CORNICE = 2,
		preset_CROWN = 3,
		preset_STEPS = 4,
	};
	inline preset_enum preset(void);
	inline void preset(preset_enum value);
	inline bool use_clip(void);
	inline void use_clip(bool value);
	inline bool use_sample_straight_edges(void);
	inline void use_sample_straight_edges(bool value);
	inline bool use_sample_even_lengths(void);
	inline void use_sample_even_lengths(bool value);
	COLLECTION_PROPERTY(CurveProfilePoints, CurveProfilePoint, CurveProfile, points, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, CurveProfilePoint, CurveProfile, segments, true, true, false)

	inline void update();
	inline void reset_view();
	inline void initialize(int totsegments);
	inline void evaluate(float length_portion, float location[2]);
};

/**************** LightProbe ****************/

class LightProbe : public ID {
public:
	LightProbe(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	enum type_enum {
		type_SPHERE = 0,
		type_PLANE = 1,
		type_VOLUME = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline float clip_start(void);
	inline void clip_start(float value);
	inline float clip_end(void);
	inline void clip_end(float value);
	inline bool show_clip(void);
	inline void show_clip(bool value);
	enum influence_type_enum {
		influence_type_ELIPSOID = 0,
		influence_type_BOX = 1,
	};
	inline influence_type_enum influence_type(void);
	inline void influence_type(influence_type_enum value);
	inline bool show_influence(void);
	inline void show_influence(bool value);
	inline float influence_distance(void);
	inline void influence_distance(float value);
	inline float falloff(void);
	inline void falloff(float value);
	inline bool use_custom_parallax(void);
	inline void use_custom_parallax(bool value);
	inline bool show_parallax(void);
	inline void show_parallax(bool value);
	enum parallax_type_enum {
		parallax_type_ELIPSOID = 0,
		parallax_type_BOX = 1,
	};
	inline parallax_type_enum parallax_type(void);
	inline void parallax_type(parallax_type_enum value);
	inline float parallax_distance(void);
	inline void parallax_distance(float value);
	inline int grid_resolution_x(void);
	inline void grid_resolution_x(int value);
	inline int grid_resolution_y(void);
	inline void grid_resolution_y(int value);
	inline int grid_resolution_z(void);
	inline void grid_resolution_z(int value);
	inline float grid_normal_bias(void);
	inline void grid_normal_bias(float value);
	inline float grid_view_bias(void);
	inline void grid_view_bias(float value);
	inline float grid_irradiance_smoothing(void);
	inline void grid_irradiance_smoothing(float value);
	inline int grid_bake_samples(void);
	inline void grid_bake_samples(int value);
	inline float grid_surface_bias(void);
	inline void grid_surface_bias(float value);
	inline float grid_escape_bias(void);
	inline void grid_escape_bias(float value);
	inline float surfel_density(void);
	inline void surfel_density(float value);
	inline float grid_validity_threshold(void);
	inline void grid_validity_threshold(float value);
	inline float grid_dilation_threshold(void);
	inline void grid_dilation_threshold(float value);
	inline float grid_dilation_radius(void);
	inline void grid_dilation_radius(float value);
	inline bool grid_capture_world(void);
	inline void grid_capture_world(bool value);
	inline bool grid_capture_indirect(void);
	inline void grid_capture_indirect(bool value);
	inline bool grid_capture_emission(void);
	inline void grid_capture_emission(bool value);
	inline float grid_clamp_direct(void);
	inline void grid_clamp_direct(float value);
	inline float grid_clamp_indirect(void);
	inline void grid_clamp_indirect(float value);
	inline float visibility_buffer_bias(void);
	inline void visibility_buffer_bias(float value);
	inline float visibility_bleed_bias(void);
	inline void visibility_bleed_bias(float value);
	inline float visibility_blur(void);
	inline void visibility_blur(float value);
	inline float intensity(void);
	inline void intensity(float value);
	inline Collection visibility_collection(void);
	inline bool invert_visibility_collection(void);
	inline void invert_visibility_collection(bool value);
	inline bool show_data(void);
	inline void show_data(bool value);
	inline bool use_data_display(void);
	inline void use_data_display(bool value);
	inline float data_display_size(void);
	inline void data_display_size(float value);
	inline AnimData animation_data(void);

};

/**************** Render Engine ****************/

class RenderEngine : public Pointer {
public:
	RenderEngine(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_animation(void);
	inline void is_animation(bool value);
	inline bool is_preview(void);
	inline void is_preview(bool value);
	inline Object camera_override(void);
	inline Array<bool, 20> layer_override(void);
	inline void layer_override(bool values[20]);
	inline int resolution_x(void);
	inline void resolution_x(int value);
	inline int resolution_y(void);
	inline void resolution_y(int value);
	inline std::string temporary_directory(void);
	inline void temporary_directory(const std::string& value);
	inline RenderSettings render(void);
	inline bool use_highlight_tiles(void);
	inline void use_highlight_tiles(bool value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline bool bl_use_preview(void);
	inline void bl_use_preview(bool value);
	inline bool bl_use_postprocess(void);
	inline void bl_use_postprocess(bool value);
	inline bool bl_use_eevee_viewport(void);
	inline void bl_use_eevee_viewport(bool value);
	inline bool bl_use_custom_freestyle(void);
	inline void bl_use_custom_freestyle(bool value);
	inline bool bl_use_image_save(void);
	inline void bl_use_image_save(bool value);
	inline bool bl_use_gpu_context(void);
	inline void bl_use_gpu_context(bool value);
	inline bool bl_use_shading_nodes_custom(void);
	inline void bl_use_shading_nodes_custom(bool value);
	inline bool bl_use_spherical_stereo(void);
	inline void bl_use_spherical_stereo(bool value);
	inline bool bl_use_stereo_viewport(void);
	inline void bl_use_stereo_viewport(bool value);
	inline bool bl_use_alembic_procedural(void);
	inline void bl_use_alembic_procedural(bool value);
	inline bool bl_use_materialx(void);
	inline void bl_use_materialx(bool value);

	inline void tag_redraw();
	inline void tag_update();
	inline RenderResult begin_result(int x, int y, int w, int h, const char * layer, const char * view);
	inline void update_result(RenderResult& result);
	inline void end_result(RenderResult& result, bool cancel, bool highlight, bool do_merge_results);
	inline void add_pass(const char * name, int channels, const char * chan_id, const char * layer);
	inline RenderResult get_result();
	inline bool test_break();
	inline RenderPass pass_by_index_get(const char * layer, int index);
	inline const char * active_view_get();
	inline void active_view_set(const char * view);
	inline float camera_shift_x(Object& camera, bool use_spherical_stereo);
	inline void camera_model_matrix(Object& camera, bool use_spherical_stereo, float r_model_matrix[16]);
	inline bool use_spherical_stereo(Object& camera);
	inline void update_stats(const char * stats, const char * info);
	inline void frame_set(int frame, float subframe);
	inline void update_progress(float progress);
	inline void update_memory_stats(float memory_used, float memory_peak);
	inline void report(int type, const char * message);
	inline void error_set(const char * message);
	inline void bind_display_space_shader(Scene& scene);
	inline void unbind_display_space_shader();
	inline bool support_display_space_shader(Scene& scene);
	inline int get_preview_pixel_size(Scene& scene);
	inline void free_blender_memory();
	inline void tile_highlight_set(int x, int y, int width, int height, bool highlight);
	inline void tile_highlight_clear_all();
	inline void register_pass(Scene& scene, ViewLayer& view_layer, const char * name, int channels, const char * chanid, eNodeSocketDatatype type);
};

/**************** Hydra Render Engine ****************/

class HydraRenderEngine : public RenderEngine {
public:
	HydraRenderEngine(const PointerRNA &ptr_arg) :
		RenderEngine(ptr_arg)
		{}


};

/**************** Render Result ****************/

class RenderResult : public Pointer {
public:
	RenderResult(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		layers(ptr_arg),
		views(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int resolution_x(void);
	inline void resolution_x(int value);
	inline int resolution_y(void);
	inline void resolution_y(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, RenderLayer, RenderResult, layers, false, false, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, RenderView, RenderResult, views, false, false, false)

	inline void load_from_file(const char * filepath);
	inline void stamp_data_add_field(const char * field, const char * value);
};

/**************** Render View ****************/

class RenderView : public Pointer {
public:
	RenderView(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Render Layer ****************/

class RenderLayer : public Pointer {
public:
	RenderLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		passes(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool use_solid(void);
	inline void use_solid(bool value);
	inline bool use_sky(void);
	inline void use_sky(bool value);
	inline bool use_ao(void);
	inline void use_ao(bool value);
	inline bool use_strand(void);
	inline void use_strand(bool value);
	inline bool use_volumes(void);
	inline void use_volumes(bool value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline bool use_pass_combined(void);
	inline void use_pass_combined(bool value);
	inline bool use_pass_z(void);
	inline void use_pass_z(bool value);
	inline bool use_pass_vector(void);
	inline void use_pass_vector(bool value);
	inline bool use_pass_position(void);
	inline void use_pass_position(bool value);
	inline bool use_pass_normal(void);
	inline void use_pass_normal(bool value);
	inline bool use_pass_uv(void);
	inline void use_pass_uv(bool value);
	inline bool use_pass_mist(void);
	inline void use_pass_mist(bool value);
	inline bool use_pass_object_index(void);
	inline void use_pass_object_index(bool value);
	inline bool use_pass_material_index(void);
	inline void use_pass_material_index(bool value);
	inline bool use_pass_shadow(void);
	inline void use_pass_shadow(bool value);
	inline bool use_pass_ambient_occlusion(void);
	inline void use_pass_ambient_occlusion(bool value);
	inline bool use_pass_emit(void);
	inline void use_pass_emit(bool value);
	inline bool use_pass_environment(void);
	inline void use_pass_environment(bool value);
	inline bool use_pass_diffuse_direct(void);
	inline void use_pass_diffuse_direct(bool value);
	inline bool use_pass_diffuse_indirect(void);
	inline void use_pass_diffuse_indirect(bool value);
	inline bool use_pass_diffuse_color(void);
	inline void use_pass_diffuse_color(bool value);
	inline bool use_pass_glossy_direct(void);
	inline void use_pass_glossy_direct(bool value);
	inline bool use_pass_glossy_indirect(void);
	inline void use_pass_glossy_indirect(bool value);
	inline bool use_pass_glossy_color(void);
	inline void use_pass_glossy_color(bool value);
	inline bool use_pass_transmission_direct(void);
	inline void use_pass_transmission_direct(bool value);
	inline bool use_pass_transmission_indirect(void);
	inline void use_pass_transmission_indirect(bool value);
	inline bool use_pass_transmission_color(void);
	inline void use_pass_transmission_color(bool value);
	inline bool use_pass_subsurface_direct(void);
	inline void use_pass_subsurface_direct(bool value);
	inline bool use_pass_subsurface_indirect(void);
	inline void use_pass_subsurface_indirect(bool value);
	inline bool use_pass_subsurface_color(void);
	inline void use_pass_subsurface_color(bool value);
	COLLECTION_PROPERTY(RenderPasses, RenderPass, RenderLayer, passes, false, false, false)

	inline void load_from_file(const char * filepath, int x, int y);
};

/**************** Render Pass ****************/

class RenderPass : public Pointer {
public:
	RenderPass(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string fullname(void);
	inline void fullname(const std::string& value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string channel_id(void);
	inline void channel_id(const std::string& value);
	inline int channels(void);
	inline void channels(int value);
	inline DynamicArray<float> rect(void);
	inline void rect(float values[]);
	inline int view_id(void);
	inline void view_id(int value);

};

/**************** Rigid Body World ****************/

class RigidBodyWorld : public Pointer {
public:
	RigidBodyWorld(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Collection collection(void);
	inline Collection constraints(void);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline float time_scale(void);
	inline void time_scale(float value);
	inline int substeps_per_frame(void);
	inline void substeps_per_frame(int value);
	inline int solver_iterations(void);
	inline void solver_iterations(int value);
	inline bool use_split_impulse(void);
	inline void use_split_impulse(bool value);
	inline PointCache point_cache(void);
	inline EffectorWeights effector_weights(void);

	inline void convex_sweep_test(Object& object, float start[3], float end[3], float object_location[3], float hitpoint[3], float normal[3], int *has_hit);
};

/**************** Rigid Body Object ****************/

class RigidBodyObject : public Pointer {
public:
	RigidBodyObject(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_ACTIVE = 0,
		type_PASSIVE = 1,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum mesh_source_enum {
		mesh_source_BASE = 0,
		mesh_source_DEFORM = 1,
		mesh_source_FINAL = 2,
	};
	inline mesh_source_enum mesh_source(void);
	inline void mesh_source(mesh_source_enum value);
	inline bool enabled(void);
	inline void enabled(bool value);
	enum collision_shape_enum {
		collision_shape_BOX = 0,
		collision_shape_SPHERE = 1,
		collision_shape_CAPSULE = 2,
		collision_shape_CYLINDER = 3,
		collision_shape_CONE = 4,
		collision_shape_CONVEX_HULL = 5,
		collision_shape_MESH = 6,
		collision_shape_COMPOUND = 7,
	};
	inline collision_shape_enum collision_shape(void);
	inline void collision_shape(collision_shape_enum value);
	inline bool kinematic(void);
	inline void kinematic(bool value);
	inline bool use_deform(void);
	inline void use_deform(bool value);
	inline float mass(void);
	inline void mass(float value);
	inline bool use_deactivation(void);
	inline void use_deactivation(bool value);
	inline bool use_start_deactivated(void);
	inline void use_start_deactivated(bool value);
	inline float deactivate_linear_velocity(void);
	inline void deactivate_linear_velocity(float value);
	inline float deactivate_angular_velocity(void);
	inline void deactivate_angular_velocity(float value);
	inline float linear_damping(void);
	inline void linear_damping(float value);
	inline float angular_damping(void);
	inline void angular_damping(float value);
	inline float friction(void);
	inline void friction(float value);
	inline float restitution(void);
	inline void restitution(float value);
	inline bool use_margin(void);
	inline void use_margin(bool value);
	inline float collision_margin(void);
	inline void collision_margin(float value);
	inline Array<bool, 20> collision_collections(void);
	inline void collision_collections(bool values[20]);

};

/**************** Rigid Body Constraint ****************/

class RigidBodyConstraint : public Pointer {
public:
	RigidBodyConstraint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_FIXED = 8,
		type_POINT = 0,
		type_HINGE = 1,
		type_SLIDER = 3,
		type_PISTON = 9,
		type_GENERIC = 5,
		type_GENERIC_SPRING = 6,
		type_MOTOR = 11,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum spring_type_enum {
		spring_type_SPRING1 = 0,
		spring_type_SPRING2 = 1,
	};
	inline spring_type_enum spring_type(void);
	inline void spring_type(spring_type_enum value);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline bool disable_collisions(void);
	inline void disable_collisions(bool value);
	inline Object object1(void);
	inline Object object2(void);
	inline bool use_breaking(void);
	inline void use_breaking(bool value);
	inline float breaking_threshold(void);
	inline void breaking_threshold(float value);
	inline bool use_override_solver_iterations(void);
	inline void use_override_solver_iterations(bool value);
	inline int solver_iterations(void);
	inline void solver_iterations(int value);
	inline bool use_limit_lin_x(void);
	inline void use_limit_lin_x(bool value);
	inline bool use_limit_lin_y(void);
	inline void use_limit_lin_y(bool value);
	inline bool use_limit_lin_z(void);
	inline void use_limit_lin_z(bool value);
	inline bool use_limit_ang_x(void);
	inline void use_limit_ang_x(bool value);
	inline bool use_limit_ang_y(void);
	inline void use_limit_ang_y(bool value);
	inline bool use_limit_ang_z(void);
	inline void use_limit_ang_z(bool value);
	inline bool use_spring_x(void);
	inline void use_spring_x(bool value);
	inline bool use_spring_y(void);
	inline void use_spring_y(bool value);
	inline bool use_spring_z(void);
	inline void use_spring_z(bool value);
	inline bool use_spring_ang_x(void);
	inline void use_spring_ang_x(bool value);
	inline bool use_spring_ang_y(void);
	inline void use_spring_ang_y(bool value);
	inline bool use_spring_ang_z(void);
	inline void use_spring_ang_z(bool value);
	inline bool use_motor_lin(void);
	inline void use_motor_lin(bool value);
	inline bool use_motor_ang(void);
	inline void use_motor_ang(bool value);
	inline float limit_lin_x_lower(void);
	inline void limit_lin_x_lower(float value);
	inline float limit_lin_x_upper(void);
	inline void limit_lin_x_upper(float value);
	inline float limit_lin_y_lower(void);
	inline void limit_lin_y_lower(float value);
	inline float limit_lin_y_upper(void);
	inline void limit_lin_y_upper(float value);
	inline float limit_lin_z_lower(void);
	inline void limit_lin_z_lower(float value);
	inline float limit_lin_z_upper(void);
	inline void limit_lin_z_upper(float value);
	inline float limit_ang_x_lower(void);
	inline void limit_ang_x_lower(float value);
	inline float limit_ang_x_upper(void);
	inline void limit_ang_x_upper(float value);
	inline float limit_ang_y_lower(void);
	inline void limit_ang_y_lower(float value);
	inline float limit_ang_y_upper(void);
	inline void limit_ang_y_upper(float value);
	inline float limit_ang_z_lower(void);
	inline void limit_ang_z_lower(float value);
	inline float limit_ang_z_upper(void);
	inline void limit_ang_z_upper(float value);
	inline float spring_stiffness_x(void);
	inline void spring_stiffness_x(float value);
	inline float spring_stiffness_y(void);
	inline void spring_stiffness_y(float value);
	inline float spring_stiffness_z(void);
	inline void spring_stiffness_z(float value);
	inline float spring_stiffness_ang_x(void);
	inline void spring_stiffness_ang_x(float value);
	inline float spring_stiffness_ang_y(void);
	inline void spring_stiffness_ang_y(float value);
	inline float spring_stiffness_ang_z(void);
	inline void spring_stiffness_ang_z(float value);
	inline float spring_damping_x(void);
	inline void spring_damping_x(float value);
	inline float spring_damping_y(void);
	inline void spring_damping_y(float value);
	inline float spring_damping_z(void);
	inline void spring_damping_z(float value);
	inline float spring_damping_ang_x(void);
	inline void spring_damping_ang_x(float value);
	inline float spring_damping_ang_y(void);
	inline void spring_damping_ang_y(float value);
	inline float spring_damping_ang_z(void);
	inline void spring_damping_ang_z(float value);
	inline float motor_lin_target_velocity(void);
	inline void motor_lin_target_velocity(float value);
	inline float motor_lin_max_impulse(void);
	inline void motor_lin_max_impulse(float value);
	inline float motor_ang_target_velocity(void);
	inline void motor_ang_target_velocity(float value);
	inline float motor_ang_max_impulse(void);
	inline void motor_ang_max_impulse(float value);

};

/**************** Scene ****************/

class Scene : public ID {
public:
	Scene(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		objects(ptr_arg),
		keying_sets(ptr_arg),
		keying_sets_all(ptr_arg),
		timeline_markers(ptr_arg),
		transform_orientation_slots(ptr_arg),
		view_layers(ptr_arg)
		{}

	inline Object camera(void);
	inline Scene background_set(void);
	inline World world(void);
	COLLECTION_PROPERTY(SceneObjects, Object, Scene, objects, false, false, false)
	inline int frame_current(void);
	inline void frame_current(int value);
	inline float frame_subframe(void);
	inline void frame_subframe(float value);
	inline float frame_float(void);
	inline void frame_float(float value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline int frame_step(void);
	inline void frame_step(int value);
	inline float frame_current_final(void);
	inline void frame_current_final(float value);
	inline bool lock_frame_selection_to_range(void);
	inline void lock_frame_selection_to_range(bool value);
	inline bool use_preview_range(void);
	inline void use_preview_range(bool value);
	inline int frame_preview_start(void);
	inline void frame_preview_start(int value);
	inline int frame_preview_end(void);
	inline void frame_preview_end(int value);
	inline bool show_subframe(void);
	inline void show_subframe(bool value);
	inline bool show_keys_from_selected_only(void);
	inline void show_keys_from_selected_only(bool value);
	inline std::string use_stamp_note(void);
	inline void use_stamp_note(const std::string& value);
	inline AnimData animation_data(void);
	inline bool is_nla_tweakmode(void);
	inline void is_nla_tweakmode(bool value);
	inline bool use_custom_simulation_range(void);
	inline void use_custom_simulation_range(bool value);
	inline int simulation_frame_start(void);
	inline void simulation_frame_start(int value);
	inline int simulation_frame_end(void);
	inline void simulation_frame_end(int value);
	enum sync_mode_enum {
		sync_mode_NONE = 0,
		sync_mode_FRAME_DROP = 8,
		sync_mode_AUDIO_SYNC = 2,
	};
	inline sync_mode_enum sync_mode(void);
	inline void sync_mode(sync_mode_enum value);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline SequenceEditor sequence_editor(void);
	COLLECTION_PROPERTY(KeyingSets, KeyingSet, Scene, keying_sets, false, true, true)
	COLLECTION_PROPERTY(KeyingSetsAll, KeyingSet, Scene, keying_sets_all, false, false, false)
	inline RigidBodyWorld rigidbody_world(void);
	inline ToolSettings tool_settings(void);
	inline UnitSettings unit_settings(void);
	inline Array<float, 3> gravity(void);
	inline void gravity(float values[3]);
	inline bool use_gravity(void);
	inline void use_gravity(bool value);
	inline RenderSettings render(void);
	inline DisplaySafeAreas safe_areas(void);
	COLLECTION_PROPERTY(TimelineMarkers, TimelineMarker, Scene, timeline_markers, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TransformOrientationSlot, Scene, transform_orientation_slots, true, false, false)
	inline View3DCursor cursor(void);
	inline bool use_audio(void);
	inline void use_audio(bool value);
	inline bool use_audio_scrub(void);
	inline void use_audio_scrub(bool value);
	inline float audio_doppler_speed(void);
	inline void audio_doppler_speed(float value);
	inline float audio_doppler_factor(void);
	inline void audio_doppler_factor(float value);
	enum audio_distance_model_enum {
		audio_distance_model_NONE = 0,
		audio_distance_model_INVERSE = 1,
		audio_distance_model_INVERSE_CLAMPED = 2,
		audio_distance_model_LINEAR = 3,
		audio_distance_model_LINEAR_CLAMPED = 4,
		audio_distance_model_EXPONENT = 5,
		audio_distance_model_EXPONENT_CLAMPED = 6,
	};
	inline audio_distance_model_enum audio_distance_model(void);
	inline void audio_distance_model(audio_distance_model_enum value);
	inline float audio_volume(void);
	inline void audio_volume(float value);
	inline GreasePencil grease_pencil(void);
	inline MovieClip active_clip(void);
	inline ColorManagedViewSettings view_settings(void);
	inline ColorManagedDisplaySettings display_settings(void);
	inline ColorManagedSequencerColorspaceSettings sequencer_colorspace_settings(void);
	COLLECTION_PROPERTY(ViewLayers, ViewLayer, Scene, view_layers, false, true, true)
	inline Collection collection(void);
	inline SceneDisplay display(void);
	inline SceneEEVEE eevee(void);
	inline SceneGpencil grease_pencil_settings(void);
	inline SceneHydra hydra(void);

	inline void update_render_engine(void *main);
	inline const char * statistics(void *main, ViewLayer& view_layer);
	inline void frame_set(void *main, int frame, float subframe);
	inline void uvedit_aspect(Object& object, float result[2]);
	inline void ray_cast(Depsgraph& depsgraph, float origin[3], float direction[3], float distance, bool *result, float location[3], float normal[3], int *index, Object *object, float matrix[16]);
	inline SequenceEditor sequence_editor_create();
	inline void sequence_editor_clear();
	inline void alembic_export(Context C, const char * filepath, int frame_start, int frame_end, int xform_samples, int geom_samples, float shutter_open, float shutter_close, bool selected_only, bool uvs, bool normals, bool vcolors, bool apply_subdiv, bool flatten, bool visible_objects_only, bool face_sets, bool subdiv_schema, bool export_hair, bool export_particles, bool packuv, float scale, bool triangulate, int quad_method, int ngon_method);
};

/**************** Tool Settings ****************/

class ToolSettings : public Pointer {
public:
	ToolSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Sculpt sculpt(void);
	inline CurvesSculpt curves_sculpt(void);
	inline bool use_auto_normalize(void);
	inline void use_auto_normalize(bool value);
	inline bool use_lock_relative(void);
	inline void use_lock_relative(bool value);
	inline bool use_multipaint(void);
	inline void use_multipaint(bool value);
	enum vertex_group_user_enum {
		vertex_group_user_NONE = 0,
		vertex_group_user_ACTIVE = 1,
		vertex_group_user_ALL = 2,
	};
	inline vertex_group_user_enum vertex_group_user(void);
	inline void vertex_group_user(vertex_group_user_enum value);
	enum vertex_group_subset_enum {
		vertex_group_subset_ALL = 0,
		vertex_group_subset_BONE_DEFORM = 3,
		vertex_group_subset_OTHER_DEFORM = 4,
	};
	inline vertex_group_subset_enum vertex_group_subset(void);
	inline void vertex_group_subset(vertex_group_subset_enum value);
	inline VertexPaint vertex_paint(void);
	inline VertexPaint weight_paint(void);
	inline ImagePaint image_paint(void);
	inline PaintModeSettings paint_mode(void);
	inline UvSculpt uv_sculpt(void);
	inline GpPaint gpencil_paint(void);
	inline GpVertexPaint gpencil_vertex_paint(void);
	inline GpSculptPaint gpencil_sculpt_paint(void);
	inline GpWeightPaint gpencil_weight_paint(void);
	inline ParticleEdit particle_edit(void);
	inline bool uv_sculpt_lock_borders(void);
	inline void uv_sculpt_lock_borders(bool value);
	inline bool uv_sculpt_all_islands(void);
	inline void uv_sculpt_all_islands(bool value);
	enum uv_relax_method_enum {
		uv_relax_method_LAPLACIAN = 1,
		uv_relax_method_HC = 2,
		uv_relax_method_COTAN = 3,
	};
	inline uv_relax_method_enum uv_relax_method(void);
	inline void uv_relax_method(uv_relax_method_enum value);
	inline bool lock_object_mode(void);
	inline void lock_object_mode(bool value);
	enum workspace_tool_type_enum {
		workspace_tool_type_DEFAULT = 1,
		workspace_tool_type_FALLBACK = 0,
	};
	inline workspace_tool_type_enum workspace_tool_type(void);
	inline void workspace_tool_type(workspace_tool_type_enum value);
	inline bool use_proportional_edit(void);
	inline void use_proportional_edit(bool value);
	inline bool use_proportional_edit_objects(void);
	inline void use_proportional_edit_objects(bool value);
	inline bool use_proportional_projected(void);
	inline void use_proportional_projected(bool value);
	inline bool use_proportional_connected(void);
	inline void use_proportional_connected(bool value);
	inline bool use_proportional_edit_mask(void);
	inline void use_proportional_edit_mask(bool value);
	inline bool use_proportional_action(void);
	inline void use_proportional_action(bool value);
	inline bool use_proportional_fcurve(void);
	inline void use_proportional_fcurve(bool value);
	inline bool lock_markers(void);
	inline void lock_markers(bool value);
	enum proportional_edit_falloff_enum {
		proportional_edit_falloff_SMOOTH = 0,
		proportional_edit_falloff_SPHERE = 1,
		proportional_edit_falloff_ROOT = 2,
		proportional_edit_falloff_INVERSE_SQUARE = 7,
		proportional_edit_falloff_SHARP = 3,
		proportional_edit_falloff_LINEAR = 4,
		proportional_edit_falloff_CONSTANT = 5,
		proportional_edit_falloff_RANDOM = 6,
	};
	inline proportional_edit_falloff_enum proportional_edit_falloff(void);
	inline void proportional_edit_falloff(proportional_edit_falloff_enum value);
	inline float proportional_size(void);
	inline void proportional_size(float value);
	inline float proportional_distance(void);
	inline void proportional_distance(float value);
	inline float double_threshold(void);
	inline void double_threshold(float value);
	enum transform_pivot_point_enum {
		transform_pivot_point_BOUNDING_BOX_CENTER = 0,
		transform_pivot_point_CURSOR = 1,
		transform_pivot_point_INDIVIDUAL_ORIGINS = 2,
		transform_pivot_point_MEDIAN_POINT = 3,
		transform_pivot_point_ACTIVE_ELEMENT = 4,
	};
	inline transform_pivot_point_enum transform_pivot_point(void);
	inline void transform_pivot_point(transform_pivot_point_enum value);
	inline bool use_transform_pivot_point_align(void);
	inline void use_transform_pivot_point_align(bool value);
	inline bool use_transform_data_origin(void);
	inline void use_transform_data_origin(bool value);
	inline bool use_transform_skip_children(void);
	inline void use_transform_skip_children(bool value);
	inline bool use_transform_correct_face_attributes(void);
	inline void use_transform_correct_face_attributes(bool value);
	inline bool use_transform_correct_keep_connected(void);
	inline void use_transform_correct_keep_connected(bool value);
	inline bool use_mesh_automerge(void);
	inline void use_mesh_automerge(bool value);
	inline bool use_mesh_automerge_and_split(void);
	inline void use_mesh_automerge_and_split(bool value);
	inline bool use_snap(void);
	inline void use_snap(bool value);
	inline bool use_snap_node(void);
	inline void use_snap_node(bool value);
	inline bool use_snap_sequencer(void);
	inline void use_snap_sequencer(bool value);
	inline bool use_snap_uv(void);
	inline void use_snap_uv(bool value);
	inline bool use_snap_align_rotation(void);
	inline void use_snap_align_rotation(bool value);
	inline bool use_snap_grid_absolute(void);
	inline void use_snap_grid_absolute(bool value);
	enum snap_elements_enum {
		snap_elements_INCREMENT = 256,
		snap_elements_VERTEX = 5,
		snap_elements_EDGE = 16,
		snap_elements_FACE = 32,
		snap_elements_VOLUME = 64,
		snap_elements_EDGE_MIDPOINT = 2,
		snap_elements_EDGE_PERPENDICULAR = 8,
		snap_elements_FACE_PROJECT = 1024,
		snap_elements_FACE_NEAREST = 512,
	};
	inline snap_elements_enum snap_elements(void);
	inline void snap_elements(snap_elements_enum value);
	enum snap_elements_base_enum {
		snap_elements_base_INCREMENT = 256,
		snap_elements_base_VERTEX = 5,
		snap_elements_base_EDGE = 16,
		snap_elements_base_FACE = 32,
		snap_elements_base_VOLUME = 64,
		snap_elements_base_EDGE_MIDPOINT = 2,
		snap_elements_base_EDGE_PERPENDICULAR = 8,
	};
	inline snap_elements_base_enum snap_elements_base(void);
	inline void snap_elements_base(snap_elements_base_enum value);
	enum snap_elements_individual_enum {
		snap_elements_individual_FACE_PROJECT = 1024,
		snap_elements_individual_FACE_NEAREST = 512,
	};
	inline snap_elements_individual_enum snap_elements_individual(void);
	inline void snap_elements_individual(snap_elements_individual_enum value);
	inline int snap_face_nearest_steps(void);
	inline void snap_face_nearest_steps(int value);
	inline bool use_snap_to_same_target(void);
	inline void use_snap_to_same_target(bool value);
	enum snap_node_element_enum {
		snap_node_element_GRID = 128,
		snap_node_element_NODE_X = 1,
		snap_node_element_NODE_Y = 2,
		snap_node_element_NODE_XY = 3,
	};
	inline snap_node_element_enum snap_node_element(void);
	inline void snap_node_element(snap_node_element_enum value);
	inline bool use_snap_anim(void);
	inline void use_snap_anim(bool value);
	inline bool use_snap_time_absolute(void);
	inline void use_snap_time_absolute(bool value);
	enum snap_anim_element_enum {
		snap_anim_element_FRAME = 1,
		snap_anim_element_SECOND = 2,
		snap_anim_element_MARKER = 4,
	};
	inline snap_anim_element_enum snap_anim_element(void);
	inline void snap_anim_element(snap_anim_element_enum value);
	enum snap_uv_element_enum {
		snap_uv_element_INCREMENT = 256,
		snap_uv_element_VERTEX = 5,
	};
	inline snap_uv_element_enum snap_uv_element(void);
	inline void snap_uv_element(snap_uv_element_enum value);
	inline bool use_snap_uv_grid_absolute(void);
	inline void use_snap_uv_grid_absolute(bool value);
	enum snap_target_enum {
		snap_target_CLOSEST = 0,
		snap_target_CENTER = 1,
		snap_target_MEDIAN = 2,
		snap_target_ACTIVE = 3,
	};
	inline snap_target_enum snap_target(void);
	inline void snap_target(snap_target_enum value);
	inline bool use_snap_peel_object(void);
	inline void use_snap_peel_object(bool value);
	inline bool use_snap_backface_culling(void);
	inline void use_snap_backface_culling(bool value);
	inline bool use_snap_self(void);
	inline void use_snap_self(bool value);
	inline bool use_snap_edit(void);
	inline void use_snap_edit(bool value);
	inline bool use_snap_nonedit(void);
	inline void use_snap_nonedit(bool value);
	inline bool use_snap_selectable(void);
	inline void use_snap_selectable(bool value);
	inline bool use_snap_translate(void);
	inline void use_snap_translate(bool value);
	inline bool use_snap_rotate(void);
	inline void use_snap_rotate(bool value);
	inline bool use_snap_scale(void);
	inline void use_snap_scale(bool value);
	enum plane_axis_enum {
		plane_axis_X = 0,
		plane_axis_Y = 1,
		plane_axis_Z = 2,
	};
	inline plane_axis_enum plane_axis(void);
	inline void plane_axis(plane_axis_enum value);
	inline bool plane_axis_auto(void);
	inline void plane_axis_auto(bool value);
	enum plane_depth_enum {
		plane_depth_SURFACE = 0,
		plane_depth_CURSOR_PLANE = 1,
		plane_depth_CURSOR_VIEW = 2,
	};
	inline plane_depth_enum plane_depth(void);
	inline void plane_depth(plane_depth_enum value);
	enum plane_orientation_enum {
		plane_orientation_SURFACE = 0,
		plane_orientation_DEFAULT = 1,
	};
	inline plane_orientation_enum plane_orientation(void);
	inline void plane_orientation(plane_orientation_enum value);
	enum snap_elements_tool_enum {
		snap_elements_tool_GEOMETRY = 63,
		snap_elements_tool_DEFAULT = 0,
	};
	inline snap_elements_tool_enum snap_elements_tool(void);
	inline void snap_elements_tool(snap_elements_tool_enum value);
	inline bool use_gpencil_draw_additive(void);
	inline void use_gpencil_draw_additive(bool value);
	inline bool use_gpencil_draw_onback(void);
	inline void use_gpencil_draw_onback(bool value);
	inline bool use_gpencil_thumbnail_list(void);
	inline void use_gpencil_thumbnail_list(bool value);
	inline bool use_gpencil_weight_data_add(void);
	inline void use_gpencil_weight_data_add(bool value);
	inline bool use_gpencil_automerge_strokes(void);
	inline void use_gpencil_automerge_strokes(bool value);
	inline GPencilSculptSettings gpencil_sculpt(void);
	inline GPencilInterpolateSettings gpencil_interpolate(void);
	enum gpencil_stroke_placement_view3d_enum {
		gpencil_stroke_placement_view3d_ORIGIN = 1,
		gpencil_stroke_placement_view3d_CURSOR = 33,
		gpencil_stroke_placement_view3d_SURFACE = 5,
		gpencil_stroke_placement_view3d_STROKE = 9,
	};
	inline gpencil_stroke_placement_view3d_enum gpencil_stroke_placement_view3d(void);
	inline void gpencil_stroke_placement_view3d(gpencil_stroke_placement_view3d_enum value);
	enum gpencil_stroke_snap_mode_enum {
		gpencil_stroke_snap_mode_NONE = 0,
		gpencil_stroke_snap_mode_ENDS = 16,
		gpencil_stroke_snap_mode_FIRST = 64,
	};
	inline gpencil_stroke_snap_mode_enum gpencil_stroke_snap_mode(void);
	inline void gpencil_stroke_snap_mode(gpencil_stroke_snap_mode_enum value);
	inline bool use_gpencil_stroke_endpoints(void);
	inline void use_gpencil_stroke_endpoints(bool value);
	enum gpencil_selectmode_edit_enum {
		gpencil_selectmode_edit_POINT = 0,
		gpencil_selectmode_edit_STROKE = 1,
		gpencil_selectmode_edit_SEGMENT = 2,
	};
	inline gpencil_selectmode_edit_enum gpencil_selectmode_edit(void);
	inline void gpencil_selectmode_edit(gpencil_selectmode_edit_enum value);
	inline bool use_gpencil_select_mask_point(void);
	inline void use_gpencil_select_mask_point(bool value);
	inline bool use_gpencil_select_mask_stroke(void);
	inline void use_gpencil_select_mask_stroke(bool value);
	inline bool use_gpencil_select_mask_segment(void);
	inline void use_gpencil_select_mask_segment(bool value);
	inline bool use_gpencil_vertex_select_mask_point(void);
	inline void use_gpencil_vertex_select_mask_point(bool value);
	inline bool use_gpencil_vertex_select_mask_stroke(void);
	inline void use_gpencil_vertex_select_mask_stroke(bool value);
	inline bool use_gpencil_vertex_select_mask_segment(void);
	inline void use_gpencil_vertex_select_mask_segment(bool value);
	inline bool use_grease_pencil_multi_frame_editing(void);
	inline void use_grease_pencil_multi_frame_editing(bool value);
	enum annotation_stroke_placement_view2d_enum {
		annotation_stroke_placement_view2d_IMAGE = 33,
		annotation_stroke_placement_view2d_VIEW = 0,
	};
	inline annotation_stroke_placement_view2d_enum annotation_stroke_placement_view2d(void);
	inline void annotation_stroke_placement_view2d(annotation_stroke_placement_view2d_enum value);
	enum annotation_stroke_placement_view3d_enum {
		annotation_stroke_placement_view3d_CURSOR = 33,
		annotation_stroke_placement_view3d_VIEW = 0,
		annotation_stroke_placement_view3d_SURFACE = 5,
	};
	inline annotation_stroke_placement_view3d_enum annotation_stroke_placement_view3d(void);
	inline void annotation_stroke_placement_view3d(annotation_stroke_placement_view3d_enum value);
	inline int annotation_thickness(void);
	inline void annotation_thickness(int value);
	inline bool use_keyframe_insert_auto(void);
	inline void use_keyframe_insert_auto(bool value);
	enum auto_keying_mode_enum {
		auto_keying_mode_ADD_REPLACE_KEYS = 2,
		auto_keying_mode_REPLACE_KEYS = 4,
	};
	inline auto_keying_mode_enum auto_keying_mode(void);
	inline void auto_keying_mode(auto_keying_mode_enum value);
	inline bool use_record_with_nla(void);
	inline void use_record_with_nla(bool value);
	inline bool use_keyframe_insert_keyingset(void);
	inline void use_keyframe_insert_keyingset(bool value);
	inline bool use_keyframe_cycle_aware(void);
	inline void use_keyframe_cycle_aware(bool value);
	enum keyframe_type_enum {
		keyframe_type_KEYFRAME = 0,
		keyframe_type_BREAKDOWN = 2,
		keyframe_type_MOVING_HOLD = 4,
		keyframe_type_EXTREME = 1,
		keyframe_type_JITTER = 3,
	};
	inline keyframe_type_enum keyframe_type(void);
	inline void keyframe_type(keyframe_type_enum value);
	enum uv_select_mode_enum {
		uv_select_mode_VERTEX = 1,
		uv_select_mode_EDGE = 2,
		uv_select_mode_FACE = 4,
		uv_select_mode_ISLAND = 8,
	};
	inline uv_select_mode_enum uv_select_mode(void);
	inline void uv_select_mode(uv_select_mode_enum value);
	enum uv_sticky_select_mode_enum {
		uv_sticky_select_mode_DISABLED = 1,
		uv_sticky_select_mode_SHARED_LOCATION = 0,
		uv_sticky_select_mode_SHARED_VERTEX = 2,
	};
	inline uv_sticky_select_mode_enum uv_sticky_select_mode(void);
	inline void uv_sticky_select_mode(uv_sticky_select_mode_enum value);
	inline bool use_uv_select_sync(void);
	inline void use_uv_select_sync(bool value);
	inline bool show_uv_local_view(void);
	inline void show_uv_local_view(bool value);
	inline Array<bool, 3> mesh_select_mode(void);
	inline void mesh_select_mode(bool values[3]);
	inline float vertex_group_weight(void);
	inline void vertex_group_weight(float value);
	inline bool use_edge_path_live_unwrap(void);
	inline void use_edge_path_live_unwrap(bool value);
	inline Array<float, 3> normal_vector(void);
	inline void normal_vector(float values[3]);
	inline UnifiedPaintSettings unified_paint_settings(void);
	inline CurvePaintSettings curve_paint_settings(void);
	inline MeshStatVis statvis(void);
	inline CurveProfile custom_bevel_profile_preset(void);
	inline SequencerToolSettings sequencer_tool_settings(void);

};

/**************** Grease Pencil Interpolate Settings ****************/

class GPencilInterpolateSettings : public Pointer {
public:
	GPencilInterpolateSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline CurveMapping interpolation_curve(void);

};

/**************** Unified Paint Settings ****************/

class UnifiedPaintSettings : public Pointer {
public:
	UnifiedPaintSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_unified_size(void);
	inline void use_unified_size(bool value);
	inline bool use_unified_strength(void);
	inline void use_unified_strength(bool value);
	inline bool use_unified_weight(void);
	inline void use_unified_weight(bool value);
	inline bool use_unified_color(void);
	inline void use_unified_color(bool value);
	inline int size(void);
	inline void size(int value);
	inline float unprojected_radius(void);
	inline void unprojected_radius(float value);
	inline float strength(void);
	inline void strength(float value);
	inline float weight(void);
	inline void weight(float value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline Array<float, 3> secondary_color(void);
	inline void secondary_color(float values[3]);
	enum use_locked_size_enum {
		use_locked_size_VIEW = 0,
		use_locked_size_SCENE = 4,
	};
	inline use_locked_size_enum use_locked_size(void);
	inline void use_locked_size(use_locked_size_enum value);

};

/**************** Curve Paint Settings ****************/

class CurvePaintSettings : public Pointer {
public:
	CurvePaintSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum curve_type_enum {
		curve_type_POLY = 0,
		curve_type_BEZIER = 1,
	};
	inline curve_type_enum curve_type(void);
	inline void curve_type(curve_type_enum value);
	inline bool use_corners_detect(void);
	inline void use_corners_detect(bool value);
	inline bool use_pressure_radius(void);
	inline void use_pressure_radius(bool value);
	inline bool use_stroke_endpoints(void);
	inline void use_stroke_endpoints(bool value);
	inline bool use_offset_absolute(void);
	inline void use_offset_absolute(bool value);
	inline int error_threshold(void);
	inline void error_threshold(int value);
	enum fit_method_enum {
		fit_method_REFIT = 0,
		fit_method_SPLIT = 1,
	};
	inline fit_method_enum fit_method(void);
	inline void fit_method(fit_method_enum value);
	inline float corner_angle(void);
	inline void corner_angle(float value);
	inline float radius_min(void);
	inline void radius_min(float value);
	inline float radius_max(void);
	inline void radius_max(float value);
	inline float radius_taper_start(void);
	inline void radius_taper_start(float value);
	inline float radius_taper_end(void);
	inline void radius_taper_end(float value);
	inline float surface_offset(void);
	inline void surface_offset(float value);
	enum depth_mode_enum {
		depth_mode_CURSOR = 0,
		depth_mode_SURFACE = 1,
	};
	inline depth_mode_enum depth_mode(void);
	inline void depth_mode(depth_mode_enum value);
	enum surface_plane_enum {
		surface_plane_NORMAL_VIEW = 0,
		surface_plane_NORMAL_SURFACE = 1,
		surface_plane_VIEW = 2,
	};
	inline surface_plane_enum surface_plane(void);
	inline void surface_plane(surface_plane_enum value);

};

/**************** Sequencer Tool Settings ****************/

class SequencerToolSettings : public Pointer {
public:
	SequencerToolSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum fit_method_enum {
		fit_method_FIT = 0,
		fit_method_FILL = 1,
		fit_method_STRETCH = 2,
		fit_method_ORIGINAL = 3,
	};
	inline fit_method_enum fit_method(void);
	inline void fit_method(fit_method_enum value);
	inline bool snap_to_current_frame(void);
	inline void snap_to_current_frame(bool value);
	inline bool snap_to_hold_offset(void);
	inline void snap_to_hold_offset(bool value);
	inline bool snap_ignore_muted(void);
	inline void snap_ignore_muted(bool value);
	inline bool snap_ignore_sound(void);
	inline void snap_ignore_sound(bool value);
	inline bool use_snap_current_frame_to_strips(void);
	inline void use_snap_current_frame_to_strips(bool value);
	inline int snap_distance(void);
	inline void snap_distance(int value);
	enum overlap_mode_enum {
		overlap_mode_EXPAND = 0,
		overlap_mode_OVERWRITE = 1,
		overlap_mode_SHUFFLE = 2,
	};
	inline overlap_mode_enum overlap_mode(void);
	inline void overlap_mode(overlap_mode_enum value);
	enum pivot_point_enum {
		pivot_point_CENTER = 0,
		pivot_point_MEDIAN = 3,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
	};
	inline pivot_point_enum pivot_point(void);
	inline void pivot_point(pivot_point_enum value);

};

/**************** Mesh Visualize Statistics ****************/

class MeshStatVis : public Pointer {
public:
	MeshStatVis(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_OVERHANG = 0,
		type_THICKNESS = 1,
		type_INTERSECT = 2,
		type_DISTORT = 3,
		type_SHARP = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline float overhang_min(void);
	inline void overhang_min(float value);
	inline float overhang_max(void);
	inline void overhang_max(float value);
	enum overhang_axis_enum {
		overhang_axis_POS_X = 0,
		overhang_axis_POS_Y = 1,
		overhang_axis_POS_Z = 2,
		overhang_axis_NEG_X = 3,
		overhang_axis_NEG_Y = 4,
		overhang_axis_NEG_Z = 5,
	};
	inline overhang_axis_enum overhang_axis(void);
	inline void overhang_axis(overhang_axis_enum value);
	inline float thickness_min(void);
	inline void thickness_min(float value);
	inline float thickness_max(void);
	inline void thickness_max(float value);
	inline int thickness_samples(void);
	inline void thickness_samples(int value);
	inline float distort_min(void);
	inline void distort_min(float value);
	inline float distort_max(void);
	inline void distort_max(float value);
	inline float sharp_min(void);
	inline void sharp_min(float value);
	inline float sharp_max(void);
	inline void sharp_max(float value);

};

/**************** Unit Settings ****************/

class UnitSettings : public Pointer {
public:
	UnitSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum system_enum {
		system_NONE = 0,
		system_METRIC = 1,
		system_IMPERIAL = 2,
	};
	inline system_enum system(void);
	inline void system(system_enum value);
	enum system_rotation_enum {
		system_rotation_DEGREES = 0,
		system_rotation_RADIANS = 2,
	};
	inline system_rotation_enum system_rotation(void);
	inline void system_rotation(system_rotation_enum value);
	inline float scale_length(void);
	inline void scale_length(float value);
	inline bool use_separate(void);
	inline void use_separate(bool value);
	enum length_unit_enum {
		length_unit_DEFAULT = 0,
	};
	inline length_unit_enum length_unit(void);
	inline void length_unit(length_unit_enum value);
	enum mass_unit_enum {
		mass_unit_DEFAULT = 0,
	};
	inline mass_unit_enum mass_unit(void);
	inline void mass_unit(mass_unit_enum value);
	enum time_unit_enum {
		time_unit_DEFAULT = 0,
	};
	inline time_unit_enum time_unit(void);
	inline void time_unit(time_unit_enum value);
	enum temperature_unit_enum {
		temperature_unit_DEFAULT = 0,
	};
	inline temperature_unit_enum temperature_unit(void);
	inline void temperature_unit(temperature_unit_enum value);

};

/**************** Stereo Output ****************/

class Stereo3dFormat : public Pointer {
public:
	Stereo3dFormat(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum display_mode_enum {
		display_mode_ANAGLYPH = 0,
		display_mode_INTERLACE = 1,
		display_mode_SIDEBYSIDE = 3,
		display_mode_TOPBOTTOM = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	enum anaglyph_type_enum {
		anaglyph_type_RED_CYAN = 0,
		anaglyph_type_GREEN_MAGENTA = 1,
		anaglyph_type_YELLOW_BLUE = 2,
	};
	inline anaglyph_type_enum anaglyph_type(void);
	inline void anaglyph_type(anaglyph_type_enum value);
	enum interlace_type_enum {
		interlace_type_ROW_INTERLEAVED = 0,
		interlace_type_COLUMN_INTERLEAVED = 1,
		interlace_type_CHECKERBOARD_INTERLEAVED = 2,
	};
	inline interlace_type_enum interlace_type(void);
	inline void interlace_type(interlace_type_enum value);
	inline bool use_interlace_swap(void);
	inline void use_interlace_swap(bool value);
	inline bool use_sidebyside_crosseyed(void);
	inline void use_sidebyside_crosseyed(bool value);
	inline bool use_squeezed_frame(void);
	inline void use_squeezed_frame(bool value);

};

/**************** Image Format ****************/

class ImageFormatSettings : public Pointer {
public:
	ImageFormatSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum file_format_enum {
		file_format_BMP = 20,
		file_format_IRIS = 1,
		file_format_PNG = 17,
		file_format_JPEG = 4,
		file_format_JPEG2000 = 30,
		file_format_TARGA = 0,
		file_format_TARGA_RAW = 14,
		file_format_CINEON = 26,
		file_format_DPX = 27,
		file_format_OPEN_EXR_MULTILAYER = 28,
		file_format_OPEN_EXR = 23,
		file_format_HDR = 21,
		file_format_TIFF = 22,
		file_format_WEBP = 35,
		file_format_AVI_JPEG = 16,
		file_format_AVI_RAW = 15,
		file_format_FFMPEG = 24,
	};
	inline file_format_enum file_format(void);
	inline void file_format(file_format_enum value);
	enum color_mode_enum {
		color_mode_BW = 8,
		color_mode_RGB = 24,
		color_mode_RGBA = 32,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);
	enum color_depth_enum {
		color_depth_8 = 2,
		color_depth_10 = 4,
		color_depth_12 = 8,
		color_depth_16 = 16,
		color_depth_32 = 64,
	};
	inline color_depth_enum color_depth(void);
	inline void color_depth(color_depth_enum value);
	inline int quality(void);
	inline void quality(int value);
	inline int compression(void);
	inline void compression(int value);
	inline bool use_preview(void);
	inline void use_preview(bool value);
	enum exr_codec_enum {
		exr_codec_NONE = 0,
		exr_codec_PXR24 = 1,
		exr_codec_ZIP = 2,
		exr_codec_PIZ = 3,
		exr_codec_RLE = 4,
		exr_codec_ZIPS = 5,
		exr_codec_B44 = 6,
		exr_codec_B44A = 7,
		exr_codec_DWAA = 8,
		exr_codec_DWAB = 9,
	};
	inline exr_codec_enum exr_codec(void);
	inline void exr_codec(exr_codec_enum value);
	inline bool use_jpeg2k_ycc(void);
	inline void use_jpeg2k_ycc(bool value);
	inline bool use_jpeg2k_cinema_preset(void);
	inline void use_jpeg2k_cinema_preset(bool value);
	inline bool use_jpeg2k_cinema_48(void);
	inline void use_jpeg2k_cinema_48(bool value);
	enum jpeg2k_codec_enum {
		jpeg2k_codec_JP2 = 0,
		jpeg2k_codec_J2K = 1,
	};
	inline jpeg2k_codec_enum jpeg2k_codec(void);
	inline void jpeg2k_codec(jpeg2k_codec_enum value);
	enum tiff_codec_enum {
		tiff_codec_NONE = 3,
		tiff_codec_DEFLATE = 0,
		tiff_codec_LZW = 1,
		tiff_codec_PACKBITS = 2,
	};
	inline tiff_codec_enum tiff_codec(void);
	inline void tiff_codec(tiff_codec_enum value);
	inline bool use_cineon_log(void);
	inline void use_cineon_log(bool value);
	inline int cineon_black(void);
	inline void cineon_black(int value);
	inline int cineon_white(void);
	inline void cineon_white(int value);
	inline float cineon_gamma(void);
	inline void cineon_gamma(float value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
		views_format_MULTIVIEW = 2,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);
	enum color_management_enum {
		color_management_FOLLOW_SCENE = 0,
		color_management_OVERRIDE = 1,
	};
	inline color_management_enum color_management(void);
	inline void color_management(color_management_enum value);
	inline ColorManagedViewSettings view_settings(void);
	inline ColorManagedDisplaySettings display_settings(void);
	inline ColorManagedInputColorspaceSettings linear_colorspace_settings(void);
	inline bool has_linear_colorspace(void);
	inline void has_linear_colorspace(bool value);

};

/**************** TransformOrientation ****************/

class TransformOrientation : public Pointer {
public:
	TransformOrientation(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 9> matrix(void);
	inline void matrix(float values[9]);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Orientation Slot ****************/

class TransformOrientationSlot : public Pointer {
public:
	TransformOrientationSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_GLOBAL = 0,
		type_LOCAL = 1,
		type_NORMAL = 2,
		type_GIMBAL = 4,
		type_VIEW = 3,
		type_CURSOR = 5,
		type_PARENT = 6,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline TransformOrientation custom_orientation(void);
	inline bool use(void);
	inline void use(bool value);

};

/**************** 3D Cursor ****************/

class View3DCursor : public Pointer {
public:
	View3DCursor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);
	inline Array<float, 4> rotation_quaternion(void);
	inline void rotation_quaternion(float values[4]);
	inline Array<float, 4> rotation_axis_angle(void);
	inline void rotation_axis_angle(float values[4]);
	inline Array<float, 3> rotation_euler(void);
	inline void rotation_euler(float values[3]);
	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};
	inline rotation_mode_enum rotation_mode(void);
	inline void rotation_mode(rotation_mode_enum value);
	inline Array<float, 16> matrix(void);
	inline void matrix(float values[16]);

};

/**************** Selected UV Element ****************/

class SelectedUvElement : public PropertyGroup {
public:
	SelectedUvElement(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** Safe Areas ****************/

class DisplaySafeAreas : public Pointer {
public:
	DisplaySafeAreas(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> title(void);
	inline void title(float values[2]);
	inline Array<float, 2> action(void);
	inline void action(float values[2]);
	inline Array<float, 2> title_center(void);
	inline void title_center(float values[2]);
	inline Array<float, 2> action_center(void);
	inline void action_center(float values[2]);

};

/**************** Scene Display ****************/

class SceneDisplay : public Pointer {
public:
	SceneDisplay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> light_direction(void);
	inline void light_direction(float values[3]);
	inline float shadow_shift(void);
	inline void shadow_shift(float value);
	inline float shadow_focus(void);
	inline void shadow_focus(float value);
	inline float matcap_ssao_distance(void);
	inline void matcap_ssao_distance(float value);
	inline float matcap_ssao_attenuation(void);
	inline void matcap_ssao_attenuation(float value);
	inline int matcap_ssao_samples(void);
	inline void matcap_ssao_samples(int value);
	enum render_aa_enum {
		render_aa_OFF = 0,
		render_aa_FXAA = 1,
		render_aa_5 = 5,
		render_aa_8 = 8,
		render_aa_11 = 11,
		render_aa_16 = 16,
		render_aa_32 = 32,
	};
	inline render_aa_enum render_aa(void);
	inline void render_aa(render_aa_enum value);
	enum viewport_aa_enum {
		viewport_aa_OFF = 0,
		viewport_aa_FXAA = 1,
		viewport_aa_5 = 5,
		viewport_aa_8 = 8,
		viewport_aa_11 = 11,
		viewport_aa_16 = 16,
		viewport_aa_32 = 32,
	};
	inline viewport_aa_enum viewport_aa(void);
	inline void viewport_aa(viewport_aa_enum value);
	inline View3DShading shading(void);

};

/**************** RaytraceEEVEE ****************/

class RaytraceEEVEE : public Pointer {
public:
	RaytraceEEVEE(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum resolution_scale_enum {
		resolution_scale_1 = 1,
		resolution_scale_2 = 2,
		resolution_scale_4 = 4,
	};
	inline resolution_scale_enum resolution_scale(void);
	inline void resolution_scale(resolution_scale_enum value);
	inline bool use_denoise(void);
	inline void use_denoise(bool value);
	inline bool denoise_spatial(void);
	inline void denoise_spatial(bool value);
	inline bool denoise_temporal(void);
	inline void denoise_temporal(bool value);
	inline bool denoise_bilateral(void);
	inline void denoise_bilateral(bool value);
	inline float sample_clamp(void);
	inline void sample_clamp(float value);
	inline float screen_trace_thickness(void);
	inline void screen_trace_thickness(float value);
	inline float screen_trace_quality(void);
	inline void screen_trace_quality(float value);

};

/**************** Scene Display ****************/

class SceneEEVEE : public Pointer {
public:
	SceneEEVEE(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int gi_diffuse_bounces(void);
	inline void gi_diffuse_bounces(int value);
	enum gi_cubemap_resolution_enum {
		gi_cubemap_resolution_64 = 64,
		gi_cubemap_resolution_128 = 128,
		gi_cubemap_resolution_256 = 256,
		gi_cubemap_resolution_512 = 512,
		gi_cubemap_resolution_1024 = 1024,
		gi_cubemap_resolution_2048 = 2048,
		gi_cubemap_resolution_4096 = 4096,
	};
	inline gi_cubemap_resolution_enum gi_cubemap_resolution(void);
	inline void gi_cubemap_resolution(gi_cubemap_resolution_enum value);
	enum gi_visibility_resolution_enum {
		gi_visibility_resolution_8 = 8,
		gi_visibility_resolution_16 = 16,
		gi_visibility_resolution_32 = 32,
		gi_visibility_resolution_64 = 64,
	};
	inline gi_visibility_resolution_enum gi_visibility_resolution(void);
	inline void gi_visibility_resolution(gi_visibility_resolution_enum value);
	inline float gi_irradiance_smoothing(void);
	inline void gi_irradiance_smoothing(float value);
	inline float gi_glossy_clamp(void);
	inline void gi_glossy_clamp(float value);
	inline float gi_filter_quality(void);
	inline void gi_filter_quality(float value);
	inline bool gi_show_irradiance(void);
	inline void gi_show_irradiance(bool value);
	inline bool gi_show_cubemaps(void);
	inline void gi_show_cubemaps(bool value);
	inline float gi_irradiance_display_size(void);
	inline void gi_irradiance_display_size(float value);
	inline float gi_cubemap_display_size(void);
	inline void gi_cubemap_display_size(float value);
	inline bool gi_auto_bake(void);
	inline void gi_auto_bake(bool value);
	inline std::string gi_cache_info(void);
	inline void gi_cache_info(const std::string& value);
	enum gi_irradiance_pool_size_enum {
		gi_irradiance_pool_size_16 = 16,
		gi_irradiance_pool_size_32 = 32,
		gi_irradiance_pool_size_64 = 64,
		gi_irradiance_pool_size_128 = 128,
		gi_irradiance_pool_size_256 = 256,
		gi_irradiance_pool_size_512 = 512,
		gi_irradiance_pool_size_1024 = 1024,
	};
	inline gi_irradiance_pool_size_enum gi_irradiance_pool_size(void);
	inline void gi_irradiance_pool_size(gi_irradiance_pool_size_enum value);
	inline int taa_samples(void);
	inline void taa_samples(int value);
	inline int taa_render_samples(void);
	inline void taa_render_samples(int value);
	inline bool use_taa_reprojection(void);
	inline void use_taa_reprojection(bool value);
	inline int sss_samples(void);
	inline void sss_samples(int value);
	inline float sss_jitter_threshold(void);
	inline void sss_jitter_threshold(float value);
	inline bool use_ssr(void);
	inline void use_ssr(bool value);
	inline bool use_ssr_refraction(void);
	inline void use_ssr_refraction(bool value);
	inline bool use_ssr_halfres(void);
	inline void use_ssr_halfres(bool value);
	inline float ssr_quality(void);
	inline void ssr_quality(float value);
	inline float ssr_max_roughness(void);
	inline void ssr_max_roughness(float value);
	inline float ssr_thickness(void);
	inline void ssr_thickness(float value);
	inline float ssr_border_fade(void);
	inline void ssr_border_fade(float value);
	inline float ssr_firefly_fac(void);
	inline void ssr_firefly_fac(float value);
	enum ray_split_settings_enum {
		ray_split_settings_UNIFIED = 0,
		ray_split_settings_SPLIT = 1,
	};
	inline ray_split_settings_enum ray_split_settings(void);
	inline void ray_split_settings(ray_split_settings_enum value);
	enum ray_tracing_method_enum {
		ray_tracing_method_NONE = 0,
		ray_tracing_method_SCREEN = 1,
	};
	inline ray_tracing_method_enum ray_tracing_method(void);
	inline void ray_tracing_method(ray_tracing_method_enum value);
	inline float volumetric_start(void);
	inline void volumetric_start(float value);
	inline float volumetric_end(void);
	inline void volumetric_end(float value);
	enum volumetric_tile_size_enum {
		volumetric_tile_size_2 = 2,
		volumetric_tile_size_4 = 4,
		volumetric_tile_size_8 = 8,
		volumetric_tile_size_16 = 16,
	};
	inline volumetric_tile_size_enum volumetric_tile_size(void);
	inline void volumetric_tile_size(volumetric_tile_size_enum value);
	inline int volumetric_samples(void);
	inline void volumetric_samples(int value);
	inline float volumetric_sample_distribution(void);
	inline void volumetric_sample_distribution(float value);
	inline int volumetric_ray_depth(void);
	inline void volumetric_ray_depth(int value);
	inline bool use_volumetric_lights(void);
	inline void use_volumetric_lights(bool value);
	inline float volumetric_light_clamp(void);
	inline void volumetric_light_clamp(float value);
	inline bool use_volumetric_shadows(void);
	inline void use_volumetric_shadows(bool value);
	inline int volumetric_shadow_samples(void);
	inline void volumetric_shadow_samples(int value);
	inline bool use_gtao(void);
	inline void use_gtao(bool value);
	inline bool use_gtao_bent_normals(void);
	inline void use_gtao_bent_normals(bool value);
	inline bool use_gtao_bounce(void);
	inline void use_gtao_bounce(bool value);
	inline float gtao_factor(void);
	inline void gtao_factor(float value);
	inline float gtao_quality(void);
	inline void gtao_quality(float value);
	inline float gtao_distance(void);
	inline void gtao_distance(float value);
	inline float horizon_thickness(void);
	inline void horizon_thickness(float value);
	inline float horizon_quality(void);
	inline void horizon_quality(float value);
	inline float horizon_bias(void);
	inline void horizon_bias(float value);
	inline float bokeh_max_size(void);
	inline void bokeh_max_size(float value);
	inline float bokeh_threshold(void);
	inline void bokeh_threshold(float value);
	inline float bokeh_neighbor_max(void);
	inline void bokeh_neighbor_max(float value);
	inline float bokeh_denoise_fac(void);
	inline void bokeh_denoise_fac(float value);
	inline bool use_bokeh_high_quality_slight_defocus(void);
	inline void use_bokeh_high_quality_slight_defocus(bool value);
	inline bool use_bokeh_jittered(void);
	inline void use_bokeh_jittered(bool value);
	inline float bokeh_overblur(void);
	inline void bokeh_overblur(float value);
	inline bool use_bloom(void);
	inline void use_bloom(bool value);
	inline float bloom_threshold(void);
	inline void bloom_threshold(float value);
	inline Array<float, 3> bloom_color(void);
	inline void bloom_color(float values[3]);
	inline float bloom_knee(void);
	inline void bloom_knee(float value);
	inline float bloom_radius(void);
	inline void bloom_radius(float value);
	inline float bloom_clamp(void);
	inline void bloom_clamp(float value);
	inline float bloom_intensity(void);
	inline void bloom_intensity(float value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);
	inline float motion_blur_depth_scale(void);
	inline void motion_blur_depth_scale(float value);
	inline int motion_blur_max(void);
	inline void motion_blur_max(int value);
	inline int motion_blur_steps(void);
	inline void motion_blur_steps(int value);
	enum motion_blur_position_enum {
		motion_blur_position_START = 1,
		motion_blur_position_CENTER = 0,
		motion_blur_position_END = 2,
	};
	inline motion_blur_position_enum motion_blur_position(void);
	inline void motion_blur_position(motion_blur_position_enum value);
	inline bool use_shadows(void);
	inline void use_shadows(bool value);
	enum shadow_cube_size_enum {
		shadow_cube_size_64 = 64,
		shadow_cube_size_128 = 128,
		shadow_cube_size_256 = 256,
		shadow_cube_size_512 = 512,
		shadow_cube_size_1024 = 1024,
		shadow_cube_size_2048 = 2048,
		shadow_cube_size_4096 = 4096,
	};
	inline shadow_cube_size_enum shadow_cube_size(void);
	inline void shadow_cube_size(shadow_cube_size_enum value);
	enum shadow_cascade_size_enum {
		shadow_cascade_size_64 = 64,
		shadow_cascade_size_128 = 128,
		shadow_cascade_size_256 = 256,
		shadow_cascade_size_512 = 512,
		shadow_cascade_size_1024 = 1024,
		shadow_cascade_size_2048 = 2048,
		shadow_cascade_size_4096 = 4096,
	};
	inline shadow_cascade_size_enum shadow_cascade_size(void);
	inline void shadow_cascade_size(shadow_cascade_size_enum value);
	enum shadow_pool_size_enum {
		shadow_pool_size_16 = 16,
		shadow_pool_size_32 = 32,
		shadow_pool_size_64 = 64,
		shadow_pool_size_128 = 128,
		shadow_pool_size_256 = 256,
		shadow_pool_size_512 = 512,
		shadow_pool_size_1024 = 1024,
	};
	inline shadow_pool_size_enum shadow_pool_size(void);
	inline void shadow_pool_size(shadow_pool_size_enum value);
	inline int shadow_ray_count(void);
	inline void shadow_ray_count(int value);
	inline int shadow_step_count(void);
	inline void shadow_step_count(int value);
	inline float shadow_normal_bias(void);
	inline void shadow_normal_bias(float value);
	inline bool use_shadow_high_bitdepth(void);
	inline void use_shadow_high_bitdepth(bool value);
	inline bool use_soft_shadows(void);
	inline void use_soft_shadows(bool value);
	inline float light_threshold(void);
	inline void light_threshold(float value);
	inline bool use_overscan(void);
	inline void use_overscan(bool value);
	inline float overscan_size(void);
	inline void overscan_size(float value);
	inline RaytraceEEVEE reflection_options(void);
	inline RaytraceEEVEE refraction_options(void);
	inline RaytraceEEVEE diffuse_options(void);

};

/**************** Scene Hydra ****************/

class SceneHydra : public Pointer {
public:
	SceneHydra(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum export_method_enum {
		export_method_HYDRA = 0,
		export_method_USD = 1,
	};
	inline export_method_enum export_method(void);
	inline void export_method(export_method_enum value);

};

/**************** Shader AOV ****************/

class AOV : public Pointer {
public:
	AOV(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	enum type_enum {
		type_COLOR = 1,
		type_VALUE = 0,
	};
	inline type_enum type(void);
	inline void type(type_enum value);

};

/**************** Light Group ****************/

class Lightgroup : public Pointer {
public:
	Lightgroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** EEVEE Settings ****************/

class ViewLayerEEVEE : public Pointer {
public:
	ViewLayerEEVEE(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_pass_volume_direct(void);
	inline void use_pass_volume_direct(bool value);
	inline bool use_pass_bloom(void);
	inline void use_pass_bloom(bool value);
	inline bool use_pass_transparent(void);
	inline void use_pass_transparent(bool value);

};

/**************** Grease Pencil Render ****************/

class SceneGpencil : public Pointer {
public:
	SceneGpencil(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float antialias_threshold(void);
	inline void antialias_threshold(float value);

};

/**************** FFmpeg Settings ****************/

class FFmpegSettings : public Pointer {
public:
	FFmpegSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum format_enum {
		format_MPEG1 = 0,
		format_MPEG2 = 1,
		format_MPEG4 = 2,
		format_AVI = 3,
		format_QUICKTIME = 4,
		format_DV = 5,
		format_OGG = 10,
		format_MKV = 9,
		format_FLASH = 8,
		format_WEBM = 12,
	};
	inline format_enum format(void);
	inline void format(format_enum value);
	enum codec_enum {
		codec_NONE = 0,
		codec_DNXHD = 99,
		codec_DV = 24,
		codec_FFV1 = 33,
		codec_FLASH = 21,
		codec_H264 = 27,
		codec_HUFFYUV = 25,
		codec_MPEG1 = 1,
		codec_MPEG2 = 2,
		codec_MPEG4 = 12,
		codec_PNG = 61,
		codec_QTRLE = 55,
		codec_THEORA = 30,
		codec_WEBM = 167,
		codec_AV1 = 226,
	};
	inline codec_enum codec(void);
	inline void codec(codec_enum value);
	inline int video_bitrate(void);
	inline void video_bitrate(int value);
	inline int minrate(void);
	inline void minrate(int value);
	inline int maxrate(void);
	inline void maxrate(int value);
	inline int muxrate(void);
	inline void muxrate(int value);
	inline int gopsize(void);
	inline void gopsize(int value);
	inline int max_b_frames(void);
	inline void max_b_frames(int value);
	inline bool use_max_b_frames(void);
	inline void use_max_b_frames(bool value);
	inline int buffersize(void);
	inline void buffersize(int value);
	inline int packetsize(void);
	inline void packetsize(int value);
	enum constant_rate_factor_enum {
		constant_rate_factor_NONE = -1,
		constant_rate_factor_LOSSLESS = 0,
		constant_rate_factor_PERC_LOSSLESS = 17,
		constant_rate_factor_HIGH = 20,
		constant_rate_factor_MEDIUM = 23,
		constant_rate_factor_LOW = 26,
		constant_rate_factor_VERYLOW = 29,
		constant_rate_factor_LOWEST = 32,
	};
	inline constant_rate_factor_enum constant_rate_factor(void);
	inline void constant_rate_factor(constant_rate_factor_enum value);
	enum ffmpeg_preset_enum {
		ffmpeg_preset_BEST = 11,
		ffmpeg_preset_GOOD = 10,
		ffmpeg_preset_REALTIME = 12,
	};
	inline ffmpeg_preset_enum ffmpeg_preset(void);
	inline void ffmpeg_preset(ffmpeg_preset_enum value);
	inline bool use_autosplit(void);
	inline void use_autosplit(bool value);
	inline bool use_lossless_output(void);
	inline void use_lossless_output(bool value);
	enum audio_codec_enum {
		audio_codec_NONE = 0,
		audio_codec_AAC = 86018,
		audio_codec_AC3 = 86019,
		audio_codec_FLAC = 86028,
		audio_codec_MP2 = 86016,
		audio_codec_MP3 = 86017,
		audio_codec_OPUS = 86076,
		audio_codec_PCM = 65536,
		audio_codec_VORBIS = 86021,
	};
	inline audio_codec_enum audio_codec(void);
	inline void audio_codec(audio_codec_enum value);
	inline int audio_bitrate(void);
	inline void audio_bitrate(int value);
	inline float audio_volume(void);
	inline void audio_volume(float value);
	inline int audio_mixrate(void);
	inline void audio_mixrate(int value);
	enum audio_channels_enum {
		audio_channels_MONO = 1,
		audio_channels_STEREO = 2,
		audio_channels_SURROUND4 = 4,
		audio_channels_SURROUND51 = 6,
		audio_channels_SURROUND71 = 8,
	};
	inline audio_channels_enum audio_channels(void);
	inline void audio_channels(audio_channels_enum value);

};

/**************** Render Data ****************/

class RenderSettings : public Pointer {
public:
	RenderSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		views(ptr_arg),
		stereo_views(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ImageFormatSettings image_settings(void);
	inline int resolution_x(void);
	inline void resolution_x(int value);
	inline int resolution_y(void);
	inline void resolution_y(int value);
	inline int resolution_percentage(void);
	inline void resolution_percentage(int value);
	enum preview_pixel_size_enum {
		preview_pixel_size_AUTO = 0,
		preview_pixel_size_1 = 1,
		preview_pixel_size_2 = 2,
		preview_pixel_size_4 = 4,
		preview_pixel_size_8 = 8,
	};
	inline preview_pixel_size_enum preview_pixel_size(void);
	inline void preview_pixel_size(preview_pixel_size_enum value);
	inline float pixel_aspect_x(void);
	inline void pixel_aspect_x(float value);
	inline float pixel_aspect_y(void);
	inline void pixel_aspect_y(float value);
	inline FFmpegSettings ffmpeg(void);
	inline int fps(void);
	inline void fps(int value);
	inline float fps_base(void);
	inline void fps_base(float value);
	inline int frame_map_old(void);
	inline void frame_map_old(int value);
	inline int frame_map_new(void);
	inline void frame_map_new(int value);
	inline float dither_intensity(void);
	inline void dither_intensity(float value);
	inline float filter_size(void);
	inline void filter_size(float value);
	inline bool film_transparent(void);
	inline void film_transparent(bool value);
	inline bool use_freestyle(void);
	inline void use_freestyle(bool value);
	inline int threads(void);
	inline void threads(int value);
	enum threads_mode_enum {
		threads_mode_AUTO = 0,
		threads_mode_FIXED = 524288,
	};
	inline threads_mode_enum threads_mode(void);
	inline void threads_mode(threads_mode_enum value);
	inline bool use_motion_blur(void);
	inline void use_motion_blur(bool value);
	inline float motion_blur_shutter(void);
	inline void motion_blur_shutter(float value);
	inline CurveMapping motion_blur_shutter_curve(void);
	enum hair_type_enum {
		hair_type_STRAND = 0,
		hair_type_STRIP = 1,
	};
	inline hair_type_enum hair_type(void);
	inline void hair_type(hair_type_enum value);
	inline int hair_subdiv(void);
	inline void hair_subdiv(int value);
	inline bool use_high_quality_normals(void);
	inline void use_high_quality_normals(bool value);
	inline bool use_border(void);
	inline void use_border(bool value);
	inline float border_min_x(void);
	inline void border_min_x(float value);
	inline float border_min_y(void);
	inline void border_min_y(float value);
	inline float border_max_x(void);
	inline void border_max_x(float value);
	inline float border_max_y(void);
	inline void border_max_y(float value);
	inline bool use_crop_to_border(void);
	inline void use_crop_to_border(bool value);
	inline bool use_placeholder(void);
	inline void use_placeholder(bool value);
	inline bool use_overwrite(void);
	inline void use_overwrite(bool value);
	inline bool use_compositing(void);
	inline void use_compositing(bool value);
	inline bool use_sequencer(void);
	inline void use_sequencer(bool value);
	inline bool use_file_extension(void);
	inline void use_file_extension(bool value);
	inline std::string file_extension(void);
	inline void file_extension(const std::string& value);
	inline bool is_movie_format(void);
	inline void is_movie_format(bool value);
	inline bool use_lock_interface(void);
	inline void use_lock_interface(bool value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool use_render_cache(void);
	inline void use_render_cache(bool value);
	enum bake_type_enum {
		bake_type_NORMALS = 0,
		bake_type_DISPLACEMENT = 1,
	};
	inline bake_type_enum bake_type(void);
	inline void bake_type(bake_type_enum value);
	inline bool use_bake_selected_to_active(void);
	inline void use_bake_selected_to_active(bool value);
	inline bool use_bake_clear(void);
	inline void use_bake_clear(bool value);
	inline int bake_margin(void);
	inline void bake_margin(int value);
	enum bake_margin_type_enum {
		bake_margin_type_ADJACENT_FACES = 0,
		bake_margin_type_EXTEND = 1,
	};
	inline bake_margin_type_enum bake_margin_type(void);
	inline void bake_margin_type(bake_margin_type_enum value);
	inline float bake_bias(void);
	inline void bake_bias(float value);
	inline bool use_bake_multires(void);
	inline void use_bake_multires(bool value);
	inline bool use_bake_lores_mesh(void);
	inline void use_bake_lores_mesh(bool value);
	inline int bake_samples(void);
	inline void bake_samples(int value);
	inline bool use_bake_user_scale(void);
	inline void use_bake_user_scale(bool value);
	inline float bake_user_scale(void);
	inline void bake_user_scale(float value);
	inline bool use_stamp_time(void);
	inline void use_stamp_time(bool value);
	inline bool use_stamp_date(void);
	inline void use_stamp_date(bool value);
	inline bool use_stamp_frame(void);
	inline void use_stamp_frame(bool value);
	inline bool use_stamp_frame_range(void);
	inline void use_stamp_frame_range(bool value);
	inline bool use_stamp_camera(void);
	inline void use_stamp_camera(bool value);
	inline bool use_stamp_lens(void);
	inline void use_stamp_lens(bool value);
	inline bool use_stamp_scene(void);
	inline void use_stamp_scene(bool value);
	inline bool use_stamp_note(void);
	inline void use_stamp_note(bool value);
	inline bool use_stamp_marker(void);
	inline void use_stamp_marker(bool value);
	inline bool use_stamp_filename(void);
	inline void use_stamp_filename(bool value);
	inline bool use_stamp_sequencer_strip(void);
	inline void use_stamp_sequencer_strip(bool value);
	inline bool use_stamp_render_time(void);
	inline void use_stamp_render_time(bool value);
	inline std::string stamp_note_text(void);
	inline void stamp_note_text(const std::string& value);
	inline bool use_stamp(void);
	inline void use_stamp(bool value);
	inline bool use_stamp_labels(void);
	inline void use_stamp_labels(bool value);
	enum metadata_input_enum {
		metadata_input_SCENE = 0,
		metadata_input_STRIPS = 4096,
	};
	inline metadata_input_enum metadata_input(void);
	inline void metadata_input(metadata_input_enum value);
	inline bool use_stamp_memory(void);
	inline void use_stamp_memory(bool value);
	inline bool use_stamp_hostname(void);
	inline void use_stamp_hostname(bool value);
	inline int stamp_font_size(void);
	inline void stamp_font_size(int value);
	inline Array<float, 4> stamp_foreground(void);
	inline void stamp_foreground(float values[4]);
	inline Array<float, 4> stamp_background(void);
	inline void stamp_background(float values[4]);
	enum sequencer_gl_preview_enum {
		sequencer_gl_preview_WIREFRAME = 2,
		sequencer_gl_preview_SOLID = 3,
		sequencer_gl_preview_MATERIAL = 4,
		sequencer_gl_preview_RENDERED = 6,
	};
	inline sequencer_gl_preview_enum sequencer_gl_preview(void);
	inline void sequencer_gl_preview(sequencer_gl_preview_enum value);
	inline bool use_sequencer_override_scene_strip(void);
	inline void use_sequencer_override_scene_strip(bool value);
	inline bool use_single_layer(void);
	inline void use_single_layer(bool value);
	COLLECTION_PROPERTY(RenderViews, SceneRenderView, RenderSettings, views, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SceneRenderView, RenderSettings, stereo_views, false, true, true)
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	enum views_format_enum {
		views_format_STEREO_3D = 0,
		views_format_MULTIVIEW = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	enum engine_enum {
		engine_BLENDER_EEVEE = 0,
	};
	inline engine_enum engine(void);
	inline void engine(engine_enum value);
	inline bool has_multiple_engines(void);
	inline void has_multiple_engines(bool value);
	inline bool use_spherical_stereo(void);
	inline void use_spherical_stereo(bool value);
	inline bool use_simplify(void);
	inline void use_simplify(bool value);
	inline int simplify_subdivision(void);
	inline void simplify_subdivision(int value);
	inline float simplify_child_particles(void);
	inline void simplify_child_particles(float value);
	inline int simplify_subdivision_render(void);
	inline void simplify_subdivision_render(int value);
	inline float simplify_child_particles_render(void);
	inline void simplify_child_particles_render(float value);
	inline float simplify_volumes(void);
	inline void simplify_volumes(float value);
	inline float simplify_shadows_render(void);
	inline void simplify_shadows_render(float value);
	inline float simplify_shadows(void);
	inline void simplify_shadows(float value);
	inline bool simplify_gpencil(void);
	inline void simplify_gpencil(bool value);
	inline bool simplify_gpencil_onplay(void);
	inline void simplify_gpencil_onplay(bool value);
	inline bool simplify_gpencil_antialiasing(void);
	inline void simplify_gpencil_antialiasing(bool value);
	inline bool simplify_gpencil_view_fill(void);
	inline void simplify_gpencil_view_fill(bool value);
	inline bool simplify_gpencil_modifier(void);
	inline void simplify_gpencil_modifier(bool value);
	inline bool simplify_gpencil_shader_fx(void);
	inline void simplify_gpencil_shader_fx(bool value);
	inline bool simplify_gpencil_tint(void);
	inline void simplify_gpencil_tint(bool value);
	inline bool use_persistent_data(void);
	inline void use_persistent_data(bool value);
	enum line_thickness_mode_enum {
		line_thickness_mode_ABSOLUTE = 1,
		line_thickness_mode_RELATIVE = 2,
	};
	inline line_thickness_mode_enum line_thickness_mode(void);
	inline void line_thickness_mode(line_thickness_mode_enum value);
	inline float line_thickness(void);
	inline void line_thickness(float value);
	inline BakeSettings bake(void);

	inline void frame_path(void *main, int frame, bool preview, const char * view, char * filepath);
};

/**************** Bake Data ****************/

class BakeSettings : public Pointer {
public:
	BakeSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Object cage_object(void);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);
	inline int margin(void);
	inline void margin(int value);
	enum margin_type_enum {
		margin_type_ADJACENT_FACES = 0,
		margin_type_EXTEND = 1,
	};
	inline margin_type_enum margin_type(void);
	inline void margin_type(margin_type_enum value);
	inline float max_ray_distance(void);
	inline void max_ray_distance(float value);
	inline float cage_extrusion(void);
	inline void cage_extrusion(float value);
	enum normal_space_enum {
		normal_space_OBJECT = 2,
		normal_space_TANGENT = 3,
	};
	inline normal_space_enum normal_space(void);
	inline void normal_space(normal_space_enum value);
	enum normal_r_enum {
		normal_r_POS_X = 0,
		normal_r_POS_Y = 1,
		normal_r_POS_Z = 2,
		normal_r_NEG_X = 3,
		normal_r_NEG_Y = 4,
		normal_r_NEG_Z = 5,
	};
	inline normal_r_enum normal_r(void);
	inline void normal_r(normal_r_enum value);
	enum normal_g_enum {
		normal_g_POS_X = 0,
		normal_g_POS_Y = 1,
		normal_g_POS_Z = 2,
		normal_g_NEG_X = 3,
		normal_g_NEG_Y = 4,
		normal_g_NEG_Z = 5,
	};
	inline normal_g_enum normal_g(void);
	inline void normal_g(normal_g_enum value);
	enum normal_b_enum {
		normal_b_POS_X = 0,
		normal_b_POS_Y = 1,
		normal_b_POS_Z = 2,
		normal_b_NEG_X = 3,
		normal_b_NEG_Y = 4,
		normal_b_NEG_Z = 5,
	};
	inline normal_b_enum normal_b(void);
	inline void normal_b(normal_b_enum value);
	inline ImageFormatSettings image_settings(void);
	enum target_enum {
		target_IMAGE_TEXTURES = 0,
		target_VERTEX_COLORS = 1,
	};
	inline target_enum target(void);
	inline void target(target_enum value);
	enum save_mode_enum {
		save_mode_INTERNAL = 0,
		save_mode_EXTERNAL = 1,
	};
	inline save_mode_enum save_mode(void);
	inline void save_mode(save_mode_enum value);
	enum view_from_enum {
		view_from_ABOVE_SURFACE = 0,
		view_from_ACTIVE_CAMERA = 1,
	};
	inline view_from_enum view_from(void);
	inline void view_from(view_from_enum value);
	inline bool use_selected_to_active(void);
	inline void use_selected_to_active(bool value);
	inline bool use_clear(void);
	inline void use_clear(bool value);
	inline bool use_split_materials(void);
	inline void use_split_materials(bool value);
	inline bool use_automatic_name(void);
	inline void use_automatic_name(bool value);
	inline bool use_cage(void);
	inline void use_cage(bool value);
	inline bool use_pass_emit(void);
	inline void use_pass_emit(bool value);
	inline bool use_pass_direct(void);
	inline void use_pass_direct(bool value);
	inline bool use_pass_indirect(void);
	inline void use_pass_indirect(bool value);
	inline bool use_pass_color(void);
	inline void use_pass_color(bool value);
	inline bool use_pass_diffuse(void);
	inline void use_pass_diffuse(bool value);
	inline bool use_pass_glossy(void);
	inline void use_pass_glossy(bool value);
	inline bool use_pass_transmission(void);
	inline void use_pass_transmission(bool value);
	enum pass_filter_enum {
		pass_filter_NONE = 0,
		pass_filter_EMIT = 2,
		pass_filter_DIRECT = 64,
		pass_filter_INDIRECT = 128,
		pass_filter_COLOR = 256,
		pass_filter_DIFFUSE = 4,
		pass_filter_GLOSSY = 8,
		pass_filter_TRANSMISSION = 16,
	};
	inline pass_filter_enum pass_filter(void);
	inline void pass_filter(pass_filter_enum value);

};

/**************** Scene Render View ****************/

class SceneRenderView : public Pointer {
public:
	SceneRenderView(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string file_suffix(void);
	inline void file_suffix(const std::string& value);
	inline std::string camera_suffix(void);
	inline void camera_suffix(const std::string& value);
	inline bool use(void);
	inline void use(bool value);

};

/**************** Screen ****************/

class Screen : public ID {
public:
	Screen(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		areas(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Area, Screen, areas, false, true, false)
	inline bool is_animation_playing(void);
	inline void is_animation_playing(bool value);
	inline bool is_scrubbing(void);
	inline void is_scrubbing(bool value);
	inline bool is_temporary(void);
	inline void is_temporary(bool value);
	inline bool show_fullscreen(void);
	inline void show_fullscreen(bool value);
	inline bool show_statusbar(void);
	inline void show_statusbar(bool value);
	inline bool use_play_top_left_3d_editor(void);
	inline void use_play_top_left_3d_editor(bool value);
	inline bool use_play_3d_editors(void);
	inline void use_play_3d_editors(bool value);
	inline bool use_follow(void);
	inline void use_follow(bool value);
	inline bool use_play_animation_editors(void);
	inline void use_play_animation_editors(bool value);
	inline bool use_play_properties_editors(void);
	inline void use_play_properties_editors(bool value);
	inline bool use_play_image_editors(void);
	inline void use_play_image_editors(bool value);
	inline bool use_play_sequence_editors(void);
	inline void use_play_sequence_editors(bool value);
	inline bool use_play_node_editors(void);
	inline void use_play_node_editors(bool value);
	inline bool use_play_clip_editors(void);
	inline void use_play_clip_editors(bool value);
	inline bool use_play_spreadsheet_editors(void);
	inline void use_play_spreadsheet_editors(bool value);

	inline const char * statusbar_info(void *main, Context C);
};

/**************** Area ****************/

class Area : public Pointer {
public:
	Area(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		spaces(ptr_arg),
		regions(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(AreaSpaces, Space, Area, spaces, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Region, Area, regions, false, true, false)
	inline bool show_menus(void);
	inline void show_menus(bool value);
	enum type_enum {
		type_EMPTY = 0,
		type_VIEW_3D = 1,
		type_IMAGE_EDITOR = 6,
		type_NODE_EDITOR = 16,
		type_SEQUENCE_EDITOR = 8,
		type_CLIP_EDITOR = 20,
		type_DOPESHEET_EDITOR = 12,
		type_GRAPH_EDITOR = 2,
		type_NLA_EDITOR = 13,
		type_TEXT_EDITOR = 9,
		type_CONSOLE = 18,
		type_INFO = 7,
		type_TOPBAR = 21,
		type_STATUSBAR = 22,
		type_OUTLINER = 3,
		type_PROPERTIES = 4,
		type_FILE_BROWSER = 5,
		type_SPREADSHEET = 23,
		type_PREFERENCES = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum ui_type_enum {
	};
	inline ui_type_enum ui_type(void);
	inline void ui_type(ui_type_enum value);
	inline int x(void);
	inline void x(int value);
	inline int y(void);
	inline void y(int value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);

	inline void tag_redraw();
	inline void header_text_set(const char * text);
};

/**************** Region ****************/

class Region : public Pointer {
public:
	Region(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_WINDOW = 0,
		type_HEADER = 1,
		type_CHANNELS = 2,
		type_TEMPORARY = 3,
		type_UI = 4,
		type_TOOLS = 5,
		type_TOOL_PROPS = 6,
		type_ASSET_SHELF = 14,
		type_ASSET_SHELF_HEADER = 15,
		type_PREVIEW = 7,
		type_HUD = 8,
		type_NAVIGATION_BAR = 9,
		type_EXECUTE = 10,
		type_FOOTER = 11,
		type_TOOL_HEADER = 12,
		type_XR = 13,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline int x(void);
	inline void x(int value);
	inline int y(void);
	inline void y(int value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);
	inline View2D view2d(void);
	enum alignment_enum {
		alignment_NONE = 0,
		alignment_TOP = 1,
		alignment_BOTTOM = 2,
		alignment_LEFT = 3,
		alignment_RIGHT = 4,
		alignment_HORIZONTAL_SPLIT = 5,
		alignment_VERTICAL_SPLIT = 6,
		alignment_FLOAT = 7,
		alignment_QUAD_SPLIT = 8,
	};
	inline alignment_enum alignment(void);
	inline void alignment(alignment_enum value);
	inline AnyType data(void);
	enum active_panel_category_enum {
		active_panel_category_UNSUPPORTED = -1,
	};
	inline active_panel_category_enum active_panel_category(void);
	inline void active_panel_category(active_panel_category_enum value);

	inline void tag_redraw();
};

/**************** View2D ****************/

class View2D : public Pointer {
public:
	View2D(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

	inline void region_to_view(float x, float y, float result[2]);
	inline void view_to_region(float x, float y, bool clip, int result[2]);
};

/**************** Paint Curve ****************/

class PaintCurve : public ID {
public:
	PaintCurve(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}


};

/**************** Paint Tool Slot ****************/

class PaintToolSlot : public Pointer {
public:
	PaintToolSlot(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Brush brush(void);

};

/**************** Paint ****************/

class Paint : public Pointer {
public:
	Paint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tool_slots(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Brush brush(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, PaintToolSlot, Paint, tool_slots, true, true, false)
	inline Palette palette(void);
	inline bool show_brush(void);
	inline void show_brush(bool value);
	inline bool show_brush_on_surface(void);
	inline void show_brush_on_surface(bool value);
	inline bool show_low_resolution(void);
	inline void show_low_resolution(bool value);
	inline bool use_sculpt_delay_updates(void);
	inline void use_sculpt_delay_updates(bool value);
	inline int input_samples(void);
	inline void input_samples(int value);
	inline bool use_symmetry_x(void);
	inline void use_symmetry_x(bool value);
	inline bool use_symmetry_y(void);
	inline void use_symmetry_y(bool value);
	inline bool use_symmetry_z(void);
	inline void use_symmetry_z(bool value);
	inline bool use_symmetry_feather(void);
	inline void use_symmetry_feather(bool value);
	inline CurveMapping cavity_curve(void);
	inline bool use_cavity(void);
	inline void use_cavity(bool value);
	inline Array<float, 3> tile_offset(void);
	inline void tile_offset(float values[3]);
	inline bool tile_x(void);
	inline void tile_x(bool value);
	inline bool tile_y(void);
	inline void tile_y(bool value);
	inline bool tile_z(void);
	inline void tile_z(bool value);

};

/**************** Sculpt ****************/

class Sculpt : public Paint {
public:
	Sculpt(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}

	inline Array<int, 3> radial_symmetry(void);
	inline void radial_symmetry(int values[3]);
	inline bool lock_x(void);
	inline void lock_x(bool value);
	inline bool lock_y(void);
	inline void lock_y(bool value);
	inline bool lock_z(void);
	inline void lock_z(bool value);
	inline bool use_deform_only(void);
	inline void use_deform_only(bool value);
	inline float detail_size(void);
	inline void detail_size(float value);
	inline float detail_percent(void);
	inline void detail_percent(float value);
	inline float constant_detail_resolution(void);
	inline void constant_detail_resolution(float value);
	inline bool use_automasking_topology(void);
	inline void use_automasking_topology(bool value);
	inline bool use_automasking_face_sets(void);
	inline void use_automasking_face_sets(bool value);
	inline bool use_automasking_boundary_edges(void);
	inline void use_automasking_boundary_edges(bool value);
	inline bool use_automasking_boundary_face_sets(void);
	inline void use_automasking_boundary_face_sets(bool value);
	inline bool use_automasking_cavity(void);
	inline void use_automasking_cavity(bool value);
	inline bool use_automasking_cavity_inverted(void);
	inline void use_automasking_cavity_inverted(bool value);
	inline bool use_automasking_custom_cavity_curve(void);
	inline void use_automasking_custom_cavity_curve(bool value);
	inline float automasking_cavity_factor(void);
	inline void automasking_cavity_factor(float value);
	inline int automasking_cavity_blur_steps(void);
	inline void automasking_cavity_blur_steps(int value);
	inline CurveMapping automasking_cavity_curve(void);
	inline CurveMapping automasking_cavity_curve_op(void);
	inline bool use_automasking_start_normal(void);
	inline void use_automasking_start_normal(bool value);
	inline bool use_automasking_view_normal(void);
	inline void use_automasking_view_normal(bool value);
	inline bool use_automasking_view_occlusion(void);
	inline void use_automasking_view_occlusion(bool value);
	inline float automasking_start_normal_limit(void);
	inline void automasking_start_normal_limit(float value);
	inline float automasking_start_normal_falloff(void);
	inline void automasking_start_normal_falloff(float value);
	inline float automasking_view_normal_limit(void);
	inline void automasking_view_normal_limit(float value);
	inline float automasking_view_normal_falloff(void);
	inline void automasking_view_normal_falloff(float value);
	enum symmetrize_direction_enum {
		symmetrize_direction_NEGATIVE_X = 0,
		symmetrize_direction_POSITIVE_X = 3,
		symmetrize_direction_NEGATIVE_Y = 1,
		symmetrize_direction_POSITIVE_Y = 4,
		symmetrize_direction_NEGATIVE_Z = 2,
		symmetrize_direction_POSITIVE_Z = 5,
	};
	inline symmetrize_direction_enum symmetrize_direction(void);
	inline void symmetrize_direction(symmetrize_direction_enum value);
	enum detail_refine_method_enum {
		detail_refine_method_SUBDIVIDE = 4096,
		detail_refine_method_COLLAPSE = 2048,
		detail_refine_method_SUBDIVIDE_COLLAPSE = 6144,
	};
	inline detail_refine_method_enum detail_refine_method(void);
	inline void detail_refine_method(detail_refine_method_enum value);
	enum detail_type_method_enum {
		detail_type_method_RELATIVE = 0,
		detail_type_method_CONSTANT = 8192,
		detail_type_method_BRUSH = 16384,
		detail_type_method_MANUAL = 65536,
	};
	inline detail_type_method_enum detail_type_method(void);
	inline void detail_type_method(detail_type_method_enum value);
	inline float gravity(void);
	inline void gravity(float value);
	enum transform_mode_enum {
		transform_mode_ALL_VERTICES = 0,
		transform_mode_RADIUS_ELASTIC = 1,
	};
	inline transform_mode_enum transform_mode(void);
	inline void transform_mode(transform_mode_enum value);
	inline Object gravity_object(void);

};

/**************** UV Sculpting ****************/

class UvSculpt : public Paint {
public:
	UvSculpt(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}


};

/**************** Grease Pencil Paint ****************/

class GpPaint : public Paint {
public:
	GpPaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}

	enum color_mode_enum {
		color_mode_MATERIAL = 0,
		color_mode_VERTEXCOLOR = 1,
	};
	inline color_mode_enum color_mode(void);
	inline void color_mode(color_mode_enum value);

};

/**************** Grease Pencil Vertex Paint ****************/

class GpVertexPaint : public Paint {
public:
	GpVertexPaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}


};

/**************** Grease Pencil Sculpt Paint ****************/

class GpSculptPaint : public Paint {
public:
	GpSculptPaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}


};

/**************** Grease Pencil Weight Paint ****************/

class GpWeightPaint : public Paint {
public:
	GpWeightPaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}


};

/**************** Vertex Paint ****************/

class VertexPaint : public Paint {
public:
	VertexPaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}

	inline bool use_group_restrict(void);
	inline void use_group_restrict(bool value);
	inline Array<int, 3> radial_symmetry(void);
	inline void radial_symmetry(int values[3]);

};

/**************** Paint Mode ****************/

class PaintModeSettings : public Pointer {
public:
	PaintModeSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum canvas_source_enum {
		canvas_source_COLOR_ATTRIBUTE = 2,
		canvas_source_MATERIAL = 0,
		canvas_source_IMAGE = 1,
	};
	inline canvas_source_enum canvas_source(void);
	inline void canvas_source(canvas_source_enum value);
	inline Image canvas_image(void);

};

/**************** Image Paint ****************/

class ImagePaint : public Paint {
public:
	ImagePaint(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}

	inline bool use_occlude(void);
	inline void use_occlude(bool value);
	inline bool use_backface_culling(void);
	inline void use_backface_culling(bool value);
	inline bool use_normal_falloff(void);
	inline void use_normal_falloff(bool value);
	inline bool use_stencil_layer(void);
	inline void use_stencil_layer(bool value);
	inline bool invert_stencil(void);
	inline void invert_stencil(bool value);
	inline Image stencil_image(void);
	inline Image canvas(void);
	inline Image clone_image(void);
	inline Array<float, 3> stencil_color(void);
	inline void stencil_color(float values[3]);
	inline float dither(void);
	inline void dither(float value);
	inline bool use_clone_layer(void);
	inline void use_clone_layer(bool value);
	inline int seam_bleed(void);
	inline void seam_bleed(int value);
	inline int normal_angle(void);
	inline void normal_angle(int value);
	inline Array<int, 2> screen_grab_size(void);
	inline void screen_grab_size(int values[2]);
	enum mode_enum {
		mode_MATERIAL = 0,
		mode_IMAGE = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum interpolation_enum {
		interpolation_LINEAR = 0,
		interpolation_CLOSEST = 1,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);
	inline bool missing_uvs(void);
	inline void missing_uvs(bool value);
	inline bool missing_materials(void);
	inline void missing_materials(bool value);
	inline bool missing_stencil(void);
	inline void missing_stencil(bool value);
	inline bool missing_texture(void);
	inline void missing_texture(bool value);

	inline bool detect_data();
};

/**************** Particle Edit ****************/

class ParticleEdit : public Pointer {
public:
	ParticleEdit(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum tool_enum {
		tool_COMB = 0,
		tool_SMOOTH = 5,
		tool_ADD = 4,
		tool_LENGTH = 2,
		tool_PUFF = 3,
		tool_CUT = 1,
		tool_WEIGHT = 6,
	};
	inline tool_enum tool(void);
	inline void tool(tool_enum value);
	enum select_mode_enum {
		select_mode_PATH = 1,
		select_mode_POINT = 2,
		select_mode_TIP = 4,
	};
	inline select_mode_enum select_mode(void);
	inline void select_mode(select_mode_enum value);
	inline bool use_preserve_length(void);
	inline void use_preserve_length(bool value);
	inline bool use_preserve_root(void);
	inline void use_preserve_root(bool value);
	inline bool use_emitter_deflect(void);
	inline void use_emitter_deflect(bool value);
	inline float emitter_distance(void);
	inline void emitter_distance(float value);
	inline bool use_fade_time(void);
	inline void use_fade_time(bool value);
	inline bool use_auto_velocity(void);
	inline void use_auto_velocity(bool value);
	inline bool show_particles(void);
	inline void show_particles(bool value);
	inline bool use_default_interpolate(void);
	inline void use_default_interpolate(bool value);
	inline int default_key_count(void);
	inline void default_key_count(int value);
	inline ParticleBrush brush(void);
	inline int display_step(void);
	inline void display_step(int value);
	inline int fade_frames(void);
	inline void fade_frames(int value);
	enum type_enum {
		type_PARTICLES = 0,
		type_SOFT_BODY = 1,
		type_CLOTH = 2,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool is_editable(void);
	inline void is_editable(bool value);
	inline bool is_hair(void);
	inline void is_hair(bool value);
	inline Object object(void);
	inline Object shape_object(void);

};

/**************** Particle Brush ****************/

class ParticleBrush : public Pointer {
public:
	ParticleBrush(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int size(void);
	inline void size(int value);
	inline float strength(void);
	inline void strength(float value);
	inline int count(void);
	inline void count(int value);
	inline int steps(void);
	inline void steps(int value);
	enum puff_mode_enum {
		puff_mode_ADD = 0,
		puff_mode_SUB = 1,
	};
	inline puff_mode_enum puff_mode(void);
	inline void puff_mode(puff_mode_enum value);
	inline bool use_puff_volume(void);
	inline void use_puff_volume(bool value);
	enum length_mode_enum {
		length_mode_GROW = 0,
		length_mode_SHRINK = 1,
	};
	inline length_mode_enum length_mode(void);
	inline void length_mode(length_mode_enum value);
	inline CurveMapping curve(void);

};

/**************** GPencil Sculpt Guide ****************/

class GPencilSculptGuide : public Pointer {
public:
	GPencilSculptGuide(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_guide(void);
	inline void use_guide(bool value);
	inline bool use_snapping(void);
	inline void use_snapping(bool value);
	inline Object reference_object(void);
	enum reference_point_enum {
		reference_point_CURSOR = 0,
		reference_point_CUSTOM = 1,
		reference_point_OBJECT = 2,
	};
	inline reference_point_enum reference_point(void);
	inline void reference_point(reference_point_enum value);
	enum type_enum {
		type_CIRCULAR = 0,
		type_RADIAL = 1,
		type_PARALLEL = 2,
		type_GRID = 3,
		type_ISO = 4,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline float angle(void);
	inline void angle(float value);
	inline float angle_snap(void);
	inline void angle_snap(float value);
	inline float spacing(void);
	inline void spacing(float value);
	inline Array<float, 3> location(void);
	inline void location(float values[3]);

};

/**************** GPencil Sculpt Settings ****************/

class GPencilSculptSettings : public Pointer {
public:
	GPencilSculptSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline GPencilSculptGuide guide(void);
	inline bool use_multiframe_falloff(void);
	inline void use_multiframe_falloff(bool value);
	inline bool use_thickness_curve(void);
	inline void use_thickness_curve(bool value);
	inline bool use_scale_thickness(void);
	inline void use_scale_thickness(bool value);
	inline bool use_automasking_stroke(void);
	inline void use_automasking_stroke(bool value);
	inline bool use_automasking_layer_stroke(void);
	inline void use_automasking_layer_stroke(bool value);
	inline bool use_automasking_material_stroke(void);
	inline void use_automasking_material_stroke(bool value);
	inline bool use_automasking_layer_active(void);
	inline void use_automasking_layer_active(bool value);
	inline bool use_automasking_material_active(void);
	inline void use_automasking_material_active(bool value);
	inline CurveMapping multiframe_falloff_curve(void);
	inline CurveMapping thickness_primitive_curve(void);
	enum lock_axis_enum {
		lock_axis_VIEW = 0,
		lock_axis_AXIS_Y = 2,
		lock_axis_AXIS_X = 1,
		lock_axis_AXIS_Z = 3,
		lock_axis_CURSOR = 4,
	};
	inline lock_axis_enum lock_axis(void);
	inline void lock_axis(lock_axis_enum value);
	inline float intersection_threshold(void);
	inline void intersection_threshold(float value);

};

/**************** Curves Sculpt Paint ****************/

class CurvesSculpt : public Paint {
public:
	CurvesSculpt(const PointerRNA &ptr_arg) :
		Paint(ptr_arg)
		{}


};

/**************** Sequence Color Balance Data ****************/

class SequenceColorBalanceData : public Pointer {
public:
	SequenceColorBalanceData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum correction_method_enum {
		correction_method_LIFT_GAMMA_GAIN = 0,
		correction_method_OFFSET_POWER_SLOPE = 1,
	};
	inline correction_method_enum correction_method(void);
	inline void correction_method(correction_method_enum value);
	inline Array<float, 3> lift(void);
	inline void lift(float values[3]);
	inline Array<float, 3> gamma(void);
	inline void gamma(float values[3]);
	inline Array<float, 3> gain(void);
	inline void gain(float values[3]);
	inline Array<float, 3> slope(void);
	inline void slope(float values[3]);
	inline Array<float, 3> offset(void);
	inline void offset(float values[3]);
	inline Array<float, 3> power(void);
	inline void power(float values[3]);
	inline bool invert_lift(void);
	inline void invert_lift(bool value);
	inline bool invert_gamma(void);
	inline void invert_gamma(bool value);
	inline bool invert_gain(void);
	inline void invert_gain(bool value);
	inline bool invert_slope(void);
	inline void invert_slope(bool value);
	inline bool invert_offset(void);
	inline void invert_offset(bool value);
	inline bool invert_power(void);
	inline void invert_power(bool value);

};

/**************** Sequence Element ****************/

class SequenceElement : public Pointer {
public:
	SequenceElement(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string filename(void);
	inline void filename(const std::string& value);
	inline int orig_width(void);
	inline void orig_width(int value);
	inline int orig_height(void);
	inline void orig_height(int value);
	inline float orig_fps(void);
	inline void orig_fps(float value);

};

/**************** Retiming Key ****************/

class RetimingKey : public Pointer {
public:
	RetimingKey(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int timeline_frame(void);
	inline void timeline_frame(int value);

	inline void remove();
};

/**************** Sequence Proxy ****************/

class SequenceProxy : public Pointer {
public:
	SequenceProxy(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string directory(void);
	inline void directory(const std::string& value);
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool use_overwrite(void);
	inline void use_overwrite(bool value);
	inline bool build_25(void);
	inline void build_25(bool value);
	inline bool build_50(void);
	inline void build_50(bool value);
	inline bool build_75(void);
	inline void build_75(bool value);
	inline bool build_100(void);
	inline void build_100(bool value);
	inline bool build_record_run(void);
	inline void build_record_run(bool value);
	inline bool build_free_run(void);
	inline void build_free_run(bool value);
	inline bool build_free_run_rec_date(void);
	inline void build_free_run_rec_date(bool value);
	inline int quality(void);
	inline void quality(int value);
	enum timecode_enum {
		timecode_NONE = 0,
		timecode_RECORD_RUN = 1,
		timecode_FREE_RUN = 2,
		timecode_FREE_RUN_REC_DATE = 4,
		timecode_RECORD_RUN_NO_GAPS = 8,
	};
	inline timecode_enum timecode(void);
	inline void timecode(timecode_enum value);
	inline bool use_proxy_custom_directory(void);
	inline void use_proxy_custom_directory(bool value);
	inline bool use_proxy_custom_file(void);
	inline void use_proxy_custom_file(bool value);

};

/**************** Sequence Color Balance ****************/

class SequenceColorBalance : public SequenceColorBalanceData {
public:
	SequenceColorBalance(const PointerRNA &ptr_arg) :
		SequenceColorBalanceData(ptr_arg)
		{}


};

/**************** Sequence Crop ****************/

class SequenceCrop : public Pointer {
public:
	SequenceCrop(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int max_y(void);
	inline void max_y(int value);
	inline int min_y(void);
	inline void min_y(int value);
	inline int min_x(void);
	inline void min_x(int value);
	inline int max_x(void);
	inline void max_x(int value);

};

/**************** Sequence Transform ****************/

class SequenceTransform : public Pointer {
public:
	SequenceTransform(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float scale_x(void);
	inline void scale_x(float value);
	inline float scale_y(void);
	inline void scale_y(float value);
	inline float offset_x(void);
	inline void offset_x(float value);
	inline float offset_y(void);
	inline void offset_y(float value);
	inline float rotation(void);
	inline void rotation(float value);
	inline Array<float, 2> origin(void);
	inline void origin(float values[2]);
	enum filter_enum {
		filter_NEAREST = 0,
		filter_BILINEAR = 1,
		filter_SUBSAMPLING_3x3 = 2,
	};
	inline filter_enum filter(void);
	inline void filter(filter_enum value);

};

/**************** Sequence ****************/

class Sequence : public Pointer {
public:
	Sequence(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		modifiers(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_IMAGE = 0,
		type_META = 1,
		type_SCENE = 2,
		type_MOVIE = 3,
		type_MOVIECLIP = 6,
		type_MASK = 7,
		type_SOUND = 4,
		type_CROSS = 8,
		type_ADD = 9,
		type_SUBTRACT = 10,
		type_ALPHA_OVER = 11,
		type_ALPHA_UNDER = 12,
		type_GAMMA_CROSS = 13,
		type_MULTIPLY = 14,
		type_OVER_DROP = 15,
		type_WIPE = 25,
		type_GLOW = 26,
		type_TRANSFORM = 27,
		type_COLOR = 28,
		type_SPEED = 29,
		type_MULTICAM = 30,
		type_ADJUSTMENT = 31,
		type_GAUSSIAN_BLUR = 40,
		type_TEXT = 41,
		type_COLORMIX = 42,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_left_handle(void);
	inline void select_left_handle(bool value);
	inline bool select_right_handle(void);
	inline void select_right_handle(bool value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline int frame_final_duration(void);
	inline void frame_final_duration(int value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline float frame_start(void);
	inline void frame_start(float value);
	inline int frame_final_start(void);
	inline void frame_final_start(int value);
	inline int frame_final_end(void);
	inline void frame_final_end(int value);
	inline float frame_offset_start(void);
	inline void frame_offset_start(float value);
	inline float frame_offset_end(void);
	inline void frame_offset_end(float value);
	inline int channel(void);
	inline void channel(int value);
	inline bool use_linear_modifiers(void);
	inline void use_linear_modifiers(bool value);
	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_CROSS = 8,
		blend_type_DARKEN = 46,
		blend_type_MULTIPLY = 14,
		blend_type_BURN = 47,
		blend_type_LINEAR_BURN = 48,
		blend_type_LIGHTEN = 44,
		blend_type_SCREEN = 43,
		blend_type_DODGE = 45,
		blend_type_ADD = 9,
		blend_type_OVERLAY = 49,
		blend_type_SOFT_LIGHT = 51,
		blend_type_HARD_LIGHT = 50,
		blend_type_VIVID_LIGHT = 54,
		blend_type_LINEAR_LIGHT = 53,
		blend_type_PIN_LIGHT = 52,
		blend_type_DIFFERENCE = 59,
		blend_type_EXCLUSION = 60,
		blend_type_SUBTRACT = 10,
		blend_type_HUE = 55,
		blend_type_SATURATION = 56,
		blend_type_COLOR = 58,
		blend_type_VALUE = 57,
		blend_type_ALPHA_OVER = 11,
		blend_type_ALPHA_UNDER = 12,
		blend_type_GAMMA_CROSS = 13,
		blend_type_OVER_DROP = 15,
	};
	inline blend_type_enum blend_type(void);
	inline void blend_type(blend_type_enum value);
	inline float blend_alpha(void);
	inline void blend_alpha(float value);
	inline float effect_fader(void);
	inline void effect_fader(float value);
	inline bool use_default_fade(void);
	inline void use_default_fade(bool value);
	enum color_tag_enum {
		color_tag_NONE = -1,
		color_tag_COLOR_01 = 0,
		color_tag_COLOR_02 = 1,
		color_tag_COLOR_03 = 2,
		color_tag_COLOR_04 = 3,
		color_tag_COLOR_05 = 4,
		color_tag_COLOR_06 = 5,
		color_tag_COLOR_07 = 6,
		color_tag_COLOR_08 = 7,
		color_tag_COLOR_09 = 8,
	};
	inline color_tag_enum color_tag(void);
	inline void color_tag(color_tag_enum value);
	COLLECTION_PROPERTY(SequenceModifiers, SequenceModifier, Sequence, modifiers, false, true, true)
	inline bool use_cache_raw(void);
	inline void use_cache_raw(bool value);
	inline bool use_cache_preprocessed(void);
	inline void use_cache_preprocessed(bool value);
	inline bool use_cache_composite(void);
	inline void use_cache_composite(bool value);
	inline bool override_cache_settings(void);
	inline void override_cache_settings(bool value);
	inline bool show_retiming_keys(void);
	inline void show_retiming_keys(bool value);

	inline SequenceElement strip_elem_from_frame(int frame);
	inline void swap(Sequence& other);
	inline void move_to_meta(void *main, Sequence& meta_sequence);
	inline Sequence parent_meta();
	inline void invalidate_cache(int type);
	inline Sequence split(void *main, int frame, int split_method);
};

/**************** Sequence Editor ****************/

class SequenceEditor : public Pointer {
public:
	SequenceEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		sequences(ptr_arg),
		sequences_all(ptr_arg),
		meta_stack(ptr_arg),
		channels(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(SequencesTopLevel, Sequence, SequenceEditor, sequences, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Sequence, SequenceEditor, sequences_all, false, false, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Sequence, SequenceEditor, meta_stack, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SequenceTimelineChannel, SequenceEditor, channels, false, true, true)
	inline Sequence active_strip(void);
	inline bool selected_retiming_keys(void);
	inline void selected_retiming_keys(bool value);
	inline bool show_overlay_frame(void);
	inline void show_overlay_frame(bool value);
	inline bool use_overlay_frame_lock(void);
	inline void use_overlay_frame_lock(bool value);
	inline int overlay_frame(void);
	inline void overlay_frame(int value);
	enum proxy_storage_enum {
		proxy_storage_PER_STRIP = 0,
		proxy_storage_PROJECT = 1,
	};
	inline proxy_storage_enum proxy_storage(void);
	inline void proxy_storage(proxy_storage_enum value);
	inline std::string proxy_dir(void);
	inline void proxy_dir(const std::string& value);
	inline bool show_cache(void);
	inline void show_cache(bool value);
	inline bool show_cache_final_out(void);
	inline void show_cache_final_out(bool value);
	inline bool show_cache_raw(void);
	inline void show_cache_raw(bool value);
	inline bool show_cache_preprocessed(void);
	inline void show_cache_preprocessed(bool value);
	inline bool show_cache_composite(void);
	inline void show_cache_composite(bool value);
	inline bool use_cache_raw(void);
	inline void use_cache_raw(bool value);
	inline bool use_cache_preprocessed(void);
	inline void use_cache_preprocessed(bool value);
	inline bool use_cache_composite(void);
	inline void use_cache_composite(bool value);
	inline bool use_cache_final(void);
	inline void use_cache_final(bool value);
	inline bool use_prefetch(void);
	inline void use_prefetch(bool value);

	inline void display_stack(Sequence& meta_sequence);
};

/**************** Channel ****************/

class SequenceTimelineChannel : public Pointer {
public:
	SequenceTimelineChannel(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool mute(void);
	inline void mute(bool value);

};

/**************** Image Sequence ****************/

class ImageSequence : public Sequence {
public:
	ImageSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg),
		elements(ptr_arg)
		{}

	inline std::string directory(void);
	inline void directory(const std::string& value);
	COLLECTION_PROPERTY(SequenceElements, SequenceElement, ImageSequence, elements, true, true, false)
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline bool multiply_alpha(void);
	inline void multiply_alpha(bool value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline SequenceTransform transform(void);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);

};

/**************** Meta Sequence ****************/

class MetaSequence : public Sequence {
public:
	MetaSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg),
		sequences(ptr_arg),
		channels(ptr_arg)
		{}

	COLLECTION_PROPERTY(SequencesMeta, Sequence, MetaSequence, sequences, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SequenceTimelineChannel, MetaSequence, channels, false, true, true)
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline bool multiply_alpha(void);
	inline void multiply_alpha(bool value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline SequenceTransform transform(void);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

	inline void separate(void *main);
};

/**************** Scene Sequence ****************/

class SceneSequence : public Sequence {
public:
	SceneSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline Scene scene(void);
	inline Object scene_camera(void);
	enum scene_input_enum {
		scene_input_CAMERA = 0,
		scene_input_SEQUENCER = 1073741824,
	};
	inline scene_input_enum scene_input(void);
	inline void scene_input(scene_input_enum value);
	inline bool use_annotations(void);
	inline void use_annotations(bool value);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline bool multiply_alpha(void);
	inline void multiply_alpha(bool value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline SequenceTransform transform(void);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline float fps(void);
	inline void fps(float value);

};

/**************** Movie Sequence ****************/

class MovieSequence : public Sequence {
public:
	MovieSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg),
		elements(ptr_arg),
		retiming_keys(ptr_arg)
		{}

	inline int stream_index(void);
	inline void stream_index(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SequenceElement, MovieSequence, elements, true, true, false)
	COLLECTION_PROPERTY(RetimingKeys, RetimingKey, MovieSequence, retiming_keys, true, true, false)
	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool use_multiview(void);
	inline void use_multiview(bool value);
	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};
	inline views_format_enum views_format(void);
	inline void views_format(views_format_enum value);
	inline Stereo3dFormat stereo_3d_format(void);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline bool multiply_alpha(void);
	inline void multiply_alpha(bool value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline SequenceTransform transform(void);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);
	inline float fps(void);
	inline void fps(float value);

	inline bool reload_if_needed(void *main);
	inline IDPropertyWrapPtr metadata();
};

/**************** MovieClip Sequence ****************/

class MovieClipSequence : public Sequence {
public:
	MovieClipSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline bool undistort(void);
	inline void undistort(bool value);
	inline bool stabilize2d(void);
	inline void stabilize2d(bool value);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline bool multiply_alpha(void);
	inline void multiply_alpha(bool value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline SequenceTransform transform(void);
	inline SequenceCrop crop(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);
	inline float fps(void);
	inline void fps(float value);

};

/**************** Mask Sequence ****************/

class MaskSequence : public Sequence {
public:
	MaskSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline Mask mask(void);
	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline bool multiply_alpha(void);
	inline void multiply_alpha(bool value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline SequenceTransform transform(void);
	inline SequenceCrop crop(void);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Sound Sequence ****************/

class SoundSequence : public Sequence {
public:
	SoundSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline Sound sound(void);
	inline float volume(void);
	inline void volume(float value);
	inline float pan(void);
	inline void pan(float value);
	inline bool show_waveform(void);
	inline void show_waveform(bool value);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Effect Sequence ****************/

class EffectSequence : public Sequence {
public:
	EffectSequence(const PointerRNA &ptr_arg) :
		Sequence(ptr_arg)
		{}

	inline bool use_deinterlace(void);
	inline void use_deinterlace(bool value);
	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};
	inline alpha_mode_enum alpha_mode(void);
	inline void alpha_mode(alpha_mode_enum value);
	inline bool use_flip_x(void);
	inline void use_flip_x(bool value);
	inline bool use_flip_y(void);
	inline void use_flip_y(bool value);
	inline bool use_float(void);
	inline void use_float(bool value);
	inline bool use_reverse_frames(void);
	inline void use_reverse_frames(bool value);
	inline float color_multiply(void);
	inline void color_multiply(float value);
	inline bool multiply_alpha(void);
	inline void multiply_alpha(bool value);
	inline float color_saturation(void);
	inline void color_saturation(float value);
	inline float strobe(void);
	inline void strobe(float value);
	inline SequenceTransform transform(void);
	inline SequenceCrop crop(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline SequenceProxy proxy(void);

};

/**************** Add Sequence ****************/

class AddSequence : public EffectSequence {
public:
	AddSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Adjustment Layer Sequence ****************/

class AdjustmentSequence : public EffectSequence {
public:
	AdjustmentSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Alpha Over Sequence ****************/

class AlphaOverSequence : public EffectSequence {
public:
	AlphaOverSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Alpha Under Sequence ****************/

class AlphaUnderSequence : public EffectSequence {
public:
	AlphaUnderSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Color Sequence ****************/

class ColorSequence : public EffectSequence {
public:
	ColorSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);

};

/**************** Cross Sequence ****************/

class CrossSequence : public EffectSequence {
public:
	CrossSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Gamma Cross Sequence ****************/

class GammaCrossSequence : public EffectSequence {
public:
	GammaCrossSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Glow Sequence ****************/

class GlowSequence : public EffectSequence {
public:
	GlowSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline float threshold(void);
	inline void threshold(float value);
	inline float clamp(void);
	inline void clamp(float value);
	inline float boost_factor(void);
	inline void boost_factor(float value);
	inline float blur_radius(void);
	inline void blur_radius(float value);
	inline int quality(void);
	inline void quality(int value);
	inline bool use_only_boost(void);
	inline void use_only_boost(bool value);

};

/**************** Multicam Select Sequence ****************/

class MulticamSequence : public EffectSequence {
public:
	MulticamSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline int multicam_source(void);
	inline void multicam_source(int value);
	inline int animation_offset_start(void);
	inline void animation_offset_start(int value);
	inline int animation_offset_end(void);
	inline void animation_offset_end(int value);

};

/**************** Multiply Sequence ****************/

class MultiplySequence : public EffectSequence {
public:
	MultiplySequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Over Drop Sequence ****************/

class OverDropSequence : public EffectSequence {
public:
	OverDropSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** SpeedControl Sequence ****************/

class SpeedControlSequence : public EffectSequence {
public:
	SpeedControlSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	enum speed_control_enum {
		speed_control_STRETCH = 0,
		speed_control_MULTIPLY = 1,
		speed_control_FRAME_NUMBER = 3,
		speed_control_LENGTH = 2,
	};
	inline speed_control_enum speed_control(void);
	inline void speed_control(speed_control_enum value);
	inline float speed_factor(void);
	inline void speed_factor(float value);
	inline float speed_frame_number(void);
	inline void speed_frame_number(float value);
	inline float speed_length(void);
	inline void speed_length(float value);
	inline bool use_frame_interpolate(void);
	inline void use_frame_interpolate(bool value);

};

/**************** Subtract Sequence ****************/

class SubtractSequence : public EffectSequence {
public:
	SubtractSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);

};

/**************** Transform Sequence ****************/

class TransformSequence : public EffectSequence {
public:
	TransformSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline float scale_start_x(void);
	inline void scale_start_x(float value);
	inline float scale_start_y(void);
	inline void scale_start_y(float value);
	inline bool use_uniform_scale(void);
	inline void use_uniform_scale(bool value);
	inline float translate_start_x(void);
	inline void translate_start_x(float value);
	inline float translate_start_y(void);
	inline void translate_start_y(float value);
	inline float rotation_start(void);
	inline void rotation_start(float value);
	enum translation_unit_enum {
		translation_unit_PIXELS = 0,
		translation_unit_PERCENT = 1,
	};
	inline translation_unit_enum translation_unit(void);
	inline void translation_unit(translation_unit_enum value);
	enum interpolation_enum {
		interpolation_NONE = 0,
		interpolation_BILINEAR = 1,
		interpolation_BICUBIC = 2,
	};
	inline interpolation_enum interpolation(void);
	inline void interpolation(interpolation_enum value);

};

/**************** Wipe Sequence ****************/

class WipeSequence : public EffectSequence {
public:
	WipeSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);
	inline float blur_width(void);
	inline void blur_width(float value);
	inline float angle(void);
	inline void angle(float value);
	enum direction_enum {
		direction_OUT = 0,
		direction_IN = 1,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	enum transition_type_enum {
		transition_type_SINGLE = 0,
		transition_type_DOUBLE = 1,
		transition_type_IRIS = 2,
		transition_type_CLOCK = 3,
	};
	inline transition_type_enum transition_type(void);
	inline void transition_type(transition_type_enum value);

};

/**************** Gaussian Blur Sequence ****************/

class GaussianBlurSequence : public EffectSequence {
public:
	GaussianBlurSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline float size_x(void);
	inline void size_x(float value);
	inline float size_y(void);
	inline void size_y(float value);

};

/**************** Text Sequence ****************/

class TextSequence : public EffectSequence {
public:
	TextSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline VectorFont font(void);
	inline float font_size(void);
	inline void font_size(float value);
	inline Array<float, 4> color(void);
	inline void color(float values[4]);
	inline Array<float, 4> shadow_color(void);
	inline void shadow_color(float values[4]);
	inline Array<float, 4> box_color(void);
	inline void box_color(float values[4]);
	inline Array<float, 2> location(void);
	inline void location(float values[2]);
	inline float wrap_width(void);
	inline void wrap_width(float value);
	inline float box_margin(void);
	inline void box_margin(float value);
	enum align_x_enum {
		align_x_LEFT = 0,
		align_x_CENTER = 1,
		align_x_RIGHT = 2,
	};
	inline align_x_enum align_x(void);
	inline void align_x(align_x_enum value);
	enum align_y_enum {
		align_y_TOP = 0,
		align_y_CENTER = 1,
		align_y_BOTTOM = 2,
	};
	inline align_y_enum align_y(void);
	inline void align_y(align_y_enum value);
	inline std::string text(void);
	inline void text(const std::string& value);
	inline bool use_shadow(void);
	inline void use_shadow(bool value);
	inline bool use_box(void);
	inline void use_box(bool value);
	inline bool use_bold(void);
	inline void use_bold(bool value);
	inline bool use_italic(void);
	inline void use_italic(bool value);

};

/**************** Color Mix Sequence ****************/

class ColorMixSequence : public EffectSequence {
public:
	ColorMixSequence(const PointerRNA &ptr_arg) :
		EffectSequence(ptr_arg)
		{}

	inline int input_count(void);
	inline void input_count(int value);
	inline Sequence input_1(void);
	inline Sequence input_2(void);
	enum blend_effect_enum {
		blend_effect_DARKEN = 46,
		blend_effect_MULTIPLY = 14,
		blend_effect_BURN = 47,
		blend_effect_LINEAR_BURN = 48,
		blend_effect_LIGHTEN = 44,
		blend_effect_SCREEN = 43,
		blend_effect_DODGE = 45,
		blend_effect_ADD = 9,
		blend_effect_OVERLAY = 49,
		blend_effect_SOFT_LIGHT = 51,
		blend_effect_HARD_LIGHT = 50,
		blend_effect_VIVID_LIGHT = 54,
		blend_effect_LINEAR_LIGHT = 53,
		blend_effect_PIN_LIGHT = 52,
		blend_effect_DIFFERENCE = 59,
		blend_effect_EXCLUSION = 60,
		blend_effect_SUBTRACT = 10,
		blend_effect_HUE = 55,
		blend_effect_SATURATION = 56,
		blend_effect_COLOR = 58,
		blend_effect_VALUE = 57,
	};
	inline blend_effect_enum blend_effect(void);
	inline void blend_effect(blend_effect_enum value);
	inline float factor(void);
	inline void factor(float value);

};

/**************** SequenceModifier ****************/

class SequenceModifier : public Pointer {
public:
	SequenceModifier(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_BRIGHT_CONTRAST = 4,
		type_COLOR_BALANCE = 1,
		type_CURVES = 2,
		type_HUE_CORRECT = 3,
		type_MASK = 5,
		type_TONEMAP = 7,
		type_WHITE_BALANCE = 6,
		type_SOUND_EQUALIZER = 8,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool mute(void);
	inline void mute(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	enum input_mask_type_enum {
		input_mask_type_STRIP = 0,
		input_mask_type_ID = 1,
	};
	inline input_mask_type_enum input_mask_type(void);
	inline void input_mask_type(input_mask_type_enum value);
	enum mask_time_enum {
		mask_time_RELATIVE = 0,
		mask_time_ABSOLUTE = 1,
	};
	inline mask_time_enum mask_time(void);
	inline void mask_time(mask_time_enum value);
	inline Sequence input_mask_strip(void);
	inline Mask input_mask_id(void);

};

/**************** ColorBalanceModifier ****************/

class ColorBalanceModifier : public SequenceModifier {
public:
	ColorBalanceModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline SequenceColorBalanceData color_balance(void);
	inline float color_multiply(void);
	inline void color_multiply(float value);

};

/**************** CurvesModifier ****************/

class CurvesModifier : public SequenceModifier {
public:
	CurvesModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline CurveMapping curve_mapping(void);

};

/**************** HueCorrectModifier ****************/

class HueCorrectModifier : public SequenceModifier {
public:
	HueCorrectModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline CurveMapping curve_mapping(void);

};

/**************** BrightContrastModifier ****************/

class BrightContrastModifier : public SequenceModifier {
public:
	BrightContrastModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline float bright(void);
	inline void bright(float value);
	inline float contrast(void);
	inline void contrast(float value);

};

/**************** WhiteBalanceModifier ****************/

class WhiteBalanceModifier : public SequenceModifier {
public:
	WhiteBalanceModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	inline Array<float, 3> white_value(void);
	inline void white_value(float values[3]);

};

/**************** SequencerTonemapModifierData ****************/

class SequencerTonemapModifierData : public SequenceModifier {
public:
	SequencerTonemapModifierData(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg)
		{}

	enum tonemap_type_enum {
		tonemap_type_RD_PHOTORECEPTOR = 1,
		tonemap_type_RH_SIMPLE = 0,
	};
	inline tonemap_type_enum tonemap_type(void);
	inline void tonemap_type(tonemap_type_enum value);
	inline float key(void);
	inline void key(float value);
	inline float offset(void);
	inline void offset(float value);
	inline float gamma(void);
	inline void gamma(float value);
	inline float intensity(void);
	inline void intensity(float value);
	inline float contrast(void);
	inline void contrast(float value);
	inline float adaptation(void);
	inline void adaptation(float value);
	inline float correction(void);
	inline void correction(float value);

};

/**************** SoundEqualizerModifier ****************/

class SoundEqualizerModifier : public SequenceModifier {
public:
	SoundEqualizerModifier(const PointerRNA &ptr_arg) :
		SequenceModifier(ptr_arg),
		graphics(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, EQCurveMappingData, SoundEqualizerModifier, graphics, false, true, false)

	inline EQCurveMappingData new_graphic(Context C, float min_freq, float max_freq);
	inline void clear_soundeqs(Context C);
};

/**************** EQCurveMappingData ****************/

class EQCurveMappingData : public Pointer {
public:
	EQCurveMappingData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline CurveMapping curve_mapping(void);

};

/**************** Space ****************/

class Space : public Pointer {
public:
	Space(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_EMPTY = 0,
		type_VIEW_3D = 1,
		type_IMAGE_EDITOR = 6,
		type_NODE_EDITOR = 16,
		type_SEQUENCE_EDITOR = 8,
		type_CLIP_EDITOR = 20,
		type_DOPESHEET_EDITOR = 12,
		type_GRAPH_EDITOR = 2,
		type_NLA_EDITOR = 13,
		type_TEXT_EDITOR = 9,
		type_CONSOLE = 18,
		type_INFO = 7,
		type_TOPBAR = 21,
		type_STATUSBAR = 22,
		type_OUTLINER = 3,
		type_PROPERTIES = 4,
		type_FILE_BROWSER = 5,
		type_SPREADSHEET = 23,
		type_PREFERENCES = 19,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline bool show_locked_time(void);
	inline void show_locked_time(bool value);
	inline bool show_region_header(void);
	inline void show_region_header(bool value);

};

/**************** Viewer Path Element ****************/

class ViewerPathElem : public Pointer {
public:
	ViewerPathElem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_ID = 0,
		type_MODIFIER = 1,
		type_GROUP_NODE = 2,
		type_SIMULATION_ZONE = 3,
		type_VIEWER_NODE = 4,
		type_REPEAT_ZONE = 5,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string ui_name(void);
	inline void ui_name(const std::string& value);

};

/**************** IDViewerPathElem ****************/

class IDViewerPathElem : public ViewerPathElem {
public:
	IDViewerPathElem(const PointerRNA &ptr_arg) :
		ViewerPathElem(ptr_arg)
		{}

	inline ID id(void);

};

/**************** ModifierViewerPathElem ****************/

class ModifierViewerPathElem : public ViewerPathElem {
public:
	ModifierViewerPathElem(const PointerRNA &ptr_arg) :
		ViewerPathElem(ptr_arg)
		{}

	inline std::string modifier_name(void);
	inline void modifier_name(const std::string& value);

};

/**************** GroupNodeViewerPathElem ****************/

class GroupNodeViewerPathElem : public ViewerPathElem {
public:
	GroupNodeViewerPathElem(const PointerRNA &ptr_arg) :
		ViewerPathElem(ptr_arg)
		{}

	inline int node_id(void);
	inline void node_id(int value);

};

/**************** SimulationZoneViewerPathElem ****************/

class SimulationZoneViewerPathElem : public ViewerPathElem {
public:
	SimulationZoneViewerPathElem(const PointerRNA &ptr_arg) :
		ViewerPathElem(ptr_arg)
		{}

	inline int sim_output_node_id(void);
	inline void sim_output_node_id(int value);

};

/**************** RepeatZoneViewerPathElem ****************/

class RepeatZoneViewerPathElem : public ViewerPathElem {
public:
	RepeatZoneViewerPathElem(const PointerRNA &ptr_arg) :
		ViewerPathElem(ptr_arg)
		{}

	inline int repeat_output_node_id(void);
	inline void repeat_output_node_id(int value);

};

/**************** ViewerNodeViewerPathElem ****************/

class ViewerNodeViewerPathElem : public ViewerPathElem {
public:
	ViewerNodeViewerPathElem(const PointerRNA &ptr_arg) :
		ViewerPathElem(ptr_arg)
		{}

	inline int node_id(void);
	inline void node_id(int value);

};

/**************** Viewer Path ****************/

class ViewerPath : public Pointer {
public:
	ViewerPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		path(ptr_arg)
		{}

	inline Struct rna_type(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ViewerPathElem, ViewerPath, path, false, true, false)

};

/**************** Space Image Editor ****************/

class SpaceImageEditor : public Space {
public:
	SpaceImageEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_region_tool_header(void);
	inline void show_region_tool_header(bool value);
	inline bool show_region_toolbar(void);
	inline void show_region_toolbar(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool show_region_hud(void);
	inline void show_region_hud(bool value);
	inline Image image(void);
	inline ImageUser image_user(void);
	inline Scopes scopes(void);
	inline bool use_image_pin(void);
	inline void use_image_pin(bool value);
	inline Histogram sample_histogram(void);
	inline Array<float, 2> zoom(void);
	inline void zoom(float values[2]);
	inline bool show_repeat(void);
	inline void show_repeat(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	enum display_channels_enum {
		display_channels_COLOR_ALPHA = 4096,
		display_channels_COLOR = 0,
		display_channels_ALPHA = 8192,
		display_channels_Z_BUFFER = 16384,
		display_channels_RED = 134217728,
		display_channels_GREEN = 268435456,
		display_channels_BLUE = 536870912,
	};
	inline display_channels_enum display_channels(void);
	inline void display_channels(display_channels_enum value);
	inline bool show_stereo_3d(void);
	inline void show_stereo_3d(bool value);
	inline SpaceUVEditor uv_editor(void);
	enum mode_enum {
		mode_VIEW = 0,
		mode_UV = 3,
		mode_PAINT = 1,
		mode_MASK = 2,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum ui_mode_enum {
		ui_mode_VIEW = 0,
		ui_mode_PAINT = 1,
		ui_mode_MASK = 2,
	};
	inline ui_mode_enum ui_mode(void);
	inline void ui_mode(ui_mode_enum value);
	inline Array<float, 2> cursor_location(void);
	inline void cursor_location(float values[2]);
	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
		pivot_point_MEDIAN_POINT = 3,
		pivot_point_ACTIVE_ELEMENT = 4,
	};
	inline pivot_point_enum pivot_point(void);
	inline void pivot_point(pivot_point_enum value);
	inline GreasePencil grease_pencil(void);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline bool show_render(void);
	inline void show_render(bool value);
	inline bool show_paint(void);
	inline void show_paint(bool value);
	inline bool show_uvedit(void);
	inline void show_uvedit(bool value);
	inline bool show_maskedit(void);
	inline void show_maskedit(bool value);
	inline bool show_gizmo(void);
	inline void show_gizmo(bool value);
	inline bool show_gizmo_navigate(void);
	inline void show_gizmo_navigate(bool value);
	inline SpaceImageOverlay overlay(void);
	inline Mask mask(void);
	enum mask_display_type_enum {
		mask_display_type_OUTLINE = 0,
		mask_display_type_DASH = 1,
		mask_display_type_BLACK = 2,
		mask_display_type_WHITE = 3,
	};
	inline mask_display_type_enum mask_display_type(void);
	inline void mask_display_type(mask_display_type_enum value);
	inline bool show_mask_spline(void);
	inline void show_mask_spline(bool value);
	inline bool show_mask_overlay(void);
	inline void show_mask_overlay(bool value);
	enum mask_overlay_mode_enum {
		mask_overlay_mode_ALPHACHANNEL = 0,
		mask_overlay_mode_COMBINED = 1,
	};
	inline mask_overlay_mode_enum mask_overlay_mode(void);
	inline void mask_overlay_mode(mask_overlay_mode_enum value);
	inline float blend_factor(void);
	inline void blend_factor(float value);

};

/**************** Space UV Editor ****************/

class SpaceUVEditor : public Pointer {
public:
	SpaceUVEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum edge_display_type_enum {
		edge_display_type_OUTLINE = 0,
		edge_display_type_DASH = 1,
		edge_display_type_BLACK = 2,
		edge_display_type_WHITE = 3,
	};
	inline edge_display_type_enum edge_display_type(void);
	inline void edge_display_type(edge_display_type_enum value);
	inline bool show_stretch(void);
	inline void show_stretch(bool value);
	enum display_stretch_type_enum {
		display_stretch_type_ANGLE = 0,
		display_stretch_type_AREA = 1,
	};
	inline display_stretch_type_enum display_stretch_type(void);
	inline void display_stretch_type(display_stretch_type_enum value);
	inline bool show_modified_edges(void);
	inline void show_modified_edges(bool value);
	inline bool show_metadata(void);
	inline void show_metadata(bool value);
	inline bool show_texpaint(void);
	inline void show_texpaint(bool value);
	inline bool show_pixel_coords(void);
	inline void show_pixel_coords(bool value);
	inline bool show_faces(void);
	inline void show_faces(bool value);
	inline Array<int, 2> tile_grid_shape(void);
	inline void tile_grid_shape(int values[2]);
	inline bool show_grid_over_image(void);
	inline void show_grid_over_image(bool value);
	enum grid_shape_source_enum {
		grid_shape_source_DYNAMIC = 0,
		grid_shape_source_FIXED = 1,
		grid_shape_source_PIXEL = 2,
	};
	inline grid_shape_source_enum grid_shape_source(void);
	inline void grid_shape_source(grid_shape_source_enum value);
	inline Array<int, 2> custom_grid_subdivisions(void);
	inline void custom_grid_subdivisions(int values[2]);
	inline float uv_opacity(void);
	inline void uv_opacity(float value);
	enum pixel_round_mode_enum {
		pixel_round_mode_DISABLED = 0,
		pixel_round_mode_CORNER = 2,
		pixel_round_mode_CENTER = 1,
	};
	inline pixel_round_mode_enum pixel_round_mode(void);
	inline void pixel_round_mode(pixel_round_mode_enum value);
	inline bool lock_bounds(void);
	inline void lock_bounds(bool value);
	inline bool use_live_unwrap(void);
	inline void use_live_unwrap(bool value);

};

/**************** Overlay Settings ****************/

class SpaceImageOverlay : public Pointer {
public:
	SpaceImageOverlay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_overlays(void);
	inline void show_overlays(bool value);
	inline bool show_grid_background(void);
	inline void show_grid_background(bool value);

};

/**************** Space Sequence Editor ****************/

class SpaceSequenceEditor : public Space {
public:
	SpaceSequenceEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_region_tool_header(void);
	inline void show_region_tool_header(bool value);
	inline bool show_region_toolbar(void);
	inline void show_region_toolbar(bool value);
	inline bool show_region_channels(void);
	inline void show_region_channels(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool show_region_hud(void);
	inline void show_region_hud(bool value);
	enum view_type_enum {
		view_type_SEQUENCER = 1,
		view_type_PREVIEW = 2,
		view_type_SEQUENCER_PREVIEW = 3,
	};
	inline view_type_enum view_type(void);
	inline void view_type(view_type_enum value);
	enum display_mode_enum {
		display_mode_IMAGE = 1,
		display_mode_WAVEFORM = 2,
		display_mode_VECTOR_SCOPE = 3,
		display_mode_HISTOGRAM = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	inline bool show_frames(void);
	inline void show_frames(bool value);
	inline bool use_marker_sync(void);
	inline void use_marker_sync(bool value);
	inline bool show_separate_color(void);
	inline void show_separate_color(bool value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_markers(void);
	inline void show_markers(bool value);
	inline int display_channel(void);
	inline void display_channel(int value);
	enum preview_channels_enum {
		preview_channels_COLOR_ALPHA = 64,
		preview_channels_COLOR = 0,
	};
	inline preview_channels_enum preview_channels(void);
	inline void preview_channels(preview_channels_enum value);
	inline bool use_zoom_to_fit(void);
	inline void use_zoom_to_fit(bool value);
	inline int show_overexposed(void);
	inline void show_overexposed(int value);
	enum proxy_render_size_enum {
		proxy_render_size_NONE = -1,
		proxy_render_size_SCENE = 0,
		proxy_render_size_PROXY_25 = 25,
		proxy_render_size_PROXY_50 = 50,
		proxy_render_size_PROXY_75 = 75,
		proxy_render_size_PROXY_100 = 99,
	};
	inline proxy_render_size_enum proxy_render_size(void);
	inline void proxy_render_size(proxy_render_size_enum value);
	inline bool use_proxies(void);
	inline void use_proxies(bool value);
	inline bool use_clamp_view(void);
	inline void use_clamp_view(bool value);
	inline GreasePencil grease_pencil(void);
	enum overlay_frame_type_enum {
		overlay_frame_type_RECTANGLE = 0,
		overlay_frame_type_REFERENCE = 1,
		overlay_frame_type_CURRENT = 2,
	};
	inline overlay_frame_type_enum overlay_frame_type(void);
	inline void overlay_frame_type(overlay_frame_type_enum value);
	inline bool show_backdrop(void);
	inline void show_backdrop(bool value);
	inline bool show_transform_preview(void);
	inline void show_transform_preview(bool value);
	inline bool show_gizmo(void);
	inline void show_gizmo(bool value);
	inline bool show_gizmo_navigate(void);
	inline void show_gizmo_navigate(bool value);
	inline bool show_gizmo_context(void);
	inline void show_gizmo_context(bool value);
	inline bool show_gizmo_tool(void);
	inline void show_gizmo_tool(bool value);
	inline bool show_overlays(void);
	inline void show_overlays(bool value);
	inline SequencerPreviewOverlay preview_overlay(void);
	inline SequencerTimelineOverlay timeline_overlay(void);
	inline Array<float, 2> cursor_location(void);
	inline void cursor_location(float values[2]);

};

/**************** Preview Overlay Settings ****************/

class SequencerPreviewOverlay : public Pointer {
public:
	SequencerPreviewOverlay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_safe_areas(void);
	inline void show_safe_areas(bool value);
	inline bool show_safe_center(void);
	inline void show_safe_center(bool value);
	inline bool show_metadata(void);
	inline void show_metadata(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool show_image_outline(void);
	inline void show_image_outline(bool value);
	inline bool show_cursor(void);
	inline void show_cursor(bool value);

};

/**************** Timeline Overlay Settings ****************/

class SequencerTimelineOverlay : public Pointer {
public:
	SequencerTimelineOverlay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum waveform_display_type_enum {
		waveform_display_type_NO_WAVEFORMS = 256,
		waveform_display_type_ALL_WAVEFORMS = 128,
		waveform_display_type_DEFAULT_WAVEFORMS = 0,
	};
	inline waveform_display_type_enum waveform_display_type(void);
	inline void waveform_display_type(waveform_display_type_enum value);
	inline bool show_fcurves(void);
	inline void show_fcurves(bool value);
	inline bool show_strip_name(void);
	inline void show_strip_name(bool value);
	inline bool show_strip_source(void);
	inline void show_strip_source(bool value);
	inline bool show_strip_duration(void);
	inline void show_strip_duration(bool value);
	inline bool show_grid(void);
	inline void show_grid(bool value);
	inline bool show_strip_offset(void);
	inline void show_strip_offset(bool value);
	inline bool show_thumbnails(void);
	inline void show_thumbnails(bool value);
	inline bool show_strip_tag_color(void);
	inline void show_strip_tag_color(bool value);
	inline bool show_strip_retiming(void);
	inline void show_strip_retiming(bool value);

};

/**************** Space Text Editor ****************/

class SpaceTextEditor : public Space {
public:
	SpaceTextEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_region_footer(void);
	inline void show_region_footer(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline Text text(void);
	inline bool show_word_wrap(void);
	inline void show_word_wrap(bool value);
	inline bool show_line_numbers(void);
	inline void show_line_numbers(bool value);
	inline bool show_syntax_highlight(void);
	inline void show_syntax_highlight(bool value);
	inline bool show_line_highlight(void);
	inline void show_line_highlight(bool value);
	inline int tab_width(void);
	inline void tab_width(int value);
	inline int font_size(void);
	inline void font_size(int value);
	inline bool show_margin(void);
	inline void show_margin(bool value);
	inline int margin_column(void);
	inline void margin_column(int value);
	inline int top(void);
	inline void top(int value);
	inline int visible_lines(void);
	inline void visible_lines(int value);
	inline bool use_overwrite(void);
	inline void use_overwrite(bool value);
	inline bool use_live_edit(void);
	inline void use_live_edit(bool value);
	inline bool use_find_all(void);
	inline void use_find_all(bool value);
	inline bool use_find_wrap(void);
	inline void use_find_wrap(bool value);
	inline bool use_match_case(void);
	inline void use_match_case(bool value);
	inline std::string find_text(void);
	inline void find_text(const std::string& value);
	inline std::string replace_text(void);
	inline void replace_text(const std::string& value);

	inline bool is_syntax_highlight_supported();
	inline void region_location_from_cursor(int line, int column, int result[2]);
};

/**************** File Select Entry ****************/

class FileSelectEntry : public Pointer {
public:
	FileSelectEntry(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string relative_path(void);
	inline void relative_path(const std::string& value);
	inline int preview_icon_id(void);
	inline void preview_icon_id(int value);
	inline AssetMetaData asset_data(void);

};

/**************** File Select Parameters ****************/

class FileSelectParams : public Pointer {
public:
	FileSelectParams(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string title(void);
	inline void title(const std::string& value);
	inline std::string directory(void);
	inline void directory(const std::string& value);
	inline std::string filename(void);
	inline void filename(const std::string& value);
	inline bool use_library_browsing(void);
	inline void use_library_browsing(bool value);
	enum display_type_enum {
		display_type_LIST_VERTICAL = 1,
		display_type_LIST_HORIZONTAL = 2,
		display_type_THUMBNAIL = 3,
	};
	inline display_type_enum display_type(void);
	inline void display_type(display_type_enum value);
	enum recursion_level_enum {
		recursion_level_NONE = 0,
		recursion_level_BLEND = 1,
		recursion_level_ALL_1 = 2,
		recursion_level_ALL_2 = 3,
		recursion_level_ALL_3 = 4,
	};
	inline recursion_level_enum recursion_level(void);
	inline void recursion_level(recursion_level_enum value);
	inline bool show_details_size(void);
	inline void show_details_size(bool value);
	inline bool show_details_datetime(void);
	inline void show_details_datetime(bool value);
	inline bool use_filter(void);
	inline void use_filter(bool value);
	inline bool show_hidden(void);
	inline void show_hidden(bool value);
	enum sort_method_enum {
		sort_method_FILE_SORT_ALPHA = 1,
		sort_method_FILE_SORT_EXTENSION = 2,
		sort_method_FILE_SORT_TIME = 3,
		sort_method_FILE_SORT_SIZE = 4,
	};
	inline sort_method_enum sort_method(void);
	inline void sort_method(sort_method_enum value);
	inline bool use_sort_invert(void);
	inline void use_sort_invert(bool value);
	inline bool use_filter_image(void);
	inline void use_filter_image(bool value);
	inline bool use_filter_blender(void);
	inline void use_filter_blender(bool value);
	inline bool use_filter_backup(void);
	inline void use_filter_backup(bool value);
	inline bool use_filter_movie(void);
	inline void use_filter_movie(bool value);
	inline bool use_filter_script(void);
	inline void use_filter_script(bool value);
	inline bool use_filter_font(void);
	inline void use_filter_font(bool value);
	inline bool use_filter_sound(void);
	inline void use_filter_sound(bool value);
	inline bool use_filter_text(void);
	inline void use_filter_text(bool value);
	inline bool use_filter_volume(void);
	inline void use_filter_volume(bool value);
	inline bool use_filter_folder(void);
	inline void use_filter_folder(bool value);
	inline bool use_filter_blendid(void);
	inline void use_filter_blendid(bool value);
	inline bool use_filter_asset_only(void);
	inline void use_filter_asset_only(bool value);
	inline FileSelectIDFilter filter_id(void);
	inline std::string filter_glob(void);
	inline void filter_glob(const std::string& value);
	inline std::string filter_search(void);
	inline void filter_search(const std::string& value);
	inline int display_size(void);
	inline void display_size(int value);
	enum display_size_discrete_enum {
		display_size_discrete_TINY = 32,
		display_size_discrete_SMALL = 64,
		display_size_discrete_NORMAL = 96,
		display_size_discrete_BIG = 128,
		display_size_discrete_LARGE = 192,
	};
	inline display_size_discrete_enum display_size_discrete(void);
	inline void display_size_discrete(display_size_discrete_enum value);

};

/**************** Asset Select Parameters ****************/

class FileAssetSelectParams : public FileSelectParams {
public:
	FileAssetSelectParams(const PointerRNA &ptr_arg) :
		FileSelectParams(ptr_arg)
		{}

	enum asset_library_reference_enum {
	};
	inline asset_library_reference_enum asset_library_reference(void);
	inline void asset_library_reference(asset_library_reference_enum value);
	inline std::string catalog_id(void);
	inline void catalog_id(const std::string& value);
	inline FileAssetSelectIDFilter filter_asset_id(void);
	enum import_method_enum {
		import_method_FOLLOW_PREFS = 3,
		import_method_LINK = 0,
		import_method_APPEND = 1,
		import_method_APPEND_REUSE = 2,
	};
	inline import_method_enum import_method(void);
	inline void import_method(import_method_enum value);

};

/**************** File Select ID Filter ****************/

class FileSelectIDFilter : public Pointer {
public:
	FileSelectIDFilter(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool filter_action(void);
	inline void filter_action(bool value);
	inline bool filter_armature(void);
	inline void filter_armature(bool value);
	inline bool filter_brush(void);
	inline void filter_brush(bool value);
	inline bool filter_camera(void);
	inline void filter_camera(bool value);
	inline bool filter_cachefile(void);
	inline void filter_cachefile(bool value);
	inline bool filter_curve(void);
	inline void filter_curve(bool value);
	inline bool filter_grease_pencil(void);
	inline void filter_grease_pencil(bool value);
	inline bool filter_group(void);
	inline void filter_group(bool value);
	inline bool filter_curves(void);
	inline void filter_curves(bool value);
	inline bool filter_image(void);
	inline void filter_image(bool value);
	inline bool filter_light(void);
	inline void filter_light(bool value);
	inline bool filter_light_probe(void);
	inline void filter_light_probe(bool value);
	inline bool filter_linestyle(void);
	inline void filter_linestyle(bool value);
	inline bool filter_lattice(void);
	inline void filter_lattice(bool value);
	inline bool filter_material(void);
	inline void filter_material(bool value);
	inline bool filter_metaball(void);
	inline void filter_metaball(bool value);
	inline bool filter_movie_clip(void);
	inline void filter_movie_clip(bool value);
	inline bool filter_mesh(void);
	inline void filter_mesh(bool value);
	inline bool filter_mask(void);
	inline void filter_mask(bool value);
	inline bool filter_node_tree(void);
	inline void filter_node_tree(bool value);
	inline bool filter_object(void);
	inline void filter_object(bool value);
	inline bool filter_particle_settings(void);
	inline void filter_particle_settings(bool value);
	inline bool filter_palette(void);
	inline void filter_palette(bool value);
	inline bool filter_paint_curve(void);
	inline void filter_paint_curve(bool value);
	inline bool filter_pointcloud(void);
	inline void filter_pointcloud(bool value);
	inline bool filter_scene(void);
	inline void filter_scene(bool value);
	inline bool filter_speaker(void);
	inline void filter_speaker(bool value);
	inline bool filter_sound(void);
	inline void filter_sound(bool value);
	inline bool filter_texture(void);
	inline void filter_texture(bool value);
	inline bool filter_text(void);
	inline void filter_text(bool value);
	inline bool filter_font(void);
	inline void filter_font(bool value);
	inline bool filter_volume(void);
	inline void filter_volume(bool value);
	inline bool filter_world(void);
	inline void filter_world(bool value);
	inline bool filter_work_space(void);
	inline void filter_work_space(bool value);
	inline bool category_scene(void);
	inline void category_scene(bool value);
	inline bool category_animation(void);
	inline void category_animation(bool value);
	inline bool category_object(void);
	inline void category_object(bool value);
	inline bool category_geometry(void);
	inline void category_geometry(bool value);
	inline bool category_shading(void);
	inline void category_shading(bool value);
	inline bool category_image(void);
	inline void category_image(bool value);
	inline bool category_environment(void);
	inline void category_environment(bool value);
	inline bool category_misc(void);
	inline void category_misc(bool value);

};

/**************** File Select Asset Filter ****************/

class FileAssetSelectIDFilter : public Pointer {
public:
	FileAssetSelectIDFilter(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool filter_action(void);
	inline void filter_action(bool value);
	inline bool experimental_filter_armature(void);
	inline void experimental_filter_armature(bool value);
	inline bool experimental_filter_brush(void);
	inline void experimental_filter_brush(bool value);
	inline bool experimental_filter_camera(void);
	inline void experimental_filter_camera(bool value);
	inline bool experimental_filter_cachefile(void);
	inline void experimental_filter_cachefile(bool value);
	inline bool experimental_filter_curve(void);
	inline void experimental_filter_curve(bool value);
	inline bool experimental_filter_grease_pencil(void);
	inline void experimental_filter_grease_pencil(bool value);
	inline bool filter_group(void);
	inline void filter_group(bool value);
	inline bool experimental_filter_curves(void);
	inline void experimental_filter_curves(bool value);
	inline bool experimental_filter_image(void);
	inline void experimental_filter_image(bool value);
	inline bool experimental_filter_light(void);
	inline void experimental_filter_light(bool value);
	inline bool experimental_filter_light_probe(void);
	inline void experimental_filter_light_probe(bool value);
	inline bool experimental_filter_linestyle(void);
	inline void experimental_filter_linestyle(bool value);
	inline bool experimental_filter_lattice(void);
	inline void experimental_filter_lattice(bool value);
	inline bool filter_material(void);
	inline void filter_material(bool value);
	inline bool experimental_filter_metaball(void);
	inline void experimental_filter_metaball(bool value);
	inline bool experimental_filter_movie_clip(void);
	inline void experimental_filter_movie_clip(bool value);
	inline bool experimental_filter_mesh(void);
	inline void experimental_filter_mesh(bool value);
	inline bool experimental_filter_mask(void);
	inline void experimental_filter_mask(bool value);
	inline bool filter_node_tree(void);
	inline void filter_node_tree(bool value);
	inline bool filter_object(void);
	inline void filter_object(bool value);
	inline bool experimental_filter_particle_settings(void);
	inline void experimental_filter_particle_settings(bool value);
	inline bool experimental_filter_palette(void);
	inline void experimental_filter_palette(bool value);
	inline bool experimental_filter_paint_curve(void);
	inline void experimental_filter_paint_curve(bool value);
	inline bool experimental_filter_pointcloud(void);
	inline void experimental_filter_pointcloud(bool value);
	inline bool experimental_filter_scene(void);
	inline void experimental_filter_scene(bool value);
	inline bool experimental_filter_speaker(void);
	inline void experimental_filter_speaker(bool value);
	inline bool experimental_filter_sound(void);
	inline void experimental_filter_sound(bool value);
	inline bool experimental_filter_texture(void);
	inline void experimental_filter_texture(bool value);
	inline bool experimental_filter_text(void);
	inline void experimental_filter_text(bool value);
	inline bool experimental_filter_font(void);
	inline void experimental_filter_font(bool value);
	inline bool experimental_filter_volume(void);
	inline void experimental_filter_volume(bool value);
	inline bool filter_world(void);
	inline void filter_world(bool value);
	inline bool experimental_filter_work_space(void);
	inline void experimental_filter_work_space(bool value);

};

/**************** File Select Parameters ****************/

class FileBrowserFSMenuEntry : public Pointer {
public:
	FileBrowserFSMenuEntry(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int icon(void);
	inline void icon(int value);
	inline bool use_save(void);
	inline void use_save(bool value);
	inline bool is_valid(void);
	inline void is_valid(bool value);

};

/**************** Space File Browser ****************/

class SpaceFileBrowser : public Space {
public:
	SpaceFileBrowser(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		system_folders(ptr_arg),
		system_bookmarks(ptr_arg),
		bookmarks(ptr_arg),
		recent_folders(ptr_arg)
		{}

	inline bool show_region_toolbar(void);
	inline void show_region_toolbar(bool value);
	inline bool show_region_tool_props(void);
	inline void show_region_tool_props(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	enum browse_mode_enum {
		browse_mode_FILES = 0,
		browse_mode_ASSETS = 1,
	};
	inline browse_mode_enum browse_mode(void);
	inline void browse_mode(browse_mode_enum value);
	inline FileSelectParams params(void);
	inline Operator active_operator(void);
	inline Operator operator_value(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, system_folders, true, false, false)
	inline int system_folders_active(void);
	inline void system_folders_active(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, system_bookmarks, true, false, false)
	inline int system_bookmarks_active(void);
	inline void system_bookmarks_active(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, bookmarks, true, false, false)
	inline int bookmarks_active(void);
	inline void bookmarks_active(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, FileBrowserFSMenuEntry, SpaceFileBrowser, recent_folders, true, false, false)
	inline int recent_folders_active(void);
	inline void recent_folders_active(int value);

	inline void activate_asset_by_id(ID& id_to_activate, bool deferred);
	inline void activate_file_by_relative_path(const char * relative_path);
	inline void deselect_all();
};

/**************** Space Outliner ****************/

class SpaceOutliner : public Space {
public:
	SpaceOutliner(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum display_mode_enum {
		display_mode_SCENES = 0,
		display_mode_VIEW_LAYER = 15,
		display_mode_SEQUENCE = 10,
		display_mode_LIBRARIES = 7,
		display_mode_DATA_API = 11,
		display_mode_LIBRARY_OVERRIDES = 16,
		display_mode_ORPHAN_DATA = 14,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	enum lib_override_view_mode_enum {
		lib_override_view_mode_PROPERTIES = 0,
		lib_override_view_mode_HIERARCHIES = 1,
	};
	inline lib_override_view_mode_enum lib_override_view_mode(void);
	inline void lib_override_view_mode(lib_override_view_mode_enum value);
	inline std::string filter_text(void);
	inline void filter_text(const std::string& value);
	inline bool use_filter_case_sensitive(void);
	inline void use_filter_case_sensitive(bool value);
	inline bool use_filter_complete(void);
	inline void use_filter_complete(bool value);
	inline bool use_sort_alpha(void);
	inline void use_sort_alpha(bool value);
	inline bool use_sync_select(void);
	inline void use_sync_select(bool value);
	inline bool show_mode_column(void);
	inline void show_mode_column(bool value);
	inline bool show_restrict_column_enable(void);
	inline void show_restrict_column_enable(bool value);
	inline bool show_restrict_column_select(void);
	inline void show_restrict_column_select(bool value);
	inline bool show_restrict_column_hide(void);
	inline void show_restrict_column_hide(bool value);
	inline bool show_restrict_column_viewport(void);
	inline void show_restrict_column_viewport(bool value);
	inline bool show_restrict_column_render(void);
	inline void show_restrict_column_render(bool value);
	inline bool show_restrict_column_holdout(void);
	inline void show_restrict_column_holdout(bool value);
	inline bool show_restrict_column_indirect_only(void);
	inline void show_restrict_column_indirect_only(bool value);
	inline bool use_filter_object(void);
	inline void use_filter_object(bool value);
	inline bool use_filter_object_content(void);
	inline void use_filter_object_content(bool value);
	inline bool use_filter_children(void);
	inline void use_filter_children(bool value);
	inline bool use_filter_collection(void);
	inline void use_filter_collection(bool value);
	inline bool use_filter_view_layers(void);
	inline void use_filter_view_layers(bool value);
	enum filter_state_enum {
		filter_state_ALL = 0,
		filter_state_VISIBLE = 1,
		filter_state_SELECTED = 3,
		filter_state_ACTIVE = 4,
		filter_state_SELECTABLE = 5,
	};
	inline filter_state_enum filter_state(void);
	inline void filter_state(filter_state_enum value);
	inline bool filter_invert(void);
	inline void filter_invert(bool value);
	inline bool use_filter_object_mesh(void);
	inline void use_filter_object_mesh(bool value);
	inline bool use_filter_object_armature(void);
	inline void use_filter_object_armature(bool value);
	inline bool use_filter_object_empty(void);
	inline void use_filter_object_empty(bool value);
	inline bool use_filter_object_light(void);
	inline void use_filter_object_light(bool value);
	inline bool use_filter_object_camera(void);
	inline void use_filter_object_camera(bool value);
	inline bool use_filter_object_grease_pencil(void);
	inline void use_filter_object_grease_pencil(bool value);
	inline bool use_filter_object_others(void);
	inline void use_filter_object_others(bool value);
	inline bool use_filter_id_type(void);
	inline void use_filter_id_type(bool value);
	enum filter_id_type_enum {
		filter_id_type_ACTION = 17217,
		filter_id_type_ARMATURE = 21057,
		filter_id_type_BRUSH = 21058,
		filter_id_type_CACHEFILE = 17987,
		filter_id_type_CAMERA = 16707,
		filter_id_type_COLLECTION = 21063,
		filter_id_type_CURVE = 21827,
		filter_id_type_CURVES = 22083,
		filter_id_type_FONT = 18006,
		filter_id_type_GREASEPENCIL = 17479,
		filter_id_type_GREASEPENCIL_V3 = 20551,
		filter_id_type_IMAGE = 19785,
		filter_id_type_KEY = 17739,
		filter_id_type_LATTICE = 21580,
		filter_id_type_LIBRARY = 18764,
		filter_id_type_LIGHT = 16716,
		filter_id_type_LIGHT_PROBE = 20556,
		filter_id_type_LINESTYLE = 21324,
		filter_id_type_MASK = 21325,
		filter_id_type_MATERIAL = 16717,
		filter_id_type_MESH = 17741,
		filter_id_type_META = 16973,
		filter_id_type_MOVIECLIP = 17229,
		filter_id_type_NODETREE = 21582,
		filter_id_type_OBJECT = 16975,
		filter_id_type_PAINTCURVE = 17232,
		filter_id_type_PALETTE = 19536,
		filter_id_type_PARTICLE = 16720,
		filter_id_type_POINTCLOUD = 21584,
		filter_id_type_SCENE = 17235,
		filter_id_type_SOUND = 20307,
		filter_id_type_SPEAKER = 19283,
		filter_id_type_TEXT = 22612,
		filter_id_type_TEXTURE = 17748,
		filter_id_type_VOLUME = 20310,
		filter_id_type_WINDOWMANAGER = 19799,
		filter_id_type_WORKSPACE = 21335,
		filter_id_type_WORLD = 20311,
	};
	inline filter_id_type_enum filter_id_type(void);
	inline void filter_id_type(filter_id_type_enum value);
	inline bool use_filter_lib_override_system(void);
	inline void use_filter_lib_override_system(bool value);

};

/**************** 3D View Space ****************/

class SpaceView3D : public Space {
public:
	SpaceView3D(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		region_quadviews(ptr_arg)
		{}

	inline bool show_region_tool_header(void);
	inline void show_region_tool_header(bool value);
	inline bool show_region_toolbar(void);
	inline void show_region_toolbar(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool show_region_hud(void);
	inline void show_region_hud(bool value);
	inline bool show_region_asset_shelf(void);
	inline void show_region_asset_shelf(bool value);
	inline Object camera(void);
	inline bool use_render_border(void);
	inline void use_render_border(bool value);
	inline float render_border_min_x(void);
	inline void render_border_min_x(float value);
	inline float render_border_min_y(void);
	inline void render_border_min_y(float value);
	inline float render_border_max_x(void);
	inline void render_border_max_x(float value);
	inline float render_border_max_y(void);
	inline void render_border_max_y(float value);
	inline Object lock_object(void);
	inline std::string lock_bone(void);
	inline void lock_bone(const std::string& value);
	inline bool lock_cursor(void);
	inline void lock_cursor(bool value);
	inline SpaceView3D local_view(void);
	inline float lens(void);
	inline void lens(float value);
	inline float clip_start(void);
	inline void clip_start(float value);
	inline float clip_end(void);
	inline void clip_end(float value);
	inline bool lock_camera(void);
	inline void lock_camera(bool value);
	inline bool show_gizmo(void);
	inline void show_gizmo(bool value);
	inline bool show_gizmo_navigate(void);
	inline void show_gizmo_navigate(bool value);
	inline bool show_gizmo_context(void);
	inline void show_gizmo_context(bool value);
	inline bool show_gizmo_tool(void);
	inline void show_gizmo_tool(bool value);
	inline bool show_gizmo_object_translate(void);
	inline void show_gizmo_object_translate(bool value);
	inline bool show_gizmo_object_rotate(void);
	inline void show_gizmo_object_rotate(bool value);
	inline bool show_gizmo_object_scale(void);
	inline void show_gizmo_object_scale(bool value);
	inline bool show_gizmo_empty_image(void);
	inline void show_gizmo_empty_image(bool value);
	inline bool show_gizmo_empty_force_field(void);
	inline void show_gizmo_empty_force_field(bool value);
	inline bool show_gizmo_light_size(void);
	inline void show_gizmo_light_size(bool value);
	inline bool show_gizmo_light_look_at(void);
	inline void show_gizmo_light_look_at(bool value);
	inline bool show_gizmo_camera_lens(void);
	inline void show_gizmo_camera_lens(bool value);
	inline bool show_gizmo_camera_dof_distance(void);
	inline void show_gizmo_camera_dof_distance(bool value);
	inline bool use_local_camera(void);
	inline void use_local_camera(bool value);
	inline RegionView3D region_3d(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, RegionView3D, SpaceView3D, region_quadviews, false, false, false)
	inline bool show_reconstruction(void);
	inline void show_reconstruction(bool value);
	inline float tracks_display_size(void);
	inline void tracks_display_size(float value);
	enum tracks_display_type_enum {
		tracks_display_type_PLAIN_AXES = 2,
		tracks_display_type_ARROWS = 1,
		tracks_display_type_SINGLE_ARROW = 4,
		tracks_display_type_CIRCLE = 3,
		tracks_display_type_CUBE = 5,
		tracks_display_type_SPHERE = 6,
		tracks_display_type_CONE = 7,
	};
	inline tracks_display_type_enum tracks_display_type(void);
	inline void tracks_display_type(tracks_display_type_enum value);
	inline bool show_camera_path(void);
	inline void show_camera_path(bool value);
	inline bool show_bundle_names(void);
	inline void show_bundle_names(bool value);
	inline bool use_local_collections(void);
	inline void use_local_collections(bool value);
	enum stereo_3d_eye_enum {
		stereo_3d_eye_LEFT_EYE = 0,
		stereo_3d_eye_RIGHT_EYE = 1,
	};
	inline stereo_3d_eye_enum stereo_3d_eye(void);
	inline void stereo_3d_eye(stereo_3d_eye_enum value);
	enum stereo_3d_camera_enum {
		stereo_3d_camera_LEFT = 0,
		stereo_3d_camera_RIGHT = 1,
		stereo_3d_camera_S3D = 2,
	};
	inline stereo_3d_camera_enum stereo_3d_camera(void);
	inline void stereo_3d_camera(stereo_3d_camera_enum value);
	inline bool show_stereo_3d_cameras(void);
	inline void show_stereo_3d_cameras(bool value);
	inline bool show_stereo_3d_convergence_plane(void);
	inline void show_stereo_3d_convergence_plane(bool value);
	inline float stereo_3d_convergence_plane_alpha(void);
	inline void stereo_3d_convergence_plane_alpha(float value);
	inline bool show_stereo_3d_volume(void);
	inline void show_stereo_3d_volume(bool value);
	inline float stereo_3d_volume_alpha(void);
	inline void stereo_3d_volume_alpha(float value);
	inline bool mirror_xr_session(void);
	inline void mirror_xr_session(bool value);
	inline bool show_object_viewport_mesh(void);
	inline void show_object_viewport_mesh(bool value);
	inline bool show_object_viewport_curve(void);
	inline void show_object_viewport_curve(bool value);
	inline bool show_object_viewport_surf(void);
	inline void show_object_viewport_surf(bool value);
	inline bool show_object_viewport_meta(void);
	inline void show_object_viewport_meta(bool value);
	inline bool show_object_viewport_font(void);
	inline void show_object_viewport_font(bool value);
	inline bool show_object_viewport_curves(void);
	inline void show_object_viewport_curves(bool value);
	inline bool show_object_viewport_pointcloud(void);
	inline void show_object_viewport_pointcloud(bool value);
	inline bool show_object_viewport_volume(void);
	inline void show_object_viewport_volume(bool value);
	inline bool show_object_viewport_armature(void);
	inline void show_object_viewport_armature(bool value);
	inline bool show_object_viewport_lattice(void);
	inline void show_object_viewport_lattice(bool value);
	inline bool show_object_viewport_empty(void);
	inline void show_object_viewport_empty(bool value);
	inline bool show_object_viewport_grease_pencil(void);
	inline void show_object_viewport_grease_pencil(bool value);
	inline bool show_object_viewport_camera(void);
	inline void show_object_viewport_camera(bool value);
	inline bool show_object_viewport_light(void);
	inline void show_object_viewport_light(bool value);
	inline bool show_object_viewport_speaker(void);
	inline void show_object_viewport_speaker(bool value);
	inline bool show_object_viewport_light_probe(void);
	inline void show_object_viewport_light_probe(bool value);
	inline bool show_object_select_mesh(void);
	inline void show_object_select_mesh(bool value);
	inline bool show_object_select_curve(void);
	inline void show_object_select_curve(bool value);
	inline bool show_object_select_surf(void);
	inline void show_object_select_surf(bool value);
	inline bool show_object_select_meta(void);
	inline void show_object_select_meta(bool value);
	inline bool show_object_select_font(void);
	inline void show_object_select_font(bool value);
	inline bool show_object_select_curves(void);
	inline void show_object_select_curves(bool value);
	inline bool show_object_select_pointcloud(void);
	inline void show_object_select_pointcloud(bool value);
	inline bool show_object_select_volume(void);
	inline void show_object_select_volume(bool value);
	inline bool show_object_select_armature(void);
	inline void show_object_select_armature(bool value);
	inline bool show_object_select_lattice(void);
	inline void show_object_select_lattice(bool value);
	inline bool show_object_select_empty(void);
	inline void show_object_select_empty(bool value);
	inline bool show_object_select_grease_pencil(void);
	inline void show_object_select_grease_pencil(bool value);
	inline bool show_object_select_camera(void);
	inline void show_object_select_camera(bool value);
	inline bool show_object_select_light(void);
	inline void show_object_select_light(bool value);
	inline bool show_object_select_speaker(void);
	inline void show_object_select_speaker(bool value);
	inline bool show_object_select_light_probe(void);
	inline void show_object_select_light_probe(bool value);
	inline int icon_from_show_object_viewport(void);
	inline void icon_from_show_object_viewport(int value);
	inline bool show_viewer(void);
	inline void show_viewer(bool value);
	inline View3DShading shading(void);
	inline View3DOverlay overlay(void);

};

/**************** 3D View Shading Settings ****************/

class View3DShading : public Pointer {
public:
	View3DShading(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum type_enum {
		type_WIREFRAME = 2,
		type_SOLID = 3,
		type_MATERIAL = 4,
		type_RENDERED = 6,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum light_enum {
		light_STUDIO = 1,
		light_MATCAP = 2,
		light_FLAT = 0,
	};
	inline light_enum light(void);
	inline void light(light_enum value);
	inline bool show_object_outline(void);
	inline void show_object_outline(bool value);
	enum studio_light_enum {
		studio_light_DEFAULT = 0,
	};
	inline studio_light_enum studio_light(void);
	inline void studio_light(studio_light_enum value);
	inline bool use_world_space_lighting(void);
	inline void use_world_space_lighting(bool value);
	inline bool show_backface_culling(void);
	inline void show_backface_culling(bool value);
	inline bool show_cavity(void);
	inline void show_cavity(bool value);
	enum cavity_type_enum {
		cavity_type_WORLD = 0,
		cavity_type_SCREEN = 1,
		cavity_type_BOTH = 2,
	};
	inline cavity_type_enum cavity_type(void);
	inline void cavity_type(cavity_type_enum value);
	inline float curvature_ridge_factor(void);
	inline void curvature_ridge_factor(float value);
	inline float curvature_valley_factor(void);
	inline void curvature_valley_factor(float value);
	inline float cavity_ridge_factor(void);
	inline void cavity_ridge_factor(float value);
	inline float cavity_valley_factor(void);
	inline void cavity_valley_factor(float value);
	inline StudioLight selected_studio_light(void);
	inline float studiolight_rotate_z(void);
	inline void studiolight_rotate_z(float value);
	inline float studiolight_intensity(void);
	inline void studiolight_intensity(float value);
	inline float studiolight_background_alpha(void);
	inline void studiolight_background_alpha(float value);
	inline float studiolight_background_blur(void);
	inline void studiolight_background_blur(float value);
	inline bool use_studiolight_view_rotation(void);
	inline void use_studiolight_view_rotation(bool value);
	enum color_type_enum {
		color_type_MATERIAL = 0,
		color_type_SINGLE = 2,
		color_type_OBJECT = 4,
		color_type_RANDOM = 1,
		color_type_VERTEX = 5,
		color_type_TEXTURE = 3,
	};
	inline color_type_enum color_type(void);
	inline void color_type(color_type_enum value);
	enum wireframe_color_type_enum {
		wireframe_color_type_THEME = 2,
		wireframe_color_type_OBJECT = 4,
		wireframe_color_type_RANDOM = 1,
	};
	inline wireframe_color_type_enum wireframe_color_type(void);
	inline void wireframe_color_type(wireframe_color_type_enum value);
	inline Array<float, 3> single_color(void);
	inline void single_color(float values[3]);
	enum background_type_enum {
		background_type_THEME = 0,
		background_type_WORLD = 1,
		background_type_VIEWPORT = 2,
	};
	inline background_type_enum background_type(void);
	inline void background_type(background_type_enum value);
	inline Array<float, 3> background_color(void);
	inline void background_color(float values[3]);
	inline bool show_shadows(void);
	inline void show_shadows(bool value);
	inline bool show_xray(void);
	inline void show_xray(bool value);
	inline bool show_xray_wireframe(void);
	inline void show_xray_wireframe(bool value);
	inline float xray_alpha(void);
	inline void xray_alpha(float value);
	inline float xray_alpha_wireframe(void);
	inline void xray_alpha_wireframe(float value);
	inline bool use_dof(void);
	inline void use_dof(bool value);
	inline bool use_scene_lights(void);
	inline void use_scene_lights(bool value);
	inline bool use_scene_world(void);
	inline void use_scene_world(bool value);
	inline bool use_scene_lights_render(void);
	inline void use_scene_lights_render(bool value);
	inline bool use_scene_world_render(void);
	inline void use_scene_world_render(bool value);
	inline bool show_specular_highlight(void);
	inline void show_specular_highlight(bool value);
	inline Array<float, 3> object_outline_color(void);
	inline void object_outline_color(float values[3]);
	inline float shadow_intensity(void);
	inline void shadow_intensity(float value);
	enum render_pass_enum {
		render_pass_COMBINED = 1,
		render_pass_EMISSION = 1024,
		render_pass_ENVIRONMENT = 2048,
		render_pass_AO = 8192,
		render_pass_SHADOW = 4096,
		render_pass_TRANSPARENT = 1048576,
		render_pass_DIFFUSE_LIGHT = 16,
		render_pass_DIFFUSE_COLOR = 32,
		render_pass_SPECULAR_LIGHT = 64,
		render_pass_SPECULAR_COLOR = 128,
		render_pass_VOLUME_LIGHT = 512,
		render_pass_BLOOM = 16384,
		render_pass_NORMAL = 8,
		render_pass_MIST = 4,
		render_pass_CryptoObject = 65536,
		render_pass_CryptoAsset = 131072,
		render_pass_CryptoMaterial = 262144,
		render_pass_AOV = 32768,
	};
	inline render_pass_enum render_pass(void);
	inline void render_pass(render_pass_enum value);
	inline std::string aov_name(void);
	inline void aov_name(const std::string& value);
	enum use_compositor_enum {
		use_compositor_DISABLED = 0,
		use_compositor_CAMERA = 1,
		use_compositor_ALWAYS = 2,
	};
	inline use_compositor_enum use_compositor(void);
	inline void use_compositor(use_compositor_enum value);

};

/**************** 3D View Overlay Settings ****************/

class View3DOverlay : public Pointer {
public:
	View3DOverlay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_overlays(void);
	inline void show_overlays(bool value);
	inline bool show_ortho_grid(void);
	inline void show_ortho_grid(bool value);
	inline bool show_floor(void);
	inline void show_floor(bool value);
	inline bool show_axis_x(void);
	inline void show_axis_x(bool value);
	inline bool show_axis_y(void);
	inline void show_axis_y(bool value);
	inline bool show_axis_z(void);
	inline void show_axis_z(bool value);
	inline float grid_scale(void);
	inline void grid_scale(float value);
	inline int grid_lines(void);
	inline void grid_lines(int value);
	inline int grid_subdivisions(void);
	inline void grid_subdivisions(int value);
	inline float grid_scale_unit(void);
	inline void grid_scale_unit(float value);
	inline bool show_outline_selected(void);
	inline void show_outline_selected(bool value);
	inline bool show_object_origins(void);
	inline void show_object_origins(bool value);
	inline bool show_object_origins_all(void);
	inline void show_object_origins_all(bool value);
	inline bool show_relationship_lines(void);
	inline void show_relationship_lines(bool value);
	inline bool show_cursor(void);
	inline void show_cursor(bool value);
	inline bool show_text(void);
	inline void show_text(bool value);
	inline bool show_stats(void);
	inline void show_stats(bool value);
	inline bool show_extras(void);
	inline void show_extras(bool value);
	inline bool show_light_colors(void);
	inline void show_light_colors(bool value);
	inline bool show_bones(void);
	inline void show_bones(bool value);
	inline bool show_face_orientation(void);
	inline void show_face_orientation(bool value);
	inline bool show_fade_inactive(void);
	inline void show_fade_inactive(bool value);
	inline float fade_inactive_alpha(void);
	inline void fade_inactive_alpha(float value);
	inline bool show_xray_bone(void);
	inline void show_xray_bone(bool value);
	inline float xray_alpha_bone(void);
	inline void xray_alpha_bone(float value);
	inline float bone_wire_alpha(void);
	inline void bone_wire_alpha(float value);
	inline bool show_motion_paths(void);
	inline void show_motion_paths(bool value);
	inline bool show_onion_skins(void);
	inline void show_onion_skins(bool value);
	inline bool show_look_dev(void);
	inline void show_look_dev(bool value);
	inline bool show_wireframes(void);
	inline void show_wireframes(bool value);
	inline float wireframe_threshold(void);
	inline void wireframe_threshold(float value);
	inline float wireframe_opacity(void);
	inline void wireframe_opacity(float value);
	inline bool show_viewer_attribute(void);
	inline void show_viewer_attribute(bool value);
	inline float viewer_attribute_opacity(void);
	inline void viewer_attribute_opacity(float value);
	inline bool show_paint_wire(void);
	inline void show_paint_wire(bool value);
	inline bool show_wpaint_contours(void);
	inline void show_wpaint_contours(bool value);
	inline bool show_weight(void);
	inline void show_weight(bool value);
	inline bool show_retopology(void);
	inline void show_retopology(bool value);
	inline float retopology_offset(void);
	inline void retopology_offset(float value);
	inline bool show_face_normals(void);
	inline void show_face_normals(bool value);
	inline bool show_vertex_normals(void);
	inline void show_vertex_normals(bool value);
	inline bool show_split_normals(void);
	inline void show_split_normals(bool value);
	inline bool show_faces(void);
	inline void show_faces(bool value);
	inline bool show_face_center(void);
	inline void show_face_center(bool value);
	inline bool show_edge_crease(void);
	inline void show_edge_crease(bool value);
	inline bool show_edge_bevel_weight(void);
	inline void show_edge_bevel_weight(bool value);
	inline bool show_edge_seams(void);
	inline void show_edge_seams(bool value);
	inline bool show_edge_sharp(void);
	inline void show_edge_sharp(bool value);
	inline bool show_freestyle_edge_marks(void);
	inline void show_freestyle_edge_marks(bool value);
	inline bool show_freestyle_face_marks(void);
	inline void show_freestyle_face_marks(bool value);
	inline bool show_statvis(void);
	inline void show_statvis(bool value);
	inline bool show_extra_edge_length(void);
	inline void show_extra_edge_length(bool value);
	inline bool show_extra_edge_angle(void);
	inline void show_extra_edge_angle(bool value);
	inline bool show_extra_face_angle(void);
	inline void show_extra_face_angle(bool value);
	inline bool show_extra_face_area(void);
	inline void show_extra_face_area(bool value);
	inline bool show_extra_indices(void);
	inline void show_extra_indices(bool value);
	enum display_handle_enum {
		display_handle_NONE = 2,
		display_handle_SELECTED = 0,
		display_handle_ALL = 1,
	};
	inline display_handle_enum display_handle(void);
	inline void display_handle(display_handle_enum value);
	inline bool show_curve_normals(void);
	inline void show_curve_normals(bool value);
	inline float normals_length(void);
	inline void normals_length(float value);
	inline float normals_constant_screen_size(void);
	inline void normals_constant_screen_size(float value);
	inline bool use_normals_constant_screen_size(void);
	inline void use_normals_constant_screen_size(bool value);
	inline float backwire_opacity(void);
	inline void backwire_opacity(float value);
	inline float texture_paint_mode_opacity(void);
	inline void texture_paint_mode_opacity(float value);
	inline float vertex_paint_mode_opacity(void);
	inline void vertex_paint_mode_opacity(float value);
	inline float weight_paint_mode_opacity(void);
	inline void weight_paint_mode_opacity(float value);
	inline float sculpt_mode_mask_opacity(void);
	inline void sculpt_mode_mask_opacity(float value);
	inline bool show_sculpt_curves_cage(void);
	inline void show_sculpt_curves_cage(bool value);
	inline float sculpt_curves_cage_opacity(void);
	inline void sculpt_curves_cage_opacity(float value);
	inline float sculpt_mode_face_sets_opacity(void);
	inline void sculpt_mode_face_sets_opacity(float value);
	inline bool show_sculpt_mask(void);
	inline void show_sculpt_mask(bool value);
	inline bool show_sculpt_face_sets(void);
	inline void show_sculpt_face_sets(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool use_gpencil_fade_objects(void);
	inline void use_gpencil_fade_objects(bool value);
	inline bool use_gpencil_grid(void);
	inline void use_gpencil_grid(bool value);
	inline bool use_gpencil_fade_layers(void);
	inline void use_gpencil_fade_layers(bool value);
	inline bool use_gpencil_fade_gp_objects(void);
	inline void use_gpencil_fade_gp_objects(bool value);
	inline bool use_gpencil_canvas_xray(void);
	inline void use_gpencil_canvas_xray(bool value);
	inline bool use_gpencil_show_directions(void);
	inline void use_gpencil_show_directions(bool value);
	inline bool use_gpencil_show_material_name(void);
	inline void use_gpencil_show_material_name(bool value);
	inline float gpencil_grid_opacity(void);
	inline void gpencil_grid_opacity(float value);
	inline float gpencil_fade_objects(void);
	inline void gpencil_fade_objects(float value);
	inline float gpencil_fade_layer(void);
	inline void gpencil_fade_layer(float value);
	inline bool use_gpencil_edit_lines(void);
	inline void use_gpencil_edit_lines(bool value);
	inline bool use_gpencil_multiedit_line_only(void);
	inline void use_gpencil_multiedit_line_only(bool value);
	inline bool use_gpencil_onion_skin(void);
	inline void use_gpencil_onion_skin(bool value);
	inline float vertex_opacity(void);
	inline void vertex_opacity(float value);
	inline float gpencil_vertex_paint_opacity(void);
	inline void gpencil_vertex_paint_opacity(float value);
	inline bool use_debug_freeze_view_culling(void);
	inline void use_debug_freeze_view_culling(bool value);

};

/**************** 3D View Region ****************/

class RegionView3D : public Pointer {
public:
	RegionView3D(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool lock_rotation(void);
	inline void lock_rotation(bool value);
	inline bool show_sync_view(void);
	inline void show_sync_view(bool value);
	inline bool use_box_clip(void);
	inline void use_box_clip(bool value);
	inline Array<float, 16> perspective_matrix(void);
	inline void perspective_matrix(float values[16]);
	inline Array<float, 16> window_matrix(void);
	inline void window_matrix(float values[16]);
	inline Array<float, 16> view_matrix(void);
	inline void view_matrix(float values[16]);
	enum view_perspective_enum {
		view_perspective_PERSP = 1,
		view_perspective_ORTHO = 0,
		view_perspective_CAMERA = 2,
	};
	inline view_perspective_enum view_perspective(void);
	inline void view_perspective(view_perspective_enum value);
	inline bool is_perspective(void);
	inline void is_perspective(bool value);
	inline bool is_orthographic_side_view(void);
	inline void is_orthographic_side_view(bool value);
	inline bool use_clip_planes(void);
	inline void use_clip_planes(bool value);
	inline Array<float, 24> clip_planes(void);
	inline void clip_planes(float values[24]);
	inline Array<float, 3> view_location(void);
	inline void view_location(float values[3]);
	inline Array<float, 4> view_rotation(void);
	inline void view_rotation(float values[4]);
	inline float view_distance(void);
	inline void view_distance(float value);
	inline float view_camera_zoom(void);
	inline void view_camera_zoom(float value);
	inline Array<float, 2> view_camera_offset(void);
	inline void view_camera_offset(float values[2]);

	inline void update(Context C);
};

/**************** Properties Space ****************/

class SpaceProperties : public Space {
public:
	SpaceProperties(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum context_enum {
		context_TOOL = 14,
		context_SCENE = 1,
		context_RENDER = 0,
		context_OUTPUT = 16,
		context_VIEW_LAYER = 13,
		context_WORLD = 2,
		context_COLLECTION = 17,
		context_OBJECT = 3,
		context_CONSTRAINT = 11,
		context_MODIFIER = 10,
		context_DATA = 4,
		context_BONE = 9,
		context_BONE_CONSTRAINT = 12,
		context_MATERIAL = 5,
		context_TEXTURE = 6,
		context_PARTICLES = 7,
		context_PHYSICS = 8,
		context_SHADERFX = 15,
	};
	inline context_enum context(void);
	inline void context(context_enum value);
	inline ID pin_id(void);
	inline bool use_pin_id(void);
	inline void use_pin_id(bool value);
	inline DynamicArray<bool> tab_search_results(void);
	inline void tab_search_results(bool values[]);
	inline std::string search_filter(void);
	inline void search_filter(const std::string& value);
	enum outliner_sync_enum {
		outliner_sync_ALWAYS = 2,
		outliner_sync_NEVER = 1,
		outliner_sync_AUTO = 0,
	};
	inline outliner_sync_enum outliner_sync(void);
	inline void outliner_sync(outliner_sync_enum value);

};

/**************** Space Dope Sheet Editor ****************/

class SpaceDopeSheetEditor : public Space {
public:
	SpaceDopeSheetEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_region_channels(void);
	inline void show_region_channels(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool show_region_hud(void);
	inline void show_region_hud(bool value);
	inline Action action(void);
	enum mode_enum {
		mode_DOPESHEET = 3,
		mode_TIMELINE = 6,
		mode_ACTION = 0,
		mode_SHAPEKEY = 1,
		mode_GPENCIL = 2,
		mode_MASK = 4,
		mode_CACHEFILE = 5,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum ui_mode_enum {
		ui_mode_DOPESHEET = 3,
		ui_mode_ACTION = 0,
		ui_mode_SHAPEKEY = 1,
		ui_mode_GPENCIL = 2,
		ui_mode_MASK = 4,
		ui_mode_CACHEFILE = 5,
	};
	inline ui_mode_enum ui_mode(void);
	inline void ui_mode(ui_mode_enum value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_sliders(void);
	inline void show_sliders(bool value);
	inline bool show_pose_markers(void);
	inline void show_pose_markers(bool value);
	inline bool show_interpolation(void);
	inline void show_interpolation(bool value);
	inline bool show_extremes(void);
	inline void show_extremes(bool value);
	inline bool show_markers(void);
	inline void show_markers(bool value);
	inline bool use_auto_merge_keyframes(void);
	inline void use_auto_merge_keyframes(bool value);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline bool use_marker_sync(void);
	inline void use_marker_sync(bool value);
	inline DopeSheet dopesheet(void);
	inline bool show_cache(void);
	inline void show_cache(bool value);
	inline bool cache_softbody(void);
	inline void cache_softbody(bool value);
	inline bool cache_particles(void);
	inline void cache_particles(bool value);
	inline bool cache_cloth(void);
	inline void cache_cloth(bool value);
	inline bool cache_smoke(void);
	inline void cache_smoke(bool value);
	inline bool cache_simulation_nodes(void);
	inline void cache_simulation_nodes(bool value);
	inline bool cache_dynamicpaint(void);
	inline void cache_dynamicpaint(bool value);
	inline bool cache_rigidbody(void);
	inline void cache_rigidbody(bool value);

};

/**************** Space Graph Editor ****************/

class SpaceGraphEditor : public Space {
public:
	SpaceGraphEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_region_channels(void);
	inline void show_region_channels(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool show_region_hud(void);
	inline void show_region_hud(bool value);
	enum mode_enum {
		mode_FCURVES = 0,
		mode_DRIVERS = 1,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_sliders(void);
	inline void show_sliders(bool value);
	inline bool show_handles(void);
	inline void show_handles(bool value);
	inline bool use_only_selected_keyframe_handles(void);
	inline void use_only_selected_keyframe_handles(bool value);
	inline bool show_markers(void);
	inline void show_markers(bool value);
	inline bool show_extrapolation(void);
	inline void show_extrapolation(bool value);
	inline bool use_auto_merge_keyframes(void);
	inline void use_auto_merge_keyframes(bool value);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline bool show_cursor(void);
	inline void show_cursor(bool value);
	inline float cursor_position_x(void);
	inline void cursor_position_x(float value);
	inline float cursor_position_y(void);
	inline void cursor_position_y(float value);
	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
	};
	inline pivot_point_enum pivot_point(void);
	inline void pivot_point(pivot_point_enum value);
	inline DopeSheet dopesheet(void);
	inline bool has_ghost_curves(void);
	inline void has_ghost_curves(bool value);
	inline bool use_normalization(void);
	inline void use_normalization(bool value);
	inline bool use_auto_normalization(void);
	inline void use_auto_normalization(bool value);

};

/**************** Space Nla Editor ****************/

class SpaceNLA : public Space {
public:
	SpaceNLA(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_region_channels(void);
	inline void show_region_channels(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool show_region_hud(void);
	inline void show_region_hud(bool value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	inline bool show_strip_curves(void);
	inline void show_strip_curves(bool value);
	inline bool show_local_markers(void);
	inline void show_local_markers(bool value);
	inline bool show_markers(void);
	inline void show_markers(bool value);
	inline bool use_realtime_update(void);
	inline void use_realtime_update(bool value);
	inline DopeSheet dopesheet(void);

};

/**************** Space Console ****************/

class SpaceConsole : public Space {
public:
	SpaceConsole(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		history(ptr_arg),
		scrollback(ptr_arg)
		{}

	inline int font_size(void);
	inline void font_size(int value);
	inline int select_start(void);
	inline void select_start(int value);
	inline int select_end(void);
	inline void select_end(int value);
	inline std::string prompt(void);
	inline void prompt(const std::string& value);
	inline std::string language(void);
	inline void language(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ConsoleLine, SpaceConsole, history, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ConsoleLine, SpaceConsole, scrollback, false, true, false)

};

/**************** Console Input ****************/

class ConsoleLine : public Pointer {
public:
	ConsoleLine(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string body(void);
	inline void body(const std::string& value);
	inline int current_character(void);
	inline void current_character(int value);
	enum type_enum {
		type_OUTPUT = 0,
		type_INPUT = 1,
		type_INFO = 2,
		type_ERROR = 3,
	};
	inline type_enum type(void);
	inline void type(type_enum value);

};

/**************** Space Info ****************/

class SpaceInfo : public Space {
public:
	SpaceInfo(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_report_debug(void);
	inline void show_report_debug(bool value);
	inline bool show_report_info(void);
	inline void show_report_info(bool value);
	inline bool show_report_operator(void);
	inline void show_report_operator(bool value);
	inline bool show_report_warning(void);
	inline void show_report_warning(bool value);
	inline bool show_report_error(void);
	inline void show_report_error(bool value);

};

/**************** Space Preferences ****************/

class SpacePreferences : public Space {
public:
	SpacePreferences(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	enum filter_type_enum {
		filter_type_NAME = 0,
		filter_type_KEY = 1,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline std::string filter_text(void);
	inline void filter_text(const std::string& value);

};

/**************** Node Tree Path ****************/

class NodeTreePath : public Pointer {
public:
	NodeTreePath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline NodeTree node_tree(void);

};

/**************** Space Node Editor ****************/

class SpaceNodeEditor : public Space {
public:
	SpaceNodeEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		path(ptr_arg)
		{}

	inline bool show_region_toolbar(void);
	inline void show_region_toolbar(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	enum tree_type_enum {
		tree_type_DUMMY = 0,
	};
	inline tree_type_enum tree_type(void);
	inline void tree_type(tree_type_enum value);
	enum texture_type_enum {
		texture_type_WORLD = 1,
		texture_type_BRUSH = 2,
		texture_type_LINESTYLE = 3,
	};
	inline texture_type_enum texture_type(void);
	inline void texture_type(texture_type_enum value);
	enum shader_type_enum {
		shader_type_OBJECT = 0,
		shader_type_WORLD = 1,
		shader_type_LINESTYLE = 2,
	};
	inline shader_type_enum shader_type(void);
	inline void shader_type(shader_type_enum value);
	enum geometry_nodes_type_enum {
		geometry_nodes_type_MODIFIER = 0,
		geometry_nodes_type_TOOL = 1,
	};
	inline geometry_nodes_type_enum geometry_nodes_type(void);
	inline void geometry_nodes_type(geometry_nodes_type_enum value);
	inline ID id(void);
	inline ID id_from(void);
	COLLECTION_PROPERTY(SpaceNodeEditorPath, NodeTreePath, SpaceNodeEditor, path, false, true, false)
	inline NodeTree node_tree(void);
	inline NodeTree edit_tree(void);
	inline bool pin(void);
	inline void pin(bool value);
	inline bool show_backdrop(void);
	inline void show_backdrop(bool value);
	inline NodeTree geometry_nodes_tool_tree(void);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool use_auto_render(void);
	inline void use_auto_render(bool value);
	inline float backdrop_zoom(void);
	inline void backdrop_zoom(float value);
	inline Array<float, 2> backdrop_offset(void);
	inline void backdrop_offset(float values[2]);
	enum backdrop_channels_enum {
		backdrop_channels_COLOR_ALPHA = 8,
		backdrop_channels_COLOR = 0,
		backdrop_channels_ALPHA = 16,
		backdrop_channels_RED = 128,
		backdrop_channels_GREEN = 256,
		backdrop_channels_BLUE = 512,
	};
	inline backdrop_channels_enum backdrop_channels(void);
	inline void backdrop_channels(backdrop_channels_enum value);
	inline Array<float, 2> cursor_location(void);
	inline void cursor_location(float values[2]);
	enum insert_offset_direction_enum {
		insert_offset_direction_RIGHT = 0,
		insert_offset_direction_LEFT = 1,
	};
	inline insert_offset_direction_enum insert_offset_direction(void);
	inline void insert_offset_direction(insert_offset_direction_enum value);
	inline SpaceNodeOverlay overlay(void);
	inline bool supports_previews(void);
	inline void supports_previews(bool value);

	inline void cursor_location_from_region(Context C, int x, int y);
};

/**************** Overlay Settings ****************/

class SpaceNodeOverlay : public Pointer {
public:
	SpaceNodeOverlay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_overlays(void);
	inline void show_overlays(bool value);
	inline bool show_wire_color(void);
	inline void show_wire_color(bool value);
	inline bool show_timing(void);
	inline void show_timing(bool value);
	inline bool show_context_path(void);
	inline void show_context_path(bool value);
	inline bool show_named_attributes(void);
	inline void show_named_attributes(bool value);
	inline bool show_previews(void);
	inline void show_previews(bool value);
	enum preview_shape_enum {
		preview_shape_FLAT = 0,
		preview_shape_3D = 1,
	};
	inline preview_shape_enum preview_shape(void);
	inline void preview_shape(preview_shape_enum value);

};

/**************** Space Clip Editor ****************/

class SpaceClipEditor : public Space {
public:
	SpaceClipEditor(const PointerRNA &ptr_arg) :
		Space(ptr_arg)
		{}

	inline bool show_region_toolbar(void);
	inline void show_region_toolbar(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool show_region_hud(void);
	inline void show_region_hud(bool value);
	inline MovieClip clip(void);
	inline MovieClipUser clip_user(void);
	inline Mask mask(void);
	enum mask_display_type_enum {
		mask_display_type_OUTLINE = 0,
		mask_display_type_DASH = 1,
		mask_display_type_BLACK = 2,
		mask_display_type_WHITE = 3,
	};
	inline mask_display_type_enum mask_display_type(void);
	inline void mask_display_type(mask_display_type_enum value);
	inline bool show_mask_spline(void);
	inline void show_mask_spline(bool value);
	inline bool show_mask_overlay(void);
	inline void show_mask_overlay(bool value);
	enum mask_overlay_mode_enum {
		mask_overlay_mode_ALPHACHANNEL = 0,
		mask_overlay_mode_COMBINED = 1,
	};
	inline mask_overlay_mode_enum mask_overlay_mode(void);
	inline void mask_overlay_mode(mask_overlay_mode_enum value);
	inline float blend_factor(void);
	inline void blend_factor(float value);
	enum mode_enum {
		mode_TRACKING = 0,
		mode_MASK = 3,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	enum view_enum {
		view_CLIP = 0,
		view_GRAPH = 1,
		view_DOPESHEET = 2,
	};
	inline view_enum view(void);
	inline void view(view_enum value);
	inline bool show_marker_pattern(void);
	inline void show_marker_pattern(bool value);
	inline bool show_marker_search(void);
	inline void show_marker_search(bool value);
	inline bool lock_selection(void);
	inline void lock_selection(bool value);
	inline bool lock_time_cursor(void);
	inline void lock_time_cursor(bool value);
	inline bool show_track_path(void);
	inline void show_track_path(bool value);
	inline int path_length(void);
	inline void path_length(int value);
	inline bool show_tiny_markers(void);
	inline void show_tiny_markers(bool value);
	inline bool show_bundles(void);
	inline void show_bundles(bool value);
	inline bool use_mute_footage(void);
	inline void use_mute_footage(bool value);
	inline bool show_disabled(void);
	inline void show_disabled(bool value);
	inline bool show_metadata(void);
	inline void show_metadata(bool value);
	inline MovieClipScopes scopes(void);
	inline bool show_names(void);
	inline void show_names(bool value);
	inline bool show_grid(void);
	inline void show_grid(bool value);
	inline bool show_stable(void);
	inline void show_stable(bool value);
	inline bool use_manual_calibration(void);
	inline void use_manual_calibration(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool show_filters(void);
	inline void show_filters(bool value);
	inline bool show_graph_frames(void);
	inline void show_graph_frames(bool value);
	inline bool show_graph_tracks_motion(void);
	inline void show_graph_tracks_motion(bool value);
	inline bool show_graph_tracks_error(void);
	inline void show_graph_tracks_error(bool value);
	inline bool show_graph_only_selected(void);
	inline void show_graph_only_selected(bool value);
	inline bool show_graph_hidden(void);
	inline void show_graph_hidden(bool value);
	inline bool show_red_channel(void);
	inline void show_red_channel(bool value);
	inline bool show_green_channel(void);
	inline void show_green_channel(bool value);
	inline bool show_blue_channel(void);
	inline void show_blue_channel(bool value);
	inline bool use_grayscale_preview(void);
	inline void use_grayscale_preview(bool value);
	inline bool show_seconds(void);
	inline void show_seconds(bool value);
	enum annotation_source_enum {
		annotation_source_CLIP = 0,
		annotation_source_TRACK = 1,
	};
	inline annotation_source_enum annotation_source(void);
	inline void annotation_source(annotation_source_enum value);
	inline Array<float, 2> cursor_location(void);
	inline void cursor_location(float values[2]);
	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
		pivot_point_MEDIAN_POINT = 3,
	};
	inline pivot_point_enum pivot_point(void);
	inline void pivot_point(pivot_point_enum value);
	inline bool show_gizmo(void);
	inline void show_gizmo(bool value);
	inline bool show_gizmo_navigate(void);
	inline void show_gizmo_navigate(bool value);

};

/**************** Space Spreadsheet ****************/

class SpaceSpreadsheet : public Space {
public:
	SpaceSpreadsheet(const PointerRNA &ptr_arg) :
		Space(ptr_arg),
		columns(ptr_arg),
		row_filters(ptr_arg)
		{}

	inline bool show_region_footer(void);
	inline void show_region_footer(bool value);
	inline bool show_region_toolbar(void);
	inline void show_region_toolbar(bool value);
	inline bool show_region_channels(void);
	inline void show_region_channels(bool value);
	inline bool show_region_ui(void);
	inline void show_region_ui(bool value);
	inline bool is_pinned(void);
	inline void is_pinned(bool value);
	inline bool use_filter(void);
	inline void use_filter(bool value);
	inline bool display_viewer_path_collapsed(void);
	inline void display_viewer_path_collapsed(bool value);
	inline ViewerPath viewer_path(void);
	inline bool show_only_selected(void);
	inline void show_only_selected(bool value);
	enum geometry_component_type_enum {
		geometry_component_type_MESH = 0,
		geometry_component_type_POINTCLOUD = 1,
		geometry_component_type_CURVE = 4,
		geometry_component_type_INSTANCES = 2,
		geometry_component_type_GREASEPENCIL = 6,
	};
	inline geometry_component_type_enum geometry_component_type(void);
	inline void geometry_component_type(geometry_component_type_enum value);
	enum attribute_domain_enum {
		attribute_domain_POINT = 0,
		attribute_domain_EDGE = 1,
		attribute_domain_FACE = 2,
		attribute_domain_CORNER = 3,
		attribute_domain_CURVE = 4,
		attribute_domain_INSTANCE = 5,
		attribute_domain_LAYER = 6,
	};
	inline attribute_domain_enum attribute_domain(void);
	inline void attribute_domain(attribute_domain_enum value);
	enum object_eval_state_enum {
		object_eval_state_EVALUATED = 0,
		object_eval_state_ORIGINAL = 1,
		object_eval_state_VIEWER_NODE = 2,
	};
	inline object_eval_state_enum object_eval_state(void);
	inline void object_eval_state(object_eval_state_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SpreadsheetColumn, SpaceSpreadsheet, columns, false, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, SpreadsheetRowFilter, SpaceSpreadsheet, row_filters, false, true, false)

};

/**************** Spreadsheet Column ****************/

class SpreadsheetColumn : public Pointer {
public:
	SpreadsheetColumn(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum data_type_enum {
		data_type_INT32 = 1,
		data_type_FLOAT = 2,
		data_type_BOOLEAN = 0,
		data_type_INSTANCES = 6,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);
	inline SpreadsheetColumnID id(void);

};

/**************** Spreadsheet Column ID ****************/

class SpreadsheetColumnID : public Pointer {
public:
	SpreadsheetColumnID(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Spreadsheet Row Filter ****************/

class SpreadsheetRowFilter : public Pointer {
public:
	SpreadsheetRowFilter(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	inline std::string column_name(void);
	inline void column_name(const std::string& value);
	enum operation_enum {
		operation_EQUAL = 0,
		operation_GREATER = 1,
		operation_LESS = 2,
	};
	inline operation_enum operation(void);
	inline void operation(operation_enum value);
	inline float value_float(void);
	inline void value_float(float value);
	inline Array<float, 2> value_float2(void);
	inline void value_float2(float values[2]);
	inline Array<float, 3> value_float3(void);
	inline void value_float3(float values[3]);
	inline Array<float, 4> value_color(void);
	inline void value_color(float values[4]);
	inline std::string value_string(void);
	inline void value_string(const std::string& value);
	inline float threshold(void);
	inline void threshold(float value);
	inline int value_int(void);
	inline void value_int(int value);
	inline int value_int8(void);
	inline void value_int8(int value);
	inline Array<int, 2> value_int2(void);
	inline void value_int2(int values[2]);
	inline bool value_boolean(void);
	inline void value_boolean(bool value);

};

/**************** Speaker ****************/

class Speaker : public ID {
public:
	Speaker(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline bool muted(void);
	inline void muted(bool value);
	inline Sound sound(void);
	inline float volume_max(void);
	inline void volume_max(float value);
	inline float volume_min(void);
	inline void volume_min(float value);
	inline float distance_max(void);
	inline void distance_max(float value);
	inline float distance_reference(void);
	inline void distance_reference(float value);
	inline float attenuation(void);
	inline void attenuation(float value);
	inline float cone_angle_outer(void);
	inline void cone_angle_outer(float value);
	inline float cone_angle_inner(void);
	inline void cone_angle_inner(float value);
	inline float cone_volume_outer(void);
	inline void cone_volume_outer(float value);
	inline float volume(void);
	inline void volume(float value);
	inline float pitch(void);
	inline void pitch(float value);
	inline AnimData animation_data(void);

};

/**************** Text Line ****************/

class TextLine : public Pointer {
public:
	TextLine(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string body(void);
	inline void body(const std::string& value);

};

/**************** Text ****************/

class Text : public ID {
public:
	Text(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		lines(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline bool is_dirty(void);
	inline void is_dirty(bool value);
	inline bool is_modified(void);
	inline void is_modified(bool value);
	inline bool is_in_memory(void);
	inline void is_in_memory(bool value);
	inline bool use_module(void);
	inline void use_module(bool value);
	enum indentation_enum {
		indentation_TABS = 0,
		indentation_SPACES = 1024,
	};
	inline indentation_enum indentation(void);
	inline void indentation(indentation_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, TextLine, Text, lines, false, true, false)
	inline TextLine current_line(void);
	inline int current_character(void);
	inline void current_character(int value);
	inline int current_line_index(void);
	inline void current_line_index(int value);
	inline TextLine select_end_line(void);
	inline int select_end_line_index(void);
	inline void select_end_line_index(int value);
	inline int select_end_character(void);
	inline void select_end_character(int value);

	inline void clear();
	inline void write(const char * text);
	inline void from_string(const char * text);
	inline void as_string(int *text_len, const char * *text);
	inline bool is_syntax_highlight_supported();
	inline void select_set(int line_start, int char_start, int line_end, int char_end);
	inline void cursor_set(int line, int character, bool select);
};

/**************** Marker ****************/

class TimelineMarker : public Pointer {
public:
	TimelineMarker(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int frame(void);
	inline void frame(int value);
	inline bool select(void);
	inline void select(bool value);
	inline Object camera(void);

};

/**************** Sound ****************/

class Sound : public ID {
public:
	Sound(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline PackedFile packed_file(void);
	inline bool use_memory_cache(void);
	inline void use_memory_cache(bool value);
	inline bool use_mono(void);
	inline void use_mono(bool value);
	inline int samplerate(void);
	inline void samplerate(int value);
	enum channels_enum {
		channels_INVALID = 0,
		channels_MONO = 1,
		channels_STEREO = 2,
		channels_STEREO_LFE = 3,
		channels_CHANNELS_4 = 4,
		channels_CHANNELS_5 = 5,
		channels_SURROUND_51 = 6,
		channels_SURROUND_61 = 7,
		channels_SURROUND_71 = 8,
	};
	inline channels_enum channels(void);
	inline void channels(channels_enum value);

	inline void pack(void *main);
	inline void unpack(void *main, int method);
};

/**************** UI Layout ****************/

class UILayout : public Pointer {
public:
	UILayout(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool active(void);
	inline void active(bool value);
	inline bool active_default(void);
	inline void active_default(bool value);
	inline bool activate_init(void);
	inline void activate_init(bool value);
	enum operator_context_enum {
		operator_context_INVOKE_DEFAULT = 0,
		operator_context_INVOKE_REGION_WIN = 1,
		operator_context_INVOKE_REGION_CHANNELS = 2,
		operator_context_INVOKE_REGION_PREVIEW = 3,
		operator_context_INVOKE_AREA = 4,
		operator_context_INVOKE_SCREEN = 5,
		operator_context_EXEC_DEFAULT = 6,
		operator_context_EXEC_REGION_WIN = 7,
		operator_context_EXEC_REGION_CHANNELS = 8,
		operator_context_EXEC_REGION_PREVIEW = 9,
		operator_context_EXEC_AREA = 10,
		operator_context_EXEC_SCREEN = 11,
	};
	inline operator_context_enum operator_context(void);
	inline void operator_context(operator_context_enum value);
	inline bool enabled(void);
	inline void enabled(bool value);
	inline bool alert(void);
	inline void alert(bool value);
	enum alignment_enum {
		alignment_EXPAND = 0,
		alignment_LEFT = 1,
		alignment_CENTER = 2,
		alignment_RIGHT = 3,
	};
	inline alignment_enum alignment(void);
	inline void alignment(alignment_enum value);
	enum direction_enum {
		direction_HORIZONTAL = 0,
		direction_VERTICAL = 1,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	inline float scale_x(void);
	inline void scale_x(float value);
	inline float scale_y(void);
	inline void scale_y(float value);
	inline float ui_units_x(void);
	inline void ui_units_x(float value);
	inline float ui_units_y(void);
	inline void ui_units_y(float value);
	enum emboss_enum {
		emboss_NORMAL = 0,
		emboss_NONE = 1,
		emboss_PULLDOWN_MENU = 2,
		emboss_RADIAL_MENU = 3,
		emboss_NONE_OR_STATUS = 4,
	};
	inline emboss_enum emboss(void);
	inline void emboss(emboss_enum value);
	inline bool use_property_split(void);
	inline void use_property_split(bool value);
	inline bool use_property_decorate(void);
	inline void use_property_decorate(bool value);

	inline UILayout row(bool align, const char * heading, const char * heading_ctxt, bool translate);
	inline UILayout column(bool align, const char * heading, const char * heading_ctxt, bool translate);
	inline UILayout column_flow(int columns, bool align);
	inline UILayout grid_flow(bool row_major, int columns, bool even_columns, bool even_rows, bool align);
	inline UILayout box();
	inline UILayout split(float factor, bool align);
	inline UILayout menu_pie();
	inline int icon(Context C, AnyType& data);
	inline const char * enum_item_name(Context C, AnyType& data, const char * property, const char * identifier);
	inline const char * enum_item_description(Context C, AnyType& data, const char * property, const char * identifier);
	inline int enum_item_icon(Context C, AnyType& data, const char * property, const char * identifier);
	inline void prop(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, const char * placeholder, bool expand, bool slider, int toggle, bool icon_only, bool event, bool full_event, bool emboss, int index, int icon_value, bool invert_checkbox);
	inline void props_enum(AnyType& data, const char * property);
	inline void prop_menu_enum(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon);
	inline void prop_with_popover(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * panel);
	inline void prop_with_menu(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * menu);
	inline void prop_tabs_enum(Context C, AnyType& data, const char * property, AnyType& data_highlight, const char * property_highlight, bool icon_only);
	inline void prop_enum(AnyType& data, const char * property, const char * value, const char * text, const char * text_ctxt, bool translate, int icon);
	inline void prop_search(AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * text, const char * text_ctxt, bool translate, int icon, bool results_are_suggestions);
	inline void prop_decorator(AnyType& data, const char * property, int index);
	inline OperatorProperties operator_value(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value);
	inline OperatorProperties operator_menu_hold(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value, const char * menu);
	inline void operator_enum(const char * operator_value, const char * property, bool icon_only);
	inline OperatorProperties operator_menu_enum(Context C, const char * operator_value, const char * property, const char * text, const char * text_ctxt, bool translate, int icon);
	inline void label(const char * text, const char * text_ctxt, bool translate, int icon, int icon_value);
	inline void menu(const char * menu, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value);
	inline void menu_contents(const char * menu);
	inline void popover(Context C, const char * panel, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value);
	inline void popover_group(Context C, int space_type, int region_type, const char * context, const char * category);
	inline void separator(float factor);
	inline void separator_spacer();
	inline void progress(const char * text, const char * text_ctxt, bool translate, float factor, int type);
	inline void context_pointer_set(const char * name, AnyType& data);
	inline void template_header(Context C);
	inline void template_ID(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int filter, bool live_icon, const char * text, const char * text_ctxt, bool translate);
	inline void template_ID_preview(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int rows, int cols, int filter, bool hide_buttons);
	inline void template_any_ID(AnyType& data, const char * property, const char * type_property, const char * text, const char * text_ctxt, bool translate);
	inline void template_ID_tabs(Context C, AnyType& data, const char * property, const char * create, const char * menu, int filter);
	inline void template_search(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink);
	inline void template_search_preview(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink, int rows, int cols);
	inline void template_path_builder(AnyType& data, const char * property, ID& root, const char * text, const char * text_ctxt, bool translate);
	inline void template_modifiers(Context C);
	inline void template_constraints(Context C, bool use_bone_constraints);
	inline void template_grease_pencil_modifiers(Context C);
	inline void template_shaderfx(Context C);
	inline void template_greasepencil_color(Context C, AnyType& data, const char * property, int rows, int cols, float scale, int filter);
	inline void template_constraint_header(Constraint& data);
	inline void template_preview(Context C, ID& id, bool show_buttons, ID& parent, TextureSlot& slot, const char * preview_id);
	inline void template_curve_mapping(AnyType& data, const char * property, int type, bool levels, bool brush, bool use_negative_slope, bool show_tone);
	inline void template_curveprofile(AnyType& data, const char * property);
	inline void template_color_ramp(AnyType& data, const char * property, bool expand);
	inline void template_icon(int icon_value, float scale);
	inline void template_icon_view(AnyType& data, const char * property, bool show_labels, float scale, float scale_popup);
	inline void template_histogram(AnyType& data, const char * property);
	inline void template_waveform(AnyType& data, const char * property);
	inline void template_vectorscope(AnyType& data, const char * property);
	inline void template_layers(AnyType& data, const char * property, AnyType& used_layers_data, const char * used_layers_property, int active_layer);
	inline void template_color_picker(AnyType& data, const char * property, bool value_slider, bool lock, bool lock_luminosity, bool cubic);
	inline void template_palette(AnyType& data, const char * property, bool color);
	inline void template_image_layers(Context C, Image& image, ImageUser& image_user);
	inline void template_image(Context C, AnyType& data, const char * property, ImageUser& image_user, bool compact, bool multiview);
	inline void template_image_settings(ImageFormatSettings& image_settings, bool color_management);
	inline void template_image_stereo_3d(Stereo3dFormat& stereo_3d_format);
	inline void template_image_views(ImageFormatSettings& image_settings);
	inline void template_movieclip(Context C, AnyType& data, const char * property, bool compact);
	inline void template_track(AnyType& data, const char * property);
	inline void template_marker(AnyType& data, const char * property, MovieClipUser& clip_user, MovieTrackingTrack& track, bool compact);
	inline void template_movieclip_information(AnyType& data, const char * property, MovieClipUser& clip_user);
	inline void template_list(Context C, const char * listtype_name, const char * list_id, AnyType& dataptr, const char * propname, AnyType& active_dataptr, const char * active_propname, const char * item_dyntip_propname, int rows, int maxrows, int type, int columns, bool sort_reverse, bool sort_lock);
	inline void template_running_jobs(Context C);
	inline void template_operator_search();
	inline void template_menu_search();
	inline void template_header_3D_mode(Context C);
	inline void template_edit_mode_selection(Context C);
	inline void template_reports_banner(Context C);
	inline void template_input_status(Context C);
	inline void template_status_info(Context C);
	inline void template_node_link(Context C, NodeTree& ntree, Node& node, NodeSocket& socket);
	inline void template_node_view(Context C, NodeTree& ntree, Node& node, NodeSocket& socket);
	inline void template_node_asset_menu_items(Context C, const char * catalog_path);
	inline void template_modifier_asset_menu_items(Context C, const char * catalog_path);
	inline void template_node_operator_asset_menu_items(Context C, const char * catalog_path);
	inline void template_node_operator_asset_root_items(Context C);
	inline void template_texture_user(Context C);
	inline void template_keymap_item_properties(KeyMapItem& item);
	inline void template_component_menu(AnyType& data, const char * property, const char * name);
	inline void template_colorspace_settings(AnyType& data, const char * property);
	inline void template_colormanaged_view_settings(Context C, AnyType& data, const char * property);
	inline void template_node_socket(Context C, float color[4]);
	inline void template_cache_file(Context C, AnyType& data, const char * property);
	inline void template_cache_file_velocity(AnyType& data, const char * property);
	inline void template_cache_file_procedural(Context C, AnyType& data, const char * property);
	inline void template_cache_file_time_settings(AnyType& data, const char * property);
	inline void template_cache_file_layers(Context C, AnyType& data, const char * property);
	inline int template_recent_files(int rows);
	inline void template_file_select_path(Context C, FileSelectParams& params);
	inline void template_event_from_keymap_item(KeyMapItem& item, const char * text, const char * text_ctxt, bool translate);
	inline void template_asset_view(Context C, const char * list_id, AnyType& asset_library_dataptr, const char * asset_library_propname, AnyType& assets_dataptr, const char * assets_propname, AnyType& active_dataptr, const char * active_propname, int filter_id_types, int display_options, const char * activate_operator, OperatorProperties *activate_operator_properties, const char * drag_operator, OperatorProperties *drag_operator_properties);
	inline void template_light_linking_collection(UILayout& context_layout, AnyType& data, const char * property);
	inline void template_grease_pencil_layer_tree(Context C);
	inline void template_node_tree_interface(NodeTreeInterface& interface);
};

/**************** Panel ****************/

class Panel : public Pointer {
public:
	Panel(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);
	inline std::string text(void);
	inline void text(const std::string& value);
	inline Constraint custom_data(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline std::string bl_category(void);
	inline void bl_category(const std::string& value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);
	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_CONSOLE = 18,
		bl_space_type_INFO = 7,
		bl_space_type_TOPBAR = 21,
		bl_space_type_STATUSBAR = 22,
		bl_space_type_OUTLINER = 3,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_SPREADSHEET = 23,
		bl_space_type_PREFERENCES = 19,
	};
	inline bl_space_type_enum bl_space_type(void);
	inline void bl_space_type(bl_space_type_enum value);
	enum bl_region_type_enum {
		bl_region_type_WINDOW = 0,
		bl_region_type_HEADER = 1,
		bl_region_type_CHANNELS = 2,
		bl_region_type_TEMPORARY = 3,
		bl_region_type_UI = 4,
		bl_region_type_TOOLS = 5,
		bl_region_type_TOOL_PROPS = 6,
		bl_region_type_ASSET_SHELF = 14,
		bl_region_type_ASSET_SHELF_HEADER = 15,
		bl_region_type_PREVIEW = 7,
		bl_region_type_HUD = 8,
		bl_region_type_NAVIGATION_BAR = 9,
		bl_region_type_EXECUTE = 10,
		bl_region_type_FOOTER = 11,
		bl_region_type_TOOL_HEADER = 12,
		bl_region_type_XR = 13,
	};
	inline bl_region_type_enum bl_region_type(void);
	inline void bl_region_type(bl_region_type_enum value);
	inline std::string bl_context(void);
	inline void bl_context(const std::string& value);
	enum bl_options_enum {
		bl_options_DEFAULT_CLOSED = 1,
		bl_options_HIDE_HEADER = 2,
		bl_options_INSTANCED = 16,
		bl_options_HEADER_LAYOUT_EXPAND = 4,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	inline std::string bl_parent_id(void);
	inline void bl_parent_id(const std::string& value);
	inline int bl_ui_units_x(void);
	inline void bl_ui_units_x(int value);
	inline int bl_order(void);
	inline void bl_order(int value);
	inline bool use_pin(void);
	inline void use_pin(bool value);
	inline bool is_popover(void);
	inline void is_popover(bool value);

};

/**************** UIList ****************/

class UIList : public Pointer {
public:
	UIList(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string list_id(void);
	inline void list_id(const std::string& value);
	enum layout_type_enum {
		layout_type_DEFAULT = 0,
		layout_type_COMPACT = 1,
		layout_type_GRID = 2,
	};
	inline layout_type_enum layout_type(void);
	inline void layout_type(layout_type_enum value);
	inline bool use_filter_show(void);
	inline void use_filter_show(bool value);
	inline std::string filter_name(void);
	inline void filter_name(const std::string& value);
	inline bool use_filter_invert(void);
	inline void use_filter_invert(bool value);
	inline bool use_filter_sort_alpha(void);
	inline void use_filter_sort_alpha(bool value);
	inline bool use_filter_sort_reverse(void);
	inline void use_filter_sort_reverse(bool value);
	inline bool use_filter_sort_lock(void);
	inline void use_filter_sort_lock(bool value);
	inline int bitflag_filter_item(void);
	inline void bitflag_filter_item(int value);

};

/**************** Header ****************/

class Header : public Pointer {
public:
	Header(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_CONSOLE = 18,
		bl_space_type_INFO = 7,
		bl_space_type_TOPBAR = 21,
		bl_space_type_STATUSBAR = 22,
		bl_space_type_OUTLINER = 3,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_SPREADSHEET = 23,
		bl_space_type_PREFERENCES = 19,
	};
	inline bl_space_type_enum bl_space_type(void);
	inline void bl_space_type(bl_space_type_enum value);
	enum bl_region_type_enum {
		bl_region_type_WINDOW = 0,
		bl_region_type_HEADER = 1,
		bl_region_type_CHANNELS = 2,
		bl_region_type_TEMPORARY = 3,
		bl_region_type_UI = 4,
		bl_region_type_TOOLS = 5,
		bl_region_type_TOOL_PROPS = 6,
		bl_region_type_ASSET_SHELF = 14,
		bl_region_type_ASSET_SHELF_HEADER = 15,
		bl_region_type_PREVIEW = 7,
		bl_region_type_HUD = 8,
		bl_region_type_NAVIGATION_BAR = 9,
		bl_region_type_EXECUTE = 10,
		bl_region_type_FOOTER = 11,
		bl_region_type_TOOL_HEADER = 12,
		bl_region_type_XR = 13,
	};
	inline bl_region_type_enum bl_region_type(void);
	inline void bl_region_type(bl_region_type_enum value);

};

/**************** Menu ****************/

class Menu : public Pointer {
public:
	Menu(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);
	enum bl_options_enum {
		bl_options_SEARCH_ON_KEY_PRESS = 2,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);

};

/**************** Asset Shelf ****************/

class AssetShelf : public Pointer {
public:
	AssetShelf(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_CONSOLE = 18,
		bl_space_type_INFO = 7,
		bl_space_type_TOPBAR = 21,
		bl_space_type_STATUSBAR = 22,
		bl_space_type_OUTLINER = 3,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_SPREADSHEET = 23,
		bl_space_type_PREFERENCES = 19,
	};
	inline bl_space_type_enum bl_space_type(void);
	inline void bl_space_type(bl_space_type_enum value);
	enum bl_options_enum {
		bl_options_NO_ASSET_DRAG = 1,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	enum asset_library_reference_enum {
	};
	inline asset_library_reference_enum asset_library_reference(void);
	inline void asset_library_reference(asset_library_reference_enum value);
	inline bool show_names(void);
	inline void show_names(bool value);
	inline int preview_size(void);
	inline void preview_size(int value);
	inline std::string search_filter(void);
	inline void search_filter(const std::string& value);

};

/**************** USD Hook ****************/

class USDHook : public Pointer {
public:
	USDHook(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);

};

/**************** Font Style ****************/

class ThemeFontStyle : public Pointer {
public:
	ThemeFontStyle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float points(void);
	inline void points(float value);
	inline int character_weight(void);
	inline void character_weight(int value);
	inline int shadow(void);
	inline void shadow(int value);
	inline int shadow_offset_x(void);
	inline void shadow_offset_x(int value);
	inline int shadow_offset_y(void);
	inline void shadow_offset_y(int value);
	inline float shadow_alpha(void);
	inline void shadow_alpha(float value);
	inline float shadow_value(void);
	inline void shadow_value(float value);

};

/**************** Style ****************/

class ThemeStyle : public Pointer {
public:
	ThemeStyle(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeFontStyle panel_title(void);
	inline ThemeFontStyle widget_label(void);
	inline ThemeFontStyle widget(void);

};

/**************** Theme Widget Color Set ****************/

class ThemeWidgetColors : public Pointer {
public:
	ThemeWidgetColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> outline(void);
	inline void outline(float values[4]);
	inline Array<float, 4> inner(void);
	inline void inner(float values[4]);
	inline Array<float, 4> inner_sel(void);
	inline void inner_sel(float values[4]);
	inline Array<float, 4> item(void);
	inline void item(float values[4]);
	inline Array<float, 3> text(void);
	inline void text(float values[3]);
	inline Array<float, 3> text_sel(void);
	inline void text_sel(float values[3]);
	inline bool show_shaded(void);
	inline void show_shaded(bool value);
	inline int shadetop(void);
	inline void shadetop(int value);
	inline int shadedown(void);
	inline void shadedown(int value);
	inline float roundness(void);
	inline void roundness(float value);

};

/**************** Theme Widget State Color ****************/

class ThemeWidgetStateColors : public Pointer {
public:
	ThemeWidgetStateColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> inner_anim(void);
	inline void inner_anim(float values[3]);
	inline Array<float, 3> inner_anim_sel(void);
	inline void inner_anim_sel(float values[3]);
	inline Array<float, 3> inner_key(void);
	inline void inner_key(float values[3]);
	inline Array<float, 3> inner_key_sel(void);
	inline void inner_key_sel(float values[3]);
	inline Array<float, 3> inner_driven(void);
	inline void inner_driven(float values[3]);
	inline Array<float, 3> inner_driven_sel(void);
	inline void inner_driven_sel(float values[3]);
	inline Array<float, 3> inner_overridden(void);
	inline void inner_overridden(float values[3]);
	inline Array<float, 3> inner_overridden_sel(void);
	inline void inner_overridden_sel(float values[3]);
	inline Array<float, 3> inner_changed(void);
	inline void inner_changed(float values[3]);
	inline Array<float, 3> inner_changed_sel(void);
	inline void inner_changed_sel(float values[3]);
	inline float blend(void);
	inline void blend(float value);

};

/**************** Theme Panel Color ****************/

class ThemePanelColors : public Pointer {
public:
	ThemePanelColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> header(void);
	inline void header(float values[4]);
	inline Array<float, 4> back(void);
	inline void back(float values[4]);
	inline Array<float, 4> sub_back(void);
	inline void sub_back(float values[4]);

};

/**************** Theme Background Color ****************/

class ThemeGradientColors : public Pointer {
public:
	ThemeGradientColors(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum background_type_enum {
		background_type_SINGLE_COLOR = 0,
		background_type_LINEAR = 1,
		background_type_RADIAL = 2,
	};
	inline background_type_enum background_type(void);
	inline void background_type(background_type_enum value);
	inline Array<float, 3> high_gradient(void);
	inline void high_gradient(float values[3]);
	inline Array<float, 3> gradient(void);
	inline void gradient(float values[3]);

};

/**************** Theme User Interface ****************/

class ThemeUserInterface : public Pointer {
public:
	ThemeUserInterface(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeWidgetColors wcol_regular(void);
	inline ThemeWidgetColors wcol_tool(void);
	inline ThemeWidgetColors wcol_toolbar_item(void);
	inline ThemeWidgetColors wcol_radio(void);
	inline ThemeWidgetColors wcol_text(void);
	inline ThemeWidgetColors wcol_option(void);
	inline ThemeWidgetColors wcol_toggle(void);
	inline ThemeWidgetColors wcol_num(void);
	inline ThemeWidgetColors wcol_numslider(void);
	inline ThemeWidgetColors wcol_box(void);
	inline ThemeWidgetColors wcol_menu(void);
	inline ThemeWidgetColors wcol_pulldown(void);
	inline ThemeWidgetColors wcol_menu_back(void);
	inline ThemeWidgetColors wcol_pie_menu(void);
	inline ThemeWidgetColors wcol_tooltip(void);
	inline ThemeWidgetColors wcol_menu_item(void);
	inline ThemeWidgetColors wcol_scroll(void);
	inline ThemeWidgetColors wcol_progress(void);
	inline ThemeWidgetColors wcol_list_item(void);
	inline ThemeWidgetStateColors wcol_state(void);
	inline ThemeWidgetColors wcol_tab(void);
	inline float menu_shadow_fac(void);
	inline void menu_shadow_fac(float value);
	inline int menu_shadow_width(void);
	inline void menu_shadow_width(int value);
	inline float icon_alpha(void);
	inline void icon_alpha(float value);
	inline float icon_saturation(void);
	inline void icon_saturation(float value);
	inline Array<float, 4> widget_emboss(void);
	inline void widget_emboss(float values[4]);
	inline Array<float, 3> editor_outline(void);
	inline void editor_outline(float values[3]);
	inline Array<float, 3> widget_text_cursor(void);
	inline void widget_text_cursor(float values[3]);
	inline float panel_roundness(void);
	inline void panel_roundness(float value);
	inline Array<float, 3> transparent_checker_primary(void);
	inline void transparent_checker_primary(float values[3]);
	inline Array<float, 3> transparent_checker_secondary(void);
	inline void transparent_checker_secondary(float values[3]);
	inline int transparent_checker_size(void);
	inline void transparent_checker_size(int value);
	inline Array<float, 3> axis_x(void);
	inline void axis_x(float values[3]);
	inline Array<float, 3> axis_y(void);
	inline void axis_y(float values[3]);
	inline Array<float, 3> axis_z(void);
	inline void axis_z(float values[3]);
	inline Array<float, 3> gizmo_hi(void);
	inline void gizmo_hi(float values[3]);
	inline Array<float, 3> gizmo_primary(void);
	inline void gizmo_primary(float values[3]);
	inline Array<float, 3> gizmo_secondary(void);
	inline void gizmo_secondary(float values[3]);
	inline Array<float, 3> gizmo_view_align(void);
	inline void gizmo_view_align(float values[3]);
	inline Array<float, 3> gizmo_a(void);
	inline void gizmo_a(float values[3]);
	inline Array<float, 3> gizmo_b(void);
	inline void gizmo_b(float values[3]);
	inline Array<float, 4> icon_scene(void);
	inline void icon_scene(float values[4]);
	inline Array<float, 4> icon_collection(void);
	inline void icon_collection(float values[4]);
	inline Array<float, 4> icon_object(void);
	inline void icon_object(float values[4]);
	inline Array<float, 4> icon_object_data(void);
	inline void icon_object_data(float values[4]);
	inline Array<float, 4> icon_modifier(void);
	inline void icon_modifier(float values[4]);
	inline Array<float, 4> icon_shading(void);
	inline void icon_shading(float values[4]);
	inline Array<float, 4> icon_folder(void);
	inline void icon_folder(float values[4]);
	inline float icon_border_intensity(void);
	inline void icon_border_intensity(float value);

};

/**************** Theme Space Settings ****************/

class ThemeSpaceGeneric : public Pointer {
public:
	ThemeSpaceGeneric(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> back(void);
	inline void back(float values[3]);
	inline Array<float, 3> title(void);
	inline void title(float values[3]);
	inline Array<float, 3> text(void);
	inline void text(float values[3]);
	inline Array<float, 3> text_hi(void);
	inline void text_hi(float values[3]);
	inline Array<float, 4> header(void);
	inline void header(float values[4]);
	inline Array<float, 3> header_text(void);
	inline void header_text(float values[3]);
	inline Array<float, 3> header_text_hi(void);
	inline void header_text_hi(float values[3]);
	inline ThemePanelColors panelcolors(void);
	inline Array<float, 4> button(void);
	inline void button(float values[4]);
	inline Array<float, 3> button_title(void);
	inline void button_title(float values[3]);
	inline Array<float, 3> button_text(void);
	inline void button_text(float values[3]);
	inline Array<float, 3> button_text_hi(void);
	inline void button_text_hi(float values[3]);
	inline Array<float, 4> navigation_bar(void);
	inline void navigation_bar(float values[4]);
	inline Array<float, 4> execution_buts(void);
	inline void execution_buts(float values[4]);
	inline Array<float, 3> tab_active(void);
	inline void tab_active(float values[3]);
	inline Array<float, 3> tab_inactive(void);
	inline void tab_inactive(float values[3]);
	inline Array<float, 4> tab_back(void);
	inline void tab_back(float values[4]);
	inline Array<float, 4> tab_outline(void);
	inline void tab_outline(float values[4]);

};

/**************** Theme Space Settings ****************/

class ThemeSpaceGradient : public Pointer {
public:
	ThemeSpaceGradient(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeGradientColors gradients(void);
	inline Array<float, 3> title(void);
	inline void title(float values[3]);
	inline Array<float, 3> text(void);
	inline void text(float values[3]);
	inline Array<float, 3> text_hi(void);
	inline void text_hi(float values[3]);
	inline Array<float, 4> header(void);
	inline void header(float values[4]);
	inline Array<float, 3> header_text(void);
	inline void header_text(float values[3]);
	inline Array<float, 3> header_text_hi(void);
	inline void header_text_hi(float values[3]);
	inline ThemePanelColors panelcolors(void);
	inline Array<float, 4> button(void);
	inline void button(float values[4]);
	inline Array<float, 3> button_title(void);
	inline void button_title(float values[3]);
	inline Array<float, 3> button_text(void);
	inline void button_text(float values[3]);
	inline Array<float, 3> button_text_hi(void);
	inline void button_text_hi(float values[3]);
	inline Array<float, 4> navigation_bar(void);
	inline void navigation_bar(float values[4]);
	inline Array<float, 4> execution_buts(void);
	inline void execution_buts(float values[4]);
	inline Array<float, 3> tab_active(void);
	inline void tab_active(float values[3]);
	inline Array<float, 3> tab_inactive(void);
	inline void tab_inactive(float values[3]);
	inline Array<float, 4> tab_back(void);
	inline void tab_back(float values[4]);
	inline Array<float, 4> tab_outline(void);
	inline void tab_outline(float values[4]);

};

/**************** Theme Space List Settings ****************/

class ThemeSpaceListGeneric : public Pointer {
public:
	ThemeSpaceListGeneric(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> list(void);
	inline void list(float values[3]);
	inline Array<float, 3> list_title(void);
	inline void list_title(float values[3]);
	inline Array<float, 3> list_text(void);
	inline void list_text(float values[3]);
	inline Array<float, 3> list_text_hi(void);
	inline void list_text_hi(float values[3]);

};

/**************** Theme Asset Shelf Color ****************/

class ThemeAssetShelf : public Pointer {
public:
	ThemeAssetShelf(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> header_back(void);
	inline void header_back(float values[4]);
	inline Array<float, 4> back(void);
	inline void back(float values[4]);

};

/**************** Theme 3D Viewport ****************/

class ThemeView3D : public Pointer {
public:
	ThemeView3D(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGradient space(void);
	inline Array<float, 4> grid(void);
	inline void grid(float values[4]);
	inline Array<float, 4> clipping_border_3d(void);
	inline void clipping_border_3d(float values[4]);
	inline Array<float, 3> wire(void);
	inline void wire(float values[3]);
	inline Array<float, 3> wire_edit(void);
	inline void wire_edit(float values[3]);
	inline int edge_width(void);
	inline void edge_width(int value);
	inline Array<float, 3> gp_vertex(void);
	inline void gp_vertex(float values[3]);
	inline Array<float, 3> gp_vertex_select(void);
	inline void gp_vertex_select(float values[3]);
	inline int gp_vertex_size(void);
	inline void gp_vertex_size(int value);
	inline Array<float, 3> text_grease_pencil(void);
	inline void text_grease_pencil(float values[3]);
	inline Array<float, 3> object_selected(void);
	inline void object_selected(float values[3]);
	inline Array<float, 3> object_active(void);
	inline void object_active(float values[3]);
	inline Array<float, 3> text_keyframe(void);
	inline void text_keyframe(float values[3]);
	inline Array<float, 3> camera(void);
	inline void camera(float values[3]);
	inline Array<float, 3> empty(void);
	inline void empty(float values[3]);
	inline Array<float, 4> light(void);
	inline void light(float values[4]);
	inline Array<float, 3> speaker(void);
	inline void speaker(float values[3]);
	inline Array<float, 3> vertex(void);
	inline void vertex(float values[3]);
	inline Array<float, 3> vertex_select(void);
	inline void vertex_select(float values[3]);
	inline Array<float, 3> vertex_active(void);
	inline void vertex_active(float values[3]);
	inline int vertex_size(void);
	inline void vertex_size(int value);
	inline Array<float, 3> vertex_bevel(void);
	inline void vertex_bevel(float values[3]);
	inline Array<float, 3> vertex_unreferenced(void);
	inline void vertex_unreferenced(float values[3]);
	inline Array<float, 3> edge_select(void);
	inline void edge_select(float values[3]);
	inline Array<float, 3> edge_mode_select(void);
	inline void edge_mode_select(float values[3]);
	inline Array<float, 3> edge_seam(void);
	inline void edge_seam(float values[3]);
	inline Array<float, 3> edge_sharp(void);
	inline void edge_sharp(float values[3]);
	inline Array<float, 3> edge_crease(void);
	inline void edge_crease(float values[3]);
	inline Array<float, 3> edge_bevel(void);
	inline void edge_bevel(float values[3]);
	inline Array<float, 3> edge_facesel(void);
	inline void edge_facesel(float values[3]);
	inline Array<float, 3> freestyle_edge_mark(void);
	inline void freestyle_edge_mark(float values[3]);
	inline Array<float, 4> face(void);
	inline void face(float values[4]);
	inline Array<float, 4> face_select(void);
	inline void face_select(float values[4]);
	inline Array<float, 4> face_mode_select(void);
	inline void face_mode_select(float values[4]);
	inline Array<float, 3> face_dot(void);
	inline void face_dot(float values[3]);
	inline int facedot_size(void);
	inline void facedot_size(int value);
	inline Array<float, 4> freestyle_face_mark(void);
	inline void freestyle_face_mark(float values[4]);
	inline Array<float, 4> face_retopology(void);
	inline void face_retopology(float values[4]);
	inline Array<float, 4> face_back(void);
	inline void face_back(float values[4]);
	inline Array<float, 4> face_front(void);
	inline void face_front(float values[4]);
	inline Array<float, 3> nurb_uline(void);
	inline void nurb_uline(float values[3]);
	inline Array<float, 3> nurb_vline(void);
	inline void nurb_vline(float values[3]);
	inline Array<float, 3> nurb_sel_uline(void);
	inline void nurb_sel_uline(float values[3]);
	inline Array<float, 3> nurb_sel_vline(void);
	inline void nurb_sel_vline(float values[3]);
	inline Array<float, 3> act_spline(void);
	inline void act_spline(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_vect(void);
	inline void handle_vect(float values[3]);
	inline Array<float, 3> handle_sel_vect(void);
	inline void handle_sel_vect(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> lastsel_point(void);
	inline void lastsel_point(float values[3]);
	inline Array<float, 3> extra_edge_len(void);
	inline void extra_edge_len(float values[3]);
	inline Array<float, 3> extra_edge_angle(void);
	inline void extra_edge_angle(float values[3]);
	inline Array<float, 3> extra_face_angle(void);
	inline void extra_face_angle(float values[3]);
	inline Array<float, 3> extra_face_area(void);
	inline void extra_face_area(float values[3]);
	inline Array<float, 4> editmesh_active(void);
	inline void editmesh_active(float values[4]);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> vertex_normal(void);
	inline void vertex_normal(float values[3]);
	inline Array<float, 3> split_normal(void);
	inline void split_normal(float values[3]);
	inline Array<float, 3> bone_pose(void);
	inline void bone_pose(float values[3]);
	inline Array<float, 3> bone_pose_active(void);
	inline void bone_pose_active(float values[3]);
	inline Array<float, 3> bone_solid(void);
	inline void bone_solid(float values[3]);
	inline Array<float, 4> bone_locked_weight(void);
	inline void bone_locked_weight(float values[4]);
	inline Array<float, 3> bundle_solid(void);
	inline void bundle_solid(float values[3]);
	inline Array<float, 3> camera_path(void);
	inline void camera_path(float values[3]);
	inline Array<float, 3> camera_passepartout(void);
	inline void camera_passepartout(float values[3]);
	inline Array<float, 3> skin_root(void);
	inline void skin_root(float values[3]);
	inline Array<float, 3> view_overlay(void);
	inline void view_overlay(float values[3]);
	inline Array<float, 3> transform(void);
	inline void transform(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 4> paint_curve_handle(void);
	inline void paint_curve_handle(float values[4]);
	inline Array<float, 4> paint_curve_pivot(void);
	inline void paint_curve_pivot(float values[4]);
	inline int outline_width(void);
	inline void outline_width(int value);
	inline int object_origin_size(void);
	inline void object_origin_size(int value);
	inline ThemeAssetShelf asset_shelf(void);

};

/**************** Theme Graph Editor ****************/

class ThemeGraphEditor : public Pointer {
public:
	ThemeGraphEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 4> time_scrub_background(void);
	inline void time_scrub_background(float values[4]);
	inline Array<float, 4> time_marker_line(void);
	inline void time_marker_line(float values[4]);
	inline Array<float, 4> time_marker_line_selected(void);
	inline void time_marker_line_selected(float values[4]);
	inline Array<float, 3> window_sliders(void);
	inline void window_sliders(float values[3]);
	inline Array<float, 3> channels_region(void);
	inline void channels_region(float values[3]);
	inline Array<float, 3> dopesheet_channel(void);
	inline void dopesheet_channel(float values[3]);
	inline Array<float, 3> dopesheet_subchannel(void);
	inline void dopesheet_subchannel(float values[3]);
	inline Array<float, 3> channel_group(void);
	inline void channel_group(float values[3]);
	inline Array<float, 3> active_channels_group(void);
	inline void active_channels_group(float values[3]);
	inline Array<float, 4> preview_range(void);
	inline void preview_range(float values[4]);
	inline Array<float, 3> vertex(void);
	inline void vertex(float values[3]);
	inline Array<float, 3> vertex_select(void);
	inline void vertex_select(float values[3]);
	inline Array<float, 3> vertex_active(void);
	inline void vertex_active(float values[3]);
	inline int vertex_size(void);
	inline void vertex_size(int value);
	inline Array<float, 3> vertex_bevel(void);
	inline void vertex_bevel(float values[3]);
	inline Array<float, 3> vertex_unreferenced(void);
	inline void vertex_unreferenced(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_vect(void);
	inline void handle_vect(float values[3]);
	inline Array<float, 3> handle_sel_vect(void);
	inline void handle_sel_vect(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> handle_auto_clamped(void);
	inline void handle_auto_clamped(float values[3]);
	inline Array<float, 3> handle_sel_auto_clamped(void);
	inline void handle_sel_auto_clamped(float values[3]);
	inline Array<float, 3> lastsel_point(void);
	inline void lastsel_point(float values[3]);
	inline Array<float, 3> handle_vertex(void);
	inline void handle_vertex(float values[3]);
	inline Array<float, 3> handle_vertex_select(void);
	inline void handle_vertex_select(float values[3]);
	inline int handle_vertex_size(void);
	inline void handle_vertex_size(int value);

};

/**************** Theme File Browser ****************/

class ThemeFileBrowser : public Pointer {
public:
	ThemeFileBrowser(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> selected_file(void);
	inline void selected_file(float values[3]);
	inline Array<float, 4> row_alternate(void);
	inline void row_alternate(float values[4]);

};

/**************** Theme Nonlinear Animation ****************/

class ThemeNLAEditor : public Pointer {
public:
	ThemeNLAEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> view_sliders(void);
	inline void view_sliders(float values[3]);
	inline Array<float, 3> dopesheet_channel(void);
	inline void dopesheet_channel(float values[3]);
	inline Array<float, 3> dopesheet_subchannel(void);
	inline void dopesheet_subchannel(float values[3]);
	inline Array<float, 3> nla_track(void);
	inline void nla_track(float values[3]);
	inline Array<float, 4> active_action(void);
	inline void active_action(float values[4]);
	inline Array<float, 4> active_action_unset(void);
	inline void active_action_unset(float values[4]);
	inline Array<float, 4> preview_range(void);
	inline void preview_range(float values[4]);
	inline Array<float, 3> strips(void);
	inline void strips(float values[3]);
	inline Array<float, 3> strips_selected(void);
	inline void strips_selected(float values[3]);
	inline Array<float, 3> transition_strips(void);
	inline void transition_strips(float values[3]);
	inline Array<float, 3> transition_strips_selected(void);
	inline void transition_strips_selected(float values[3]);
	inline Array<float, 3> meta_strips(void);
	inline void meta_strips(float values[3]);
	inline Array<float, 3> meta_strips_selected(void);
	inline void meta_strips_selected(float values[3]);
	inline Array<float, 3> sound_strips(void);
	inline void sound_strips(float values[3]);
	inline Array<float, 3> sound_strips_selected(void);
	inline void sound_strips_selected(float values[3]);
	inline Array<float, 3> tweak(void);
	inline void tweak(float values[3]);
	inline Array<float, 3> tweak_duplicate(void);
	inline void tweak_duplicate(float values[3]);
	inline Array<float, 4> keyframe_border(void);
	inline void keyframe_border(float values[4]);
	inline Array<float, 4> keyframe_border_selected(void);
	inline void keyframe_border_selected(float values[4]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 4> time_scrub_background(void);
	inline void time_scrub_background(float values[4]);
	inline Array<float, 4> time_marker_line(void);
	inline void time_marker_line(float values[4]);
	inline Array<float, 4> time_marker_line_selected(void);
	inline void time_marker_line_selected(float values[4]);

};

/**************** Theme Dope Sheet ****************/

class ThemeDopeSheet : public Pointer {
public:
	ThemeDopeSheet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 4> time_scrub_background(void);
	inline void time_scrub_background(float values[4]);
	inline Array<float, 4> time_marker_line(void);
	inline void time_marker_line(float values[4]);
	inline Array<float, 4> time_marker_line_selected(void);
	inline void time_marker_line_selected(float values[4]);
	inline Array<float, 3> value_sliders(void);
	inline void value_sliders(float values[3]);
	inline Array<float, 3> view_sliders(void);
	inline void view_sliders(float values[3]);
	inline Array<float, 4> dopesheet_channel(void);
	inline void dopesheet_channel(float values[4]);
	inline Array<float, 4> dopesheet_subchannel(void);
	inline void dopesheet_subchannel(float values[4]);
	inline Array<float, 4> channels(void);
	inline void channels(float values[4]);
	inline Array<float, 4> channels_selected(void);
	inline void channels_selected(float values[4]);
	inline Array<float, 4> channel_group(void);
	inline void channel_group(float values[4]);
	inline Array<float, 4> active_channels_group(void);
	inline void active_channels_group(float values[4]);
	inline Array<float, 4> long_key(void);
	inline void long_key(float values[4]);
	inline Array<float, 4> long_key_selected(void);
	inline void long_key_selected(float values[4]);
	inline Array<float, 3> keyframe(void);
	inline void keyframe(float values[3]);
	inline Array<float, 3> keyframe_selected(void);
	inline void keyframe_selected(float values[3]);
	inline Array<float, 3> keyframe_extreme(void);
	inline void keyframe_extreme(float values[3]);
	inline Array<float, 3> keyframe_extreme_selected(void);
	inline void keyframe_extreme_selected(float values[3]);
	inline Array<float, 3> keyframe_breakdown(void);
	inline void keyframe_breakdown(float values[3]);
	inline Array<float, 3> keyframe_breakdown_selected(void);
	inline void keyframe_breakdown_selected(float values[3]);
	inline Array<float, 3> keyframe_jitter(void);
	inline void keyframe_jitter(float values[3]);
	inline Array<float, 3> keyframe_jitter_selected(void);
	inline void keyframe_jitter_selected(float values[3]);
	inline Array<float, 3> keyframe_movehold(void);
	inline void keyframe_movehold(float values[3]);
	inline Array<float, 3> keyframe_movehold_selected(void);
	inline void keyframe_movehold_selected(float values[3]);
	inline Array<float, 4> keyframe_border(void);
	inline void keyframe_border(float values[4]);
	inline Array<float, 4> keyframe_border_selected(void);
	inline void keyframe_border_selected(float values[4]);
	inline float keyframe_scale_factor(void);
	inline void keyframe_scale_factor(float value);
	inline Array<float, 4> summary(void);
	inline void summary(float values[4]);
	inline Array<float, 4> preview_range(void);
	inline void preview_range(float values[4]);
	inline Array<float, 4> interpolation_line(void);
	inline void interpolation_line(float values[4]);
	inline Array<float, 4> simulated_frames(void);
	inline void simulated_frames(float values[4]);

};

/**************** Theme Image Editor ****************/

class ThemeImageEditor : public Pointer {
public:
	ThemeImageEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 4> grid(void);
	inline void grid(float values[4]);
	inline Array<float, 3> vertex(void);
	inline void vertex(float values[3]);
	inline Array<float, 3> vertex_select(void);
	inline void vertex_select(float values[3]);
	inline Array<float, 3> vertex_active(void);
	inline void vertex_active(float values[3]);
	inline int vertex_size(void);
	inline void vertex_size(int value);
	inline Array<float, 3> vertex_bevel(void);
	inline void vertex_bevel(float values[3]);
	inline Array<float, 3> vertex_unreferenced(void);
	inline void vertex_unreferenced(float values[3]);
	inline Array<float, 4> face(void);
	inline void face(float values[4]);
	inline Array<float, 4> face_select(void);
	inline void face_select(float values[4]);
	inline Array<float, 4> face_mode_select(void);
	inline void face_mode_select(float values[4]);
	inline Array<float, 3> face_dot(void);
	inline void face_dot(float values[3]);
	inline int facedot_size(void);
	inline void facedot_size(int value);
	inline Array<float, 4> freestyle_face_mark(void);
	inline void freestyle_face_mark(float values[4]);
	inline Array<float, 4> face_retopology(void);
	inline void face_retopology(float values[4]);
	inline Array<float, 4> face_back(void);
	inline void face_back(float values[4]);
	inline Array<float, 4> face_front(void);
	inline void face_front(float values[4]);
	inline Array<float, 4> editmesh_active(void);
	inline void editmesh_active(float values[4]);
	inline Array<float, 3> wire_edit(void);
	inline void wire_edit(float values[3]);
	inline int edge_width(void);
	inline void edge_width(int value);
	inline Array<float, 3> edge_select(void);
	inline void edge_select(float values[3]);
	inline Array<float, 4> scope_back(void);
	inline void scope_back(float values[4]);
	inline Array<float, 4> preview_stitch_face(void);
	inline void preview_stitch_face(float values[4]);
	inline Array<float, 4> preview_stitch_edge(void);
	inline void preview_stitch_edge(float values[4]);
	inline Array<float, 4> preview_stitch_vert(void);
	inline void preview_stitch_vert(float values[4]);
	inline Array<float, 4> preview_stitch_stitchable(void);
	inline void preview_stitch_stitchable(float values[4]);
	inline Array<float, 4> preview_stitch_unstitchable(void);
	inline void preview_stitch_unstitchable(float values[4]);
	inline Array<float, 4> preview_stitch_active(void);
	inline void preview_stitch_active(float values[4]);
	inline Array<float, 4> uv_shadow(void);
	inline void uv_shadow(float values[4]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 3> metadatabg(void);
	inline void metadatabg(float values[3]);
	inline Array<float, 3> metadatatext(void);
	inline void metadatatext(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> handle_auto_clamped(void);
	inline void handle_auto_clamped(float values[3]);
	inline Array<float, 3> handle_sel_auto_clamped(void);
	inline void handle_sel_auto_clamped(float values[3]);
	inline Array<float, 3> handle_vertex(void);
	inline void handle_vertex(float values[3]);
	inline Array<float, 3> handle_vertex_select(void);
	inline void handle_vertex_select(float values[3]);
	inline int handle_vertex_size(void);
	inline void handle_vertex_size(int value);
	inline Array<float, 4> paint_curve_handle(void);
	inline void paint_curve_handle(float values[4]);
	inline Array<float, 4> paint_curve_pivot(void);
	inline void paint_curve_pivot(float values[4]);

};

/**************** Theme Sequence Editor ****************/

class ThemeSequenceEditor : public Pointer {
public:
	ThemeSequenceEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> window_sliders(void);
	inline void window_sliders(float values[3]);
	inline Array<float, 3> movie_strip(void);
	inline void movie_strip(float values[3]);
	inline Array<float, 3> movieclip_strip(void);
	inline void movieclip_strip(float values[3]);
	inline Array<float, 3> image_strip(void);
	inline void image_strip(float values[3]);
	inline Array<float, 3> scene_strip(void);
	inline void scene_strip(float values[3]);
	inline Array<float, 3> audio_strip(void);
	inline void audio_strip(float values[3]);
	inline Array<float, 3> effect_strip(void);
	inline void effect_strip(float values[3]);
	inline Array<float, 3> transition_strip(void);
	inline void transition_strip(float values[3]);
	inline Array<float, 3> color_strip(void);
	inline void color_strip(float values[3]);
	inline Array<float, 3> meta_strip(void);
	inline void meta_strip(float values[3]);
	inline Array<float, 3> mask_strip(void);
	inline void mask_strip(float values[3]);
	inline Array<float, 3> text_strip(void);
	inline void text_strip(float values[3]);
	inline Array<float, 3> active_strip(void);
	inline void active_strip(float values[3]);
	inline Array<float, 3> selected_strip(void);
	inline void selected_strip(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 4> time_scrub_background(void);
	inline void time_scrub_background(float values[4]);
	inline Array<float, 4> time_marker_line(void);
	inline void time_marker_line(float values[4]);
	inline Array<float, 4> time_marker_line_selected(void);
	inline void time_marker_line_selected(float values[4]);
	inline Array<float, 3> keyframe(void);
	inline void keyframe(float values[3]);
	inline Array<float, 3> keyframe_selected(void);
	inline void keyframe_selected(float values[3]);
	inline Array<float, 3> keyframe_breakdown(void);
	inline void keyframe_breakdown(float values[3]);
	inline Array<float, 3> keyframe_breakdown_selected(void);
	inline void keyframe_breakdown_selected(float values[3]);
	inline Array<float, 3> keyframe_movehold(void);
	inline void keyframe_movehold(float values[3]);
	inline Array<float, 3> keyframe_movehold_selected(void);
	inline void keyframe_movehold_selected(float values[3]);
	inline Array<float, 4> keyframe_border(void);
	inline void keyframe_border(float values[4]);
	inline Array<float, 4> keyframe_border_selected(void);
	inline void keyframe_border_selected(float values[4]);
	inline Array<float, 3> draw_action(void);
	inline void draw_action(float values[3]);
	inline Array<float, 3> preview_back(void);
	inline void preview_back(float values[3]);
	inline Array<float, 3> metadatabg(void);
	inline void metadatabg(float values[3]);
	inline Array<float, 3> metadatatext(void);
	inline void metadatatext(float values[3]);
	inline Array<float, 4> preview_range(void);
	inline void preview_range(float values[4]);
	inline Array<float, 4> row_alternate(void);
	inline void row_alternate(float values[4]);

};

/**************** Theme Properties ****************/

class ThemeProperties : public Pointer {
public:
	ThemeProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> match(void);
	inline void match(float values[3]);
	inline Array<float, 4> active_modifier(void);
	inline void active_modifier(float values[4]);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Text Editor ****************/

class ThemeTextEditor : public Pointer {
public:
	ThemeTextEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> line_numbers(void);
	inline void line_numbers(float values[3]);
	inline Array<float, 3> line_numbers_background(void);
	inline void line_numbers_background(float values[3]);
	inline Array<float, 3> selected_text(void);
	inline void selected_text(float values[3]);
	inline Array<float, 3> cursor(void);
	inline void cursor(float values[3]);
	inline Array<float, 3> syntax_builtin(void);
	inline void syntax_builtin(float values[3]);
	inline Array<float, 3> syntax_symbols(void);
	inline void syntax_symbols(float values[3]);
	inline Array<float, 3> syntax_special(void);
	inline void syntax_special(float values[3]);
	inline Array<float, 3> syntax_preprocessor(void);
	inline void syntax_preprocessor(float values[3]);
	inline Array<float, 3> syntax_reserved(void);
	inline void syntax_reserved(float values[3]);
	inline Array<float, 3> syntax_comment(void);
	inline void syntax_comment(float values[3]);
	inline Array<float, 3> syntax_string(void);
	inline void syntax_string(float values[3]);
	inline Array<float, 3> syntax_numbers(void);
	inline void syntax_numbers(float values[3]);

};

/**************** Theme Node Editor ****************/

class ThemeNodeEditor : public Pointer {
public:
	ThemeNodeEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 3> grid(void);
	inline void grid(float values[3]);
	inline Array<float, 3> node_selected(void);
	inline void node_selected(float values[3]);
	inline Array<float, 3> node_active(void);
	inline void node_active(float values[3]);
	inline Array<float, 4> wire(void);
	inline void wire(float values[4]);
	inline Array<float, 3> wire_inner(void);
	inline void wire_inner(float values[3]);
	inline Array<float, 4> wire_select(void);
	inline void wire_select(float values[4]);
	inline Array<float, 3> selected_text(void);
	inline void selected_text(float values[3]);
	inline Array<float, 4> node_backdrop(void);
	inline void node_backdrop(float values[4]);
	inline Array<float, 3> converter_node(void);
	inline void converter_node(float values[3]);
	inline Array<float, 3> color_node(void);
	inline void color_node(float values[3]);
	inline Array<float, 3> group_node(void);
	inline void group_node(float values[3]);
	inline Array<float, 3> group_socket_node(void);
	inline void group_socket_node(float values[3]);
	inline Array<float, 4> frame_node(void);
	inline void frame_node(float values[4]);
	inline Array<float, 3> matte_node(void);
	inline void matte_node(float values[3]);
	inline Array<float, 3> distor_node(void);
	inline void distor_node(float values[3]);
	inline int noodle_curving(void);
	inline void noodle_curving(int value);
	inline int grid_levels(void);
	inline void grid_levels(int value);
	inline float dash_alpha(void);
	inline void dash_alpha(float value);
	inline Array<float, 3> input_node(void);
	inline void input_node(float values[3]);
	inline Array<float, 3> output_node(void);
	inline void output_node(float values[3]);
	inline Array<float, 3> filter_node(void);
	inline void filter_node(float values[3]);
	inline Array<float, 3> vector_node(void);
	inline void vector_node(float values[3]);
	inline Array<float, 3> texture_node(void);
	inline void texture_node(float values[3]);
	inline Array<float, 3> shader_node(void);
	inline void shader_node(float values[3]);
	inline Array<float, 3> script_node(void);
	inline void script_node(float values[3]);
	inline Array<float, 3> pattern_node(void);
	inline void pattern_node(float values[3]);
	inline Array<float, 3> layout_node(void);
	inline void layout_node(float values[3]);
	inline Array<float, 3> geometry_node(void);
	inline void geometry_node(float values[3]);
	inline Array<float, 3> attribute_node(void);
	inline void attribute_node(float values[3]);
	inline Array<float, 4> simulation_zone(void);
	inline void simulation_zone(float values[4]);
	inline Array<float, 4> repeat_zone(void);
	inline void repeat_zone(float values[4]);

};

/**************** Theme Outliner ****************/

class ThemeOutliner : public Pointer {
public:
	ThemeOutliner(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> match(void);
	inline void match(float values[3]);
	inline Array<float, 3> selected_highlight(void);
	inline void selected_highlight(float values[3]);
	inline Array<float, 3> active(void);
	inline void active(float values[3]);
	inline Array<float, 3> selected_object(void);
	inline void selected_object(float values[3]);
	inline Array<float, 3> active_object(void);
	inline void active_object(float values[3]);
	inline Array<float, 4> edited_object(void);
	inline void edited_object(float values[4]);
	inline Array<float, 4> row_alternate(void);
	inline void row_alternate(float values[4]);

};

/**************** Theme Info ****************/

class ThemeInfo : public Pointer {
public:
	ThemeInfo(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> info_selected(void);
	inline void info_selected(float values[3]);
	inline Array<float, 3> info_selected_text(void);
	inline void info_selected_text(float values[3]);
	inline Array<float, 4> info_error(void);
	inline void info_error(float values[4]);
	inline Array<float, 3> info_error_text(void);
	inline void info_error_text(float values[3]);
	inline Array<float, 4> info_warning(void);
	inline void info_warning(float values[4]);
	inline Array<float, 3> info_warning_text(void);
	inline void info_warning_text(float values[3]);
	inline Array<float, 4> info_info(void);
	inline void info_info(float values[4]);
	inline Array<float, 3> info_info_text(void);
	inline void info_info_text(float values[3]);
	inline Array<float, 4> info_debug(void);
	inline void info_debug(float values[4]);
	inline Array<float, 3> info_debug_text(void);
	inline void info_debug_text(float values[3]);
	inline Array<float, 4> info_property(void);
	inline void info_property(float values[4]);
	inline Array<float, 3> info_property_text(void);
	inline void info_property_text(float values[3]);
	inline Array<float, 4> info_operator(void);
	inline void info_operator(float values[4]);
	inline Array<float, 3> info_operator_text(void);
	inline void info_operator_text(float values[3]);

};

/**************** Theme Preferences ****************/

class ThemePreferences : public Pointer {
public:
	ThemePreferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Console ****************/

class ThemeConsole : public Pointer {
public:
	ThemeConsole(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline Array<float, 3> line_output(void);
	inline void line_output(float values[3]);
	inline Array<float, 3> line_input(void);
	inline void line_input(float values[3]);
	inline Array<float, 3> line_info(void);
	inline void line_info(float values[3]);
	inline Array<float, 3> line_error(void);
	inline void line_error(float values[3]);
	inline Array<float, 3> cursor(void);
	inline void cursor(float values[3]);
	inline Array<float, 4> select(void);
	inline void select(float values[4]);

};

/**************** Theme Clip Editor ****************/

class ThemeClipEditor : public Pointer {
public:
	ThemeClipEditor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);
	inline Array<float, 4> grid(void);
	inline void grid(float values[4]);
	inline Array<float, 3> marker_outline(void);
	inline void marker_outline(float values[3]);
	inline Array<float, 3> marker(void);
	inline void marker(float values[3]);
	inline Array<float, 3> active_marker(void);
	inline void active_marker(float values[3]);
	inline Array<float, 3> selected_marker(void);
	inline void selected_marker(float values[3]);
	inline Array<float, 3> disabled_marker(void);
	inline void disabled_marker(float values[3]);
	inline Array<float, 3> locked_marker(void);
	inline void locked_marker(float values[3]);
	inline Array<float, 3> path_before(void);
	inline void path_before(float values[3]);
	inline Array<float, 3> path_after(void);
	inline void path_after(float values[3]);
	inline Array<float, 3> path_keyframe_before(void);
	inline void path_keyframe_before(float values[3]);
	inline Array<float, 3> path_keyframe_after(void);
	inline void path_keyframe_after(float values[3]);
	inline Array<float, 3> frame_current(void);
	inline void frame_current(float values[3]);
	inline Array<float, 4> time_scrub_background(void);
	inline void time_scrub_background(float values[4]);
	inline Array<float, 4> time_marker_line(void);
	inline void time_marker_line(float values[4]);
	inline Array<float, 4> time_marker_line_selected(void);
	inline void time_marker_line_selected(float values[4]);
	inline Array<float, 3> strips(void);
	inline void strips(float values[3]);
	inline Array<float, 3> strips_selected(void);
	inline void strips_selected(float values[3]);
	inline Array<float, 3> metadatabg(void);
	inline void metadatabg(float values[3]);
	inline Array<float, 3> metadatatext(void);
	inline void metadatatext(float values[3]);
	inline Array<float, 3> handle_free(void);
	inline void handle_free(float values[3]);
	inline Array<float, 3> handle_auto(void);
	inline void handle_auto(float values[3]);
	inline Array<float, 3> handle_align(void);
	inline void handle_align(float values[3]);
	inline Array<float, 3> handle_sel_free(void);
	inline void handle_sel_free(float values[3]);
	inline Array<float, 3> handle_sel_auto(void);
	inline void handle_sel_auto(float values[3]);
	inline Array<float, 3> handle_sel_align(void);
	inline void handle_sel_align(float values[3]);
	inline Array<float, 3> handle_auto_clamped(void);
	inline void handle_auto_clamped(float values[3]);
	inline Array<float, 3> handle_sel_auto_clamped(void);
	inline void handle_sel_auto_clamped(float values[3]);
	inline Array<float, 3> handle_vertex(void);
	inline void handle_vertex(float values[3]);
	inline Array<float, 3> handle_vertex_select(void);
	inline void handle_vertex_select(float values[3]);
	inline int handle_vertex_size(void);
	inline void handle_vertex_size(int value);

};

/**************** Theme Top Bar ****************/

class ThemeTopBar : public Pointer {
public:
	ThemeTopBar(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Status Bar ****************/

class ThemeStatusBar : public Pointer {
public:
	ThemeStatusBar(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ThemeSpaceGeneric space(void);

};

/**************** Theme Spreadsheet ****************/

class ThemeSpreadsheet : public Pointer {
public:
	ThemeSpreadsheet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 4> row_alternate(void);
	inline void row_alternate(float values[4]);
	inline ThemeSpaceGeneric space(void);
	inline ThemeSpaceListGeneric space_list(void);

};

/**************** Theme Bone Color Set ****************/

class ThemeBoneColorSet : public Pointer {
public:
	ThemeBoneColorSet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> normal(void);
	inline void normal(float values[3]);
	inline Array<float, 3> select(void);
	inline void select(float values[3]);
	inline Array<float, 3> active(void);
	inline void active(float values[3]);
	inline bool show_colored_constraints(void);
	inline void show_colored_constraints(bool value);

};

/**************** Theme Collection Color ****************/

class ThemeCollectionColor : public Pointer {
public:
	ThemeCollectionColor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);

};

/**************** Theme Strip Color ****************/

class ThemeStripColor : public Pointer {
public:
	ThemeStripColor(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);

};

/**************** Theme ****************/

class Theme : public Pointer {
public:
	Theme(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		bone_color_sets(ptr_arg),
		collection_color(ptr_arg),
		strip_color(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum theme_area_enum {
		theme_area_USER_INTERFACE = 0,
		theme_area_STYLE = 19,
		theme_area_VIEW_3D = 1,
		theme_area_DOPESHEET_EDITOR = 4,
		theme_area_FILE_BROWSER = 16,
		theme_area_GRAPH_EDITOR = 3,
		theme_area_IMAGE_EDITOR = 6,
		theme_area_INFO = 15,
		theme_area_CLIP_EDITOR = 20,
		theme_area_NODE_EDITOR = 9,
		theme_area_NLA_EDITOR = 5,
		theme_area_OUTLINER = 12,
		theme_area_PREFERENCES = 14,
		theme_area_PROPERTIES = 11,
		theme_area_CONSOLE = 17,
		theme_area_SPREADSHEET = 23,
		theme_area_STATUSBAR = 22,
		theme_area_TEXT_EDITOR = 8,
		theme_area_TOPBAR = 21,
		theme_area_SEQUENCE_EDITOR = 7,
		theme_area_BONE_COLOR_SETS = 18,
	};
	inline theme_area_enum theme_area(void);
	inline void theme_area(theme_area_enum value);
	inline ThemeUserInterface user_interface(void);
	inline ThemeView3D view_3d(void);
	inline ThemeGraphEditor graph_editor(void);
	inline ThemeFileBrowser file_browser(void);
	inline ThemeNLAEditor nla_editor(void);
	inline ThemeDopeSheet dopesheet_editor(void);
	inline ThemeImageEditor image_editor(void);
	inline ThemeSequenceEditor sequence_editor(void);
	inline ThemeProperties properties(void);
	inline ThemeTextEditor text_editor(void);
	inline ThemeNodeEditor node_editor(void);
	inline ThemeOutliner outliner(void);
	inline ThemeInfo info(void);
	inline ThemePreferences preferences(void);
	inline ThemeConsole console(void);
	inline ThemeClipEditor clip_editor(void);
	inline ThemeTopBar topbar(void);
	inline ThemeStatusBar statusbar(void);
	inline ThemeSpreadsheet spreadsheet(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ThemeBoneColorSet, Theme, bone_color_sets, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ThemeCollectionColor, Theme, collection_color, true, true, false)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ThemeStripColor, Theme, strip_color, true, true, false)

};

/**************** Solid Light ****************/

class UserSolidLight : public Pointer {
public:
	UserSolidLight(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use(void);
	inline void use(bool value);
	inline float smooth(void);
	inline void smooth(float value);
	inline Array<float, 3> direction(void);
	inline void direction(float values[3]);
	inline Array<float, 3> specular_color(void);
	inline void specular_color(float values[3]);
	inline Array<float, 3> diffuse_color(void);
	inline void diffuse_color(float values[3]);

};

/**************** Walk Navigation ****************/

class WalkNavigation : public Pointer {
public:
	WalkNavigation(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float mouse_speed(void);
	inline void mouse_speed(float value);
	inline float walk_speed(void);
	inline void walk_speed(float value);
	inline float walk_speed_factor(void);
	inline void walk_speed_factor(float value);
	inline float view_height(void);
	inline void view_height(float value);
	inline float jump_height(void);
	inline void jump_height(float value);
	inline float teleport_time(void);
	inline void teleport_time(float value);
	inline bool use_gravity(void);
	inline void use_gravity(bool value);
	inline bool use_mouse_reverse(void);
	inline void use_mouse_reverse(bool value);

};

/**************** Preferences ****************/

class Preferences : public Pointer {
public:
	Preferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		themes(ptr_arg),
		ui_styles(ptr_arg),
		addons(ptr_arg),
		autoexec_paths(ptr_arg),
		studio_lights(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum active_section_enum {
		active_section_INTERFACE = 0,
		active_section_THEMES = 4,
		active_section_VIEWPORT = 12,
		active_section_LIGHTS = 7,
		active_section_EDITING = 1,
		active_section_ANIMATION = 13,
		active_section_ADDONS = 6,
		active_section_INPUT = 5,
		active_section_NAVIGATION = 14,
		active_section_KEYMAP = 8,
		active_section_SYSTEM = 3,
		active_section_SAVE_LOAD = 2,
		active_section_FILE_PATHS = 15,
		active_section_EXTENSIONS = 17,
		active_section_EXPERIMENTAL = 16,
	};
	inline active_section_enum active_section(void);
	inline void active_section(active_section_enum value);
	inline std::string app_template(void);
	inline void app_template(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Theme, Preferences, themes, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, ThemeStyle, Preferences, ui_styles, false, true, false)
	COLLECTION_PROPERTY(Addons, Addon, Preferences, addons, false, true, true)
	COLLECTION_PROPERTY(PathCompareCollection, PathCompare, Preferences, autoexec_paths, false, true, true)
	inline bool use_recent_searches(void);
	inline void use_recent_searches(bool value);
	inline PreferencesView view(void);
	inline PreferencesEdit edit(void);
	inline PreferencesInput inputs(void);
	inline PreferencesKeymap keymap(void);
	inline PreferencesFilePaths filepaths(void);
	inline PreferencesSystem system(void);
	inline PreferencesApps apps(void);
	inline PreferencesExperimental experimental(void);
	inline Array<int, 3> version(void);
	inline void version(int values[3]);
	COLLECTION_PROPERTY(StudioLights, StudioLight, Preferences, studio_lights, false, false, false)
	inline bool use_preferences_save(void);
	inline void use_preferences_save(bool value);
	inline bool is_dirty(void);
	inline void is_dirty(bool value);

};

/**************** View & Controls ****************/

class PreferencesView : public Pointer {
public:
	PreferencesView(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float ui_scale(void);
	inline void ui_scale(float value);
	enum ui_line_width_enum {
		ui_line_width_THIN = -1,
		ui_line_width_AUTO = 0,
		ui_line_width_THICK = 1,
	};
	inline ui_line_width_enum ui_line_width(void);
	inline void ui_line_width(ui_line_width_enum value);
	inline bool show_tooltips(void);
	inline void show_tooltips(bool value);
	inline bool show_tooltips_python(void);
	inline void show_tooltips_python(bool value);
	inline bool show_developer_ui(void);
	inline void show_developer_ui(bool value);
	inline bool show_object_info(void);
	inline void show_object_info(bool value);
	inline bool show_view_name(void);
	inline void show_view_name(bool value);
	inline bool show_splash(void);
	inline void show_splash(bool value);
	inline bool show_playback_fps(void);
	inline void show_playback_fps(bool value);
	inline int playback_fps_samples(void);
	inline void playback_fps_samples(int value);
	inline bool use_fresnel_edit(void);
	inline void use_fresnel_edit(bool value);
	inline bool show_addons_enabled_only(void);
	inline void show_addons_enabled_only(bool value);
	enum factor_display_type_enum {
		factor_display_type_FACTOR = 0,
		factor_display_type_PERCENTAGE = 1,
	};
	inline factor_display_type_enum factor_display_type(void);
	inline void factor_display_type(factor_display_type_enum value);
	inline bool use_weight_color_range(void);
	inline void use_weight_color_range(bool value);
	inline ColorRamp weight_color_range(void);
	inline bool show_navigate_ui(void);
	inline void show_navigate_ui(bool value);
	inline bool use_mouse_over_open(void);
	inline void use_mouse_over_open(bool value);
	inline int open_toplevel_delay(void);
	inline void open_toplevel_delay(int value);
	inline int open_sublevel_delay(void);
	inline void open_sublevel_delay(int value);
	enum color_picker_type_enum {
		color_picker_type_CIRCLE_HSV = 0,
		color_picker_type_CIRCLE_HSL = 4,
		color_picker_type_SQUARE_SV = 1,
		color_picker_type_SQUARE_HS = 2,
		color_picker_type_SQUARE_HV = 3,
	};
	inline color_picker_type_enum color_picker_type(void);
	inline void color_picker_type(color_picker_type_enum value);
	inline int pie_initial_timeout(void);
	inline void pie_initial_timeout(int value);
	inline int pie_tap_timeout(void);
	inline void pie_tap_timeout(int value);
	inline int pie_animation_timeout(void);
	inline void pie_animation_timeout(int value);
	inline int pie_menu_radius(void);
	inline void pie_menu_radius(int value);
	inline int pie_menu_threshold(void);
	inline void pie_menu_threshold(int value);
	inline int pie_menu_confirm(void);
	inline void pie_menu_confirm(int value);
	inline bool use_save_prompt(void);
	inline void use_save_prompt(bool value);
	inline bool show_column_layout(void);
	inline void show_column_layout(bool value);
	enum header_align_enum {
		header_align_NONE = 0,
		header_align_TOP = 256,
		header_align_BOTTOM = 384,
	};
	inline header_align_enum header_align(void);
	inline void header_align(header_align_enum value);
	enum render_display_type_enum {
		render_display_type_NONE = 0,
		render_display_type_SCREEN = 1,
		render_display_type_AREA = 2,
		render_display_type_WINDOW = 3,
	};
	inline render_display_type_enum render_display_type(void);
	inline void render_display_type(render_display_type_enum value);
	enum filebrowser_display_type_enum {
		filebrowser_display_type_SCREEN = 0,
		filebrowser_display_type_WINDOW = 1,
	};
	inline filebrowser_display_type_enum filebrowser_display_type(void);
	inline void filebrowser_display_type(filebrowser_display_type_enum value);
	enum mini_axis_type_enum {
		mini_axis_type_NONE = 2,
		mini_axis_type_MINIMAL = 1,
		mini_axis_type_GIZMO = 0,
	};
	inline mini_axis_type_enum mini_axis_type(void);
	inline void mini_axis_type(mini_axis_type_enum value);
	inline int mini_axis_size(void);
	inline void mini_axis_size(int value);
	inline int mini_axis_brightness(void);
	inline void mini_axis_brightness(int value);
	inline int smooth_view(void);
	inline void smooth_view(int value);
	inline float rotation_angle(void);
	inline void rotation_angle(float value);
	inline bool show_gizmo(void);
	inline void show_gizmo(bool value);
	inline int gizmo_size(void);
	inline void gizmo_size(int value);
	inline int gizmo_size_navigate_v3d(void);
	inline void gizmo_size_navigate_v3d(int value);
	inline int lookdev_sphere_size(void);
	inline void lookdev_sphere_size(int value);
	inline int view2d_grid_spacing_min(void);
	inline void view2d_grid_spacing_min(int value);
	enum timecode_style_enum {
		timecode_style_MINIMAL = 0,
		timecode_style_SMPTE = 2,
		timecode_style_SMPTE_COMPACT = 1,
		timecode_style_MILLISECONDS = 3,
		timecode_style_SECONDS_ONLY = 4,
	};
	inline timecode_style_enum timecode_style(void);
	inline void timecode_style(timecode_style_enum value);
	enum view_frame_type_enum {
		view_frame_type_KEEP_RANGE = 0,
		view_frame_type_SECONDS = 1,
		view_frame_type_KEYFRAMES = 2,
	};
	inline view_frame_type_enum view_frame_type(void);
	inline void view_frame_type(view_frame_type_enum value);
	inline int view_frame_keyframes(void);
	inline void view_frame_keyframes(int value);
	inline float view_frame_seconds(void);
	inline void view_frame_seconds(float value);
	inline bool use_text_antialiasing(void);
	inline void use_text_antialiasing(bool value);
	inline bool use_text_render_subpixelaa(void);
	inline void use_text_render_subpixelaa(bool value);
	enum text_hinting_enum {
		text_hinting_AUTO = 0,
		text_hinting_NONE = 2,
		text_hinting_SLIGHT = 4,
		text_hinting_FULL = 8,
	};
	inline text_hinting_enum text_hinting(void);
	inline void text_hinting(text_hinting_enum value);
	inline std::string font_path_ui(void);
	inline void font_path_ui(const std::string& value);
	inline std::string font_path_ui_mono(void);
	inline void font_path_ui_mono(const std::string& value);
	enum language_enum {
		language_DEFAULT = 0,
	};
	inline language_enum language(void);
	inline void language(language_enum value);
	inline bool use_translate_tooltips(void);
	inline void use_translate_tooltips(bool value);
	inline bool use_translate_interface(void);
	inline void use_translate_interface(bool value);
	inline bool use_translate_new_dataname(void);
	inline void use_translate_new_dataname(bool value);
	inline bool show_statusbar_memory(void);
	inline void show_statusbar_memory(bool value);
	inline bool show_statusbar_vram(void);
	inline void show_statusbar_vram(bool value);
	inline bool show_statusbar_version(void);
	inline void show_statusbar_version(bool value);
	inline bool show_statusbar_stats(void);
	inline void show_statusbar_stats(bool value);
	inline bool show_statusbar_scene_duration(void);
	inline void show_statusbar_scene_duration(bool value);

};

/**************** Edit Methods ****************/

class PreferencesEdit : public Pointer {
public:
	PreferencesEdit(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum material_link_enum {
		material_link_OBDATA = 0,
		material_link_OBJECT = 256,
	};
	inline material_link_enum material_link(void);
	inline void material_link(material_link_enum value);
	enum object_align_enum {
		object_align_WORLD = 0,
		object_align_VIEW = 524288,
		object_align_CURSOR = 16384,
	};
	inline object_align_enum object_align(void);
	inline void object_align(object_align_enum value);
	inline bool use_enter_edit_mode(void);
	inline void use_enter_edit_mode(bool value);
	inline float collection_instance_empty_size(void);
	inline void collection_instance_empty_size(float value);
	inline bool use_text_edit_auto_close(void);
	inline void use_text_edit_auto_close(bool value);
	inline int undo_steps(void);
	inline void undo_steps(int value);
	inline int undo_memory_limit(void);
	inline void undo_memory_limit(int value);
	inline bool use_global_undo(void);
	inline void use_global_undo(bool value);
	inline bool use_auto_keying(void);
	inline void use_auto_keying(bool value);
	enum auto_keying_mode_enum {
		auto_keying_mode_ADD_REPLACE_KEYS = 3,
		auto_keying_mode_REPLACE_KEYS = 5,
	};
	inline auto_keying_mode_enum auto_keying_mode(void);
	inline void auto_keying_mode(auto_keying_mode_enum value);
	inline bool use_keyframe_insert_available(void);
	inline void use_keyframe_insert_available(bool value);
	inline bool use_auto_keying_warning(void);
	inline void use_auto_keying_warning(bool value);
	inline bool use_keyframe_insert_needed(void);
	inline void use_keyframe_insert_needed(bool value);
	inline bool use_visual_keying(void);
	inline void use_visual_keying(bool value);
	inline bool use_insertkey_xyz_to_rgb(void);
	inline void use_insertkey_xyz_to_rgb(bool value);
	inline bool use_anim_channel_group_colors(void);
	inline void use_anim_channel_group_colors(bool value);
	enum fcurve_new_auto_smoothing_enum {
		fcurve_new_auto_smoothing_NONE = 0,
		fcurve_new_auto_smoothing_CONT_ACCEL = 1,
	};
	inline fcurve_new_auto_smoothing_enum fcurve_new_auto_smoothing(void);
	inline void fcurve_new_auto_smoothing(fcurve_new_auto_smoothing_enum value);
	enum keyframe_new_interpolation_type_enum {
		keyframe_new_interpolation_type_CONSTANT = 0,
		keyframe_new_interpolation_type_LINEAR = 1,
		keyframe_new_interpolation_type_BEZIER = 2,
		keyframe_new_interpolation_type_SINE = 12,
		keyframe_new_interpolation_type_QUAD = 9,
		keyframe_new_interpolation_type_CUBIC = 6,
		keyframe_new_interpolation_type_QUART = 10,
		keyframe_new_interpolation_type_QUINT = 11,
		keyframe_new_interpolation_type_EXPO = 8,
		keyframe_new_interpolation_type_CIRC = 5,
		keyframe_new_interpolation_type_BACK = 3,
		keyframe_new_interpolation_type_BOUNCE = 4,
		keyframe_new_interpolation_type_ELASTIC = 7,
	};
	inline keyframe_new_interpolation_type_enum keyframe_new_interpolation_type(void);
	inline void keyframe_new_interpolation_type(keyframe_new_interpolation_type_enum value);
	enum keyframe_new_handle_type_enum {
		keyframe_new_handle_type_FREE = 0,
		keyframe_new_handle_type_ALIGNED = 3,
		keyframe_new_handle_type_VECTOR = 2,
		keyframe_new_handle_type_AUTO = 1,
		keyframe_new_handle_type_AUTO_CLAMPED = 4,
	};
	inline keyframe_new_handle_type_enum keyframe_new_handle_type(void);
	inline void keyframe_new_handle_type(keyframe_new_handle_type_enum value);
	inline bool use_negative_frames(void);
	inline void use_negative_frames(bool value);
	inline float fcurve_unselected_alpha(void);
	inline void fcurve_unselected_alpha(float value);
	inline bool show_only_selected_curve_keyframes(void);
	inline void show_only_selected_curve_keyframes(bool value);
	inline bool use_fcurve_high_quality_drawing(void);
	inline void use_fcurve_high_quality_drawing(bool value);
	inline int grease_pencil_manhattan_distance(void);
	inline void grease_pencil_manhattan_distance(int value);
	inline int grease_pencil_euclidean_distance(void);
	inline void grease_pencil_euclidean_distance(int value);
	inline int grease_pencil_eraser_radius(void);
	inline void grease_pencil_eraser_radius(int value);
	inline Array<float, 4> grease_pencil_default_color(void);
	inline void grease_pencil_default_color(float values[4]);
	inline Array<float, 3> sculpt_paint_overlay_color(void);
	inline void sculpt_paint_overlay_color(float values[3]);
	inline bool use_duplicate_mesh(void);
	inline void use_duplicate_mesh(bool value);
	inline bool use_duplicate_surface(void);
	inline void use_duplicate_surface(bool value);
	inline bool use_duplicate_curve(void);
	inline void use_duplicate_curve(bool value);
	inline bool use_duplicate_lattice(void);
	inline void use_duplicate_lattice(bool value);
	inline bool use_duplicate_text(void);
	inline void use_duplicate_text(bool value);
	inline bool use_duplicate_metaball(void);
	inline void use_duplicate_metaball(bool value);
	inline bool use_duplicate_armature(void);
	inline void use_duplicate_armature(bool value);
	inline bool use_duplicate_camera(void);
	inline void use_duplicate_camera(bool value);
	inline bool use_duplicate_speaker(void);
	inline void use_duplicate_speaker(bool value);
	inline bool use_duplicate_light(void);
	inline void use_duplicate_light(bool value);
	inline bool use_duplicate_material(void);
	inline void use_duplicate_material(bool value);
	inline bool use_duplicate_action(void);
	inline void use_duplicate_action(bool value);
	inline bool use_duplicate_particle(void);
	inline void use_duplicate_particle(bool value);
	inline bool use_duplicate_lightprobe(void);
	inline void use_duplicate_lightprobe(bool value);
	inline bool use_duplicate_grease_pencil(void);
	inline void use_duplicate_grease_pencil(bool value);
	inline bool use_duplicate_curves(void);
	inline void use_duplicate_curves(bool value);
	inline bool use_duplicate_pointcloud(void);
	inline void use_duplicate_pointcloud(bool value);
	inline bool use_duplicate_volume(void);
	inline void use_duplicate_volume(bool value);
	inline bool use_duplicate_node_tree(void);
	inline void use_duplicate_node_tree(bool value);
	inline bool node_use_insert_offset(void);
	inline void node_use_insert_offset(bool value);
	inline int node_margin(void);
	inline void node_margin(int value);
	inline int node_preview_resolution(void);
	inline void node_preview_resolution(int value);
	inline bool use_cursor_lock_adjust(void);
	inline void use_cursor_lock_adjust(bool value);
	inline bool use_mouse_depth_cursor(void);
	inline void use_mouse_depth_cursor(bool value);

};

/**************** Input ****************/

class PreferencesInput : public Pointer {
public:
	PreferencesInput(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum view_zoom_method_enum {
		view_zoom_method_CONTINUE = 0,
		view_zoom_method_DOLLY = 2,
		view_zoom_method_SCALE = 1,
	};
	inline view_zoom_method_enum view_zoom_method(void);
	inline void view_zoom_method(view_zoom_method_enum value);
	enum view_zoom_axis_enum {
		view_zoom_axis_VERTICAL = 0,
		view_zoom_axis_HORIZONTAL = 67108864,
	};
	inline view_zoom_axis_enum view_zoom_axis(void);
	inline void view_zoom_axis(view_zoom_axis_enum value);
	inline bool use_multitouch_gestures(void);
	inline void use_multitouch_gestures(bool value);
	inline bool invert_mouse_zoom(void);
	inline void invert_mouse_zoom(bool value);
	inline bool use_mouse_depth_navigate(void);
	inline void use_mouse_depth_navigate(bool value);
	inline bool use_zoom_to_mouse(void);
	inline void use_zoom_to_mouse(bool value);
	inline bool use_auto_perspective(void);
	inline void use_auto_perspective(bool value);
	inline bool use_rotate_around_active(void);
	inline void use_rotate_around_active(bool value);
	enum view_rotate_method_enum {
		view_rotate_method_TURNTABLE = 0,
		view_rotate_method_TRACKBALL = 32,
	};
	inline view_rotate_method_enum view_rotate_method(void);
	inline void view_rotate_method(view_rotate_method_enum value);
	inline bool use_mouse_continuous(void);
	inline void use_mouse_continuous(bool value);
	inline bool use_drag_immediately(void);
	inline void use_drag_immediately(bool value);
	inline bool use_numeric_input_advanced(void);
	inline void use_numeric_input_advanced(bool value);
	enum navigation_mode_enum {
		navigation_mode_WALK = 0,
		navigation_mode_FLY = 1,
	};
	inline navigation_mode_enum navigation_mode(void);
	inline void navigation_mode(navigation_mode_enum value);
	inline WalkNavigation walk_navigation(void);
	inline float view_rotate_sensitivity_turntable(void);
	inline void view_rotate_sensitivity_turntable(float value);
	inline float view_rotate_sensitivity_trackball(void);
	inline void view_rotate_sensitivity_trackball(float value);
	inline int drag_threshold_mouse(void);
	inline void drag_threshold_mouse(int value);
	inline int drag_threshold_tablet(void);
	inline void drag_threshold_tablet(int value);
	inline int drag_threshold(void);
	inline void drag_threshold(int value);
	inline int move_threshold(void);
	inline void move_threshold(int value);
	inline float pressure_threshold_max(void);
	inline void pressure_threshold_max(float value);
	inline float pressure_softness(void);
	inline void pressure_softness(float value);
	enum tablet_api_enum {
		tablet_api_AUTOMATIC = 0,
		tablet_api_WINDOWS_INK = 1,
		tablet_api_WINTAB = 2,
	};
	inline tablet_api_enum tablet_api(void);
	inline void tablet_api(tablet_api_enum value);
	inline float ndof_sensitivity(void);
	inline void ndof_sensitivity(float value);
	inline float ndof_orbit_sensitivity(void);
	inline void ndof_orbit_sensitivity(float value);
	inline float ndof_deadzone(void);
	inline void ndof_deadzone(float value);
	inline bool ndof_pan_yz_swap_axis(void);
	inline void ndof_pan_yz_swap_axis(bool value);
	inline bool ndof_zoom_invert(void);
	inline void ndof_zoom_invert(bool value);
	inline bool ndof_show_guide(void);
	inline void ndof_show_guide(bool value);
	enum ndof_view_navigate_method_enum {
		ndof_view_navigate_method_FREE = 0,
		ndof_view_navigate_method_ORBIT = 64,
	};
	inline ndof_view_navigate_method_enum ndof_view_navigate_method(void);
	inline void ndof_view_navigate_method(ndof_view_navigate_method_enum value);
	enum ndof_view_rotate_method_enum {
		ndof_view_rotate_method_TURNTABLE = 32768,
		ndof_view_rotate_method_TRACKBALL = 0,
	};
	inline ndof_view_rotate_method_enum ndof_view_rotate_method(void);
	inline void ndof_view_rotate_method(ndof_view_rotate_method_enum value);
	inline bool ndof_rotx_invert_axis(void);
	inline void ndof_rotx_invert_axis(bool value);
	inline bool ndof_roty_invert_axis(void);
	inline void ndof_roty_invert_axis(bool value);
	inline bool ndof_rotz_invert_axis(void);
	inline void ndof_rotz_invert_axis(bool value);
	inline bool ndof_panx_invert_axis(void);
	inline void ndof_panx_invert_axis(bool value);
	inline bool ndof_pany_invert_axis(void);
	inline void ndof_pany_invert_axis(bool value);
	inline bool ndof_panz_invert_axis(void);
	inline void ndof_panz_invert_axis(bool value);
	inline bool ndof_lock_horizon(void);
	inline void ndof_lock_horizon(bool value);
	inline bool ndof_fly_helicopter(void);
	inline void ndof_fly_helicopter(bool value);
	inline bool ndof_lock_camera_pan_zoom(void);
	inline void ndof_lock_camera_pan_zoom(bool value);
	inline int mouse_double_click_time(void);
	inline void mouse_double_click_time(int value);
	inline bool use_mouse_emulate_3_button(void);
	inline void use_mouse_emulate_3_button(bool value);
	enum mouse_emulate_3_button_modifier_enum {
		mouse_emulate_3_button_modifier_ALT = 0,
		mouse_emulate_3_button_modifier_OSKEY = 1,
	};
	inline mouse_emulate_3_button_modifier_enum mouse_emulate_3_button_modifier(void);
	inline void mouse_emulate_3_button_modifier(mouse_emulate_3_button_modifier_enum value);
	inline bool use_emulate_numpad(void);
	inline void use_emulate_numpad(bool value);
	inline bool invert_zoom_wheel(void);
	inline void invert_zoom_wheel(bool value);

};

/**************** Keymap ****************/

class PreferencesKeymap : public Pointer {
public:
	PreferencesKeymap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_ui_keyconfig(void);
	inline void show_ui_keyconfig(bool value);
	inline std::string active_keyconfig(void);
	inline void active_keyconfig(const std::string& value);

};

/**************** File Paths ****************/

class PreferencesFilePaths : public Pointer {
public:
	PreferencesFilePaths(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		script_directories(ptr_arg),
		asset_libraries(ptr_arg),
		extension_repos(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_hidden_files_datablocks(void);
	inline void show_hidden_files_datablocks(bool value);
	inline bool use_filter_files(void);
	inline void use_filter_files(bool value);
	inline bool show_recent_locations(void);
	inline void show_recent_locations(bool value);
	inline bool show_system_bookmarks(void);
	inline void show_system_bookmarks(bool value);
	inline bool use_relative_paths(void);
	inline void use_relative_paths(bool value);
	inline bool use_file_compression(void);
	inline void use_file_compression(bool value);
	inline bool use_load_ui(void);
	inline void use_load_ui(bool value);
	inline bool use_scripts_auto_execute(void);
	inline void use_scripts_auto_execute(bool value);
	inline bool use_tabs_as_spaces(void);
	inline void use_tabs_as_spaces(bool value);
	inline std::string font_directory(void);
	inline void font_directory(const std::string& value);
	inline std::string texture_directory(void);
	inline void texture_directory(const std::string& value);
	inline std::string render_output_directory(void);
	inline void render_output_directory(const std::string& value);
	COLLECTION_PROPERTY(ScriptDirectoryCollection, ScriptDirectory, PreferencesFilePaths, script_directories, false, true, true)
	inline std::string i18n_branches_directory(void);
	inline void i18n_branches_directory(const std::string& value);
	inline std::string sound_directory(void);
	inline void sound_directory(const std::string& value);
	inline std::string temporary_directory(void);
	inline void temporary_directory(const std::string& value);
	inline std::string render_cache_directory(void);
	inline void render_cache_directory(const std::string& value);
	inline std::string image_editor(void);
	inline void image_editor(const std::string& value);
	inline std::string text_editor(void);
	inline void text_editor(const std::string& value);
	inline std::string text_editor_args(void);
	inline void text_editor_args(const std::string& value);
	inline std::string animation_player(void);
	inline void animation_player(const std::string& value);
	enum animation_player_preset_enum {
		animation_player_preset_INTERNAL = 0,
		animation_player_preset_DJV = 2,
		animation_player_preset_FRAMECYCLER = 3,
		animation_player_preset_RV = 4,
		animation_player_preset_MPLAYER = 5,
		animation_player_preset_CUSTOM = 50,
	};
	inline animation_player_preset_enum animation_player_preset(void);
	inline void animation_player_preset(animation_player_preset_enum value);
	inline int save_version(void);
	inline void save_version(int value);
	inline bool use_auto_save_temporary_files(void);
	inline void use_auto_save_temporary_files(bool value);
	inline int auto_save_time(void);
	inline void auto_save_time(int value);
	inline int recent_files(void);
	inline void recent_files(int value);
	enum file_preview_type_enum {
		file_preview_type_NONE = 0,
		file_preview_type_AUTO = 1,
		file_preview_type_SCREENSHOT = 2,
		file_preview_type_CAMERA = 3,
	};
	inline file_preview_type_enum file_preview_type(void);
	inline void file_preview_type(file_preview_type_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UserAssetLibrary, PreferencesFilePaths, asset_libraries, false, true, true)
	inline int active_asset_library(void);
	inline void active_asset_library(int value);
	COLLECTION_PROPERTY(UserExtensionRepoCollection, UserExtensionRepo, PreferencesFilePaths, extension_repos, false, true, true)
	inline int active_extension_repo(void);
	inline void active_extension_repo(int value);

};

/**************** Python Scripts Directory ****************/

class ScriptDirectory : public Pointer {
public:
	ScriptDirectory(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string directory(void);
	inline void directory(const std::string& value);

};

/**************** Asset Library ****************/

class UserAssetLibrary : public Pointer {
public:
	UserAssetLibrary(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string path(void);
	inline void path(const std::string& value);
	enum import_method_enum {
		import_method_LINK = 0,
		import_method_APPEND = 1,
		import_method_APPEND_REUSE = 2,
	};
	inline import_method_enum import_method(void);
	inline void import_method(import_method_enum value);
	inline bool use_relative_path(void);
	inline void use_relative_path(bool value);

};

/**************** Extension Repository ****************/

class UserExtensionRepo : public Pointer {
public:
	UserExtensionRepo(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string module(void);
	inline void module(const std::string& value);
	inline std::string directory(void);
	inline void directory(const std::string& value);
	inline std::string remote_path(void);
	inline void remote_path(const std::string& value);
	inline bool use_cache(void);
	inline void use_cache(bool value);

};

/**************** System & OpenGL ****************/

class PreferencesSystem : public Pointer {
public:
	PreferencesSystem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		solid_lights(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float ui_scale(void);
	inline void ui_scale(float value);
	inline float ui_line_width(void);
	inline void ui_line_width(float value);
	inline int dpi(void);
	inline void dpi(int value);
	inline float pixel_size(void);
	inline void pixel_size(float value);
	inline int memory_cache_limit(void);
	inline void memory_cache_limit(int value);
	inline bool use_sequencer_disk_cache(void);
	inline void use_sequencer_disk_cache(bool value);
	inline std::string sequencer_disk_cache_dir(void);
	inline void sequencer_disk_cache_dir(const std::string& value);
	inline int sequencer_disk_cache_size_limit(void);
	inline void sequencer_disk_cache_size_limit(int value);
	enum sequencer_disk_cache_compression_enum {
		sequencer_disk_cache_compression_NONE = 0,
		sequencer_disk_cache_compression_LOW = 1,
		sequencer_disk_cache_compression_HIGH = 2,
	};
	inline sequencer_disk_cache_compression_enum sequencer_disk_cache_compression(void);
	inline void sequencer_disk_cache_compression(sequencer_disk_cache_compression_enum value);
	enum sequencer_proxy_setup_enum {
		sequencer_proxy_setup_MANUAL = 0,
		sequencer_proxy_setup_AUTOMATIC = 1,
	};
	inline sequencer_proxy_setup_enum sequencer_proxy_setup(void);
	inline void sequencer_proxy_setup(sequencer_proxy_setup_enum value);
	inline int scrollback(void);
	inline void scrollback(int value);
	inline bool use_overlay_smooth_wire(void);
	inline void use_overlay_smooth_wire(bool value);
	inline bool use_edit_mode_smooth_wire(void);
	inline void use_edit_mode_smooth_wire(bool value);
	inline bool use_region_overlap(void);
	inline void use_region_overlap(bool value);
	enum viewport_aa_enum {
		viewport_aa_OFF = 0,
		viewport_aa_FXAA = 1,
		viewport_aa_5 = 5,
		viewport_aa_8 = 8,
		viewport_aa_11 = 11,
		viewport_aa_16 = 16,
		viewport_aa_32 = 32,
	};
	inline viewport_aa_enum viewport_aa(void);
	inline void viewport_aa(viewport_aa_enum value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UserSolidLight, PreferencesSystem, solid_lights, true, true, false)
	inline Array<float, 3> light_ambient(void);
	inline void light_ambient(float values[3]);
	inline bool use_studio_light_edit(void);
	inline void use_studio_light_edit(bool value);
	inline float gl_clip_alpha(void);
	inline void gl_clip_alpha(float value);
	enum image_draw_method_enum {
		image_draw_method_AUTO = 0,
		image_draw_method_2DTEXTURE = 2,
		image_draw_method_GLSL = 1,
	};
	inline image_draw_method_enum image_draw_method(void);
	inline void image_draw_method(image_draw_method_enum value);
	enum anisotropic_filter_enum {
		anisotropic_filter_FILTER_0 = 1,
		anisotropic_filter_FILTER_2 = 2,
		anisotropic_filter_FILTER_4 = 4,
		anisotropic_filter_FILTER_8 = 8,
		anisotropic_filter_FILTER_16 = 16,
	};
	inline anisotropic_filter_enum anisotropic_filter(void);
	inline void anisotropic_filter(anisotropic_filter_enum value);
	enum gl_texture_limit_enum {
		gl_texture_limit_CLAMP_OFF = 0,
		gl_texture_limit_CLAMP_8192 = 8192,
		gl_texture_limit_CLAMP_4096 = 4096,
		gl_texture_limit_CLAMP_2048 = 2048,
		gl_texture_limit_CLAMP_1024 = 1024,
		gl_texture_limit_CLAMP_512 = 512,
		gl_texture_limit_CLAMP_256 = 256,
		gl_texture_limit_CLAMP_128 = 128,
	};
	inline gl_texture_limit_enum gl_texture_limit(void);
	inline void gl_texture_limit(gl_texture_limit_enum value);
	inline int texture_time_out(void);
	inline void texture_time_out(int value);
	inline int texture_collection_rate(void);
	inline void texture_collection_rate(int value);
	inline int vbo_time_out(void);
	inline void vbo_time_out(int value);
	inline int vbo_collection_rate(void);
	inline void vbo_collection_rate(int value);
	inline bool use_select_pick_depth(void);
	inline void use_select_pick_depth(bool value);
	inline bool use_gpu_subdivision(void);
	inline void use_gpu_subdivision(bool value);
	enum gpu_backend_enum {
		gpu_backend_OPENGL = 1,
		gpu_backend_METAL = 2,
		gpu_backend_VULKAN = 8,
	};
	inline gpu_backend_enum gpu_backend(void);
	inline void gpu_backend(gpu_backend_enum value);
	enum audio_mixing_buffer_enum {
		audio_mixing_buffer_SAMPLES_256 = 256,
		audio_mixing_buffer_SAMPLES_512 = 512,
		audio_mixing_buffer_SAMPLES_1024 = 1024,
		audio_mixing_buffer_SAMPLES_2048 = 2048,
		audio_mixing_buffer_SAMPLES_4096 = 4096,
		audio_mixing_buffer_SAMPLES_8192 = 8192,
		audio_mixing_buffer_SAMPLES_16384 = 16384,
		audio_mixing_buffer_SAMPLES_32768 = 32768,
	};
	inline audio_mixing_buffer_enum audio_mixing_buffer(void);
	inline void audio_mixing_buffer(audio_mixing_buffer_enum value);
	enum audio_device_enum {
		audio_device_None = 0,
	};
	inline audio_device_enum audio_device(void);
	inline void audio_device(audio_device_enum value);
	enum audio_sample_rate_enum {
		audio_sample_rate_RATE_44100 = 44100,
		audio_sample_rate_RATE_48000 = 48000,
		audio_sample_rate_RATE_96000 = 96000,
		audio_sample_rate_RATE_192000 = 192000,
	};
	inline audio_sample_rate_enum audio_sample_rate(void);
	inline void audio_sample_rate(audio_sample_rate_enum value);
	enum audio_sample_format_enum {
		audio_sample_format_U8 = 1,
		audio_sample_format_S16 = 18,
		audio_sample_format_S24 = 19,
		audio_sample_format_S32 = 20,
		audio_sample_format_FLOAT = 36,
		audio_sample_format_DOUBLE = 40,
	};
	inline audio_sample_format_enum audio_sample_format(void);
	inline void audio_sample_format(audio_sample_format_enum value);
	enum audio_channels_enum {
		audio_channels_MONO = 1,
		audio_channels_STEREO = 2,
		audio_channels_SURROUND4 = 4,
		audio_channels_SURROUND51 = 6,
		audio_channels_SURROUND71 = 8,
	};
	inline audio_channels_enum audio_channels(void);
	inline void audio_channels(audio_channels_enum value);
	inline int legacy_compute_device_type(void);
	inline void legacy_compute_device_type(int value);
	inline bool register_all_users(void);
	inline void register_all_users(bool value);
	inline bool is_microsoft_store_install(void);
	inline void is_microsoft_store_install(bool value);

};

/**************** Add-on ****************/

class Addon : public Pointer {
public:
	Addon(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string module(void);
	inline void module(const std::string& value);
	inline AddonPreferences preferences(void);

};

/**************** Add-on Preferences ****************/

class AddonPreferences : public Pointer {
public:
	AddonPreferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);

};

/**************** Studio Light ****************/

class StudioLight : public Pointer {
public:
	StudioLight(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		solid_lights(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int index(void);
	inline void index(int value);
	inline bool is_user_defined(void);
	inline void is_user_defined(bool value);
	inline bool has_specular_highlight_pass(void);
	inline void has_specular_highlight_pass(bool value);
	enum type_enum {
		type_STUDIO = 16,
		type_WORLD = 32,
		type_MATCAP = 64,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string path(void);
	inline void path(const std::string& value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, UserSolidLight, StudioLight, solid_lights, true, true, false)
	inline Array<float, 3> light_ambient(void);
	inline void light_ambient(float values[3]);
	inline std::string path_irr_cache(void);
	inline void path_irr_cache(const std::string& value);
	inline std::string path_sh_cache(void);
	inline void path_sh_cache(const std::string& value);
	inline Array<float, 12> spherical_harmonics_coefficients(void);
	inline void spherical_harmonics_coefficients(float values[12]);

};

/**************** Path Compare ****************/

class PathCompare : public Pointer {
public:
	PathCompare(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);
	inline bool use_glob(void);
	inline void use_glob(bool value);

};

/**************** Apps ****************/

class PreferencesApps : public Pointer {
public:
	PreferencesApps(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool show_corner_split(void);
	inline void show_corner_split(bool value);
	inline bool show_edge_resize(void);
	inline void show_edge_resize(bool value);
	inline bool show_regions_visibility_toggle(void);
	inline void show_regions_visibility_toggle(bool value);

};

/**************** Experimental ****************/

class PreferencesExperimental : public Pointer {
public:
	PreferencesExperimental(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_undo_legacy(void);
	inline void use_undo_legacy(bool value);
	inline bool override_auto_resync(void);
	inline void override_auto_resync(bool value);
	inline bool use_new_point_cloud_type(void);
	inline void use_new_point_cloud_type(bool value);
	inline bool use_experimental_compositors(void);
	inline void use_experimental_compositors(bool value);
	inline bool use_new_curves_tools(void);
	inline void use_new_curves_tools(bool value);
	inline bool use_cycles_debug(void);
	inline void use_cycles_debug(bool value);
	inline bool use_eevee_debug(void);
	inline void use_eevee_debug(bool value);
	inline bool use_sculpt_tools_tilt(void);
	inline void use_sculpt_tools_tilt(bool value);
	inline bool use_sculpt_texture_paint(void);
	inline void use_sculpt_texture_paint(bool value);
	inline bool use_extended_asset_browser(void);
	inline void use_extended_asset_browser(bool value);
	inline bool show_asset_debug_info(void);
	inline void show_asset_debug_info(bool value);
	inline bool use_asset_indexing(void);
	inline void use_asset_indexing(bool value);
	inline bool use_override_templates(void);
	inline void use_override_templates(bool value);
	inline bool use_grease_pencil_version3(void);
	inline void use_grease_pencil_version3(bool value);
	inline bool use_viewport_debug(void);
	inline void use_viewport_debug(bool value);
	inline bool enable_overlay_next(void);
	inline void enable_overlay_next(bool value);
	inline bool use_all_linked_data_direct(void);
	inline void use_all_linked_data_direct(bool value);
	inline bool use_new_volume_nodes(void);
	inline void use_new_volume_nodes(bool value);
	inline bool use_shader_node_previews(void);
	inline void use_shader_node_previews(bool value);
	inline bool use_extension_repos(void);
	inline void use_extension_repos(bool value);

};

/**************** Vector Font ****************/

class VectorFont : public ID {
public:
	VectorFont(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline PackedFile packed_file(void);

	inline void pack(void *main);
	inline void unpack(void *main, int method);
};

/**************** Volume Grid ****************/

class VolumeGrid : public Pointer {
public:
	VolumeGrid(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum data_type_enum {
		data_type_BOOLEAN = 1,
		data_type_FLOAT = 2,
		data_type_DOUBLE = 3,
		data_type_INT = 4,
		data_type_INT64 = 5,
		data_type_MASK = 6,
		data_type_VECTOR_FLOAT = 7,
		data_type_VECTOR_DOUBLE = 8,
		data_type_VECTOR_INT = 9,
		data_type_POINTS = 10,
		data_type_UNKNOWN = 0,
	};
	inline data_type_enum data_type(void);
	inline void data_type(data_type_enum value);
	inline int channels(void);
	inline void channels(int value);
	inline Array<float, 16> matrix_object(void);
	inline void matrix_object(float values[16]);
	inline bool is_loaded(void);
	inline void is_loaded(bool value);

	inline bool load();
	inline void unload();
};

/**************** Volume Display ****************/

class VolumeDisplay : public Pointer {
public:
	VolumeDisplay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float density(void);
	inline void density(float value);
	enum wireframe_type_enum {
		wireframe_type_NONE = 0,
		wireframe_type_BOUNDS = 1,
		wireframe_type_BOXES = 2,
		wireframe_type_POINTS = 3,
	};
	inline wireframe_type_enum wireframe_type(void);
	inline void wireframe_type(wireframe_type_enum value);
	enum wireframe_detail_enum {
		wireframe_detail_COARSE = 0,
		wireframe_detail_FINE = 1,
	};
	inline wireframe_detail_enum wireframe_detail(void);
	inline void wireframe_detail(wireframe_detail_enum value);
	enum interpolation_method_enum {
		interpolation_method_LINEAR = 0,
		interpolation_method_CUBIC = 1,
		interpolation_method_CLOSEST = 2,
	};
	inline interpolation_method_enum interpolation_method(void);
	inline void interpolation_method(interpolation_method_enum value);
	inline bool use_slice(void);
	inline void use_slice(bool value);
	enum slice_axis_enum {
		slice_axis_AUTO = 0,
		slice_axis_X = 1,
		slice_axis_Y = 2,
		slice_axis_Z = 3,
	};
	inline slice_axis_enum slice_axis(void);
	inline void slice_axis(slice_axis_enum value);
	inline float slice_depth(void);
	inline void slice_depth(float value);

};

/**************** Volume Render ****************/

class VolumeRender : public Pointer {
public:
	VolumeRender(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum precision_enum {
		precision_FULL = 1,
		precision_HALF = 0,
		precision_VARIABLE = 2,
	};
	inline precision_enum precision(void);
	inline void precision(precision_enum value);
	enum space_enum {
		space_OBJECT = 0,
		space_WORLD = 1,
	};
	inline space_enum space(void);
	inline void space(space_enum value);
	inline float step_size(void);
	inline void step_size(float value);
	inline float clipping(void);
	inline void clipping(float value);

};

/**************** Volume ****************/

class Volume : public ID {
public:
	Volume(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		grids(ptr_arg),
		materials(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline PackedFile packed_file(void);
	inline bool is_sequence(void);
	inline void is_sequence(bool value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	enum sequence_mode_enum {
		sequence_mode_CLIP = 0,
		sequence_mode_EXTEND = 1,
		sequence_mode_REPEAT = 2,
		sequence_mode_PING_PONG = 3,
	};
	inline sequence_mode_enum sequence_mode(void);
	inline void sequence_mode(sequence_mode_enum value);
	COLLECTION_PROPERTY(VolumeGrids, VolumeGrid, Volume, grids, true, false, false)
	COLLECTION_PROPERTY(IDMaterials, Material, Volume, materials, true, true, true)
	inline VolumeDisplay display(void);
	inline VolumeRender render(void);
	inline std::string velocity_grid(void);
	inline void velocity_grid(const std::string& value);
	enum velocity_unit_enum {
		velocity_unit_SECOND = 1,
		velocity_unit_FRAME = 0,
	};
	inline velocity_unit_enum velocity_unit(void);
	inline void velocity_unit(velocity_unit_enum value);
	inline float velocity_scale(void);
	inline void velocity_scale(float value);
	inline std::string velocity_x_grid(void);
	inline void velocity_x_grid(const std::string& value);
	inline std::string velocity_y_grid(void);
	inline void velocity_y_grid(const std::string& value);
	inline std::string velocity_z_grid(void);
	inline void velocity_z_grid(const std::string& value);
	inline AnimData animation_data(void);

};

/**************** Operator ****************/

class Operator : public Pointer {
public:
	Operator(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		macros(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline OperatorProperties properties(void);
	inline bool has_reports(void);
	inline void has_reports(bool value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline std::string bl_undo_group(void);
	inline void bl_undo_group(const std::string& value);
	enum bl_options_enum {
		bl_options_REGISTER = 1,
		bl_options_UNDO = 2,
		bl_options_UNDO_GROUPED = 1024,
		bl_options_BLOCKING = 4,
		bl_options_MACRO = 8,
		bl_options_GRAB_CURSOR = 16,
		bl_options_GRAB_CURSOR_X = 32,
		bl_options_GRAB_CURSOR_Y = 64,
		bl_options_DEPENDS_ON_CURSOR = 2048,
		bl_options_PRESET = 128,
		bl_options_INTERNAL = 256,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	enum bl_cursor_pending_enum {
		bl_cursor_pending_DEFAULT = 1,
		bl_cursor_pending_NONE = 34,
		bl_cursor_pending_WAIT = 3,
		bl_cursor_pending_CROSSHAIR = 5,
		bl_cursor_pending_MOVE_X = 18,
		bl_cursor_pending_MOVE_Y = 19,
		bl_cursor_pending_KNIFE = 12,
		bl_cursor_pending_TEXT = 2,
		bl_cursor_pending_PAINT_BRUSH = 14,
		bl_cursor_pending_PAINT_CROSS = 9,
		bl_cursor_pending_DOT = 10,
		bl_cursor_pending_ERASER = 15,
		bl_cursor_pending_HAND = 7,
		bl_cursor_pending_SCROLL_X = 31,
		bl_cursor_pending_SCROLL_Y = 30,
		bl_cursor_pending_SCROLL_XY = 29,
		bl_cursor_pending_EYEDROPPER = 16,
		bl_cursor_pending_PICK_AREA = 36,
		bl_cursor_pending_STOP = 4,
		bl_cursor_pending_COPY = 6,
		bl_cursor_pending_CROSS = 8,
		bl_cursor_pending_MUTE = 35,
		bl_cursor_pending_ZOOM_IN = 32,
		bl_cursor_pending_ZOOM_OUT = 33,
	};
	inline bl_cursor_pending_enum bl_cursor_pending(void);
	inline void bl_cursor_pending(bl_cursor_pending_enum value);
	inline UILayout layout(void);
	inline OperatorOptions options(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Macro, Operator, macros, false, true, true)

	inline void report(int type, const char * message);
	inline bool is_repeat(Context C);
};

/**************** Operator Properties ****************/

class OperatorProperties : public Pointer {
public:
	OperatorProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Operator Options ****************/

class OperatorOptions : public Pointer {
public:
	OperatorOptions(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_grab_cursor(void);
	inline void is_grab_cursor(bool value);
	inline bool is_invoke(void);
	inline void is_invoke(bool value);
	inline bool is_repeat(void);
	inline void is_repeat(bool value);
	inline bool is_repeat_last(void);
	inline void is_repeat_last(bool value);
	inline bool use_cursor_region(void);
	inline void use_cursor_region(bool value);

};

/**************** Operator Mouse Path ****************/

class OperatorMousePath : public PropertyGroup {
public:
	OperatorMousePath(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** Operator File List Element ****************/

class OperatorFileListElement : public PropertyGroup {
public:
	OperatorFileListElement(const PointerRNA &ptr_arg) :
		PropertyGroup(ptr_arg)
		{}


};

/**************** Macro Operator ****************/

class Macro : public Pointer {
public:
	Macro(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline OperatorProperties properties(void);
	inline bool has_reports(void);
	inline void has_reports(bool value);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	inline std::string bl_translation_context(void);
	inline void bl_translation_context(const std::string& value);
	inline std::string bl_description(void);
	inline void bl_description(const std::string& value);
	inline std::string bl_undo_group(void);
	inline void bl_undo_group(const std::string& value);
	enum bl_options_enum {
		bl_options_REGISTER = 1,
		bl_options_UNDO = 2,
		bl_options_UNDO_GROUPED = 1024,
		bl_options_BLOCKING = 4,
		bl_options_MACRO = 8,
		bl_options_GRAB_CURSOR = 16,
		bl_options_GRAB_CURSOR_X = 32,
		bl_options_GRAB_CURSOR_Y = 64,
		bl_options_DEPENDS_ON_CURSOR = 2048,
		bl_options_PRESET = 128,
		bl_options_INTERNAL = 256,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	enum bl_cursor_pending_enum {
		bl_cursor_pending_DEFAULT = 1,
		bl_cursor_pending_NONE = 34,
		bl_cursor_pending_WAIT = 3,
		bl_cursor_pending_CROSSHAIR = 5,
		bl_cursor_pending_MOVE_X = 18,
		bl_cursor_pending_MOVE_Y = 19,
		bl_cursor_pending_KNIFE = 12,
		bl_cursor_pending_TEXT = 2,
		bl_cursor_pending_PAINT_BRUSH = 14,
		bl_cursor_pending_PAINT_CROSS = 9,
		bl_cursor_pending_DOT = 10,
		bl_cursor_pending_ERASER = 15,
		bl_cursor_pending_HAND = 7,
		bl_cursor_pending_SCROLL_X = 31,
		bl_cursor_pending_SCROLL_Y = 30,
		bl_cursor_pending_SCROLL_XY = 29,
		bl_cursor_pending_EYEDROPPER = 16,
		bl_cursor_pending_PICK_AREA = 36,
		bl_cursor_pending_STOP = 4,
		bl_cursor_pending_COPY = 6,
		bl_cursor_pending_CROSS = 8,
		bl_cursor_pending_MUTE = 35,
		bl_cursor_pending_ZOOM_IN = 32,
		bl_cursor_pending_ZOOM_OUT = 33,
	};
	inline bl_cursor_pending_enum bl_cursor_pending(void);
	inline void bl_cursor_pending(bl_cursor_pending_enum value);

	inline void report(int type, const char * message);
};

/**************** Operator Macro ****************/

class OperatorMacro : public Pointer {
public:
	OperatorMacro(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline OperatorProperties properties(void);

};

/**************** Event ****************/

class Event : public Pointer {
public:
	Event(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string ascii(void);
	inline void ascii(const std::string& value);
	inline std::string unicode(void);
	inline void unicode(const std::string& value);
	enum value_enum {
		value_ANY = -1,
		value_PRESS = 1,
		value_RELEASE = 2,
		value_CLICK = 3,
		value_DOUBLE_CLICK = 4,
		value_CLICK_DRAG = 5,
		value_NOTHING = 0,
	};
	inline value_enum value(void);
	inline void value(value_enum value);
	enum value_prev_enum {
		value_prev_ANY = -1,
		value_prev_PRESS = 1,
		value_prev_RELEASE = 2,
		value_prev_CLICK = 3,
		value_prev_DOUBLE_CLICK = 4,
		value_prev_CLICK_DRAG = 5,
		value_prev_NOTHING = 0,
	};
	inline value_prev_enum value_prev(void);
	inline void value_prev(value_prev_enum value);
	enum type_enum {
		type_NONE = 0,
		type_LEFTMOUSE = 1,
		type_MIDDLEMOUSE = 2,
		type_RIGHTMOUSE = 3,
		type_BUTTON4MOUSE = 7,
		type_BUTTON5MOUSE = 8,
		type_BUTTON6MOUSE = 18,
		type_BUTTON7MOUSE = 19,
		type_PEN = 26,
		type_ERASER = 27,
		type_MOUSEMOVE = 4,
		type_INBETWEEN_MOUSEMOVE = 17,
		type_TRACKPADPAN = 14,
		type_TRACKPADZOOM = 15,
		type_MOUSEROTATE = 16,
		type_MOUSESMARTZOOM = 23,
		type_WHEELUPMOUSE = 10,
		type_WHEELDOWNMOUSE = 11,
		type_WHEELINMOUSE = 12,
		type_WHEELOUTMOUSE = 13,
		type_A = 97,
		type_B = 98,
		type_C = 99,
		type_D = 100,
		type_E = 101,
		type_F = 102,
		type_G = 103,
		type_H = 104,
		type_I = 105,
		type_J = 106,
		type_K = 107,
		type_L = 108,
		type_M = 109,
		type_N = 110,
		type_O = 111,
		type_P = 112,
		type_Q = 113,
		type_R = 114,
		type_S = 115,
		type_T = 116,
		type_U = 117,
		type_V = 118,
		type_W = 119,
		type_X = 120,
		type_Y = 121,
		type_Z = 122,
		type_ZERO = 48,
		type_ONE = 49,
		type_TWO = 50,
		type_THREE = 51,
		type_FOUR = 52,
		type_FIVE = 53,
		type_SIX = 54,
		type_SEVEN = 55,
		type_EIGHT = 56,
		type_NINE = 57,
		type_LEFT_CTRL = 212,
		type_LEFT_ALT = 213,
		type_LEFT_SHIFT = 217,
		type_RIGHT_ALT = 214,
		type_RIGHT_CTRL = 215,
		type_RIGHT_SHIFT = 216,
		type_OSKEY = 172,
		type_APP = 178,
		type_GRLESS = 173,
		type_ESC = 218,
		type_TAB = 219,
		type_RET = 220,
		type_SPACE = 221,
		type_LINE_FEED = 222,
		type_BACK_SPACE = 223,
		type_DEL = 224,
		type_SEMI_COLON = 225,
		type_PERIOD = 226,
		type_COMMA = 227,
		type_QUOTE = 228,
		type_ACCENT_GRAVE = 229,
		type_MINUS = 230,
		type_PLUS = 231,
		type_SLASH = 232,
		type_BACK_SLASH = 233,
		type_EQUAL = 234,
		type_LEFT_BRACKET = 235,
		type_RIGHT_BRACKET = 236,
		type_LEFT_ARROW = 137,
		type_DOWN_ARROW = 138,
		type_RIGHT_ARROW = 139,
		type_UP_ARROW = 140,
		type_NUMPAD_2 = 152,
		type_NUMPAD_4 = 154,
		type_NUMPAD_6 = 156,
		type_NUMPAD_8 = 158,
		type_NUMPAD_1 = 151,
		type_NUMPAD_3 = 153,
		type_NUMPAD_5 = 155,
		type_NUMPAD_7 = 157,
		type_NUMPAD_9 = 159,
		type_NUMPAD_PERIOD = 199,
		type_NUMPAD_SLASH = 161,
		type_NUMPAD_ASTERIX = 160,
		type_NUMPAD_0 = 150,
		type_NUMPAD_MINUS = 162,
		type_NUMPAD_ENTER = 163,
		type_NUMPAD_PLUS = 164,
		type_F1 = 300,
		type_F2 = 301,
		type_F3 = 302,
		type_F4 = 303,
		type_F5 = 304,
		type_F6 = 305,
		type_F7 = 306,
		type_F8 = 307,
		type_F9 = 308,
		type_F10 = 309,
		type_F11 = 310,
		type_F12 = 311,
		type_F13 = 312,
		type_F14 = 313,
		type_F15 = 314,
		type_F16 = 315,
		type_F17 = 316,
		type_F18 = 317,
		type_F19 = 318,
		type_F20 = 319,
		type_F21 = 320,
		type_F22 = 321,
		type_F23 = 322,
		type_F24 = 323,
		type_PAUSE = 165,
		type_INSERT = 166,
		type_HOME = 167,
		type_PAGE_UP = 168,
		type_PAGE_DOWN = 169,
		type_END = 170,
		type_MEDIA_PLAY = 174,
		type_MEDIA_STOP = 175,
		type_MEDIA_FIRST = 176,
		type_MEDIA_LAST = 177,
		type_TEXTINPUT = -2,
		type_WINDOW_DEACTIVATE = 260,
		type_TIMER = 272,
		type_TIMER0 = 273,
		type_TIMER1 = 274,
		type_TIMER2 = 275,
		type_TIMER_JOBS = 276,
		type_TIMER_AUTOSAVE = 277,
		type_TIMER_REPORT = 278,
		type_TIMERREGION = 279,
		type_NDOF_MOTION = 400,
		type_NDOF_BUTTON_MENU = 401,
		type_NDOF_BUTTON_FIT = 402,
		type_NDOF_BUTTON_TOP = 403,
		type_NDOF_BUTTON_BOTTOM = 404,
		type_NDOF_BUTTON_LEFT = 405,
		type_NDOF_BUTTON_RIGHT = 406,
		type_NDOF_BUTTON_FRONT = 407,
		type_NDOF_BUTTON_BACK = 408,
		type_NDOF_BUTTON_ISO1 = 409,
		type_NDOF_BUTTON_ISO2 = 410,
		type_NDOF_BUTTON_ROLL_CW = 411,
		type_NDOF_BUTTON_ROLL_CCW = 412,
		type_NDOF_BUTTON_SPIN_CW = 413,
		type_NDOF_BUTTON_SPIN_CCW = 414,
		type_NDOF_BUTTON_TILT_CW = 415,
		type_NDOF_BUTTON_TILT_CCW = 416,
		type_NDOF_BUTTON_ROTATE = 417,
		type_NDOF_BUTTON_PANZOOM = 418,
		type_NDOF_BUTTON_DOMINANT = 419,
		type_NDOF_BUTTON_PLUS = 420,
		type_NDOF_BUTTON_MINUS = 421,
		type_NDOF_BUTTON_V1 = 422,
		type_NDOF_BUTTON_V2 = 423,
		type_NDOF_BUTTON_V3 = 424,
		type_NDOF_BUTTON_1 = 426,
		type_NDOF_BUTTON_2 = 427,
		type_NDOF_BUTTON_3 = 428,
		type_NDOF_BUTTON_4 = 429,
		type_NDOF_BUTTON_5 = 430,
		type_NDOF_BUTTON_6 = 431,
		type_NDOF_BUTTON_7 = 432,
		type_NDOF_BUTTON_8 = 433,
		type_NDOF_BUTTON_9 = 434,
		type_NDOF_BUTTON_10 = 435,
		type_NDOF_BUTTON_A = 436,
		type_NDOF_BUTTON_B = 437,
		type_NDOF_BUTTON_C = 438,
		type_ACTIONZONE_AREA = 20480,
		type_ACTIONZONE_REGION = 20481,
		type_ACTIONZONE_FULLSCREEN = 20497,
		type_XR_ACTION = 20528,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum type_prev_enum {
		type_prev_NONE = 0,
		type_prev_LEFTMOUSE = 1,
		type_prev_MIDDLEMOUSE = 2,
		type_prev_RIGHTMOUSE = 3,
		type_prev_BUTTON4MOUSE = 7,
		type_prev_BUTTON5MOUSE = 8,
		type_prev_BUTTON6MOUSE = 18,
		type_prev_BUTTON7MOUSE = 19,
		type_prev_PEN = 26,
		type_prev_ERASER = 27,
		type_prev_MOUSEMOVE = 4,
		type_prev_INBETWEEN_MOUSEMOVE = 17,
		type_prev_TRACKPADPAN = 14,
		type_prev_TRACKPADZOOM = 15,
		type_prev_MOUSEROTATE = 16,
		type_prev_MOUSESMARTZOOM = 23,
		type_prev_WHEELUPMOUSE = 10,
		type_prev_WHEELDOWNMOUSE = 11,
		type_prev_WHEELINMOUSE = 12,
		type_prev_WHEELOUTMOUSE = 13,
		type_prev_A = 97,
		type_prev_B = 98,
		type_prev_C = 99,
		type_prev_D = 100,
		type_prev_E = 101,
		type_prev_F = 102,
		type_prev_G = 103,
		type_prev_H = 104,
		type_prev_I = 105,
		type_prev_J = 106,
		type_prev_K = 107,
		type_prev_L = 108,
		type_prev_M = 109,
		type_prev_N = 110,
		type_prev_O = 111,
		type_prev_P = 112,
		type_prev_Q = 113,
		type_prev_R = 114,
		type_prev_S = 115,
		type_prev_T = 116,
		type_prev_U = 117,
		type_prev_V = 118,
		type_prev_W = 119,
		type_prev_X = 120,
		type_prev_Y = 121,
		type_prev_Z = 122,
		type_prev_ZERO = 48,
		type_prev_ONE = 49,
		type_prev_TWO = 50,
		type_prev_THREE = 51,
		type_prev_FOUR = 52,
		type_prev_FIVE = 53,
		type_prev_SIX = 54,
		type_prev_SEVEN = 55,
		type_prev_EIGHT = 56,
		type_prev_NINE = 57,
		type_prev_LEFT_CTRL = 212,
		type_prev_LEFT_ALT = 213,
		type_prev_LEFT_SHIFT = 217,
		type_prev_RIGHT_ALT = 214,
		type_prev_RIGHT_CTRL = 215,
		type_prev_RIGHT_SHIFT = 216,
		type_prev_OSKEY = 172,
		type_prev_APP = 178,
		type_prev_GRLESS = 173,
		type_prev_ESC = 218,
		type_prev_TAB = 219,
		type_prev_RET = 220,
		type_prev_SPACE = 221,
		type_prev_LINE_FEED = 222,
		type_prev_BACK_SPACE = 223,
		type_prev_DEL = 224,
		type_prev_SEMI_COLON = 225,
		type_prev_PERIOD = 226,
		type_prev_COMMA = 227,
		type_prev_QUOTE = 228,
		type_prev_ACCENT_GRAVE = 229,
		type_prev_MINUS = 230,
		type_prev_PLUS = 231,
		type_prev_SLASH = 232,
		type_prev_BACK_SLASH = 233,
		type_prev_EQUAL = 234,
		type_prev_LEFT_BRACKET = 235,
		type_prev_RIGHT_BRACKET = 236,
		type_prev_LEFT_ARROW = 137,
		type_prev_DOWN_ARROW = 138,
		type_prev_RIGHT_ARROW = 139,
		type_prev_UP_ARROW = 140,
		type_prev_NUMPAD_2 = 152,
		type_prev_NUMPAD_4 = 154,
		type_prev_NUMPAD_6 = 156,
		type_prev_NUMPAD_8 = 158,
		type_prev_NUMPAD_1 = 151,
		type_prev_NUMPAD_3 = 153,
		type_prev_NUMPAD_5 = 155,
		type_prev_NUMPAD_7 = 157,
		type_prev_NUMPAD_9 = 159,
		type_prev_NUMPAD_PERIOD = 199,
		type_prev_NUMPAD_SLASH = 161,
		type_prev_NUMPAD_ASTERIX = 160,
		type_prev_NUMPAD_0 = 150,
		type_prev_NUMPAD_MINUS = 162,
		type_prev_NUMPAD_ENTER = 163,
		type_prev_NUMPAD_PLUS = 164,
		type_prev_F1 = 300,
		type_prev_F2 = 301,
		type_prev_F3 = 302,
		type_prev_F4 = 303,
		type_prev_F5 = 304,
		type_prev_F6 = 305,
		type_prev_F7 = 306,
		type_prev_F8 = 307,
		type_prev_F9 = 308,
		type_prev_F10 = 309,
		type_prev_F11 = 310,
		type_prev_F12 = 311,
		type_prev_F13 = 312,
		type_prev_F14 = 313,
		type_prev_F15 = 314,
		type_prev_F16 = 315,
		type_prev_F17 = 316,
		type_prev_F18 = 317,
		type_prev_F19 = 318,
		type_prev_F20 = 319,
		type_prev_F21 = 320,
		type_prev_F22 = 321,
		type_prev_F23 = 322,
		type_prev_F24 = 323,
		type_prev_PAUSE = 165,
		type_prev_INSERT = 166,
		type_prev_HOME = 167,
		type_prev_PAGE_UP = 168,
		type_prev_PAGE_DOWN = 169,
		type_prev_END = 170,
		type_prev_MEDIA_PLAY = 174,
		type_prev_MEDIA_STOP = 175,
		type_prev_MEDIA_FIRST = 176,
		type_prev_MEDIA_LAST = 177,
		type_prev_TEXTINPUT = -2,
		type_prev_WINDOW_DEACTIVATE = 260,
		type_prev_TIMER = 272,
		type_prev_TIMER0 = 273,
		type_prev_TIMER1 = 274,
		type_prev_TIMER2 = 275,
		type_prev_TIMER_JOBS = 276,
		type_prev_TIMER_AUTOSAVE = 277,
		type_prev_TIMER_REPORT = 278,
		type_prev_TIMERREGION = 279,
		type_prev_NDOF_MOTION = 400,
		type_prev_NDOF_BUTTON_MENU = 401,
		type_prev_NDOF_BUTTON_FIT = 402,
		type_prev_NDOF_BUTTON_TOP = 403,
		type_prev_NDOF_BUTTON_BOTTOM = 404,
		type_prev_NDOF_BUTTON_LEFT = 405,
		type_prev_NDOF_BUTTON_RIGHT = 406,
		type_prev_NDOF_BUTTON_FRONT = 407,
		type_prev_NDOF_BUTTON_BACK = 408,
		type_prev_NDOF_BUTTON_ISO1 = 409,
		type_prev_NDOF_BUTTON_ISO2 = 410,
		type_prev_NDOF_BUTTON_ROLL_CW = 411,
		type_prev_NDOF_BUTTON_ROLL_CCW = 412,
		type_prev_NDOF_BUTTON_SPIN_CW = 413,
		type_prev_NDOF_BUTTON_SPIN_CCW = 414,
		type_prev_NDOF_BUTTON_TILT_CW = 415,
		type_prev_NDOF_BUTTON_TILT_CCW = 416,
		type_prev_NDOF_BUTTON_ROTATE = 417,
		type_prev_NDOF_BUTTON_PANZOOM = 418,
		type_prev_NDOF_BUTTON_DOMINANT = 419,
		type_prev_NDOF_BUTTON_PLUS = 420,
		type_prev_NDOF_BUTTON_MINUS = 421,
		type_prev_NDOF_BUTTON_V1 = 422,
		type_prev_NDOF_BUTTON_V2 = 423,
		type_prev_NDOF_BUTTON_V3 = 424,
		type_prev_NDOF_BUTTON_1 = 426,
		type_prev_NDOF_BUTTON_2 = 427,
		type_prev_NDOF_BUTTON_3 = 428,
		type_prev_NDOF_BUTTON_4 = 429,
		type_prev_NDOF_BUTTON_5 = 430,
		type_prev_NDOF_BUTTON_6 = 431,
		type_prev_NDOF_BUTTON_7 = 432,
		type_prev_NDOF_BUTTON_8 = 433,
		type_prev_NDOF_BUTTON_9 = 434,
		type_prev_NDOF_BUTTON_10 = 435,
		type_prev_NDOF_BUTTON_A = 436,
		type_prev_NDOF_BUTTON_B = 437,
		type_prev_NDOF_BUTTON_C = 438,
		type_prev_ACTIONZONE_AREA = 20480,
		type_prev_ACTIONZONE_REGION = 20481,
		type_prev_ACTIONZONE_FULLSCREEN = 20497,
		type_prev_XR_ACTION = 20528,
	};
	inline type_prev_enum type_prev(void);
	inline void type_prev(type_prev_enum value);
	enum direction_enum {
		direction_ANY = -1,
		direction_NORTH = 1,
		direction_NORTH_EAST = 2,
		direction_EAST = 3,
		direction_SOUTH_EAST = 4,
		direction_SOUTH = 5,
		direction_SOUTH_WEST = 6,
		direction_WEST = 7,
		direction_NORTH_WEST = 8,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	inline bool is_repeat(void);
	inline void is_repeat(bool value);
	inline bool is_consecutive(void);
	inline void is_consecutive(bool value);
	inline int mouse_x(void);
	inline void mouse_x(int value);
	inline int mouse_y(void);
	inline void mouse_y(int value);
	inline int mouse_region_x(void);
	inline void mouse_region_x(int value);
	inline int mouse_region_y(void);
	inline void mouse_region_y(int value);
	inline int mouse_prev_x(void);
	inline void mouse_prev_x(int value);
	inline int mouse_prev_y(void);
	inline void mouse_prev_y(int value);
	inline int mouse_prev_press_x(void);
	inline void mouse_prev_press_x(int value);
	inline int mouse_prev_press_y(void);
	inline void mouse_prev_press_y(int value);
	inline float pressure(void);
	inline void pressure(float value);
	inline Array<float, 2> tilt(void);
	inline void tilt(float values[2]);
	inline bool is_tablet(void);
	inline void is_tablet(bool value);
	inline bool is_mouse_absolute(void);
	inline void is_mouse_absolute(bool value);
	inline XrEventData xr(void);
	inline bool shift(void);
	inline void shift(bool value);
	inline bool ctrl(void);
	inline void ctrl(bool value);
	inline bool alt(void);
	inline void alt(bool value);
	inline bool oskey(void);
	inline void oskey(bool value);

};

/**************** Timer ****************/

class Timer : public Pointer {
public:
	Timer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float time_step(void);
	inline void time_step(float value);
	inline float time_delta(void);
	inline void time_delta(float value);
	inline float time_duration(void);
	inline void time_duration(float value);

};

/**************** UIPopupMenu ****************/

class UIPopupMenu : public Pointer {
public:
	UIPopupMenu(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);

};

/**************** UIPopover ****************/

class UIPopover : public Pointer {
public:
	UIPopover(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);

};

/**************** UIPieMenu ****************/

class UIPieMenu : public Pointer {
public:
	UIPieMenu(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline UILayout layout(void);

};

/**************** Window ****************/

class Window : public Pointer {
public:
	Window(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Window parent(void);
	inline Scene scene(void);
	inline WorkSpace workspace(void);
	inline Screen screen(void);
	inline ViewLayer view_layer(void);
	inline int x(void);
	inline void x(int value);
	inline int y(void);
	inline void y(int value);
	inline int width(void);
	inline void width(int value);
	inline int height(void);
	inline void height(int value);
	inline Stereo3dDisplay stereo_3d_display(void);

	inline void cursor_warp(int x, int y);
	inline void cursor_set(int cursor);
	inline void cursor_modal_set(int cursor);
	inline void cursor_modal_restore();
	inline Event event_simulate(int type, int value, const char * unicode, int x, int y, bool shift, bool ctrl, bool alt, bool oskey);
};

/**************** Stereo 3D Display ****************/

class Stereo3dDisplay : public Pointer {
public:
	Stereo3dDisplay(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum display_mode_enum {
		display_mode_ANAGLYPH = 0,
		display_mode_INTERLACE = 1,
		display_mode_TIMESEQUENTIAL = 2,
		display_mode_SIDEBYSIDE = 3,
		display_mode_TOPBOTTOM = 4,
	};
	inline display_mode_enum display_mode(void);
	inline void display_mode(display_mode_enum value);
	enum anaglyph_type_enum {
		anaglyph_type_RED_CYAN = 0,
		anaglyph_type_GREEN_MAGENTA = 1,
		anaglyph_type_YELLOW_BLUE = 2,
	};
	inline anaglyph_type_enum anaglyph_type(void);
	inline void anaglyph_type(anaglyph_type_enum value);
	enum interlace_type_enum {
		interlace_type_ROW_INTERLEAVED = 0,
		interlace_type_COLUMN_INTERLEAVED = 1,
		interlace_type_CHECKERBOARD_INTERLEAVED = 2,
	};
	inline interlace_type_enum interlace_type(void);
	inline void interlace_type(interlace_type_enum value);
	inline bool use_interlace_swap(void);
	inline void use_interlace_swap(bool value);
	inline bool use_sidebyside_crosseyed(void);
	inline void use_sidebyside_crosseyed(bool value);

};

/**************** Window Manager ****************/

class WindowManager : public ID {
public:
	WindowManager(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		operators(ptr_arg),
		windows(ptr_arg),
		keyconfigs(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Operator, WindowManager, operators, false, true, true)
	COLLECTION_PROPERTY(DefaultCollectionFunctions, Window, WindowManager, windows, false, true, false)
	COLLECTION_PROPERTY(KeyConfigurations, KeyConfig, WindowManager, keyconfigs, false, true, true)
	inline XrSessionSettings xr_session_settings(void);
	inline XrSessionState xr_session_state(void);
	inline bool is_interface_locked(void);
	inline void is_interface_locked(bool value);

	inline void fileselect_add(Context C, Operator& operator_value);
	inline bool modal_handler_add(Context C, Operator& operator_value);
	inline Timer event_timer_add(float time_step, Window& window);
	inline void event_timer_remove(Timer& timer);
	inline void gizmo_group_type_ensure(const char * identifier);
	inline void gizmo_group_type_unlink_delayed(const char * identifier);
	inline void progress_begin(float min, float max);
	inline void progress_update(float value);
	inline void progress_end();
	inline int invoke_props_popup(Context C, Operator& operator_value, Event& event);
	inline int invoke_props_dialog(Context C, Operator& operator_value, int width);
	inline void invoke_search_popup(Context C, Operator& operator_value);
	inline int invoke_popup(Context C, Operator& operator_value, int width);
	inline int invoke_confirm(Context C, Operator& operator_value, Event& event);
	inline UIPopupMenu popmenu_begin__internal(Context C, const char * title, int icon);
	inline void popmenu_end__internal(Context C, UIPopupMenu& menu);
	inline UIPopover popover_begin__internal(Context C, int ui_units_x, bool from_active_button);
	inline void popover_end__internal(Context C, UIPopover& menu, KeyMap& keymap);
	inline UIPieMenu piemenu_begin__internal(Context C, const char * title, int icon, Event& event);
	inline void piemenu_end__internal(Context C, UIPieMenu& menu);
	inline OperatorProperties operator_properties_last(const char * operator_value);
	inline void print_undo_steps();
	inline void tag_script_reload();
};

/**************** Key-Config Preferences ****************/

class KeyConfigPreferences : public Pointer {
public:
	KeyConfigPreferences(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);

};

/**************** Key Configuration ****************/

class KeyConfig : public Pointer {
public:
	KeyConfig(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		keymaps(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(KeyMaps, KeyMap, KeyConfig, keymaps, false, true, true)
	inline bool is_user_defined(void);
	inline void is_user_defined(bool value);
	inline KeyConfigPreferences preferences(void);

};

/**************** Key Map ****************/

class KeyMap : public Pointer {
public:
	KeyMap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		keymap_items(ptr_arg),
		modal_event_values(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);
	enum space_type_enum {
		space_type_EMPTY = 0,
		space_type_VIEW_3D = 1,
		space_type_IMAGE_EDITOR = 6,
		space_type_NODE_EDITOR = 16,
		space_type_SEQUENCE_EDITOR = 8,
		space_type_CLIP_EDITOR = 20,
		space_type_DOPESHEET_EDITOR = 12,
		space_type_GRAPH_EDITOR = 2,
		space_type_NLA_EDITOR = 13,
		space_type_TEXT_EDITOR = 9,
		space_type_CONSOLE = 18,
		space_type_INFO = 7,
		space_type_TOPBAR = 21,
		space_type_STATUSBAR = 22,
		space_type_OUTLINER = 3,
		space_type_PROPERTIES = 4,
		space_type_FILE_BROWSER = 5,
		space_type_SPREADSHEET = 23,
		space_type_PREFERENCES = 19,
	};
	inline space_type_enum space_type(void);
	inline void space_type(space_type_enum value);
	enum region_type_enum {
		region_type_WINDOW = 0,
		region_type_HEADER = 1,
		region_type_CHANNELS = 2,
		region_type_TEMPORARY = 3,
		region_type_UI = 4,
		region_type_TOOLS = 5,
		region_type_TOOL_PROPS = 6,
		region_type_ASSET_SHELF = 14,
		region_type_ASSET_SHELF_HEADER = 15,
		region_type_PREVIEW = 7,
		region_type_HUD = 8,
		region_type_NAVIGATION_BAR = 9,
		region_type_EXECUTE = 10,
		region_type_FOOTER = 11,
		region_type_TOOL_HEADER = 12,
		region_type_XR = 13,
	};
	inline region_type_enum region_type(void);
	inline void region_type(region_type_enum value);
	COLLECTION_PROPERTY(KeyMapItems, KeyMapItem, KeyMap, keymap_items, false, true, true)
	inline bool is_user_modified(void);
	inline void is_user_modified(bool value);
	inline bool is_modal(void);
	inline void is_modal(bool value);
	inline bool show_expanded_items(void);
	inline void show_expanded_items(bool value);
	inline bool show_expanded_children(void);
	inline void show_expanded_children(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, EnumPropertyItem, KeyMap, modal_event_values, false, false, false)

	inline KeyMap active(Context C);
	inline void restore_to_default(Context C);
	inline void restore_item_to_default(Context C, KeyMapItem& item);
};

/**************** Key Map Item ****************/

class KeyMapItem : public Pointer {
public:
	KeyMapItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string idname(void);
	inline void idname(const std::string& value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline OperatorProperties properties(void);
	enum map_type_enum {
		map_type_KEYBOARD = 0,
		map_type_MOUSE = 1,
		map_type_NDOF = 5,
		map_type_TEXTINPUT = 3,
		map_type_TIMER = 4,
	};
	inline map_type_enum map_type(void);
	inline void map_type(map_type_enum value);
	enum type_enum {
		type_NONE = 0,
		type_LEFTMOUSE = 1,
		type_MIDDLEMOUSE = 2,
		type_RIGHTMOUSE = 3,
		type_BUTTON4MOUSE = 7,
		type_BUTTON5MOUSE = 8,
		type_BUTTON6MOUSE = 18,
		type_BUTTON7MOUSE = 19,
		type_PEN = 26,
		type_ERASER = 27,
		type_MOUSEMOVE = 4,
		type_INBETWEEN_MOUSEMOVE = 17,
		type_TRACKPADPAN = 14,
		type_TRACKPADZOOM = 15,
		type_MOUSEROTATE = 16,
		type_MOUSESMARTZOOM = 23,
		type_WHEELUPMOUSE = 10,
		type_WHEELDOWNMOUSE = 11,
		type_WHEELINMOUSE = 12,
		type_WHEELOUTMOUSE = 13,
		type_A = 97,
		type_B = 98,
		type_C = 99,
		type_D = 100,
		type_E = 101,
		type_F = 102,
		type_G = 103,
		type_H = 104,
		type_I = 105,
		type_J = 106,
		type_K = 107,
		type_L = 108,
		type_M = 109,
		type_N = 110,
		type_O = 111,
		type_P = 112,
		type_Q = 113,
		type_R = 114,
		type_S = 115,
		type_T = 116,
		type_U = 117,
		type_V = 118,
		type_W = 119,
		type_X = 120,
		type_Y = 121,
		type_Z = 122,
		type_ZERO = 48,
		type_ONE = 49,
		type_TWO = 50,
		type_THREE = 51,
		type_FOUR = 52,
		type_FIVE = 53,
		type_SIX = 54,
		type_SEVEN = 55,
		type_EIGHT = 56,
		type_NINE = 57,
		type_LEFT_CTRL = 212,
		type_LEFT_ALT = 213,
		type_LEFT_SHIFT = 217,
		type_RIGHT_ALT = 214,
		type_RIGHT_CTRL = 215,
		type_RIGHT_SHIFT = 216,
		type_OSKEY = 172,
		type_APP = 178,
		type_GRLESS = 173,
		type_ESC = 218,
		type_TAB = 219,
		type_RET = 220,
		type_SPACE = 221,
		type_LINE_FEED = 222,
		type_BACK_SPACE = 223,
		type_DEL = 224,
		type_SEMI_COLON = 225,
		type_PERIOD = 226,
		type_COMMA = 227,
		type_QUOTE = 228,
		type_ACCENT_GRAVE = 229,
		type_MINUS = 230,
		type_PLUS = 231,
		type_SLASH = 232,
		type_BACK_SLASH = 233,
		type_EQUAL = 234,
		type_LEFT_BRACKET = 235,
		type_RIGHT_BRACKET = 236,
		type_LEFT_ARROW = 137,
		type_DOWN_ARROW = 138,
		type_RIGHT_ARROW = 139,
		type_UP_ARROW = 140,
		type_NUMPAD_2 = 152,
		type_NUMPAD_4 = 154,
		type_NUMPAD_6 = 156,
		type_NUMPAD_8 = 158,
		type_NUMPAD_1 = 151,
		type_NUMPAD_3 = 153,
		type_NUMPAD_5 = 155,
		type_NUMPAD_7 = 157,
		type_NUMPAD_9 = 159,
		type_NUMPAD_PERIOD = 199,
		type_NUMPAD_SLASH = 161,
		type_NUMPAD_ASTERIX = 160,
		type_NUMPAD_0 = 150,
		type_NUMPAD_MINUS = 162,
		type_NUMPAD_ENTER = 163,
		type_NUMPAD_PLUS = 164,
		type_F1 = 300,
		type_F2 = 301,
		type_F3 = 302,
		type_F4 = 303,
		type_F5 = 304,
		type_F6 = 305,
		type_F7 = 306,
		type_F8 = 307,
		type_F9 = 308,
		type_F10 = 309,
		type_F11 = 310,
		type_F12 = 311,
		type_F13 = 312,
		type_F14 = 313,
		type_F15 = 314,
		type_F16 = 315,
		type_F17 = 316,
		type_F18 = 317,
		type_F19 = 318,
		type_F20 = 319,
		type_F21 = 320,
		type_F22 = 321,
		type_F23 = 322,
		type_F24 = 323,
		type_PAUSE = 165,
		type_INSERT = 166,
		type_HOME = 167,
		type_PAGE_UP = 168,
		type_PAGE_DOWN = 169,
		type_END = 170,
		type_MEDIA_PLAY = 174,
		type_MEDIA_STOP = 175,
		type_MEDIA_FIRST = 176,
		type_MEDIA_LAST = 177,
		type_TEXTINPUT = -2,
		type_WINDOW_DEACTIVATE = 260,
		type_TIMER = 272,
		type_TIMER0 = 273,
		type_TIMER1 = 274,
		type_TIMER2 = 275,
		type_TIMER_JOBS = 276,
		type_TIMER_AUTOSAVE = 277,
		type_TIMER_REPORT = 278,
		type_TIMERREGION = 279,
		type_NDOF_MOTION = 400,
		type_NDOF_BUTTON_MENU = 401,
		type_NDOF_BUTTON_FIT = 402,
		type_NDOF_BUTTON_TOP = 403,
		type_NDOF_BUTTON_BOTTOM = 404,
		type_NDOF_BUTTON_LEFT = 405,
		type_NDOF_BUTTON_RIGHT = 406,
		type_NDOF_BUTTON_FRONT = 407,
		type_NDOF_BUTTON_BACK = 408,
		type_NDOF_BUTTON_ISO1 = 409,
		type_NDOF_BUTTON_ISO2 = 410,
		type_NDOF_BUTTON_ROLL_CW = 411,
		type_NDOF_BUTTON_ROLL_CCW = 412,
		type_NDOF_BUTTON_SPIN_CW = 413,
		type_NDOF_BUTTON_SPIN_CCW = 414,
		type_NDOF_BUTTON_TILT_CW = 415,
		type_NDOF_BUTTON_TILT_CCW = 416,
		type_NDOF_BUTTON_ROTATE = 417,
		type_NDOF_BUTTON_PANZOOM = 418,
		type_NDOF_BUTTON_DOMINANT = 419,
		type_NDOF_BUTTON_PLUS = 420,
		type_NDOF_BUTTON_MINUS = 421,
		type_NDOF_BUTTON_V1 = 422,
		type_NDOF_BUTTON_V2 = 423,
		type_NDOF_BUTTON_V3 = 424,
		type_NDOF_BUTTON_1 = 426,
		type_NDOF_BUTTON_2 = 427,
		type_NDOF_BUTTON_3 = 428,
		type_NDOF_BUTTON_4 = 429,
		type_NDOF_BUTTON_5 = 430,
		type_NDOF_BUTTON_6 = 431,
		type_NDOF_BUTTON_7 = 432,
		type_NDOF_BUTTON_8 = 433,
		type_NDOF_BUTTON_9 = 434,
		type_NDOF_BUTTON_10 = 435,
		type_NDOF_BUTTON_A = 436,
		type_NDOF_BUTTON_B = 437,
		type_NDOF_BUTTON_C = 438,
		type_ACTIONZONE_AREA = 20480,
		type_ACTIONZONE_REGION = 20481,
		type_ACTIONZONE_FULLSCREEN = 20497,
		type_XR_ACTION = 20528,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	enum value_enum {
		value_ANY = -1,
		value_PRESS = 1,
		value_RELEASE = 2,
		value_CLICK = 3,
		value_DOUBLE_CLICK = 4,
		value_CLICK_DRAG = 5,
		value_NOTHING = 0,
	};
	inline value_enum value(void);
	inline void value(value_enum value);
	enum direction_enum {
		direction_ANY = -1,
		direction_NORTH = 1,
		direction_NORTH_EAST = 2,
		direction_EAST = 3,
		direction_SOUTH_EAST = 4,
		direction_SOUTH = 5,
		direction_SOUTH_WEST = 6,
		direction_WEST = 7,
		direction_NORTH_WEST = 8,
	};
	inline direction_enum direction(void);
	inline void direction(direction_enum value);
	inline int id(void);
	inline void id(int value);
	inline bool any(void);
	inline void any(bool value);
	inline int shift(void);
	inline void shift(int value);
	inline int ctrl(void);
	inline void ctrl(int value);
	inline int alt(void);
	inline void alt(int value);
	inline int oskey(void);
	inline void oskey(int value);
	inline bool shift_ui(void);
	inline void shift_ui(bool value);
	inline bool ctrl_ui(void);
	inline void ctrl_ui(bool value);
	inline bool alt_ui(void);
	inline void alt_ui(bool value);
	inline bool oskey_ui(void);
	inline void oskey_ui(bool value);
	enum key_modifier_enum {
		key_modifier_NONE = 0,
		key_modifier_LEFTMOUSE = 1,
		key_modifier_MIDDLEMOUSE = 2,
		key_modifier_RIGHTMOUSE = 3,
		key_modifier_BUTTON4MOUSE = 7,
		key_modifier_BUTTON5MOUSE = 8,
		key_modifier_BUTTON6MOUSE = 18,
		key_modifier_BUTTON7MOUSE = 19,
		key_modifier_PEN = 26,
		key_modifier_ERASER = 27,
		key_modifier_MOUSEMOVE = 4,
		key_modifier_INBETWEEN_MOUSEMOVE = 17,
		key_modifier_TRACKPADPAN = 14,
		key_modifier_TRACKPADZOOM = 15,
		key_modifier_MOUSEROTATE = 16,
		key_modifier_MOUSESMARTZOOM = 23,
		key_modifier_WHEELUPMOUSE = 10,
		key_modifier_WHEELDOWNMOUSE = 11,
		key_modifier_WHEELINMOUSE = 12,
		key_modifier_WHEELOUTMOUSE = 13,
		key_modifier_A = 97,
		key_modifier_B = 98,
		key_modifier_C = 99,
		key_modifier_D = 100,
		key_modifier_E = 101,
		key_modifier_F = 102,
		key_modifier_G = 103,
		key_modifier_H = 104,
		key_modifier_I = 105,
		key_modifier_J = 106,
		key_modifier_K = 107,
		key_modifier_L = 108,
		key_modifier_M = 109,
		key_modifier_N = 110,
		key_modifier_O = 111,
		key_modifier_P = 112,
		key_modifier_Q = 113,
		key_modifier_R = 114,
		key_modifier_S = 115,
		key_modifier_T = 116,
		key_modifier_U = 117,
		key_modifier_V = 118,
		key_modifier_W = 119,
		key_modifier_X = 120,
		key_modifier_Y = 121,
		key_modifier_Z = 122,
		key_modifier_ZERO = 48,
		key_modifier_ONE = 49,
		key_modifier_TWO = 50,
		key_modifier_THREE = 51,
		key_modifier_FOUR = 52,
		key_modifier_FIVE = 53,
		key_modifier_SIX = 54,
		key_modifier_SEVEN = 55,
		key_modifier_EIGHT = 56,
		key_modifier_NINE = 57,
		key_modifier_LEFT_CTRL = 212,
		key_modifier_LEFT_ALT = 213,
		key_modifier_LEFT_SHIFT = 217,
		key_modifier_RIGHT_ALT = 214,
		key_modifier_RIGHT_CTRL = 215,
		key_modifier_RIGHT_SHIFT = 216,
		key_modifier_OSKEY = 172,
		key_modifier_APP = 178,
		key_modifier_GRLESS = 173,
		key_modifier_ESC = 218,
		key_modifier_TAB = 219,
		key_modifier_RET = 220,
		key_modifier_SPACE = 221,
		key_modifier_LINE_FEED = 222,
		key_modifier_BACK_SPACE = 223,
		key_modifier_DEL = 224,
		key_modifier_SEMI_COLON = 225,
		key_modifier_PERIOD = 226,
		key_modifier_COMMA = 227,
		key_modifier_QUOTE = 228,
		key_modifier_ACCENT_GRAVE = 229,
		key_modifier_MINUS = 230,
		key_modifier_PLUS = 231,
		key_modifier_SLASH = 232,
		key_modifier_BACK_SLASH = 233,
		key_modifier_EQUAL = 234,
		key_modifier_LEFT_BRACKET = 235,
		key_modifier_RIGHT_BRACKET = 236,
		key_modifier_LEFT_ARROW = 137,
		key_modifier_DOWN_ARROW = 138,
		key_modifier_RIGHT_ARROW = 139,
		key_modifier_UP_ARROW = 140,
		key_modifier_NUMPAD_2 = 152,
		key_modifier_NUMPAD_4 = 154,
		key_modifier_NUMPAD_6 = 156,
		key_modifier_NUMPAD_8 = 158,
		key_modifier_NUMPAD_1 = 151,
		key_modifier_NUMPAD_3 = 153,
		key_modifier_NUMPAD_5 = 155,
		key_modifier_NUMPAD_7 = 157,
		key_modifier_NUMPAD_9 = 159,
		key_modifier_NUMPAD_PERIOD = 199,
		key_modifier_NUMPAD_SLASH = 161,
		key_modifier_NUMPAD_ASTERIX = 160,
		key_modifier_NUMPAD_0 = 150,
		key_modifier_NUMPAD_MINUS = 162,
		key_modifier_NUMPAD_ENTER = 163,
		key_modifier_NUMPAD_PLUS = 164,
		key_modifier_F1 = 300,
		key_modifier_F2 = 301,
		key_modifier_F3 = 302,
		key_modifier_F4 = 303,
		key_modifier_F5 = 304,
		key_modifier_F6 = 305,
		key_modifier_F7 = 306,
		key_modifier_F8 = 307,
		key_modifier_F9 = 308,
		key_modifier_F10 = 309,
		key_modifier_F11 = 310,
		key_modifier_F12 = 311,
		key_modifier_F13 = 312,
		key_modifier_F14 = 313,
		key_modifier_F15 = 314,
		key_modifier_F16 = 315,
		key_modifier_F17 = 316,
		key_modifier_F18 = 317,
		key_modifier_F19 = 318,
		key_modifier_F20 = 319,
		key_modifier_F21 = 320,
		key_modifier_F22 = 321,
		key_modifier_F23 = 322,
		key_modifier_F24 = 323,
		key_modifier_PAUSE = 165,
		key_modifier_INSERT = 166,
		key_modifier_HOME = 167,
		key_modifier_PAGE_UP = 168,
		key_modifier_PAGE_DOWN = 169,
		key_modifier_END = 170,
		key_modifier_MEDIA_PLAY = 174,
		key_modifier_MEDIA_STOP = 175,
		key_modifier_MEDIA_FIRST = 176,
		key_modifier_MEDIA_LAST = 177,
		key_modifier_TEXTINPUT = -2,
		key_modifier_WINDOW_DEACTIVATE = 260,
		key_modifier_TIMER = 272,
		key_modifier_TIMER0 = 273,
		key_modifier_TIMER1 = 274,
		key_modifier_TIMER2 = 275,
		key_modifier_TIMER_JOBS = 276,
		key_modifier_TIMER_AUTOSAVE = 277,
		key_modifier_TIMER_REPORT = 278,
		key_modifier_TIMERREGION = 279,
		key_modifier_NDOF_MOTION = 400,
		key_modifier_NDOF_BUTTON_MENU = 401,
		key_modifier_NDOF_BUTTON_FIT = 402,
		key_modifier_NDOF_BUTTON_TOP = 403,
		key_modifier_NDOF_BUTTON_BOTTOM = 404,
		key_modifier_NDOF_BUTTON_LEFT = 405,
		key_modifier_NDOF_BUTTON_RIGHT = 406,
		key_modifier_NDOF_BUTTON_FRONT = 407,
		key_modifier_NDOF_BUTTON_BACK = 408,
		key_modifier_NDOF_BUTTON_ISO1 = 409,
		key_modifier_NDOF_BUTTON_ISO2 = 410,
		key_modifier_NDOF_BUTTON_ROLL_CW = 411,
		key_modifier_NDOF_BUTTON_ROLL_CCW = 412,
		key_modifier_NDOF_BUTTON_SPIN_CW = 413,
		key_modifier_NDOF_BUTTON_SPIN_CCW = 414,
		key_modifier_NDOF_BUTTON_TILT_CW = 415,
		key_modifier_NDOF_BUTTON_TILT_CCW = 416,
		key_modifier_NDOF_BUTTON_ROTATE = 417,
		key_modifier_NDOF_BUTTON_PANZOOM = 418,
		key_modifier_NDOF_BUTTON_DOMINANT = 419,
		key_modifier_NDOF_BUTTON_PLUS = 420,
		key_modifier_NDOF_BUTTON_MINUS = 421,
		key_modifier_NDOF_BUTTON_V1 = 422,
		key_modifier_NDOF_BUTTON_V2 = 423,
		key_modifier_NDOF_BUTTON_V3 = 424,
		key_modifier_NDOF_BUTTON_1 = 426,
		key_modifier_NDOF_BUTTON_2 = 427,
		key_modifier_NDOF_BUTTON_3 = 428,
		key_modifier_NDOF_BUTTON_4 = 429,
		key_modifier_NDOF_BUTTON_5 = 430,
		key_modifier_NDOF_BUTTON_6 = 431,
		key_modifier_NDOF_BUTTON_7 = 432,
		key_modifier_NDOF_BUTTON_8 = 433,
		key_modifier_NDOF_BUTTON_9 = 434,
		key_modifier_NDOF_BUTTON_10 = 435,
		key_modifier_NDOF_BUTTON_A = 436,
		key_modifier_NDOF_BUTTON_B = 437,
		key_modifier_NDOF_BUTTON_C = 438,
		key_modifier_ACTIONZONE_AREA = 20480,
		key_modifier_ACTIONZONE_REGION = 20481,
		key_modifier_ACTIONZONE_FULLSCREEN = 20497,
		key_modifier_XR_ACTION = 20528,
	};
	inline key_modifier_enum key_modifier(void);
	inline void key_modifier(key_modifier_enum value);
	inline bool repeat(void);
	inline void repeat(bool value);
	inline bool show_expanded(void);
	inline void show_expanded(bool value);
	enum propvalue_enum {
		propvalue_NONE = 0,
	};
	inline propvalue_enum propvalue(void);
	inline void propvalue(propvalue_enum value);
	inline bool active(void);
	inline void active(bool value);
	inline bool is_user_modified(void);
	inline void is_user_modified(bool value);
	inline bool is_user_defined(void);
	inline void is_user_defined(bool value);

	inline bool compare(KeyMapItem& item);
	inline void to_string(bool compact, char * result);
};

/**************** GizmoGroup ****************/

class GizmoGroup : public Pointer {
public:
	GizmoGroup(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		gizmos(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline std::string bl_label(void);
	inline void bl_label(const std::string& value);
	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_CONSOLE = 18,
		bl_space_type_INFO = 7,
		bl_space_type_TOPBAR = 21,
		bl_space_type_STATUSBAR = 22,
		bl_space_type_OUTLINER = 3,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_SPREADSHEET = 23,
		bl_space_type_PREFERENCES = 19,
	};
	inline bl_space_type_enum bl_space_type(void);
	inline void bl_space_type(bl_space_type_enum value);
	enum bl_region_type_enum {
		bl_region_type_WINDOW = 0,
		bl_region_type_HEADER = 1,
		bl_region_type_CHANNELS = 2,
		bl_region_type_TEMPORARY = 3,
		bl_region_type_UI = 4,
		bl_region_type_TOOLS = 5,
		bl_region_type_TOOL_PROPS = 6,
		bl_region_type_ASSET_SHELF = 14,
		bl_region_type_ASSET_SHELF_HEADER = 15,
		bl_region_type_PREVIEW = 7,
		bl_region_type_HUD = 8,
		bl_region_type_NAVIGATION_BAR = 9,
		bl_region_type_EXECUTE = 10,
		bl_region_type_FOOTER = 11,
		bl_region_type_TOOL_HEADER = 12,
		bl_region_type_XR = 13,
	};
	inline bl_region_type_enum bl_region_type(void);
	inline void bl_region_type(bl_region_type_enum value);
	inline std::string bl_owner_id(void);
	inline void bl_owner_id(const std::string& value);
	enum bl_options_enum {
		bl_options_3D = 1,
		bl_options_SCALE = 2,
		bl_options_DEPTH_3D = 4,
		bl_options_SELECT = 8,
		bl_options_PERSISTENT = 16,
		bl_options_SHOW_MODAL_ALL = 32,
		bl_options_EXCLUDE_MODAL = 64,
		bl_options_TOOL_INIT = 128,
		bl_options_TOOL_FALLBACK_KEYMAP = 256,
		bl_options_VR_REDRAWS = 1024,
	};
	inline bl_options_enum bl_options(void);
	inline void bl_options(bl_options_enum value);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool has_reports(void);
	inline void has_reports(bool value);
	COLLECTION_PROPERTY(Gizmos, Gizmo, GizmoGroup, gizmos, false, true, false)

};

/**************** Gizmo ****************/

class Gizmo : public Pointer {
public:
	Gizmo(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline GizmoProperties properties(void);
	inline std::string bl_idname(void);
	inline void bl_idname(const std::string& value);
	inline GizmoGroup group(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float alpha(void);
	inline void alpha(float value);
	inline Array<float, 3> color_highlight(void);
	inline void color_highlight(float values[3]);
	inline float alpha_highlight(void);
	inline void alpha_highlight(float value);
	inline Array<float, 16> matrix_space(void);
	inline void matrix_space(float values[16]);
	inline Array<float, 16> matrix_basis(void);
	inline void matrix_basis(float values[16]);
	inline Array<float, 16> matrix_offset(void);
	inline void matrix_offset(float values[16]);
	inline Array<float, 16> matrix_world(void);
	inline void matrix_world(float values[16]);
	inline float scale_basis(void);
	inline void scale_basis(float value);
	inline float line_width(void);
	inline void line_width(float value);
	inline float select_bias(void);
	inline void select_bias(float value);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool hide_keymap(void);
	inline void hide_keymap(bool value);
	inline bool use_grab_cursor(void);
	inline void use_grab_cursor(bool value);
	inline bool use_draw_hover(void);
	inline void use_draw_hover(bool value);
	inline bool use_draw_modal(void);
	inline void use_draw_modal(bool value);
	inline bool use_draw_value(void);
	inline void use_draw_value(bool value);
	inline bool use_draw_offset_scale(void);
	inline void use_draw_offset_scale(bool value);
	inline bool use_draw_scale(void);
	inline void use_draw_scale(bool value);
	inline bool use_select_background(void);
	inline void use_select_background(bool value);
	inline bool use_operator_tool_properties(void);
	inline void use_operator_tool_properties(bool value);
	inline bool use_event_handle_all(void);
	inline void use_event_handle_all(bool value);
	inline bool use_tooltip(void);
	inline void use_tooltip(bool value);
	inline bool is_highlight(void);
	inline void is_highlight(bool value);
	inline bool is_modal(void);
	inline void is_modal(bool value);
	inline bool select(void);
	inline void select(bool value);

	inline void draw_preset_box(float matrix[16], int select_id);
	inline void draw_preset_arrow(float matrix[16], int axis, int select_id);
	inline void draw_preset_circle(float matrix[16], int axis, int select_id);
	inline void target_set_prop(const char * target, AnyType& data, const char * property, int index);
	inline OperatorProperties target_set_operator(const char * operator_value, int index);
	inline bool target_is_valid(const char * property);
};

/**************** Gizmo Properties ****************/

class GizmoProperties : public Pointer {
public:
	GizmoProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Gizmo Group Properties ****************/

class GizmoGroupProperties : public Pointer {
public:
	GizmoGroupProperties(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Work Space UI Tag ****************/

class wmOwnerID : public Pointer {
public:
	wmOwnerID(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);

};

/**************** Work Space Tool ****************/

class WorkSpaceTool : public Pointer {
public:
	WorkSpaceTool(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string idname(void);
	inline void idname(const std::string& value);
	inline std::string idname_fallback(void);
	inline void idname_fallback(const std::string& value);
	inline int index(void);
	inline void index(int value);
	enum space_type_enum {
		space_type_EMPTY = 0,
		space_type_VIEW_3D = 1,
		space_type_IMAGE_EDITOR = 6,
		space_type_NODE_EDITOR = 16,
		space_type_SEQUENCE_EDITOR = 8,
		space_type_CLIP_EDITOR = 20,
		space_type_DOPESHEET_EDITOR = 12,
		space_type_GRAPH_EDITOR = 2,
		space_type_NLA_EDITOR = 13,
		space_type_TEXT_EDITOR = 9,
		space_type_CONSOLE = 18,
		space_type_INFO = 7,
		space_type_TOPBAR = 21,
		space_type_STATUSBAR = 22,
		space_type_OUTLINER = 3,
		space_type_PROPERTIES = 4,
		space_type_FILE_BROWSER = 5,
		space_type_SPREADSHEET = 23,
		space_type_PREFERENCES = 19,
	};
	inline space_type_enum space_type(void);
	inline void space_type(space_type_enum value);
	enum mode_enum {
		mode_DEFAULT = 0,
	};
	inline mode_enum mode(void);
	inline void mode(mode_enum value);
	inline bool use_paint_canvas(void);
	inline void use_paint_canvas(bool value);
	inline bool has_datablock(void);
	inline void has_datablock(bool value);
	inline std::string widget(void);
	inline void widget(const std::string& value);

	inline void setup(Context C, const char * idname, int cursor, const char * keymap, const char * gizmo_group, const char * data_block, const char * operator_value, int index, int options, const char * idname_fallback, const char * keymap_fallback);
	inline OperatorProperties operator_properties(const char * operator_value);
	inline GizmoGroupProperties gizmo_group_properties(const char * group);
	inline void refresh_from_context(void *main);
};

/**************** Workspace ****************/

class WorkSpace : public ID {
public:
	WorkSpace(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		screens(ptr_arg),
		owner_ids(ptr_arg),
		tools(ptr_arg)
		{}

	COLLECTION_PROPERTY(DefaultCollectionFunctions, Screen, WorkSpace, screens, false, true, true)
	COLLECTION_PROPERTY(wmOwnerIDs, wmOwnerID, WorkSpace, owner_ids, false, true, true)
	COLLECTION_PROPERTY(wmTools, WorkSpaceTool, WorkSpace, tools, false, true, true)
	enum object_mode_enum {
		object_mode_OBJECT = 0,
		object_mode_EDIT = 1,
		object_mode_POSE = 64,
		object_mode_SCULPT = 2,
		object_mode_VERTEX_PAINT = 4,
		object_mode_WEIGHT_PAINT = 8,
		object_mode_TEXTURE_PAINT = 16,
		object_mode_PARTICLE_EDIT = 32,
		object_mode_EDIT_GPENCIL = 128,
		object_mode_SCULPT_GPENCIL = 512,
		object_mode_PAINT_GPENCIL = 256,
		object_mode_VERTEX_GPENCIL = 2048,
		object_mode_WEIGHT_GPENCIL = 1024,
	};
	inline object_mode_enum object_mode(void);
	inline void object_mode(object_mode_enum value);
	inline bool use_pin_scene(void);
	inline void use_pin_scene(bool value);
	inline bool use_filter_by_owner(void);
	inline void use_filter_by_owner(bool value);
	enum asset_library_reference_enum {
	};
	inline asset_library_reference_enum asset_library_reference(void);
	inline void asset_library_reference(asset_library_reference_enum value);

	inline void status_text_set_internal(Context C, const char * text);
};

/**************** World ****************/

class World : public ID {
public:
	World(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline AnimData animation_data(void);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline WorldLighting light_settings(void);
	inline WorldMistSettings mist_settings(void);
	inline NodeTree node_tree(void);
	inline bool use_nodes(void);
	inline void use_nodes(bool value);
	inline std::string lightgroup(void);
	inline void lightgroup(const std::string& value);
	enum probe_resolution_enum {
		probe_resolution_64 = 6,
		probe_resolution_128 = 7,
		probe_resolution_256 = 8,
		probe_resolution_512 = 9,
		probe_resolution_1024 = 10,
		probe_resolution_2048 = 11,
	};
	inline probe_resolution_enum probe_resolution(void);
	inline void probe_resolution(probe_resolution_enum value);

};

/**************** Lighting ****************/

class WorldLighting : public Pointer {
public:
	WorldLighting(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float ao_factor(void);
	inline void ao_factor(float value);
	inline float distance(void);
	inline void distance(float value);

};

/**************** World Mist ****************/

class WorldMistSettings : public Pointer {
public:
	WorldMistSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_mist(void);
	inline void use_mist(bool value);
	inline float intensity(void);
	inline void intensity(float value);
	inline float start(void);
	inline void start(float value);
	inline float depth(void);
	inline void depth(float value);
	inline float height(void);
	inline void height(float value);
	enum falloff_enum {
		falloff_QUADRATIC = 0,
		falloff_LINEAR = 1,
		falloff_INVERSE_QUADRATIC = 2,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);

};

/**************** MovieClip ****************/

class MovieClip : public ID {
public:
	MovieClip(const PointerRNA &ptr_arg) :
		ID(ptr_arg)
		{}

	inline std::string filepath(void);
	inline void filepath(const std::string& value);
	inline MovieTracking tracking(void);
	inline MovieClipProxy proxy(void);
	inline bool use_proxy(void);
	inline void use_proxy(bool value);
	inline Array<int, 2> size(void);
	inline void size(int values[2]);
	inline Array<float, 2> display_aspect(void);
	inline void display_aspect(float values[2]);
	enum source_enum {
		source_SEQUENCE = 1,
		source_MOVIE = 2,
	};
	inline source_enum source(void);
	inline void source(source_enum value);
	inline bool use_proxy_custom_directory(void);
	inline void use_proxy_custom_directory(bool value);
	inline GreasePencil grease_pencil(void);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_offset(void);
	inline void frame_offset(int value);
	inline int frame_duration(void);
	inline void frame_duration(int value);
	inline float fps(void);
	inline void fps(float value);
	inline ColorManagedInputColorspaceSettings colorspace_settings(void);
	inline AnimData animation_data(void);

	inline IDPropertyWrapPtr metadata();
};

/**************** Movie Clip Proxy ****************/

class MovieClipProxy : public Pointer {
public:
	MovieClipProxy(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool build_25(void);
	inline void build_25(bool value);
	inline bool build_50(void);
	inline void build_50(bool value);
	inline bool build_75(void);
	inline void build_75(bool value);
	inline bool build_100(void);
	inline void build_100(bool value);
	inline bool build_undistorted_25(void);
	inline void build_undistorted_25(bool value);
	inline bool build_undistorted_50(void);
	inline void build_undistorted_50(bool value);
	inline bool build_undistorted_75(void);
	inline void build_undistorted_75(bool value);
	inline bool build_undistorted_100(void);
	inline void build_undistorted_100(bool value);
	inline bool build_record_run(void);
	inline void build_record_run(bool value);
	inline bool build_free_run(void);
	inline void build_free_run(bool value);
	inline bool build_free_run_rec_date(void);
	inline void build_free_run_rec_date(bool value);
	inline int quality(void);
	inline void quality(int value);
	enum timecode_enum {
		timecode_NONE = 0,
		timecode_RECORD_RUN = 1,
		timecode_FREE_RUN = 2,
		timecode_FREE_RUN_REC_DATE = 4,
		timecode_FREE_RUN_NO_GAPS = 8,
	};
	inline timecode_enum timecode(void);
	inline void timecode(timecode_enum value);
	inline std::string directory(void);
	inline void directory(const std::string& value);

};

/**************** Movie Clip User ****************/

class MovieClipUser : public Pointer {
public:
	MovieClipUser(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame_current(void);
	inline void frame_current(int value);
	enum proxy_render_size_enum {
		proxy_render_size_PROXY_25 = 1,
		proxy_render_size_PROXY_50 = 2,
		proxy_render_size_PROXY_75 = 3,
		proxy_render_size_PROXY_100 = 4,
		proxy_render_size_FULL = 0,
	};
	inline proxy_render_size_enum proxy_render_size(void);
	inline void proxy_render_size(proxy_render_size_enum value);
	inline bool use_render_undistorted(void);
	inline void use_render_undistorted(bool value);

};

/**************** MovieClipScopes ****************/

class MovieClipScopes : public Pointer {
public:
	MovieClipScopes(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);

};

/**************** Movie tracking settings ****************/

class MovieTrackingSettings : public Pointer {
public:
	MovieTrackingSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum speed_enum {
		speed_FASTEST = 0,
		speed_DOUBLE = 5,
		speed_REALTIME = 1,
		speed_HALF = 2,
		speed_QUARTER = 4,
	};
	inline speed_enum speed(void);
	inline void speed(speed_enum value);
	inline bool use_keyframe_selection(void);
	inline void use_keyframe_selection(bool value);
	inline bool refine_intrinsics_focal_length(void);
	inline void refine_intrinsics_focal_length(bool value);
	inline bool refine_intrinsics_principal_point(void);
	inline void refine_intrinsics_principal_point(bool value);
	inline bool refine_intrinsics_radial_distortion(void);
	inline void refine_intrinsics_radial_distortion(bool value);
	inline bool refine_intrinsics_tangential_distortion(void);
	inline void refine_intrinsics_tangential_distortion(bool value);
	inline float distance(void);
	inline void distance(float value);
	inline int clean_frames(void);
	inline void clean_frames(int value);
	inline float clean_error(void);
	inline void clean_error(float value);
	enum clean_action_enum {
		clean_action_SELECT = 0,
		clean_action_DELETE_TRACK = 1,
		clean_action_DELETE_SEGMENTS = 2,
	};
	inline clean_action_enum clean_action(void);
	inline void clean_action(clean_action_enum value);
	inline bool use_tripod_solver(void);
	inline void use_tripod_solver(bool value);
	inline int default_frames_limit(void);
	inline void default_frames_limit(int value);
	enum default_pattern_match_enum {
		default_pattern_match_KEYFRAME = 0,
		default_pattern_match_PREV_FRAME = 1,
	};
	inline default_pattern_match_enum default_pattern_match(void);
	inline void default_pattern_match(default_pattern_match_enum value);
	inline int default_margin(void);
	inline void default_margin(int value);
	enum default_motion_model_enum {
		default_motion_model_Perspective = 5,
		default_motion_model_Affine = 4,
		default_motion_model_LocRotScale = 3,
		default_motion_model_LocScale = 2,
		default_motion_model_LocRot = 1,
		default_motion_model_Loc = 0,
	};
	inline default_motion_model_enum default_motion_model(void);
	inline void default_motion_model(default_motion_model_enum value);
	inline bool use_default_brute(void);
	inline void use_default_brute(bool value);
	inline bool use_default_mask(void);
	inline void use_default_mask(bool value);
	inline bool use_default_normalization(void);
	inline void use_default_normalization(bool value);
	inline float default_correlation_min(void);
	inline void default_correlation_min(float value);
	inline int default_pattern_size(void);
	inline void default_pattern_size(int value);
	inline int default_search_size(void);
	inline void default_search_size(int value);
	inline bool use_default_red_channel(void);
	inline void use_default_red_channel(bool value);
	inline bool use_default_green_channel(void);
	inline void use_default_green_channel(bool value);
	inline bool use_default_blue_channel(void);
	inline void use_default_blue_channel(bool value);
	inline float default_weight(void);
	inline void default_weight(float value);
	inline float object_distance(void);
	inline void object_distance(float value);

};

/**************** Movie tracking camera data ****************/

class MovieTrackingCamera : public Pointer {
public:
	MovieTrackingCamera(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum distortion_model_enum {
		distortion_model_POLYNOMIAL = 0,
		distortion_model_DIVISION = 1,
		distortion_model_NUKE = 2,
		distortion_model_BROWN = 3,
	};
	inline distortion_model_enum distortion_model(void);
	inline void distortion_model(distortion_model_enum value);
	inline float sensor_width(void);
	inline void sensor_width(float value);
	inline float focal_length(void);
	inline void focal_length(float value);
	inline float focal_length_pixels(void);
	inline void focal_length_pixels(float value);
	enum units_enum {
		units_PIXELS = 0,
		units_MILLIMETERS = 1,
	};
	inline units_enum units(void);
	inline void units(units_enum value);
	inline Array<float, 2> principal_point(void);
	inline void principal_point(float values[2]);
	inline Array<float, 2> principal_point_pixels(void);
	inline void principal_point_pixels(float values[2]);
	inline float k1(void);
	inline void k1(float value);
	inline float k2(void);
	inline void k2(float value);
	inline float k3(void);
	inline void k3(float value);
	inline float division_k1(void);
	inline void division_k1(float value);
	inline float division_k2(void);
	inline void division_k2(float value);
	inline float nuke_k1(void);
	inline void nuke_k1(float value);
	inline float nuke_k2(void);
	inline void nuke_k2(float value);
	inline float brown_k1(void);
	inline void brown_k1(float value);
	inline float brown_k2(void);
	inline void brown_k2(float value);
	inline float brown_k3(void);
	inline void brown_k3(float value);
	inline float brown_k4(void);
	inline void brown_k4(float value);
	inline float brown_p1(void);
	inline void brown_p1(float value);
	inline float brown_p2(void);
	inline void brown_p2(float value);
	inline float pixel_aspect(void);
	inline void pixel_aspect(float value);

};

/**************** Movie tracking marker data ****************/

class MovieTrackingMarker : public Pointer {
public:
	MovieTrackingMarker(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);
	inline int frame(void);
	inline void frame(int value);
	inline bool mute(void);
	inline void mute(bool value);
	inline Array<float, 8> pattern_corners(void);
	inline void pattern_corners(float values[8]);
	inline Array<float, 4> pattern_bound_box(void);
	inline void pattern_bound_box(float values[4]);
	inline Array<float, 2> search_min(void);
	inline void search_min(float values[2]);
	inline Array<float, 2> search_max(void);
	inline void search_max(float values[2]);
	inline bool is_keyed(void);
	inline void is_keyed(bool value);

};

/**************** Movie tracking track data ****************/

class MovieTrackingTrack : public Pointer {
public:
	MovieTrackingTrack(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		markers(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline int frames_limit(void);
	inline void frames_limit(int value);
	enum pattern_match_enum {
		pattern_match_KEYFRAME = 0,
		pattern_match_PREV_FRAME = 1,
	};
	inline pattern_match_enum pattern_match(void);
	inline void pattern_match(pattern_match_enum value);
	inline int margin(void);
	inline void margin(int value);
	enum motion_model_enum {
		motion_model_Perspective = 5,
		motion_model_Affine = 4,
		motion_model_LocRotScale = 3,
		motion_model_LocScale = 2,
		motion_model_LocRot = 1,
		motion_model_Loc = 0,
	};
	inline motion_model_enum motion_model(void);
	inline void motion_model(motion_model_enum value);
	inline float correlation_min(void);
	inline void correlation_min(float value);
	inline bool use_brute(void);
	inline void use_brute(bool value);
	inline bool use_mask(void);
	inline void use_mask(bool value);
	inline bool use_normalization(void);
	inline void use_normalization(bool value);
	COLLECTION_PROPERTY(MovieTrackingMarkers, MovieTrackingMarker, MovieTrackingTrack, markers, true, true, false)
	inline bool use_red_channel(void);
	inline void use_red_channel(bool value);
	inline bool use_green_channel(void);
	inline void use_green_channel(bool value);
	inline bool use_blue_channel(void);
	inline void use_blue_channel(bool value);
	inline bool use_grayscale_preview(void);
	inline void use_grayscale_preview(bool value);
	inline bool use_alpha_preview(void);
	inline void use_alpha_preview(bool value);
	inline bool has_bundle(void);
	inline void has_bundle(bool value);
	inline Array<float, 3> bundle(void);
	inline void bundle(float values[3]);
	inline bool hide(void);
	inline void hide(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline bool select_anchor(void);
	inline void select_anchor(bool value);
	inline bool select_pattern(void);
	inline void select_pattern(bool value);
	inline bool select_search(void);
	inline void select_search(bool value);
	inline bool lock(void);
	inline void lock(bool value);
	inline bool use_custom_color(void);
	inline void use_custom_color(bool value);
	inline Array<float, 3> color(void);
	inline void color(float values[3]);
	inline float average_error(void);
	inline void average_error(float value);
	inline GreasePencil grease_pencil(void);
	inline float weight(void);
	inline void weight(float value);
	inline float weight_stab(void);
	inline void weight_stab(float value);
	inline Array<float, 2> offset(void);
	inline void offset(float values[2]);

};

/**************** Movie Tracking Plane Marker Data ****************/

class MovieTrackingPlaneMarker : public Pointer {
public:
	MovieTrackingPlaneMarker(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame(void);
	inline void frame(int value);
	inline Array<float, 8> corners(void);
	inline void corners(float values[8]);
	inline bool mute(void);
	inline void mute(bool value);

};

/**************** Movie tracking plane track data ****************/

class MovieTrackingPlaneTrack : public Pointer {
public:
	MovieTrackingPlaneTrack(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		markers(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(MovieTrackingPlaneMarkers, MovieTrackingPlaneMarker, MovieTrackingPlaneTrack, markers, true, true, false)
	inline bool select(void);
	inline void select(bool value);
	inline bool use_auto_keying(void);
	inline void use_auto_keying(bool value);
	inline Image image(void);
	inline float image_opacity(void);
	inline void image_opacity(float value);

};

/**************** Movie tracking stabilization data ****************/

class MovieTrackingStabilization : public Pointer {
public:
	MovieTrackingStabilization(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tracks(ptr_arg),
		rotation_tracks(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool use_2d_stabilization(void);
	inline void use_2d_stabilization(bool value);
	inline bool use_stabilize_rotation(void);
	inline void use_stabilize_rotation(bool value);
	inline bool use_stabilize_scale(void);
	inline void use_stabilize_scale(bool value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MovieTrackingTrack, MovieTrackingStabilization, tracks, false, false, false)
	inline int active_track_index(void);
	inline void active_track_index(int value);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MovieTrackingTrack, MovieTrackingStabilization, rotation_tracks, false, false, false)
	inline int active_rotation_track_index(void);
	inline void active_rotation_track_index(int value);
	inline int anchor_frame(void);
	inline void anchor_frame(int value);
	inline Array<float, 2> target_position(void);
	inline void target_position(float values[2]);
	inline float target_rotation(void);
	inline void target_rotation(float value);
	inline float target_scale(void);
	inline void target_scale(float value);
	inline bool use_autoscale(void);
	inline void use_autoscale(bool value);
	inline float scale_max(void);
	inline void scale_max(float value);
	inline float influence_location(void);
	inline void influence_location(float value);
	inline float influence_scale(void);
	inline void influence_scale(float value);
	inline float influence_rotation(void);
	inline void influence_rotation(float value);
	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};
	inline filter_type_enum filter_type(void);
	inline void filter_type(filter_type_enum value);
	inline bool show_tracks_expanded(void);
	inline void show_tracks_expanded(bool value);

};

/**************** Movie tracking reconstructed camera data ****************/

class MovieReconstructedCamera : public Pointer {
public:
	MovieReconstructedCamera(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline int frame(void);
	inline void frame(int value);
	inline Array<float, 16> matrix(void);
	inline void matrix(float values[16]);
	inline float average_error(void);
	inline void average_error(float value);

};

/**************** Movie tracking reconstruction data ****************/

class MovieTrackingReconstruction : public Pointer {
public:
	MovieTrackingReconstruction(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		cameras(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline bool is_valid(void);
	inline void is_valid(bool value);
	inline float average_error(void);
	inline void average_error(float value);
	COLLECTION_PROPERTY(MovieTrackingReconstructedCameras, MovieReconstructedCamera, MovieTrackingReconstruction, cameras, true, true, false)

};

/**************** Movie tracking object data ****************/

class MovieTrackingObject : public Pointer {
public:
	MovieTrackingObject(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tracks(ptr_arg),
		plane_tracks(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline bool is_camera(void);
	inline void is_camera(bool value);
	COLLECTION_PROPERTY(MovieTrackingObjectTracks, MovieTrackingTrack, MovieTrackingObject, tracks, false, true, true)
	COLLECTION_PROPERTY(MovieTrackingObjectPlaneTracks, MovieTrackingPlaneTrack, MovieTrackingObject, plane_tracks, false, true, true)
	inline MovieTrackingReconstruction reconstruction(void);
	inline float scale(void);
	inline void scale(float value);
	inline int keyframe_a(void);
	inline void keyframe_a(int value);
	inline int keyframe_b(void);
	inline void keyframe_b(int value);

};

/**************** Movie Tracking Dopesheet ****************/

class MovieTrackingDopesheet : public Pointer {
public:
	MovieTrackingDopesheet(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum sort_method_enum {
		sort_method_NAME = 0,
		sort_method_LONGEST = 1,
		sort_method_TOTAL = 2,
		sort_method_AVERAGE_ERROR = 3,
		sort_method_START = 4,
		sort_method_END = 5,
	};
	inline sort_method_enum sort_method(void);
	inline void sort_method(sort_method_enum value);
	inline bool use_invert_sort(void);
	inline void use_invert_sort(bool value);
	inline bool show_only_selected(void);
	inline void show_only_selected(bool value);
	inline bool show_hidden(void);
	inline void show_hidden(bool value);

};

/**************** Movie tracking data ****************/

class MovieTracking : public Pointer {
public:
	MovieTracking(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		tracks(ptr_arg),
		plane_tracks(ptr_arg),
		objects(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline MovieTrackingSettings settings(void);
	inline MovieTrackingCamera camera(void);
	COLLECTION_PROPERTY(MovieTrackingTracks, MovieTrackingTrack, MovieTracking, tracks, false, false, false)
	COLLECTION_PROPERTY(MovieTrackingPlaneTracks, MovieTrackingPlaneTrack, MovieTracking, plane_tracks, false, false, false)
	inline MovieTrackingStabilization stabilization(void);
	inline MovieTrackingReconstruction reconstruction(void);
	COLLECTION_PROPERTY(MovieTrackingObjects, MovieTrackingObject, MovieTracking, objects, false, true, true)
	inline int active_object_index(void);
	inline void active_object_index(int value);
	inline MovieTrackingDopesheet dopesheet(void);

};

/**************** Mask Parent ****************/

class MaskParent : public Pointer {
public:
	MaskParent(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline ID id(void);
	enum id_type_enum {
		id_type_MOVIECLIP = 17229,
	};
	inline id_type_enum id_type(void);
	inline void id_type(id_type_enum value);
	enum type_enum {
		type_POINT_TRACK = 0,
		type_PLANE_TRACK = 1,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline std::string parent(void);
	inline void parent(const std::string& value);
	inline std::string sub_parent(void);
	inline void sub_parent(const std::string& value);

};

/**************** Mask Spline UW Point ****************/

class MaskSplinePointUW : public Pointer {
public:
	MaskSplinePointUW(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline float u(void);
	inline void u(float value);
	inline float weight(void);
	inline void weight(float value);
	inline bool select(void);
	inline void select(bool value);

};

/**************** Mask Spline Point ****************/

class MaskSplinePoint : public Pointer {
public:
	MaskSplinePoint(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		feather_points(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 2> handle_left(void);
	inline void handle_left(float values[2]);
	inline Array<float, 2> co(void);
	inline void co(float values[2]);
	inline Array<float, 2> handle_right(void);
	inline void handle_right(float values[2]);
	enum handle_type_enum {
		handle_type_AUTO = 1,
		handle_type_VECTOR = 2,
		handle_type_ALIGNED = 3,
		handle_type_ALIGNED_DOUBLESIDE = 5,
		handle_type_FREE = 0,
	};
	inline handle_type_enum handle_type(void);
	inline void handle_type(handle_type_enum value);
	enum handle_left_type_enum {
		handle_left_type_AUTO = 1,
		handle_left_type_VECTOR = 2,
		handle_left_type_ALIGNED = 3,
		handle_left_type_ALIGNED_DOUBLESIDE = 5,
		handle_left_type_FREE = 0,
	};
	inline handle_left_type_enum handle_left_type(void);
	inline void handle_left_type(handle_left_type_enum value);
	enum handle_right_type_enum {
		handle_right_type_AUTO = 1,
		handle_right_type_VECTOR = 2,
		handle_right_type_ALIGNED = 3,
		handle_right_type_ALIGNED_DOUBLESIDE = 5,
		handle_right_type_FREE = 0,
	};
	inline handle_right_type_enum handle_right_type(void);
	inline void handle_right_type(handle_right_type_enum value);
	inline float weight(void);
	inline void weight(float value);
	inline bool select(void);
	inline void select(bool value);
	inline MaskParent parent(void);
	COLLECTION_PROPERTY(DefaultCollectionFunctions, MaskSplinePointUW, MaskSplinePoint, feather_points, true, true, false)

};

/**************** Mask spline ****************/

class MaskSpline : public Pointer {
public:
	MaskSpline(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		points(ptr_arg)
		{}

	inline Struct rna_type(void);
	enum offset_mode_enum {
		offset_mode_EVEN = 0,
		offset_mode_SMOOTH = 1,
	};
	inline offset_mode_enum offset_mode(void);
	inline void offset_mode(offset_mode_enum value);
	enum weight_interpolation_enum {
		weight_interpolation_LINEAR = 1,
		weight_interpolation_EASE = 2,
	};
	inline weight_interpolation_enum weight_interpolation(void);
	inline void weight_interpolation(weight_interpolation_enum value);
	inline bool use_cyclic(void);
	inline void use_cyclic(bool value);
	inline bool use_fill(void);
	inline void use_fill(bool value);
	inline bool use_self_intersection_check(void);
	inline void use_self_intersection_check(bool value);
	COLLECTION_PROPERTY(MaskSplinePoints, MaskSplinePoint, MaskSpline, points, true, true, false)

};

/**************** Mask Layer ****************/

class MaskLayer : public Pointer {
public:
	MaskLayer(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		splines(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(MaskSplines, MaskSpline, MaskLayer, splines, false, true, false)
	inline bool hide(void);
	inline void hide(bool value);
	inline bool hide_select(void);
	inline void hide_select(bool value);
	inline bool hide_render(void);
	inline void hide_render(bool value);
	inline bool select(void);
	inline void select(bool value);
	inline float alpha(void);
	inline void alpha(float value);
	enum blend_enum {
		blend_MERGE_ADD = 7,
		blend_MERGE_SUBTRACT = 8,
		blend_ADD = 0,
		blend_SUBTRACT = 1,
		blend_LIGHTEN = 2,
		blend_DARKEN = 3,
		blend_MUL = 4,
		blend_REPLACE = 5,
		blend_DIFFERENCE = 6,
	};
	inline blend_enum blend(void);
	inline void blend(blend_enum value);
	inline bool invert(void);
	inline void invert(bool value);
	enum falloff_enum {
		falloff_SMOOTH = 0,
		falloff_SPHERE = 1,
		falloff_ROOT = 2,
		falloff_INVERSE_SQUARE = 7,
		falloff_SHARP = 3,
		falloff_LINEAR = 4,
	};
	inline falloff_enum falloff(void);
	inline void falloff(falloff_enum value);
	inline bool use_fill_holes(void);
	inline void use_fill_holes(bool value);
	inline bool use_fill_overlap(void);
	inline void use_fill_overlap(bool value);

};

/**************** Mask ****************/

class Mask : public ID {
public:
	Mask(const PointerRNA &ptr_arg) :
		ID(ptr_arg),
		layers(ptr_arg)
		{}

	COLLECTION_PROPERTY(MaskLayers, MaskLayer, Mask, layers, false, false, false)
	inline int active_layer_index(void);
	inline void active_layer_index(int value);
	inline int frame_start(void);
	inline void frame_start(int value);
	inline int frame_end(void);
	inline void frame_end(int value);
	inline AnimData animation_data(void);

};

/**************** XR Action Map ****************/

class XrActionMap : public Pointer {
public:
	XrActionMap(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		actionmap_items(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	COLLECTION_PROPERTY(XrActionMapItems, XrActionMapItem, XrActionMap, actionmap_items, true, true, true)
	inline int selected_item(void);
	inline void selected_item(int value);

};

/**************** XR User Path ****************/

class XrUserPath : public Pointer {
public:
	XrUserPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);

};

/**************** XR Action Map Item ****************/

class XrActionMapItem : public Pointer {
public:
	XrActionMapItem(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		user_paths(ptr_arg),
		bindings(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	enum type_enum {
		type_FLOAT = 2,
		type_VECTOR2D = 3,
		type_POSE = 4,
		type_VIBRATION = 100,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	COLLECTION_PROPERTY(XrUserPaths, XrUserPath, XrActionMapItem, user_paths, true, true, false)
	inline std::string op(void);
	inline void op(const std::string& value);
	inline std::string op_name(void);
	inline void op_name(const std::string& value);
	inline OperatorProperties op_properties(void);
	enum op_mode_enum {
		op_mode_PRESS = 0,
		op_mode_RELEASE = 1,
		op_mode_MODAL = 2,
	};
	inline op_mode_enum op_mode(void);
	inline void op_mode(op_mode_enum value);
	inline bool bimanual(void);
	inline void bimanual(bool value);
	inline bool pose_is_controller_grip(void);
	inline void pose_is_controller_grip(bool value);
	inline bool pose_is_controller_aim(void);
	inline void pose_is_controller_aim(bool value);
	inline std::string haptic_name(void);
	inline void haptic_name(const std::string& value);
	inline bool haptic_match_user_paths(void);
	inline void haptic_match_user_paths(bool value);
	inline float haptic_duration(void);
	inline void haptic_duration(float value);
	inline float haptic_frequency(void);
	inline void haptic_frequency(float value);
	inline float haptic_amplitude(void);
	inline void haptic_amplitude(float value);
	enum haptic_mode_enum {
		haptic_mode_PRESS = 2,
		haptic_mode_RELEASE = 4,
		haptic_mode_PRESS_RELEASE = 6,
		haptic_mode_REPEAT = 8,
	};
	inline haptic_mode_enum haptic_mode(void);
	inline void haptic_mode(haptic_mode_enum value);
	COLLECTION_PROPERTY(XrActionMapBindings, XrActionMapBinding, XrActionMapItem, bindings, true, true, true)
	inline int selected_binding(void);
	inline void selected_binding(int value);

};

/**************** XR Component Path ****************/

class XrComponentPath : public Pointer {
public:
	XrComponentPath(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string path(void);
	inline void path(const std::string& value);

};

/**************** XR Action Map Binding ****************/

class XrActionMapBinding : public Pointer {
public:
	XrActionMapBinding(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		component_paths(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string name(void);
	inline void name(const std::string& value);
	inline std::string profile(void);
	inline void profile(const std::string& value);
	COLLECTION_PROPERTY(XrComponentPaths, XrComponentPath, XrActionMapBinding, component_paths, true, true, false)
	inline float threshold(void);
	inline void threshold(float value);
	enum axis0_region_enum {
		axis0_region_ANY = 0,
		axis0_region_POSITIVE = 1,
		axis0_region_NEGATIVE = 2,
	};
	inline axis0_region_enum axis0_region(void);
	inline void axis0_region(axis0_region_enum value);
	enum axis1_region_enum {
		axis1_region_ANY = 0,
		axis1_region_POSITIVE = 4,
		axis1_region_NEGATIVE = 8,
	};
	inline axis1_region_enum axis1_region(void);
	inline void axis1_region(axis1_region_enum value);
	inline Array<float, 3> pose_location(void);
	inline void pose_location(float values[3]);
	inline Array<float, 3> pose_rotation(void);
	inline void pose_rotation(float values[3]);

};

/**************** XR Session Settings ****************/

class XrSessionSettings : public Pointer {
public:
	XrSessionSettings(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline View3DShading shading(void);
	enum base_pose_type_enum {
		base_pose_type_SCENE_CAMERA = 0,
		base_pose_type_OBJECT = 1,
		base_pose_type_CUSTOM = 2,
	};
	inline base_pose_type_enum base_pose_type(void);
	inline void base_pose_type(base_pose_type_enum value);
	inline Object base_pose_object(void);
	inline Array<float, 3> base_pose_location(void);
	inline void base_pose_location(float values[3]);
	inline float base_pose_angle(void);
	inline void base_pose_angle(float value);
	inline float base_scale(void);
	inline void base_scale(float value);
	inline bool show_floor(void);
	inline void show_floor(bool value);
	inline bool show_annotation(void);
	inline void show_annotation(bool value);
	inline bool show_selection(void);
	inline void show_selection(bool value);
	inline bool show_controllers(void);
	inline void show_controllers(bool value);
	inline bool show_custom_overlays(void);
	inline void show_custom_overlays(bool value);
	inline bool show_object_extras(void);
	inline void show_object_extras(bool value);
	enum controller_draw_style_enum {
		controller_draw_style_DARK = 0,
		controller_draw_style_LIGHT = 1,
		controller_draw_style_DARK_RAY = 2,
		controller_draw_style_LIGHT_RAY = 3,
	};
	inline controller_draw_style_enum controller_draw_style(void);
	inline void controller_draw_style(controller_draw_style_enum value);
	inline float clip_start(void);
	inline void clip_start(float value);
	inline float clip_end(void);
	inline void clip_end(float value);
	inline bool use_positional_tracking(void);
	inline void use_positional_tracking(bool value);
	inline bool use_absolute_tracking(void);
	inline void use_absolute_tracking(bool value);
	inline bool show_object_viewport_mesh(void);
	inline void show_object_viewport_mesh(bool value);
	inline bool show_object_viewport_curve(void);
	inline void show_object_viewport_curve(bool value);
	inline bool show_object_viewport_surf(void);
	inline void show_object_viewport_surf(bool value);
	inline bool show_object_viewport_meta(void);
	inline void show_object_viewport_meta(bool value);
	inline bool show_object_viewport_font(void);
	inline void show_object_viewport_font(bool value);
	inline bool show_object_viewport_curves(void);
	inline void show_object_viewport_curves(bool value);
	inline bool show_object_viewport_pointcloud(void);
	inline void show_object_viewport_pointcloud(bool value);
	inline bool show_object_viewport_volume(void);
	inline void show_object_viewport_volume(bool value);
	inline bool show_object_viewport_armature(void);
	inline void show_object_viewport_armature(bool value);
	inline bool show_object_viewport_lattice(void);
	inline void show_object_viewport_lattice(bool value);
	inline bool show_object_viewport_empty(void);
	inline void show_object_viewport_empty(bool value);
	inline bool show_object_viewport_grease_pencil(void);
	inline void show_object_viewport_grease_pencil(bool value);
	inline bool show_object_viewport_camera(void);
	inline void show_object_viewport_camera(bool value);
	inline bool show_object_viewport_light(void);
	inline void show_object_viewport_light(bool value);
	inline bool show_object_viewport_speaker(void);
	inline void show_object_viewport_speaker(bool value);
	inline bool show_object_viewport_light_probe(void);
	inline void show_object_viewport_light_probe(bool value);
	inline bool show_object_select_mesh(void);
	inline void show_object_select_mesh(bool value);
	inline bool show_object_select_curve(void);
	inline void show_object_select_curve(bool value);
	inline bool show_object_select_surf(void);
	inline void show_object_select_surf(bool value);
	inline bool show_object_select_meta(void);
	inline void show_object_select_meta(bool value);
	inline bool show_object_select_font(void);
	inline void show_object_select_font(bool value);
	inline bool show_object_select_curves(void);
	inline void show_object_select_curves(bool value);
	inline bool show_object_select_pointcloud(void);
	inline void show_object_select_pointcloud(bool value);
	inline bool show_object_select_volume(void);
	inline void show_object_select_volume(bool value);
	inline bool show_object_select_armature(void);
	inline void show_object_select_armature(bool value);
	inline bool show_object_select_lattice(void);
	inline void show_object_select_lattice(bool value);
	inline bool show_object_select_empty(void);
	inline void show_object_select_empty(bool value);
	inline bool show_object_select_grease_pencil(void);
	inline void show_object_select_grease_pencil(bool value);
	inline bool show_object_select_camera(void);
	inline void show_object_select_camera(bool value);
	inline bool show_object_select_light(void);
	inline void show_object_select_light(bool value);
	inline bool show_object_select_speaker(void);
	inline void show_object_select_speaker(bool value);
	inline bool show_object_select_light_probe(void);
	inline void show_object_select_light_probe(bool value);
	inline int icon_from_show_object_viewport(void);
	inline void icon_from_show_object_viewport(int value);

};

/**************** Session State ****************/

class XrSessionState : public Pointer {
public:
	XrSessionState(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg),
		actionmaps(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline Array<float, 3> viewer_pose_location(void);
	inline void viewer_pose_location(float values[3]);
	inline Array<float, 4> viewer_pose_rotation(void);
	inline void viewer_pose_rotation(float values[4]);
	inline Array<float, 3> navigation_location(void);
	inline void navigation_location(float values[3]);
	inline Array<float, 4> navigation_rotation(void);
	inline void navigation_rotation(float values[4]);
	inline float navigation_scale(void);
	inline void navigation_scale(float value);
	COLLECTION_PROPERTY(XrActionMaps, XrActionMap, XrSessionState, actionmaps, true, false, false)
	inline int active_actionmap(void);
	inline void active_actionmap(int value);
	inline int selected_actionmap(void);
	inline void selected_actionmap(int value);

	inline bool is_running(Context& context);
	inline void reset_to_base_pose(Context& context);
	inline bool action_set_create(Context& context, XrActionMap& actionmap);
	inline bool action_create(Context& context, XrActionMap& actionmap, XrActionMapItem& actionmap_item);
	inline bool action_binding_create(Context& context, XrActionMap& actionmap, XrActionMapItem& actionmap_item, XrActionMapBinding& actionmap_binding);
	inline bool active_action_set_set(Context& context, const char * action_set);
	inline bool controller_pose_actions_set(Context& context, const char * action_set, const char * grip_action, const char * aim_action);
	inline void action_state_get(Context& context, const char * action_set_name, const char * action_name, const char * user_path, float state[2]);
	inline bool haptic_action_apply(Context& context, const char * action_set_name, const char * action_name, const char * user_path, float duration, float frequency, float amplitude);
	inline void haptic_action_stop(Context& context, const char * action_set_name, const char * action_name, const char * user_path);
	inline void controller_grip_location_get(Context& context, int index, float location[3]);
	inline void controller_grip_rotation_get(Context& context, int index, float rotation[4]);
	inline void controller_aim_location_get(Context& context, int index, float location[3]);
	inline void controller_aim_rotation_get(Context& context, int index, float rotation[4]);
};

/**************** XrEventData ****************/

class XrEventData : public Pointer {
public:
	XrEventData(const PointerRNA &ptr_arg) :
		Pointer(ptr_arg)
		{}

	inline Struct rna_type(void);
	inline std::string action_set(void);
	inline void action_set(const std::string& value);
	inline std::string action(void);
	inline void action(const std::string& value);
	inline std::string user_path(void);
	inline void user_path(const std::string& value);
	inline std::string user_path_other(void);
	inline void user_path_other(const std::string& value);
	enum type_enum {
		type_FLOAT = 2,
		type_VECTOR2D = 3,
		type_POSE = 4,
		type_VIBRATION = 100,
	};
	inline type_enum type(void);
	inline void type(type_enum value);
	inline Array<float, 2> state(void);
	inline void state(float values[2]);
	inline Array<float, 2> state_other(void);
	inline void state_other(float values[2]);
	inline float float_threshold(void);
	inline void float_threshold(float value);
	inline Array<float, 3> controller_location(void);
	inline void controller_location(float values[3]);
	inline Array<float, 4> controller_rotation(void);
	inline void controller_rotation(float values[4]);
	inline Array<float, 3> controller_location_other(void);
	inline void controller_location_other(float values[3]);
	inline Array<float, 4> controller_rotation_other(void);
	inline void controller_rotation_other(float values[4]);
	inline bool bimanual(void);
	inline void bimanual(bool value);

};

} /* namespace BL */

/**************** Implementation ****************/

/* Structure prototypes */

extern "C" {
struct Depsgraph;
struct ID;
struct Scene;
struct ViewLayer;
struct AnimData;
struct PreviewImage;
struct Collection;
struct IDOverrideLibraryProperty;
struct IDOverrideLibraryPropertyOperation;
struct Material;
struct Object;
struct FCurve;
struct PointerRNA;
struct bActionGroup;
struct TimeMarker;
struct NlaTrack;
struct KS_Path;
struct EditBone;
struct BoneCollection;
struct AssetTag;
struct CacheFileLayer;
struct CameraBGImage;
struct CurveMapPoint;
struct CurveMap;
struct CBData;
struct bConstraintTarget;
struct Nurb;
struct BezTriple;
struct FModifier;
struct DriverVar;
struct FCM_EnvelopeData;
struct bGPDlayer;
struct bGPDframe;
struct bGPDstroke;
struct ImageUser;
struct RenderSlot;
struct ImageTile;
struct ViewLayerAOV;
struct ViewLayerLightgroup;
struct FreestyleModuleConfig;
struct FreestyleLineSet;
struct MTex;
struct LineStyleModifier;
struct Camera;
struct bNodeTree;
struct Mesh;
struct Light;
struct Image;
struct Lattice;
struct Curve;
struct MetaBall;
struct VFont;
struct Tex;
struct Brush;
struct World;
struct Text;
struct Speaker;
struct bSound;
struct bArmature;
struct bAction;
struct ParticleSettings;
struct Palette;
struct bGPdata;
struct MovieClip;
struct Mask;
struct FreestyleLineStyle;
struct LightProbe;
struct Curves;
struct PointCloud;
struct Volume;
struct CustomDataLayer;
struct MetaElem;
struct NlaStrip;
struct bContext;
struct bNodeSocket;
struct uiLayout;
struct bNode;
struct bNodeLink;
struct NodeSimulationItem;
struct NodeRepeatItem;
struct bNodeTreeInterfacePanel;
struct bNodeTreeInterfaceSocket;
struct bNodeTreeInterfaceItem;
struct View3D;
struct bPoseChannel;
struct ModifierData;
struct GpencilModifierData;
struct ShaderFxData;
struct bConstraint;
struct bDeformGroup;
struct PaletteColor;
struct ParticleSystemModifierData;
struct ParticleData;
struct CurveProfilePoint;
struct RenderResult;
struct RenderPass;
struct Editing;
struct KeyingSet;
struct SceneRenderView;
struct StripElem;
struct Sequence;
struct SequenceModifierData;
struct SeqRetimingKey;
struct EQCurveMappingData;
struct FileSelectParams;
struct wmKeyMapItem;
struct bAddon;
struct bPathCompare;
struct bUserScriptDirectory;
struct bUserExtensionRepo;
struct StudioLight;
struct wmEvent;
struct wmOperator;
struct wmWindow;
struct wmTimer;
struct wmKeyMap;
struct wmKeyConfig;
struct wmGizmo;
struct wmOwnerID;
struct bToolRef;
struct MovieTrackingMarker;
struct MovieTrackingPlaneMarker;
struct MovieTrackingTrack;
struct MovieReconstructedCamera;
struct MovieTrackingObject;
struct MaskSpline;
struct MaskLayer;
struct XrActionMapItem;
struct XrUserPath;
struct XrActionMapBinding;
struct XrComponentPath;
struct XrActionMap;

}

namespace BL {
	POINTER_PROPERTY(Struct, Struct, rna_type)
	STRING_PROPERTY(Struct, name)
	STRING_PROPERTY(Struct, identifier)
	STRING_PROPERTY(Struct, description)
	STRING_PROPERTY(Struct, translation_context)
	POINTER_PROPERTY(Struct, Struct, base)
	POINTER_PROPERTY(Struct, Struct, nested)
	POINTER_PROPERTY(StringProperty, Struct, name_property)





	POINTER_PROPERTY(Struct, Property, rna_type)
	STRING_PROPERTY(Property, name)
	STRING_PROPERTY(Property, identifier)
	STRING_PROPERTY(Property, description)
	STRING_PROPERTY(Property, translation_context)
	ENUM_PROPERTY(type_enum, Property, type)
	ENUM_PROPERTY(subtype_enum, Property, subtype)
	POINTER_PROPERTY(Struct, Property, srna)
	ENUM_PROPERTY(unit_enum, Property, unit)
	ENUM_PROPERTY(icon_enum, Property, icon)
	BOOLEAN_PROPERTY(Property, is_readonly)
	BOOLEAN_PROPERTY(Property, is_animatable)
	BOOLEAN_PROPERTY(Property, is_overridable)
	BOOLEAN_PROPERTY(Property, is_required)
	BOOLEAN_PROPERTY(Property, is_argument_optional)
	BOOLEAN_PROPERTY(Property, is_never_none)
	BOOLEAN_PROPERTY(Property, is_hidden)
	BOOLEAN_PROPERTY(Property, is_skip_save)
	BOOLEAN_PROPERTY(Property, is_output)
	BOOLEAN_PROPERTY(Property, is_registered)
	BOOLEAN_PROPERTY(Property, is_registered_optional)
	BOOLEAN_PROPERTY(Property, is_runtime)
	BOOLEAN_PROPERTY(Property, is_enum_flag)
	BOOLEAN_PROPERTY(Property, is_library_editable)
	BOOLEAN_PROPERTY(Property, is_path_output)
	ENUM_PROPERTY(tags_enum, Property, tags)


	BOOLEAN_PROPERTY(BoolProperty, default_value)
	BOOLEAN_ARRAY_PROPERTY(BoolProperty, 3, default_array)
	INT_PROPERTY(BoolProperty, array_length)
	INT_ARRAY_PROPERTY(BoolProperty, 3, array_dimensions)
	BOOLEAN_PROPERTY(BoolProperty, is_array)


	INT_PROPERTY(IntProperty, default_value)
	INT_ARRAY_PROPERTY(IntProperty, 3, default_array)
	INT_PROPERTY(IntProperty, array_length)
	INT_ARRAY_PROPERTY(IntProperty, 3, array_dimensions)
	BOOLEAN_PROPERTY(IntProperty, is_array)
	INT_PROPERTY(IntProperty, hard_min)
	INT_PROPERTY(IntProperty, hard_max)
	INT_PROPERTY(IntProperty, soft_min)
	INT_PROPERTY(IntProperty, soft_max)
	INT_PROPERTY(IntProperty, step)


	FLOAT_PROPERTY(FloatProperty, default_value)
	FLOAT_ARRAY_PROPERTY(FloatProperty, 3, default_array)
	INT_PROPERTY(FloatProperty, array_length)
	INT_ARRAY_PROPERTY(FloatProperty, 3, array_dimensions)
	BOOLEAN_PROPERTY(FloatProperty, is_array)
	FLOAT_PROPERTY(FloatProperty, hard_min)
	FLOAT_PROPERTY(FloatProperty, hard_max)
	FLOAT_PROPERTY(FloatProperty, soft_min)
	FLOAT_PROPERTY(FloatProperty, soft_max)
	FLOAT_PROPERTY(FloatProperty, step)
	INT_PROPERTY(FloatProperty, precision)


	STRING_PROPERTY(StringProperty, default_value)
	INT_PROPERTY(StringProperty, length_max)


	ENUM_PROPERTY(default_value_enum, EnumProperty, default_value)
	ENUM_PROPERTY(default_flag_enum, EnumProperty, default_flag)





	POINTER_PROPERTY(Struct, EnumPropertyItem, rna_type)
	STRING_PROPERTY(EnumPropertyItem, name)
	STRING_PROPERTY(EnumPropertyItem, description)
	STRING_PROPERTY(EnumPropertyItem, identifier)
	INT_PROPERTY(EnumPropertyItem, value)
	ENUM_PROPERTY(icon_enum, EnumPropertyItem, icon)


	POINTER_PROPERTY(Struct, PointerProperty, fixed_type)


	POINTER_PROPERTY(Struct, CollectionProperty, fixed_type)


	POINTER_PROPERTY(Struct, Function, rna_type)
	STRING_PROPERTY(Function, identifier)
	STRING_PROPERTY(Function, description)

	BOOLEAN_PROPERTY(Function, is_registered)
	BOOLEAN_PROPERTY(Function, is_registered_optional)
	BOOLEAN_PROPERTY(Function, use_self)
	BOOLEAN_PROPERTY(Function, use_self_type)


	POINTER_PROPERTY(Struct, BlenderRNA, rna_type)



	POINTER_PROPERTY(Struct, PrimitiveString, rna_type)
	STRING_PROPERTY(PrimitiveString, value)


	POINTER_PROPERTY(Struct, PrimitiveInt, rna_type)
	INT_PROPERTY(PrimitiveInt, value)


	POINTER_PROPERTY(Struct, PrimitiveFloat, rna_type)
	FLOAT_PROPERTY(PrimitiveFloat, value)


	POINTER_PROPERTY(Struct, PrimitiveBoolean, rna_type)
	BOOLEAN_PROPERTY(PrimitiveBoolean, value)


	POINTER_PROPERTY(Struct, UnknownType, rna_type)


	POINTER_PROPERTY(Struct, AnyType, rna_type)


	POINTER_PROPERTY(Struct, ID, rna_type)
	STRING_PROPERTY(ID, name)
	STRING_PROPERTY(ID, name_full)
	BOOLEAN_PROPERTY(ID, is_evaluated)
	POINTER_PROPERTY(ID, ID, original)
	INT_PROPERTY(ID, users)
	BOOLEAN_PROPERTY(ID, use_fake_user)
	BOOLEAN_PROPERTY(ID, use_extra_user)
	BOOLEAN_PROPERTY(ID, is_embedded_data)
	BOOLEAN_PROPERTY(ID, is_missing)
	BOOLEAN_PROPERTY(ID, is_runtime_data)
	BOOLEAN_PROPERTY(ID, tag)
	BOOLEAN_PROPERTY(ID, is_library_indirect)
	POINTER_PROPERTY(Library, ID, library)
	POINTER_PROPERTY(LibraryWeakReference, ID, library_weak_reference)
	POINTER_PROPERTY(AssetMetaData, ID, asset_data)
	POINTER_PROPERTY(IDOverrideLibrary, ID, override_library)
	POINTER_PROPERTY(ImagePreview, ID, preview)

	inline ID ID::evaluated_get(Depsgraph& depsgraph) {
		PointerRNA result;
		::ID *retdata = ID_evaluated_get_func((::ID *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data);
		result = RNA_id_pointer_create((::ID *) retdata);
		return ID(result);
	}

	inline ID ID::copy(void *main) {
		PointerRNA result;
		::ID *retdata = ID_copy_func((::ID *) this->ptr.data, (::Main *) main);
		result = RNA_id_pointer_create((::ID *) retdata);
		return ID(result);
	}

	inline void ID::asset_mark() {
		ID_asset_mark_func((::ID *) this->ptr.data);
	}

	inline void ID::asset_clear() {
		ID_asset_clear_func((::ID *) this->ptr.data);
	}

	inline void ID::asset_generate_preview(Context C) {
		ID_asset_generate_preview_func((::ID *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline ID ID::override_create(void *main, bool remap_local_usages) {
		PointerRNA result;
		::ID *retdata = ID_override_create_func((::ID *) this->ptr.data, (::Main *) main, remap_local_usages);
		result = RNA_id_pointer_create((::ID *) retdata);
		return ID(result);
	}

	inline ID ID::override_hierarchy_create(void *main, Scene& scene, ViewLayer& view_layer, ID& reference, bool do_fully_editable) {
		PointerRNA result;
		::ID *retdata = ID_override_hierarchy_create_func((::ID *) this->ptr.data, (::Main *) main, (::Scene *) scene.ptr.data, (::ViewLayer *) view_layer.ptr.data, (::ID *) reference.ptr.data, do_fully_editable);
		result = RNA_id_pointer_create((::ID *) retdata);
		return ID(result);
	}

	inline void ID::override_template_create() {
		ID_override_template_create_func((::ID *) this->ptr.data, nullptr);
	}

	inline void ID::user_clear() {
		ID_user_clear_func((::ID *) this->ptr.data);
	}

	inline void ID::user_remap(void *main, ID& new_id) {
		ID_user_remap_func((::ID *) this->ptr.data, (::Main *) main, (::ID *) new_id.ptr.data);
	}

	inline ID ID::make_local(void *main, bool clear_proxy) {
		PointerRNA result;
		::ID *retdata = ID_make_local_func((::ID *) this->ptr.data, (::Main *) main, clear_proxy);
		result = RNA_id_pointer_create((::ID *) retdata);
		return ID(result);
	}

	inline int ID::user_of_id(ID& id) {
		return ID_user_of_id_func((::ID *) this->ptr.data, (::ID *) id.ptr.data);
	}

	inline AnimData ID::animation_data_create(void *main) {
		PointerRNA result;
		::AnimData *retdata = ID_animation_data_create_func((::ID *) this->ptr.data, (::Main *) main);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_AnimData, retdata);
		return AnimData(result);
	}

	inline void ID::animation_data_clear(void *main) {
		ID_animation_data_clear_func((::ID *) this->ptr.data, (::Main *) main);
	}

	inline void ID::update_tag(void *main, int refresh) {
		ID_update_tag_func((::ID *) this->ptr.data, (::Main *) main, nullptr, refresh);
	}

	inline ImagePreview ID::preview_ensure() {
		PointerRNA result;
		::PreviewImage *retdata = ID_preview_ensure_func((::ID *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ImagePreview, retdata);
		return ImagePreview(result);
	}


	POINTER_PROPERTY(Struct, IDOverrideLibrary, rna_type)
	POINTER_PROPERTY(ID, IDOverrideLibrary, reference)
	POINTER_PROPERTY(ID, IDOverrideLibrary, hierarchy_root)
	BOOLEAN_PROPERTY(IDOverrideLibrary, is_in_hierarchy)
	BOOLEAN_PROPERTY(IDOverrideLibrary, is_system_override)


	inline void IDOverrideLibrary::operations_update(void *main) {
		IDOverrideLibrary_operations_update_func((::ID *) ptr.owner_id, (::IDOverrideLibrary *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline void IDOverrideLibrary::reset(void *main, bool do_hierarchy, bool set_system_override) {
		IDOverrideLibrary_reset_func((::ID *) ptr.owner_id, (::IDOverrideLibrary *) this->ptr.data, (::Main *) main, nullptr, do_hierarchy, set_system_override);
	}

	inline void IDOverrideLibrary::destroy(void *main, bool do_hierarchy) {
		IDOverrideLibrary_destroy_func((::ID *) ptr.owner_id, (::IDOverrideLibrary *) this->ptr.data, (::Main *) main, nullptr, do_hierarchy);
	}

	inline bool IDOverrideLibrary::resync(void *main, Scene& scene, ViewLayer& view_layer, Collection& residual_storage, bool do_hierarchy_enforce, bool do_whole_hierarchy) {
		return IDOverrideLibrary_resync_func((::ID *) ptr.owner_id, (::IDOverrideLibrary *) this->ptr.data, (::Main *) main, nullptr, (::Scene *) scene.ptr.data, (::ViewLayer *) view_layer.ptr.data, (::Collection *) residual_storage.ptr.data, do_hierarchy_enforce, do_whole_hierarchy);
	}


	POINTER_PROPERTY(Struct, IDOverrideLibraryProperties, rna_type)

	inline IDOverrideLibraryProperty IDOverrideLibraryProperties::add(const char * rna_path) {
		PointerRNA result;
		::IDOverrideLibraryProperty *retdata = IDOverrideLibraryProperties_add_func((::IDOverrideLibrary *) this->ptr.data, nullptr, rna_path);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_IDOverrideLibraryProperty, retdata);
		return IDOverrideLibraryProperty(result);
	}

	inline void IDOverrideLibraryProperties::remove(IDOverrideLibraryProperty& property) {
		IDOverrideLibraryProperties_remove_func((::IDOverrideLibrary *) this->ptr.data, nullptr, (::IDOverrideLibraryProperty *) property.ptr.data);
	}


	POINTER_PROPERTY(Struct, IDOverrideLibraryProperty, rna_type)
	STRING_PROPERTY(IDOverrideLibraryProperty, rna_path)



	POINTER_PROPERTY(Struct, IDOverrideLibraryPropertyOperations, rna_type)

	inline IDOverrideLibraryPropertyOperation IDOverrideLibraryPropertyOperations::add(int operation, bool use_id, const char * subitem_reference_name, const char * subitem_local_name, ID& subitem_reference_id, ID& subitem_local_id, int subitem_reference_index, int subitem_local_index) {
		PointerRNA result;
		::IDOverrideLibraryPropertyOperation *retdata = IDOverrideLibraryPropertyOperations_add_func((::IDOverrideLibraryProperty *) this->ptr.data, nullptr, operation, use_id, subitem_reference_name, subitem_local_name, (::ID *) subitem_reference_id.ptr.data, (::ID *) subitem_local_id.ptr.data, subitem_reference_index, subitem_local_index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_IDOverrideLibraryPropertyOperation, retdata);
		return IDOverrideLibraryPropertyOperation(result);
	}

	inline void IDOverrideLibraryPropertyOperations::remove(IDOverrideLibraryPropertyOperation& operation) {
		IDOverrideLibraryPropertyOperations_remove_func((::IDOverrideLibraryProperty *) this->ptr.data, nullptr, (::IDOverrideLibraryPropertyOperation *) operation.ptr.data);
	}


	POINTER_PROPERTY(Struct, IDOverrideLibraryPropertyOperation, rna_type)
	ENUM_PROPERTY(operation_enum, IDOverrideLibraryPropertyOperation, operation)
	ENUM_PROPERTY(flag_enum, IDOverrideLibraryPropertyOperation, flag)
	STRING_PROPERTY(IDOverrideLibraryPropertyOperation, subitem_reference_name)
	STRING_PROPERTY(IDOverrideLibraryPropertyOperation, subitem_local_name)
	POINTER_PROPERTY(ID, IDOverrideLibraryPropertyOperation, subitem_reference_id)
	POINTER_PROPERTY(ID, IDOverrideLibraryPropertyOperation, subitem_local_id)
	INT_PROPERTY(IDOverrideLibraryPropertyOperation, subitem_reference_index)
	INT_PROPERTY(IDOverrideLibraryPropertyOperation, subitem_local_index)


	POINTER_PROPERTY(Struct, ImagePreview, rna_type)
	BOOLEAN_PROPERTY(ImagePreview, is_image_custom)
	INT_ARRAY_PROPERTY(ImagePreview, 2, image_size)
	INT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, image_pixels)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, image_pixels_float)
	BOOLEAN_PROPERTY(ImagePreview, is_icon_custom)
	INT_ARRAY_PROPERTY(ImagePreview, 2, icon_size)
	INT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, icon_pixels)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(ImagePreview, icon_pixels_float)
	INT_PROPERTY(ImagePreview, icon_id)

	inline void ImagePreview::reload() {
		ImagePreview_reload_func((::PreviewImage *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, PropertyGroupItem, rna_type)


	POINTER_PROPERTY(Struct, PropertyGroup, rna_type)


	POINTER_PROPERTY(Struct, IDMaterials, rna_type)

	inline void IDMaterials::append(void *main, Material& material) {
		IDMaterials_append_func((::ID *) this->ptr.data, (::Main *) main, (::Material *) material.ptr.data);
	}

	inline Material IDMaterials::pop(void *main, int index) {
		PointerRNA result;
		::Material *retdata = IDMaterials_pop_func((::ID *) this->ptr.data, (::Main *) main, nullptr, index);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Material(result);
	}

	inline void IDMaterials::clear(void *main) {
		IDMaterials_clear_func((::ID *) this->ptr.data, (::Main *) main);
	}


	STRING_PROPERTY(Library, filepath)
	POINTER_PROPERTY(Library, Library, parent)
	POINTER_PROPERTY(PackedFile, Library, packed_file)
	INT_ARRAY_PROPERTY(Library, 3, version)
	BOOLEAN_PROPERTY(Library, needs_liboverride_resync)

	inline void Library::reload(Context C) {
		Library_reload_func((::Library *) this->ptr.data, (::bContext *) C.ptr.data, nullptr);
	}


	POINTER_PROPERTY(Struct, LibraryWeakReference, rna_type)
	STRING_PROPERTY(LibraryWeakReference, filepath)
	STRING_PROPERTY(LibraryWeakReference, id_name)


	POINTER_PROPERTY(Struct, IDPropertyWrapPtr, rna_type)


	ENUM_PROPERTY(type_enum, Texture, type)
	BOOLEAN_PROPERTY(Texture, use_clamp)
	BOOLEAN_PROPERTY(Texture, use_color_ramp)
	POINTER_PROPERTY(ColorRamp, Texture, color_ramp)
	FLOAT_PROPERTY(Texture, intensity)
	FLOAT_PROPERTY(Texture, contrast)
	FLOAT_PROPERTY(Texture, saturation)
	FLOAT_PROPERTY(Texture, factor_red)
	FLOAT_PROPERTY(Texture, factor_green)
	FLOAT_PROPERTY(Texture, factor_blue)
	BOOLEAN_PROPERTY(Texture, use_preview_alpha)
	BOOLEAN_PROPERTY(Texture, use_nodes)
	POINTER_PROPERTY(NodeTree, Texture, node_tree)
	POINTER_PROPERTY(AnimData, Texture, animation_data)

	inline void Texture::evaluate(float value[3], float result[4]) {
		Texture_evaluate_func((::Tex *) this->ptr.data, value, result);
	}


	FLOAT_PROPERTY(CloudsTexture, noise_scale)
	INT_PROPERTY(CloudsTexture, noise_depth)
	ENUM_PROPERTY(noise_basis_enum, CloudsTexture, noise_basis)
	ENUM_PROPERTY(noise_type_enum, CloudsTexture, noise_type)
	ENUM_PROPERTY(cloud_type_enum, CloudsTexture, cloud_type)
	FLOAT_PROPERTY(CloudsTexture, nabla)


	FLOAT_PROPERTY(WoodTexture, noise_scale)
	FLOAT_PROPERTY(WoodTexture, turbulence)
	ENUM_PROPERTY(noise_basis_enum, WoodTexture, noise_basis)
	ENUM_PROPERTY(noise_type_enum, WoodTexture, noise_type)
	ENUM_PROPERTY(wood_type_enum, WoodTexture, wood_type)
	ENUM_PROPERTY(noise_basis_2_enum, WoodTexture, noise_basis_2)
	FLOAT_PROPERTY(WoodTexture, nabla)


	FLOAT_PROPERTY(MarbleTexture, noise_scale)
	FLOAT_PROPERTY(MarbleTexture, turbulence)
	INT_PROPERTY(MarbleTexture, noise_depth)
	ENUM_PROPERTY(noise_type_enum, MarbleTexture, noise_type)
	ENUM_PROPERTY(marble_type_enum, MarbleTexture, marble_type)
	ENUM_PROPERTY(noise_basis_enum, MarbleTexture, noise_basis)
	ENUM_PROPERTY(noise_basis_2_enum, MarbleTexture, noise_basis_2)
	FLOAT_PROPERTY(MarbleTexture, nabla)


	FLOAT_PROPERTY(MagicTexture, turbulence)
	INT_PROPERTY(MagicTexture, noise_depth)


	ENUM_PROPERTY(progression_enum, BlendTexture, progression)
	ENUM_PROPERTY(use_flip_axis_enum, BlendTexture, use_flip_axis)


	FLOAT_PROPERTY(StucciTexture, turbulence)
	ENUM_PROPERTY(noise_basis_enum, StucciTexture, noise_basis)
	FLOAT_PROPERTY(StucciTexture, noise_scale)
	ENUM_PROPERTY(noise_type_enum, StucciTexture, noise_type)
	ENUM_PROPERTY(stucci_type_enum, StucciTexture, stucci_type)




	BOOLEAN_PROPERTY(ImageTexture, use_interpolation)
	BOOLEAN_PROPERTY(ImageTexture, use_flip_axis)
	BOOLEAN_PROPERTY(ImageTexture, use_alpha)
	BOOLEAN_PROPERTY(ImageTexture, use_calculate_alpha)
	BOOLEAN_PROPERTY(ImageTexture, invert_alpha)
	BOOLEAN_PROPERTY(ImageTexture, use_mipmap)
	BOOLEAN_PROPERTY(ImageTexture, use_mipmap_gauss)
	ENUM_PROPERTY(filter_type_enum, ImageTexture, filter_type)
	INT_PROPERTY(ImageTexture, filter_lightprobes)
	INT_PROPERTY(ImageTexture, filter_eccentricity)
	BOOLEAN_PROPERTY(ImageTexture, use_filter_size_min)
	FLOAT_PROPERTY(ImageTexture, filter_size)
	ENUM_PROPERTY(extension_enum, ImageTexture, extension)
	INT_PROPERTY(ImageTexture, repeat_x)
	INT_PROPERTY(ImageTexture, repeat_y)
	BOOLEAN_PROPERTY(ImageTexture, use_mirror_x)
	BOOLEAN_PROPERTY(ImageTexture, use_mirror_y)
	BOOLEAN_PROPERTY(ImageTexture, use_checker_odd)
	BOOLEAN_PROPERTY(ImageTexture, use_checker_even)
	FLOAT_PROPERTY(ImageTexture, checker_distance)
	FLOAT_PROPERTY(ImageTexture, crop_min_x)
	FLOAT_PROPERTY(ImageTexture, crop_min_y)
	FLOAT_PROPERTY(ImageTexture, crop_max_x)
	FLOAT_PROPERTY(ImageTexture, crop_max_y)
	POINTER_PROPERTY(Image, ImageTexture, image)
	POINTER_PROPERTY(ImageUser, ImageTexture, image_user)
	BOOLEAN_PROPERTY(ImageTexture, use_normal_map)


	ENUM_PROPERTY(musgrave_type_enum, MusgraveTexture, musgrave_type)
	FLOAT_PROPERTY(MusgraveTexture, dimension_max)
	FLOAT_PROPERTY(MusgraveTexture, lacunarity)
	FLOAT_PROPERTY(MusgraveTexture, octaves)
	FLOAT_PROPERTY(MusgraveTexture, offset)
	FLOAT_PROPERTY(MusgraveTexture, gain)
	FLOAT_PROPERTY(MusgraveTexture, noise_intensity)
	FLOAT_PROPERTY(MusgraveTexture, noise_scale)
	ENUM_PROPERTY(noise_basis_enum, MusgraveTexture, noise_basis)
	FLOAT_PROPERTY(MusgraveTexture, nabla)


	FLOAT_PROPERTY(VoronoiTexture, weight_1)
	FLOAT_PROPERTY(VoronoiTexture, weight_2)
	FLOAT_PROPERTY(VoronoiTexture, weight_3)
	FLOAT_PROPERTY(VoronoiTexture, weight_4)
	FLOAT_PROPERTY(VoronoiTexture, minkovsky_exponent)
	ENUM_PROPERTY(distance_metric_enum, VoronoiTexture, distance_metric)
	ENUM_PROPERTY(color_mode_enum, VoronoiTexture, color_mode)
	FLOAT_PROPERTY(VoronoiTexture, noise_intensity)
	FLOAT_PROPERTY(VoronoiTexture, noise_scale)
	FLOAT_PROPERTY(VoronoiTexture, nabla)


	FLOAT_PROPERTY(DistortedNoiseTexture, distortion)
	FLOAT_PROPERTY(DistortedNoiseTexture, noise_scale)
	ENUM_PROPERTY(noise_basis_enum, DistortedNoiseTexture, noise_basis)
	ENUM_PROPERTY(noise_distortion_enum, DistortedNoiseTexture, noise_distortion)
	FLOAT_PROPERTY(DistortedNoiseTexture, nabla)


	POINTER_PROPERTY(Struct, TextureSlot, rna_type)
	POINTER_PROPERTY(Texture, TextureSlot, texture)
	STRING_PROPERTY(TextureSlot, name)
	FLOAT_ARRAY_PROPERTY(TextureSlot, 3, offset)
	FLOAT_ARRAY_PROPERTY(TextureSlot, 3, scale)
	FLOAT_ARRAY_PROPERTY(TextureSlot, 3, color)
	ENUM_PROPERTY(blend_type_enum, TextureSlot, blend_type)
	FLOAT_PROPERTY(TextureSlot, default_value)
	ENUM_PROPERTY(output_node_enum, TextureSlot, output_node)


	POINTER_PROPERTY(Struct, TexMapping, rna_type)
	ENUM_PROPERTY(vector_type_enum, TexMapping, vector_type)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, translation)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, rotation)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, scale)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, min)
	FLOAT_ARRAY_PROPERTY(TexMapping, 3, max)
	BOOLEAN_PROPERTY(TexMapping, use_min)
	BOOLEAN_PROPERTY(TexMapping, use_max)
	ENUM_PROPERTY(mapping_x_enum, TexMapping, mapping_x)
	ENUM_PROPERTY(mapping_y_enum, TexMapping, mapping_y)
	ENUM_PROPERTY(mapping_z_enum, TexMapping, mapping_z)
	ENUM_PROPERTY(mapping_enum, TexMapping, mapping)


	POINTER_PROPERTY(Struct, ColorMapping, rna_type)
	BOOLEAN_PROPERTY(ColorMapping, use_color_ramp)
	POINTER_PROPERTY(ColorRamp, ColorMapping, color_ramp)
	FLOAT_PROPERTY(ColorMapping, brightness)
	FLOAT_PROPERTY(ColorMapping, contrast)
	FLOAT_PROPERTY(ColorMapping, saturation)
	ENUM_PROPERTY(blend_type_enum, ColorMapping, blend_type)
	FLOAT_ARRAY_PROPERTY(ColorMapping, 3, blend_color)
	FLOAT_PROPERTY(ColorMapping, blend_factor)





	BOOLEAN_PROPERTY(Action, use_frame_range)
	BOOLEAN_PROPERTY(Action, use_cyclic)
	FLOAT_PROPERTY(Action, frame_start)
	FLOAT_PROPERTY(Action, frame_end)
	FLOAT_ARRAY_PROPERTY(Action, 2, frame_range)
	FLOAT_ARRAY_PROPERTY(Action, 2, curve_frame_range)
	ENUM_PROPERTY(id_root_enum, Action, id_root)

	inline void Action::flip_with_pose(Object& object) {
		Action_flip_with_pose_func((::bAction *) this->ptr.data, nullptr, (::Object *) object.ptr.data);
	}


	POINTER_PROPERTY(Struct, ActionFCurves, rna_type)

	inline FCurve ActionFCurves::create(void *main, const char * data_path, int index, const char * action_group) {
		PointerRNA result;
		::FCurve *retdata = ActionFCurves_new_func((::bAction *) this->ptr.data, (::Main *) main, nullptr, data_path, index, action_group);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FCurve, retdata);
		return FCurve(result);
	}

	inline FCurve ActionFCurves::find(const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = ActionFCurves_find_func((::bAction *) this->ptr.data, nullptr, data_path, index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FCurve, retdata);
		return FCurve(result);
	}

	inline void ActionFCurves::remove(FCurve& fcurve) {
		ActionFCurves_remove_func((::bAction *) this->ptr.data, nullptr, (::PointerRNA *) &fcurve.ptr);
	}

	inline void ActionFCurves::clear() {
		ActionFCurves_clear_func((::bAction *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ActionGroups, rna_type)

	inline ActionGroup ActionGroups::create(const char * name) {
		PointerRNA result;
		::bActionGroup *retdata = ActionGroups_new_func((::bAction *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ActionGroup, retdata);
		return ActionGroup(result);
	}

	inline void ActionGroups::remove(ActionGroup& action_group) {
		ActionGroups_remove_func((::bAction *) this->ptr.data, nullptr, (::PointerRNA *) &action_group.ptr);
	}


	POINTER_PROPERTY(Struct, ActionPoseMarkers, rna_type)
	POINTER_PROPERTY(TimelineMarker, ActionPoseMarkers, active)
	INT_PROPERTY(ActionPoseMarkers, active_index)

	inline TimelineMarker ActionPoseMarkers::create(const char * name) {
		PointerRNA result;
		::TimeMarker *retdata = ActionPoseMarkers_new_func((::bAction *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_TimelineMarker, retdata);
		return TimelineMarker(result);
	}

	inline void ActionPoseMarkers::remove(TimelineMarker& marker) {
		ActionPoseMarkers_remove_func((::bAction *) this->ptr.data, nullptr, (::PointerRNA *) &marker.ptr);
	}


	POINTER_PROPERTY(Struct, ActionGroup, rna_type)
	STRING_PROPERTY(ActionGroup, name)

	BOOLEAN_PROPERTY(ActionGroup, select)
	BOOLEAN_PROPERTY(ActionGroup, lock)
	BOOLEAN_PROPERTY(ActionGroup, mute)
	BOOLEAN_PROPERTY(ActionGroup, show_expanded)
	BOOLEAN_PROPERTY(ActionGroup, show_expanded_graph)
	BOOLEAN_PROPERTY(ActionGroup, use_pin)
	ENUM_PROPERTY(color_set_enum, ActionGroup, color_set)
	BOOLEAN_PROPERTY(ActionGroup, is_custom_color_set)
	POINTER_PROPERTY(ThemeBoneColorSet, ActionGroup, colors)


	POINTER_PROPERTY(Struct, DopeSheet, rna_type)
	POINTER_PROPERTY(ID, DopeSheet, source)
	BOOLEAN_PROPERTY(DopeSheet, show_datablock_filters)
	BOOLEAN_PROPERTY(DopeSheet, show_only_selected)
	BOOLEAN_PROPERTY(DopeSheet, show_hidden)
	BOOLEAN_PROPERTY(DopeSheet, use_datablock_sort)
	BOOLEAN_PROPERTY(DopeSheet, use_filter_invert)
	BOOLEAN_PROPERTY(DopeSheet, show_only_errors)
	POINTER_PROPERTY(Collection, DopeSheet, filter_collection)
	STRING_PROPERTY(DopeSheet, filter_fcurve_name)
	STRING_PROPERTY(DopeSheet, filter_text)
	BOOLEAN_PROPERTY(DopeSheet, use_multi_word_filter)
	BOOLEAN_PROPERTY(DopeSheet, show_missing_nla)
	BOOLEAN_PROPERTY(DopeSheet, show_summary)
	BOOLEAN_PROPERTY(DopeSheet, show_expanded_summary)
	BOOLEAN_PROPERTY(DopeSheet, show_transforms)
	BOOLEAN_PROPERTY(DopeSheet, show_shapekeys)
	BOOLEAN_PROPERTY(DopeSheet, show_modifiers)
	BOOLEAN_PROPERTY(DopeSheet, show_meshes)
	BOOLEAN_PROPERTY(DopeSheet, show_lattices)
	BOOLEAN_PROPERTY(DopeSheet, show_cameras)
	BOOLEAN_PROPERTY(DopeSheet, show_materials)
	BOOLEAN_PROPERTY(DopeSheet, show_lights)
	BOOLEAN_PROPERTY(DopeSheet, show_linestyles)
	BOOLEAN_PROPERTY(DopeSheet, show_textures)
	BOOLEAN_PROPERTY(DopeSheet, show_curves)
	BOOLEAN_PROPERTY(DopeSheet, show_worlds)
	BOOLEAN_PROPERTY(DopeSheet, show_scenes)
	BOOLEAN_PROPERTY(DopeSheet, show_particles)
	BOOLEAN_PROPERTY(DopeSheet, show_metaballs)
	BOOLEAN_PROPERTY(DopeSheet, show_armatures)
	BOOLEAN_PROPERTY(DopeSheet, show_nodes)
	BOOLEAN_PROPERTY(DopeSheet, show_speakers)
	BOOLEAN_PROPERTY(DopeSheet, show_cache_files)
	BOOLEAN_PROPERTY(DopeSheet, show_hair_curves)
	BOOLEAN_PROPERTY(DopeSheet, show_pointclouds)
	BOOLEAN_PROPERTY(DopeSheet, show_volumes)
	BOOLEAN_PROPERTY(DopeSheet, show_gpencil)
	BOOLEAN_PROPERTY(DopeSheet, show_movieclips)


	POINTER_PROPERTY(Struct, AnimData, rna_type)

	POINTER_PROPERTY(Action, AnimData, action)
	ENUM_PROPERTY(action_extrapolation_enum, AnimData, action_extrapolation)
	ENUM_PROPERTY(action_blend_type_enum, AnimData, action_blend_type)
	FLOAT_PROPERTY(AnimData, action_influence)
	POINTER_PROPERTY(Action, AnimData, action_tweak_storage)

	BOOLEAN_PROPERTY(AnimData, use_nla)
	BOOLEAN_PROPERTY(AnimData, use_tweak_mode)
	BOOLEAN_PROPERTY(AnimData, use_pin)

	inline float AnimData::nla_tweak_strip_time_to_scene(float frame, bool invert) {
		return AnimData_nla_tweak_strip_time_to_scene_func((::AnimData *) this->ptr.data, frame, invert);
	}


	POINTER_PROPERTY(Struct, NlaTracks, rna_type)
	POINTER_PROPERTY(NlaTrack, NlaTracks, active)

	inline NlaTrack NlaTracks::create(void *main, Context C, NlaTrack& prev) {
		PointerRNA result;
		::NlaTrack *retdata = NlaTracks_new_func((::ID *) ptr.owner_id, (::AnimData *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, (::NlaTrack *) prev.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NlaTrack, retdata);
		return NlaTrack(result);
	}

	inline void NlaTracks::remove(void *main, Context C, NlaTrack& track) {
		NlaTracks_remove_func((::ID *) ptr.owner_id, (::AnimData *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &track.ptr);
	}


	POINTER_PROPERTY(Struct, AnimDataDrivers, rna_type)

	inline FCurve AnimDataDrivers::create(void *main, const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = AnimDataDrivers_new_func((::ID *) ptr.owner_id, (::AnimData *) this->ptr.data, (::Main *) main, nullptr, data_path, index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FCurve, retdata);
		return FCurve(result);
	}

	inline void AnimDataDrivers::remove(void *main, FCurve& driver) {
		AnimDataDrivers_remove_func((::AnimData *) this->ptr.data, (::Main *) main, nullptr, (::FCurve *) driver.ptr.data);
	}

	inline FCurve AnimDataDrivers::from_existing(Context C, FCurve& src_driver) {
		PointerRNA result;
		::FCurve *retdata = AnimDataDrivers_from_existing_func((::AnimData *) this->ptr.data, (::bContext *) C.ptr.data, (::FCurve *) src_driver.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FCurve, retdata);
		return FCurve(result);
	}

	inline FCurve AnimDataDrivers::find(const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = AnimDataDrivers_find_func((::AnimData *) this->ptr.data, nullptr, data_path, index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FCurve, retdata);
		return FCurve(result);
	}


	POINTER_PROPERTY(Struct, KeyingSet, rna_type)
	STRING_PROPERTY(KeyingSet, bl_idname)
	STRING_PROPERTY(KeyingSet, bl_label)
	STRING_PROPERTY(KeyingSet, bl_description)
	POINTER_PROPERTY(KeyingSetInfo, KeyingSet, type_info)

	BOOLEAN_PROPERTY(KeyingSet, is_path_absolute)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_override_needed)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_override_visual)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_override_xyz_to_rgb)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_needed)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_visual)
	BOOLEAN_PROPERTY(KeyingSet, use_insertkey_xyz_to_rgb)

	inline void KeyingSet::refresh(Context C) {
		KeyingSet_refresh_func((::KeyingSet *) this->ptr.data, (::bContext *) C.ptr.data, nullptr);
	}


	POINTER_PROPERTY(Struct, KeyingSetPaths, rna_type)
	POINTER_PROPERTY(KeyingSetPath, KeyingSetPaths, active)
	INT_PROPERTY(KeyingSetPaths, active_index)

	inline KeyingSetPath KeyingSetPaths::add(ID& target_id, const char * data_path, int index, int group_method, const char * group_name) {
		PointerRNA result;
		::KS_Path *retdata = KeyingSetPaths_add_func((::KeyingSet *) this->ptr.data, nullptr, (::ID *) target_id.ptr.data, data_path, index, group_method, group_name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyingSetPath, retdata);
		return KeyingSetPath(result);
	}

	inline void KeyingSetPaths::remove(KeyingSetPath& path) {
		KeyingSetPaths_remove_func((::KeyingSet *) this->ptr.data, nullptr, (::PointerRNA *) &path.ptr);
	}

	inline void KeyingSetPaths::clear() {
		KeyingSetPaths_clear_func((::KeyingSet *) this->ptr.data, nullptr);
	}


	POINTER_PROPERTY(Struct, KeyingSetPath, rna_type)
	POINTER_PROPERTY(ID, KeyingSetPath, id)
	ENUM_PROPERTY(id_type_enum, KeyingSetPath, id_type)
	STRING_PROPERTY(KeyingSetPath, group)
	ENUM_PROPERTY(group_method_enum, KeyingSetPath, group_method)
	STRING_PROPERTY(KeyingSetPath, data_path)
	INT_PROPERTY(KeyingSetPath, array_index)
	BOOLEAN_PROPERTY(KeyingSetPath, use_entire_array)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_override_needed)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_override_visual)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_override_xyz_to_rgb)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_needed)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_visual)
	BOOLEAN_PROPERTY(KeyingSetPath, use_insertkey_xyz_to_rgb)


	POINTER_PROPERTY(Struct, KeyingSetInfo, rna_type)
	STRING_PROPERTY(KeyingSetInfo, bl_idname)
	STRING_PROPERTY(KeyingSetInfo, bl_label)
	STRING_PROPERTY(KeyingSetInfo, bl_description)
	ENUM_PROPERTY(bl_options_enum, KeyingSetInfo, bl_options)


	POINTER_PROPERTY(Struct, AnimViz, rna_type)
	POINTER_PROPERTY(AnimVizMotionPaths, AnimViz, motion_path)


	POINTER_PROPERTY(Struct, AnimVizMotionPaths, rna_type)
	ENUM_PROPERTY(type_enum, AnimVizMotionPaths, type)
	ENUM_PROPERTY(range_enum, AnimVizMotionPaths, range)
	ENUM_PROPERTY(bake_location_enum, AnimVizMotionPaths, bake_location)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_frame_numbers)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_keyframe_highlight)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_keyframe_numbers)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, show_keyframe_action_all)
	INT_PROPERTY(AnimVizMotionPaths, frame_step)
	INT_PROPERTY(AnimVizMotionPaths, frame_start)
	INT_PROPERTY(AnimVizMotionPaths, frame_end)
	INT_PROPERTY(AnimVizMotionPaths, frame_before)
	INT_PROPERTY(AnimVizMotionPaths, frame_after)
	BOOLEAN_PROPERTY(AnimVizMotionPaths, has_motion_paths)


	POINTER_PROPERTY(Struct, MotionPath, rna_type)

	INT_PROPERTY(MotionPath, frame_start)
	INT_PROPERTY(MotionPath, frame_end)
	INT_PROPERTY(MotionPath, length)
	FLOAT_ARRAY_PROPERTY(MotionPath, 3, color)
	INT_PROPERTY(MotionPath, line_thickness)
	BOOLEAN_PROPERTY(MotionPath, use_bone_head)
	BOOLEAN_PROPERTY(MotionPath, is_modified)
	BOOLEAN_PROPERTY(MotionPath, use_custom_color)
	BOOLEAN_PROPERTY(MotionPath, lines)


	POINTER_PROPERTY(Struct, MotionPathVert, rna_type)
	FLOAT_ARRAY_PROPERTY(MotionPathVert, 3, co)
	BOOLEAN_PROPERTY(MotionPathVert, select)


	POINTER_PROPERTY(Struct, BoneColor, rna_type)
	ENUM_PROPERTY(palette_enum, BoneColor, palette)
	BOOLEAN_PROPERTY(BoneColor, is_custom)
	POINTER_PROPERTY(ThemeBoneColorSet, BoneColor, custom)


	POINTER_PROPERTY(Struct, BoneCollection, rna_type)
	STRING_PROPERTY(BoneCollection, name)
	BOOLEAN_PROPERTY(BoneCollection, is_visible)
	BOOLEAN_PROPERTY(BoneCollection, is_local_override)
	BOOLEAN_PROPERTY(BoneCollection, is_editable)


	inline bool BoneCollection::assign(Context C, AnyType& bone) {
		return BoneCollection_assign_func((::BoneCollection *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &bone);
	}

	inline bool BoneCollection::unassign(Context C, AnyType& bone) {
		return BoneCollection_unassign_func((::BoneCollection *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &bone);
	}


	POINTER_PROPERTY(AnimData, Armature, animation_data)



	ENUM_PROPERTY(pose_position_enum, Armature, pose_position)
	ENUM_PROPERTY(display_type_enum, Armature, display_type)
	BOOLEAN_PROPERTY(Armature, show_axes)
	FLOAT_PROPERTY(Armature, axes_position)
	ENUM_PROPERTY(relation_line_position_enum, Armature, relation_line_position)
	BOOLEAN_PROPERTY(Armature, show_names)
	BOOLEAN_PROPERTY(Armature, use_mirror_x)
	BOOLEAN_PROPERTY(Armature, show_bone_custom_shapes)
	BOOLEAN_PROPERTY(Armature, show_bone_colors)
	BOOLEAN_PROPERTY(Armature, is_editmode)

	inline void Armature::transform(float matrix[16]) {
		Armature_transform_func((::bArmature *) this->ptr.data, matrix);
	}


	POINTER_PROPERTY(Struct, ArmatureBones, rna_type)
	POINTER_PROPERTY(Bone, ArmatureBones, active)


	POINTER_PROPERTY(Struct, ArmatureEditBones, rna_type)
	POINTER_PROPERTY(EditBone, ArmatureEditBones, active)

	inline EditBone ArmatureEditBones::create(const char * name) {
		PointerRNA result;
		::EditBone *retdata = ArmatureEditBones_new_func((::bArmature *) this->ptr.data, nullptr, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_EditBone, retdata);
		return EditBone(result);
	}

	inline void ArmatureEditBones::remove(EditBone& bone) {
		ArmatureEditBones_remove_func((::bArmature *) this->ptr.data, nullptr, (::PointerRNA *) &bone.ptr);
	}


	POINTER_PROPERTY(Struct, BoneCollections, rna_type)
	POINTER_PROPERTY(BoneCollection, BoneCollections, active)
	INT_PROPERTY(BoneCollections, active_index)
	STRING_PROPERTY(BoneCollections, active_name)

	inline BoneCollection BoneCollections::create(const char * name) {
		PointerRNA result;
		::BoneCollection *retdata = BoneCollections_new_func((::bArmature *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_BoneCollection, retdata);
		return BoneCollection(result);
	}

	inline void BoneCollections::remove(BoneCollection& bone_collection) {
		BoneCollections_remove_func((::bArmature *) this->ptr.data, (::BoneCollection *) bone_collection.ptr.data);
	}

	inline void BoneCollections::move(int from_index, int to_index) {
		BoneCollections_move_func((::bArmature *) this->ptr.data, nullptr, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, Bone, rna_type)
	POINTER_PROPERTY(Bone, Bone, parent)


	STRING_PROPERTY(Bone, name)
	POINTER_PROPERTY(BoneColor, Bone, color)
	BOOLEAN_PROPERTY(Bone, use_connect)
	BOOLEAN_PROPERTY(Bone, use_inherit_rotation)
	BOOLEAN_PROPERTY(Bone, use_envelope_multiply)
	BOOLEAN_PROPERTY(Bone, use_deform)
	ENUM_PROPERTY(inherit_scale_enum, Bone, inherit_scale)
	BOOLEAN_PROPERTY(Bone, use_local_location)
	BOOLEAN_PROPERTY(Bone, use_relative_parent)
	BOOLEAN_PROPERTY(Bone, show_wire)
	BOOLEAN_PROPERTY(Bone, use_cyclic_offset)
	BOOLEAN_PROPERTY(Bone, hide_select)
	FLOAT_PROPERTY(Bone, envelope_distance)
	FLOAT_PROPERTY(Bone, envelope_weight)
	FLOAT_PROPERTY(Bone, head_radius)
	FLOAT_PROPERTY(Bone, tail_radius)
	INT_PROPERTY(Bone, bbone_segments)
	ENUM_PROPERTY(bbone_mapping_mode_enum, Bone, bbone_mapping_mode)
	FLOAT_PROPERTY(Bone, bbone_x)
	FLOAT_PROPERTY(Bone, bbone_z)
	ENUM_PROPERTY(bbone_handle_type_start_enum, Bone, bbone_handle_type_start)
	POINTER_PROPERTY(Bone, Bone, bbone_custom_handle_start)
	BOOLEAN_ARRAY_PROPERTY(Bone, 3, bbone_handle_use_scale_start)
	BOOLEAN_PROPERTY(Bone, bbone_handle_use_ease_start)
	ENUM_PROPERTY(bbone_handle_type_end_enum, Bone, bbone_handle_type_end)
	POINTER_PROPERTY(Bone, Bone, bbone_custom_handle_end)
	BOOLEAN_ARRAY_PROPERTY(Bone, 3, bbone_handle_use_scale_end)
	BOOLEAN_PROPERTY(Bone, bbone_handle_use_ease_end)
	FLOAT_PROPERTY(Bone, bbone_rollin)
	FLOAT_PROPERTY(Bone, bbone_rollout)
	BOOLEAN_PROPERTY(Bone, use_endroll_as_inroll)
	FLOAT_PROPERTY(Bone, bbone_curveinx)
	FLOAT_PROPERTY(Bone, bbone_curveinz)
	FLOAT_PROPERTY(Bone, bbone_curveoutx)
	FLOAT_PROPERTY(Bone, bbone_curveoutz)
	FLOAT_PROPERTY(Bone, bbone_easein)
	FLOAT_PROPERTY(Bone, bbone_easeout)
	BOOLEAN_PROPERTY(Bone, use_scale_easing)
	FLOAT_ARRAY_PROPERTY(Bone, 3, bbone_scalein)
	FLOAT_ARRAY_PROPERTY(Bone, 3, bbone_scaleout)
	BOOLEAN_PROPERTY(Bone, hide)
	BOOLEAN_PROPERTY(Bone, select)
	BOOLEAN_PROPERTY(Bone, select_head)
	BOOLEAN_PROPERTY(Bone, select_tail)
	FLOAT_ARRAY_PROPERTY(Bone, 9, matrix)
	FLOAT_ARRAY_PROPERTY(Bone, 16, matrix_local)
	FLOAT_ARRAY_PROPERTY(Bone, 3, tail)
	FLOAT_ARRAY_PROPERTY(Bone, 3, tail_local)
	FLOAT_ARRAY_PROPERTY(Bone, 3, head)
	FLOAT_ARRAY_PROPERTY(Bone, 3, head_local)
	FLOAT_PROPERTY(Bone, length)

	inline float Bone::evaluate_envelope(float point[3]) {
		return Bone_evaluate_envelope_func((::Bone *) this->ptr.data, point);
	}

	inline void Bone::convert_local_to_pose(float matrix_return[16], float matrix[16], float matrix_local[16], float parent_matrix[16], float parent_matrix_local[16], bool invert) {
		Bone_convert_local_to_pose_func((::Bone *) this->ptr.data, matrix_return, matrix, matrix_local, parent_matrix, parent_matrix_local, invert);
	}

	inline void Bone::MatrixFromAxisRoll(float axis[3], float roll, float result_matrix[9]) {
		Bone_MatrixFromAxisRoll_func(axis, roll, result_matrix);
	}

	inline void Bone::AxisRollFromMatrix(float matrix[9], float axis[3], float result_axis[3], float *result_roll) {
		Bone_AxisRollFromMatrix_func(matrix, axis, result_axis, result_roll);
	}


	POINTER_PROPERTY(Struct, BoneCollectionMemberships, rna_type)

	inline void BoneCollectionMemberships::clear() {
		BoneCollectionMemberships_clear_func((::Bone *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, EditBone, rna_type)

	POINTER_PROPERTY(EditBone, EditBone, parent)
	FLOAT_PROPERTY(EditBone, roll)
	FLOAT_ARRAY_PROPERTY(EditBone, 3, head)
	FLOAT_ARRAY_PROPERTY(EditBone, 3, tail)
	FLOAT_PROPERTY(EditBone, length)
	STRING_PROPERTY(EditBone, name)
	POINTER_PROPERTY(BoneColor, EditBone, color)
	BOOLEAN_PROPERTY(EditBone, use_connect)
	BOOLEAN_PROPERTY(EditBone, use_inherit_rotation)
	BOOLEAN_PROPERTY(EditBone, use_envelope_multiply)
	BOOLEAN_PROPERTY(EditBone, use_deform)
	ENUM_PROPERTY(inherit_scale_enum, EditBone, inherit_scale)
	BOOLEAN_PROPERTY(EditBone, use_local_location)
	BOOLEAN_PROPERTY(EditBone, use_relative_parent)
	BOOLEAN_PROPERTY(EditBone, show_wire)
	BOOLEAN_PROPERTY(EditBone, use_cyclic_offset)
	BOOLEAN_PROPERTY(EditBone, hide_select)
	FLOAT_PROPERTY(EditBone, envelope_distance)
	FLOAT_PROPERTY(EditBone, envelope_weight)
	FLOAT_PROPERTY(EditBone, head_radius)
	FLOAT_PROPERTY(EditBone, tail_radius)
	INT_PROPERTY(EditBone, bbone_segments)
	ENUM_PROPERTY(bbone_mapping_mode_enum, EditBone, bbone_mapping_mode)
	FLOAT_PROPERTY(EditBone, bbone_x)
	FLOAT_PROPERTY(EditBone, bbone_z)
	ENUM_PROPERTY(bbone_handle_type_start_enum, EditBone, bbone_handle_type_start)
	POINTER_PROPERTY(EditBone, EditBone, bbone_custom_handle_start)
	BOOLEAN_ARRAY_PROPERTY(EditBone, 3, bbone_handle_use_scale_start)
	BOOLEAN_PROPERTY(EditBone, bbone_handle_use_ease_start)
	ENUM_PROPERTY(bbone_handle_type_end_enum, EditBone, bbone_handle_type_end)
	POINTER_PROPERTY(EditBone, EditBone, bbone_custom_handle_end)
	BOOLEAN_ARRAY_PROPERTY(EditBone, 3, bbone_handle_use_scale_end)
	BOOLEAN_PROPERTY(EditBone, bbone_handle_use_ease_end)
	FLOAT_PROPERTY(EditBone, bbone_rollin)
	FLOAT_PROPERTY(EditBone, bbone_rollout)
	BOOLEAN_PROPERTY(EditBone, use_endroll_as_inroll)
	FLOAT_PROPERTY(EditBone, bbone_curveinx)
	FLOAT_PROPERTY(EditBone, bbone_curveinz)
	FLOAT_PROPERTY(EditBone, bbone_curveoutx)
	FLOAT_PROPERTY(EditBone, bbone_curveoutz)
	FLOAT_PROPERTY(EditBone, bbone_easein)
	FLOAT_PROPERTY(EditBone, bbone_easeout)
	BOOLEAN_PROPERTY(EditBone, use_scale_easing)
	FLOAT_ARRAY_PROPERTY(EditBone, 3, bbone_scalein)
	FLOAT_ARRAY_PROPERTY(EditBone, 3, bbone_scaleout)
	BOOLEAN_PROPERTY(EditBone, hide)
	BOOLEAN_PROPERTY(EditBone, lock)
	BOOLEAN_PROPERTY(EditBone, select)
	BOOLEAN_PROPERTY(EditBone, select_head)
	BOOLEAN_PROPERTY(EditBone, select_tail)
	FLOAT_ARRAY_PROPERTY(EditBone, 16, matrix)

	inline void EditBone::align_roll(float vector[3]) {
		EditBone_align_roll_func((::EditBone *) this->ptr.data, vector);
	}


	POINTER_PROPERTY(Struct, Attribute, rna_type)
	STRING_PROPERTY(Attribute, name)
	ENUM_PROPERTY(data_type_enum, Attribute, data_type)
	ENUM_PROPERTY(domain_enum, Attribute, domain)
	BOOLEAN_PROPERTY(Attribute, is_internal)
	BOOLEAN_PROPERTY(Attribute, is_required)





	POINTER_PROPERTY(Struct, FloatAttributeValue, rna_type)
	FLOAT_PROPERTY(FloatAttributeValue, value)





	POINTER_PROPERTY(Struct, FloatVectorAttributeValue, rna_type)
	FLOAT_ARRAY_PROPERTY(FloatVectorAttributeValue, 3, vector)





	POINTER_PROPERTY(Struct, FloatColorAttributeValue, rna_type)
	FLOAT_ARRAY_PROPERTY(FloatColorAttributeValue, 4, color)
	FLOAT_ARRAY_PROPERTY(FloatColorAttributeValue, 4, color_srgb)





	POINTER_PROPERTY(Struct, ByteColorAttributeValue, rna_type)
	FLOAT_ARRAY_PROPERTY(ByteColorAttributeValue, 4, color)
	FLOAT_ARRAY_PROPERTY(ByteColorAttributeValue, 4, color_srgb)





	POINTER_PROPERTY(Struct, IntAttributeValue, rna_type)
	INT_PROPERTY(IntAttributeValue, value)





	POINTER_PROPERTY(Struct, Int2AttributeValue, rna_type)
	INT_ARRAY_PROPERTY(Int2AttributeValue, 2, value)





	POINTER_PROPERTY(Struct, QuaternionAttributeValue, rna_type)
	FLOAT_ARRAY_PROPERTY(QuaternionAttributeValue, 4, value)





	POINTER_PROPERTY(Struct, StringAttributeValue, rna_type)
	STRING_PROPERTY(StringAttributeValue, value)





	POINTER_PROPERTY(Struct, BoolAttributeValue, rna_type)
	BOOLEAN_PROPERTY(BoolAttributeValue, value)





	POINTER_PROPERTY(Struct, Float2AttributeValue, rna_type)
	FLOAT_ARRAY_PROPERTY(Float2AttributeValue, 2, vector)





	POINTER_PROPERTY(Struct, ByteIntAttributeValue, rna_type)
	INT_PROPERTY(ByteIntAttributeValue, value)


	POINTER_PROPERTY(Struct, AttributeGroup, rna_type)
	POINTER_PROPERTY(Attribute, AttributeGroup, active)
	INT_PROPERTY(AttributeGroup, active_index)
	POINTER_PROPERTY(Attribute, AttributeGroup, active_color)
	INT_PROPERTY(AttributeGroup, active_color_index)
	INT_PROPERTY(AttributeGroup, render_color_index)
	STRING_PROPERTY(AttributeGroup, default_color_name)
	STRING_PROPERTY(AttributeGroup, active_color_name)

	inline Attribute AttributeGroup::create(const char * name, int type, int domain) {
		PointerRNA result;
		result = AttributeGroup_new_func((::ID *) this->ptr.data, nullptr, name, type, domain);
		return Attribute(result);
	}

	inline void AttributeGroup::remove(Attribute& attribute) {
		AttributeGroup_remove_func((::ID *) this->ptr.data, nullptr, (::PointerRNA *) &attribute.ptr);
	}


	POINTER_PROPERTY(Struct, AssetTag, rna_type)
	STRING_PROPERTY(AssetTag, name)


	POINTER_PROPERTY(Struct, AssetMetaData, rna_type)
	STRING_PROPERTY(AssetMetaData, author)
	STRING_PROPERTY(AssetMetaData, description)
	STRING_PROPERTY(AssetMetaData, copyright)
	STRING_PROPERTY(AssetMetaData, license)

	INT_PROPERTY(AssetMetaData, active_tag)
	STRING_PROPERTY(AssetMetaData, catalog_id)
	STRING_PROPERTY(AssetMetaData, catalog_simple_name)


	POINTER_PROPERTY(Struct, AssetTags, rna_type)

	inline AssetTag AssetTags::create(const char * name, bool skip_if_exists) {
		PointerRNA result;
		::AssetTag *retdata = AssetTags_new_func((::ID *) ptr.owner_id, (::AssetMetaData *) this->ptr.data, nullptr, name, skip_if_exists);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_AssetTag, retdata);
		return AssetTag(result);
	}

	inline void AssetTags::remove(AssetTag& tag) {
		AssetTags_remove_func((::ID *) ptr.owner_id, (::AssetMetaData *) this->ptr.data, nullptr, (::PointerRNA *) &tag.ptr);
	}


	POINTER_PROPERTY(Struct, AssetLibraryReference, rna_type)


	POINTER_PROPERTY(FileSelectEntry, AssetHandle, file_data)


	POINTER_PROPERTY(Struct, AssetRepresentation, rna_type)
	STRING_PROPERTY(AssetRepresentation, name)
	POINTER_PROPERTY(AssetMetaData, AssetRepresentation, metadata)
	ENUM_PROPERTY(id_type_enum, AssetRepresentation, id_type)
	POINTER_PROPERTY(ID, AssetRepresentation, local_id)
	STRING_PROPERTY(AssetRepresentation, full_library_path)
	STRING_PROPERTY(AssetRepresentation, full_path)


	POINTER_PROPERTY(Struct, AssetCatalogPath, rna_type)


	POINTER_PROPERTY(Struct, BoidRule, rna_type)
	STRING_PROPERTY(BoidRule, name)
	ENUM_PROPERTY(type_enum, BoidRule, type)
	BOOLEAN_PROPERTY(BoidRule, use_in_air)
	BOOLEAN_PROPERTY(BoidRule, use_on_land)


	POINTER_PROPERTY(Object, BoidRuleGoal, object)
	BOOLEAN_PROPERTY(BoidRuleGoal, use_predict)


	POINTER_PROPERTY(Object, BoidRuleAvoid, object)
	BOOLEAN_PROPERTY(BoidRuleAvoid, use_predict)
	FLOAT_PROPERTY(BoidRuleAvoid, fear_factor)


	BOOLEAN_PROPERTY(BoidRuleAvoidCollision, use_avoid)
	BOOLEAN_PROPERTY(BoidRuleAvoidCollision, use_avoid_collision)
	FLOAT_PROPERTY(BoidRuleAvoidCollision, look_ahead)


	POINTER_PROPERTY(Object, BoidRuleFollowLeader, object)
	FLOAT_PROPERTY(BoidRuleFollowLeader, distance)
	INT_PROPERTY(BoidRuleFollowLeader, queue_count)
	BOOLEAN_PROPERTY(BoidRuleFollowLeader, use_line)


	FLOAT_PROPERTY(BoidRuleAverageSpeed, wander)
	FLOAT_PROPERTY(BoidRuleAverageSpeed, level)
	FLOAT_PROPERTY(BoidRuleAverageSpeed, speed)


	FLOAT_PROPERTY(BoidRuleFight, distance)
	FLOAT_PROPERTY(BoidRuleFight, flee_distance)


	POINTER_PROPERTY(Struct, BoidState, rna_type)
	STRING_PROPERTY(BoidState, name)
	ENUM_PROPERTY(ruleset_type_enum, BoidState, ruleset_type)

	POINTER_PROPERTY(BoidRule, BoidState, active_boid_rule)
	INT_PROPERTY(BoidState, active_boid_rule_index)
	FLOAT_PROPERTY(BoidState, rule_fuzzy)
	FLOAT_PROPERTY(BoidState, volume)
	FLOAT_PROPERTY(BoidState, falloff)


	POINTER_PROPERTY(Struct, BoidSettings, rna_type)
	FLOAT_PROPERTY(BoidSettings, land_smooth)
	FLOAT_PROPERTY(BoidSettings, bank)
	FLOAT_PROPERTY(BoidSettings, pitch)
	FLOAT_PROPERTY(BoidSettings, height)

	POINTER_PROPERTY(BoidRule, BoidSettings, active_boid_state)
	INT_PROPERTY(BoidSettings, active_boid_state_index)
	FLOAT_PROPERTY(BoidSettings, health)
	FLOAT_PROPERTY(BoidSettings, strength)
	FLOAT_PROPERTY(BoidSettings, aggression)
	FLOAT_PROPERTY(BoidSettings, accuracy)
	FLOAT_PROPERTY(BoidSettings, range)
	FLOAT_PROPERTY(BoidSettings, air_speed_min)
	FLOAT_PROPERTY(BoidSettings, air_speed_max)
	FLOAT_PROPERTY(BoidSettings, air_acc_max)
	FLOAT_PROPERTY(BoidSettings, air_ave_max)
	FLOAT_PROPERTY(BoidSettings, air_personal_space)
	FLOAT_PROPERTY(BoidSettings, land_jump_speed)
	FLOAT_PROPERTY(BoidSettings, land_speed_max)
	FLOAT_PROPERTY(BoidSettings, land_acc_max)
	FLOAT_PROPERTY(BoidSettings, land_ave_max)
	FLOAT_PROPERTY(BoidSettings, land_personal_space)
	FLOAT_PROPERTY(BoidSettings, land_stick_force)
	BOOLEAN_PROPERTY(BoidSettings, use_flight)
	BOOLEAN_PROPERTY(BoidSettings, use_land)
	BOOLEAN_PROPERTY(BoidSettings, use_climb)


	ENUM_PROPERTY(blend_enum, Brush, blend)
	ENUM_PROPERTY(sculpt_tool_enum, Brush, sculpt_tool)
	ENUM_PROPERTY(uv_sculpt_tool_enum, Brush, uv_sculpt_tool)
	ENUM_PROPERTY(vertex_tool_enum, Brush, vertex_tool)
	ENUM_PROPERTY(weight_tool_enum, Brush, weight_tool)
	ENUM_PROPERTY(image_tool_enum, Brush, image_tool)
	ENUM_PROPERTY(gpencil_tool_enum, Brush, gpencil_tool)
	ENUM_PROPERTY(gpencil_vertex_tool_enum, Brush, gpencil_vertex_tool)
	ENUM_PROPERTY(gpencil_sculpt_tool_enum, Brush, gpencil_sculpt_tool)
	ENUM_PROPERTY(gpencil_weight_tool_enum, Brush, gpencil_weight_tool)
	ENUM_PROPERTY(curves_sculpt_tool_enum, Brush, curves_sculpt_tool)
	ENUM_PROPERTY(direction_enum, Brush, direction)
	ENUM_PROPERTY(stroke_method_enum, Brush, stroke_method)
	ENUM_PROPERTY(sculpt_plane_enum, Brush, sculpt_plane)
	ENUM_PROPERTY(mask_tool_enum, Brush, mask_tool)
	ENUM_PROPERTY(curve_preset_enum, Brush, curve_preset)
	ENUM_PROPERTY(deform_target_enum, Brush, deform_target)
	ENUM_PROPERTY(elastic_deform_type_enum, Brush, elastic_deform_type)
	ENUM_PROPERTY(snake_hook_deform_type_enum, Brush, snake_hook_deform_type)
	ENUM_PROPERTY(cloth_deform_type_enum, Brush, cloth_deform_type)
	ENUM_PROPERTY(cloth_force_falloff_type_enum, Brush, cloth_force_falloff_type)
	ENUM_PROPERTY(cloth_simulation_area_type_enum, Brush, cloth_simulation_area_type)
	ENUM_PROPERTY(boundary_falloff_type_enum, Brush, boundary_falloff_type)
	ENUM_PROPERTY(smooth_deform_type_enum, Brush, smooth_deform_type)
	ENUM_PROPERTY(smear_deform_type_enum, Brush, smear_deform_type)
	ENUM_PROPERTY(slide_deform_type_enum, Brush, slide_deform_type)
	ENUM_PROPERTY(boundary_deform_type_enum, Brush, boundary_deform_type)
	ENUM_PROPERTY(pose_deform_type_enum, Brush, pose_deform_type)
	ENUM_PROPERTY(pose_origin_type_enum, Brush, pose_origin_type)
	ENUM_PROPERTY(jitter_unit_enum, Brush, jitter_unit)
	ENUM_PROPERTY(falloff_shape_enum, Brush, falloff_shape)
	INT_PROPERTY(Brush, size)
	FLOAT_PROPERTY(Brush, unprojected_radius)
	FLOAT_PROPERTY(Brush, jitter)
	INT_PROPERTY(Brush, jitter_absolute)
	INT_PROPERTY(Brush, spacing)
	INT_PROPERTY(Brush, grad_spacing)
	INT_PROPERTY(Brush, smooth_stroke_radius)
	FLOAT_PROPERTY(Brush, smooth_stroke_factor)
	FLOAT_PROPERTY(Brush, rate)
	FLOAT_ARRAY_PROPERTY(Brush, 3, color)
	FLOAT_ARRAY_PROPERTY(Brush, 3, secondary_color)
	FLOAT_PROPERTY(Brush, weight)
	FLOAT_PROPERTY(Brush, strength)
	FLOAT_PROPERTY(Brush, flow)
	FLOAT_PROPERTY(Brush, wet_mix)
	FLOAT_PROPERTY(Brush, wet_persistence)
	FLOAT_PROPERTY(Brush, density)
	FLOAT_PROPERTY(Brush, tip_scale_x)
	BOOLEAN_PROPERTY(Brush, use_hardness_pressure)
	BOOLEAN_PROPERTY(Brush, invert_hardness_pressure)
	BOOLEAN_PROPERTY(Brush, use_flow_pressure)
	BOOLEAN_PROPERTY(Brush, invert_flow_pressure)
	BOOLEAN_PROPERTY(Brush, use_wet_mix_pressure)
	BOOLEAN_PROPERTY(Brush, invert_wet_mix_pressure)
	BOOLEAN_PROPERTY(Brush, use_wet_persistence_pressure)
	BOOLEAN_PROPERTY(Brush, invert_wet_persistence_pressure)
	BOOLEAN_PROPERTY(Brush, use_density_pressure)
	BOOLEAN_PROPERTY(Brush, invert_density_pressure)
	FLOAT_PROPERTY(Brush, dash_ratio)
	INT_PROPERTY(Brush, dash_samples)
	FLOAT_PROPERTY(Brush, plane_offset)
	FLOAT_PROPERTY(Brush, plane_trim)
	FLOAT_PROPERTY(Brush, height)
	FLOAT_PROPERTY(Brush, texture_sample_bias)
	BOOLEAN_PROPERTY(Brush, use_color_as_displacement)
	FLOAT_PROPERTY(Brush, normal_weight)
	FLOAT_PROPERTY(Brush, elastic_deform_volume_preservation)
	FLOAT_PROPERTY(Brush, rake_factor)
	FLOAT_PROPERTY(Brush, crease_pinch_factor)
	FLOAT_PROPERTY(Brush, pose_offset)
	FLOAT_PROPERTY(Brush, disconnected_distance_max)
	FLOAT_PROPERTY(Brush, boundary_offset)
	FLOAT_PROPERTY(Brush, surface_smooth_shape_preservation)
	FLOAT_PROPERTY(Brush, surface_smooth_current_vertex)
	INT_PROPERTY(Brush, surface_smooth_iterations)
	FLOAT_PROPERTY(Brush, multiplane_scrape_angle)
	INT_PROPERTY(Brush, pose_smooth_iterations)
	INT_PROPERTY(Brush, pose_ik_segments)
	FLOAT_PROPERTY(Brush, tip_roundness)
	FLOAT_PROPERTY(Brush, cloth_mass)
	FLOAT_PROPERTY(Brush, cloth_damping)
	FLOAT_PROPERTY(Brush, cloth_sim_limit)
	FLOAT_PROPERTY(Brush, cloth_sim_falloff)
	FLOAT_PROPERTY(Brush, cloth_constraint_softbody_strength)
	FLOAT_PROPERTY(Brush, hardness)
	INT_PROPERTY(Brush, automasking_boundary_edges_propagation_steps)
	FLOAT_PROPERTY(Brush, auto_smooth_factor)
	FLOAT_PROPERTY(Brush, topology_rake_factor)
	FLOAT_PROPERTY(Brush, tilt_strength_factor)
	FLOAT_PROPERTY(Brush, normal_radius_factor)
	FLOAT_PROPERTY(Brush, area_radius_factor)
	FLOAT_PROPERTY(Brush, wet_paint_radius_factor)
	FLOAT_ARRAY_PROPERTY(Brush, 2, stencil_pos)
	FLOAT_ARRAY_PROPERTY(Brush, 2, stencil_dimension)
	FLOAT_ARRAY_PROPERTY(Brush, 2, mask_stencil_pos)
	FLOAT_ARRAY_PROPERTY(Brush, 2, mask_stencil_dimension)
	FLOAT_PROPERTY(Brush, sharp_threshold)
	FLOAT_PROPERTY(Brush, fill_threshold)
	INT_PROPERTY(Brush, blur_kernel_radius)
	ENUM_PROPERTY(blur_mode_enum, Brush, blur_mode)
	FLOAT_PROPERTY(Brush, falloff_angle)
	BOOLEAN_PROPERTY(Brush, use_airbrush)
	BOOLEAN_PROPERTY(Brush, use_original_normal)
	BOOLEAN_PROPERTY(Brush, use_original_plane)
	BOOLEAN_PROPERTY(Brush, use_automasking_topology)
	BOOLEAN_PROPERTY(Brush, use_automasking_face_sets)
	BOOLEAN_PROPERTY(Brush, use_automasking_boundary_edges)
	BOOLEAN_PROPERTY(Brush, use_automasking_boundary_face_sets)
	BOOLEAN_PROPERTY(Brush, use_automasking_cavity)
	BOOLEAN_PROPERTY(Brush, use_automasking_cavity_inverted)
	BOOLEAN_PROPERTY(Brush, use_automasking_custom_cavity_curve)
	FLOAT_PROPERTY(Brush, automasking_cavity_factor)
	INT_PROPERTY(Brush, automasking_cavity_blur_steps)
	POINTER_PROPERTY(CurveMapping, Brush, automasking_cavity_curve)
	BOOLEAN_PROPERTY(Brush, use_automasking_start_normal)
	BOOLEAN_PROPERTY(Brush, use_automasking_view_normal)
	BOOLEAN_PROPERTY(Brush, use_automasking_view_occlusion)
	ENUM_PROPERTY(use_scene_spacing_enum, Brush, use_scene_spacing)
	BOOLEAN_PROPERTY(Brush, use_grab_active_vertex)
	BOOLEAN_PROPERTY(Brush, use_grab_silhouette)
	BOOLEAN_PROPERTY(Brush, use_paint_antialiasing)
	BOOLEAN_PROPERTY(Brush, use_multiplane_scrape_dynamic)
	BOOLEAN_PROPERTY(Brush, show_multiplane_scrape_planes_preview)
	BOOLEAN_PROPERTY(Brush, use_pose_ik_anchored)
	BOOLEAN_PROPERTY(Brush, use_pose_lock_rotation)
	BOOLEAN_PROPERTY(Brush, use_connected_only)
	BOOLEAN_PROPERTY(Brush, use_cloth_pin_simulation_boundary)
	BOOLEAN_PROPERTY(Brush, use_cloth_collision)
	BOOLEAN_PROPERTY(Brush, invert_to_scrape_fill)
	BOOLEAN_PROPERTY(Brush, use_pressure_strength)
	BOOLEAN_PROPERTY(Brush, use_offset_pressure)
	BOOLEAN_PROPERTY(Brush, use_pressure_area_radius)
	BOOLEAN_PROPERTY(Brush, use_pressure_size)
	BOOLEAN_PROPERTY(Brush, use_pressure_jitter)
	BOOLEAN_PROPERTY(Brush, use_pressure_spacing)
	ENUM_PROPERTY(use_pressure_masking_enum, Brush, use_pressure_masking)
	BOOLEAN_PROPERTY(Brush, use_inverse_smooth_pressure)
	BOOLEAN_PROPERTY(Brush, use_plane_trim)
	BOOLEAN_PROPERTY(Brush, use_frontface)
	BOOLEAN_PROPERTY(Brush, use_frontface_falloff)
	BOOLEAN_PROPERTY(Brush, use_anchor)
	BOOLEAN_PROPERTY(Brush, use_space)
	BOOLEAN_PROPERTY(Brush, use_line)
	BOOLEAN_PROPERTY(Brush, use_curve)
	BOOLEAN_PROPERTY(Brush, use_smooth_stroke)
	BOOLEAN_PROPERTY(Brush, use_persistent)
	BOOLEAN_PROPERTY(Brush, use_accumulate)
	BOOLEAN_PROPERTY(Brush, use_space_attenuation)
	BOOLEAN_PROPERTY(Brush, use_adaptive_space)
	ENUM_PROPERTY(use_locked_size_enum, Brush, use_locked_size)
	ENUM_PROPERTY(color_type_enum, Brush, color_type)
	BOOLEAN_PROPERTY(Brush, use_edge_to_edge)
	BOOLEAN_PROPERTY(Brush, use_restore_mesh)
	BOOLEAN_PROPERTY(Brush, use_alpha)
	POINTER_PROPERTY(CurveMapping, Brush, curve)
	POINTER_PROPERTY(PaintCurve, Brush, paint_curve)
	POINTER_PROPERTY(ColorRamp, Brush, gradient)
	ENUM_PROPERTY(gradient_stroke_mode_enum, Brush, gradient_stroke_mode)
	ENUM_PROPERTY(gradient_fill_mode_enum, Brush, gradient_fill_mode)
	BOOLEAN_PROPERTY(Brush, use_primary_overlay)
	BOOLEAN_PROPERTY(Brush, use_secondary_overlay)
	BOOLEAN_PROPERTY(Brush, use_cursor_overlay)
	BOOLEAN_PROPERTY(Brush, use_cursor_overlay_override)
	BOOLEAN_PROPERTY(Brush, use_primary_overlay_override)
	BOOLEAN_PROPERTY(Brush, use_secondary_overlay_override)
	BOOLEAN_PROPERTY(Brush, use_paint_sculpt)
	BOOLEAN_PROPERTY(Brush, use_paint_uv_sculpt)
	BOOLEAN_PROPERTY(Brush, use_paint_vertex)
	BOOLEAN_PROPERTY(Brush, use_paint_weight)
	BOOLEAN_PROPERTY(Brush, use_paint_image)
	BOOLEAN_PROPERTY(Brush, use_paint_grease_pencil)
	BOOLEAN_PROPERTY(Brush, use_vertex_grease_pencil)
	BOOLEAN_PROPERTY(Brush, use_paint_sculpt_curves)
	POINTER_PROPERTY(BrushTextureSlot, Brush, texture_slot)
	POINTER_PROPERTY(Texture, Brush, texture)
	POINTER_PROPERTY(BrushTextureSlot, Brush, mask_texture_slot)
	POINTER_PROPERTY(Texture, Brush, mask_texture)
	INT_PROPERTY(Brush, texture_overlay_alpha)
	INT_PROPERTY(Brush, mask_overlay_alpha)
	INT_PROPERTY(Brush, cursor_overlay_alpha)
	FLOAT_ARRAY_PROPERTY(Brush, 4, cursor_color_add)
	FLOAT_ARRAY_PROPERTY(Brush, 4, cursor_color_subtract)
	BOOLEAN_PROPERTY(Brush, use_custom_icon)
	STRING_PROPERTY(Brush, icon_filepath)
	POINTER_PROPERTY(Image, Brush, clone_image)
	FLOAT_PROPERTY(Brush, clone_alpha)
	FLOAT_ARRAY_PROPERTY(Brush, 2, clone_offset)
	POINTER_PROPERTY(BrushCapabilities, Brush, brush_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesSculpt, Brush, sculpt_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesImagePaint, Brush, image_paint_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesVertexPaint, Brush, vertex_paint_capabilities)
	POINTER_PROPERTY(BrushCapabilitiesWeightPaint, Brush, weight_paint_capabilities)
	POINTER_PROPERTY(BrushGpencilSettings, Brush, gpencil_settings)
	POINTER_PROPERTY(BrushCurvesSculptSettings, Brush, curves_sculpt_settings)


	POINTER_PROPERTY(Struct, BrushCapabilities, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilities, has_overlay)
	BOOLEAN_PROPERTY(BrushCapabilities, has_random_texture_angle)
	BOOLEAN_PROPERTY(BrushCapabilities, has_spacing)
	BOOLEAN_PROPERTY(BrushCapabilities, has_smooth_stroke)


	POINTER_PROPERTY(Struct, BrushCapabilitiesSculpt, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_accumulate)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_auto_smooth)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_topology_rake)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_height)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_jitter)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_normal_weight)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_rake_factor)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_persistence)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_pinch_factor)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_plane_offset)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_random_texture_angle)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_sculpt_plane)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_color)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_secondary_color)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_smooth_stroke)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_space_attenuation)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_strength_pressure)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_direction)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_gravity)
	BOOLEAN_PROPERTY(BrushCapabilitiesSculpt, has_tilt)


	POINTER_PROPERTY(Struct, BrushCapabilitiesImagePaint, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_accumulate)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_space_attenuation)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_radius)
	BOOLEAN_PROPERTY(BrushCapabilitiesImagePaint, has_color)


	POINTER_PROPERTY(Struct, BrushCapabilitiesVertexPaint, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesVertexPaint, has_color)


	POINTER_PROPERTY(Struct, BrushCapabilitiesWeightPaint, rna_type)
	BOOLEAN_PROPERTY(BrushCapabilitiesWeightPaint, has_weight)


	POINTER_PROPERTY(Struct, BrushGpencilSettings, rna_type)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_strength)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_jitter)
	FLOAT_PROPERTY(BrushGpencilSettings, random_pressure)
	FLOAT_PROPERTY(BrushGpencilSettings, random_strength)
	FLOAT_PROPERTY(BrushGpencilSettings, angle)
	FLOAT_PROPERTY(BrushGpencilSettings, angle_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, pen_smooth_factor)
	INT_PROPERTY(BrushGpencilSettings, pen_smooth_steps)
	INT_PROPERTY(BrushGpencilSettings, pen_subdivision_steps)
	FLOAT_PROPERTY(BrushGpencilSettings, simplify_factor)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_sensitivity)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_strength)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_jitter)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_random_pressure)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_random_strength)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_random_uv)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_random_hue)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_random_saturation)
	POINTER_PROPERTY(CurveMapping, BrushGpencilSettings, curve_random_value)
	FLOAT_PROPERTY(BrushGpencilSettings, fill_threshold)
	FLOAT_PROPERTY(BrushGpencilSettings, fill_factor)
	INT_PROPERTY(BrushGpencilSettings, fill_simplify_level)
	FLOAT_PROPERTY(BrushGpencilSettings, uv_random)
	FLOAT_PROPERTY(BrushGpencilSettings, hardness)
	FLOAT_ARRAY_PROPERTY(BrushGpencilSettings, 2, aspect)
	INT_PROPERTY(BrushGpencilSettings, input_samples)
	FLOAT_PROPERTY(BrushGpencilSettings, active_smooth_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, eraser_strength_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, eraser_thickness_factor)
	ENUM_PROPERTY(gpencil_paint_icon_enum, BrushGpencilSettings, gpencil_paint_icon)
	ENUM_PROPERTY(gpencil_sculpt_icon_enum, BrushGpencilSettings, gpencil_sculpt_icon)
	ENUM_PROPERTY(gpencil_weight_icon_enum, BrushGpencilSettings, gpencil_weight_icon)
	ENUM_PROPERTY(gpencil_vertex_icon_enum, BrushGpencilSettings, gpencil_vertex_icon)
	ENUM_PROPERTY(vertex_mode_enum, BrushGpencilSettings, vertex_mode)
	FLOAT_PROPERTY(BrushGpencilSettings, vertex_color_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, random_hue_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, random_saturation_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, random_value_factor)
	FLOAT_PROPERTY(BrushGpencilSettings, extend_stroke_factor)
	ENUM_PROPERTY(fill_extend_mode_enum, BrushGpencilSettings, fill_extend_mode)
	INT_PROPERTY(BrushGpencilSettings, dilate)
	FLOAT_PROPERTY(BrushGpencilSettings, outline_thickness_factor)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_pressure)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_strength_pressure)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_jitter_pressure)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_stroke_random_hue)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_stroke_random_sat)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_stroke_random_val)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_stroke_random_radius)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_stroke_random_strength)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_stroke_random_uv)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_random_press_hue)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_random_press_sat)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_random_press_val)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_random_press_radius)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_random_press_strength)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_random_press_uv)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_settings_stabilizer)
	ENUM_PROPERTY(eraser_mode_enum, BrushGpencilSettings, eraser_mode)
	ENUM_PROPERTY(caps_type_enum, BrushGpencilSettings, caps_type)
	ENUM_PROPERTY(fill_draw_mode_enum, BrushGpencilSettings, fill_draw_mode)
	ENUM_PROPERTY(fill_layer_mode_enum, BrushGpencilSettings, fill_layer_mode)
	ENUM_PROPERTY(fill_direction_enum, BrushGpencilSettings, fill_direction)
	BOOLEAN_PROPERTY(BrushGpencilSettings, pin_draw_mode)
	ENUM_PROPERTY(brush_draw_mode_enum, BrushGpencilSettings, brush_draw_mode)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_trim)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_settings_outline)
	ENUM_PROPERTY(direction_enum, BrushGpencilSettings, direction)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_edit_position)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_edit_strength)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_edit_thickness)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_edit_uv)
	POINTER_PROPERTY(Material, BrushGpencilSettings, material)
	POINTER_PROPERTY(Material, BrushGpencilSettings, material_alt)
	BOOLEAN_PROPERTY(BrushGpencilSettings, show_fill_boundary)
	BOOLEAN_PROPERTY(BrushGpencilSettings, show_fill_extend)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_collide_strokes)
	BOOLEAN_PROPERTY(BrushGpencilSettings, show_fill)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_fill_limit)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_default_eraser)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_settings_postprocess)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_settings_random)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_material_pin)
	BOOLEAN_PROPERTY(BrushGpencilSettings, show_lasso)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_occlude_eraser)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_keep_caps_eraser)
	BOOLEAN_PROPERTY(BrushGpencilSettings, use_active_layer_only)


	POINTER_PROPERTY(Struct, BrushCurvesSculptSettings, rna_type)
	INT_PROPERTY(BrushCurvesSculptSettings, add_amount)
	INT_PROPERTY(BrushCurvesSculptSettings, points_per_curve)
	BOOLEAN_PROPERTY(BrushCurvesSculptSettings, scale_uniform)
	FLOAT_PROPERTY(BrushCurvesSculptSettings, minimum_length)
	BOOLEAN_PROPERTY(BrushCurvesSculptSettings, interpolate_length)
	BOOLEAN_PROPERTY(BrushCurvesSculptSettings, interpolate_point_count)
	BOOLEAN_PROPERTY(BrushCurvesSculptSettings, interpolate_shape)
	FLOAT_PROPERTY(BrushCurvesSculptSettings, curve_length)
	FLOAT_PROPERTY(BrushCurvesSculptSettings, minimum_distance)
	INT_PROPERTY(BrushCurvesSculptSettings, density_add_attempts)
	ENUM_PROPERTY(density_mode_enum, BrushCurvesSculptSettings, density_mode)
	POINTER_PROPERTY(CurveMapping, BrushCurvesSculptSettings, curve_parameter_falloff)


	FLOAT_PROPERTY(BrushTextureSlot, angle)
	ENUM_PROPERTY(map_mode_enum, BrushTextureSlot, map_mode)
	ENUM_PROPERTY(mask_map_mode_enum, BrushTextureSlot, mask_map_mode)
	BOOLEAN_PROPERTY(BrushTextureSlot, use_rake)
	BOOLEAN_PROPERTY(BrushTextureSlot, use_random)
	FLOAT_PROPERTY(BrushTextureSlot, random_angle)
	BOOLEAN_PROPERTY(BrushTextureSlot, has_texture_angle_source)
	BOOLEAN_PROPERTY(BrushTextureSlot, has_random_texture_angle)
	BOOLEAN_PROPERTY(BrushTextureSlot, has_texture_angle)




	STRING_PROPERTY(CacheFile, filepath)
	BOOLEAN_PROPERTY(CacheFile, is_sequence)
	BOOLEAN_PROPERTY(CacheFile, use_render_procedural)
	BOOLEAN_PROPERTY(CacheFile, override_frame)
	FLOAT_PROPERTY(CacheFile, frame)
	FLOAT_PROPERTY(CacheFile, frame_offset)
	BOOLEAN_PROPERTY(CacheFile, use_prefetch)
	INT_PROPERTY(CacheFile, prefetch_cache_size)
	ENUM_PROPERTY(forward_axis_enum, CacheFile, forward_axis)
	ENUM_PROPERTY(up_axis_enum, CacheFile, up_axis)
	FLOAT_PROPERTY(CacheFile, scale)

	STRING_PROPERTY(CacheFile, velocity_name)
	ENUM_PROPERTY(velocity_unit_enum, CacheFile, velocity_unit)

	INT_PROPERTY(CacheFile, active_index)
	POINTER_PROPERTY(AnimData, CacheFile, animation_data)


	POINTER_PROPERTY(Struct, CacheFileLayers, rna_type)
	POINTER_PROPERTY(CacheFileLayer, CacheFileLayers, active)

	inline CacheFileLayer CacheFileLayers::create(Context C, const char * filepath) {
		PointerRNA result;
		::CacheFileLayer *retdata = CacheFileLayers_new_func((::CacheFile *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, filepath);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_CacheFileLayer, retdata);
		return CacheFileLayer(result);
	}

	inline void CacheFileLayers::remove(Context C, CacheFileLayer& layer) {
		CacheFileLayers_remove_func((::CacheFile *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &layer.ptr);
	}


	POINTER_PROPERTY(Struct, CacheObjectPaths, rna_type)


	POINTER_PROPERTY(Struct, CacheObjectPath, rna_type)
	STRING_PROPERTY(CacheObjectPath, path)


	POINTER_PROPERTY(Struct, CacheFileLayer, rna_type)
	STRING_PROPERTY(CacheFileLayer, filepath)
	BOOLEAN_PROPERTY(CacheFileLayer, hide_layer)


	ENUM_PROPERTY(type_enum, Camera, type)
	ENUM_PROPERTY(sensor_fit_enum, Camera, sensor_fit)
	FLOAT_PROPERTY(Camera, passepartout_alpha)
	FLOAT_PROPERTY(Camera, angle_x)
	FLOAT_PROPERTY(Camera, angle_y)
	FLOAT_PROPERTY(Camera, angle)
	FLOAT_PROPERTY(Camera, clip_start)
	FLOAT_PROPERTY(Camera, clip_end)
	FLOAT_PROPERTY(Camera, lens)
	FLOAT_PROPERTY(Camera, sensor_width)
	FLOAT_PROPERTY(Camera, sensor_height)
	FLOAT_PROPERTY(Camera, ortho_scale)
	FLOAT_PROPERTY(Camera, display_size)
	FLOAT_PROPERTY(Camera, shift_x)
	FLOAT_PROPERTY(Camera, shift_y)
	POINTER_PROPERTY(CameraStereoData, Camera, stereo)
	BOOLEAN_PROPERTY(Camera, show_limits)
	BOOLEAN_PROPERTY(Camera, show_mist)
	BOOLEAN_PROPERTY(Camera, show_passepartout)
	BOOLEAN_PROPERTY(Camera, show_safe_areas)
	BOOLEAN_PROPERTY(Camera, show_safe_center)
	BOOLEAN_PROPERTY(Camera, show_name)
	BOOLEAN_PROPERTY(Camera, show_sensor)
	BOOLEAN_PROPERTY(Camera, show_background_images)
	ENUM_PROPERTY(lens_unit_enum, Camera, lens_unit)
	BOOLEAN_PROPERTY(Camera, show_composition_center)
	BOOLEAN_PROPERTY(Camera, show_composition_center_diagonal)
	BOOLEAN_PROPERTY(Camera, show_composition_thirds)
	BOOLEAN_PROPERTY(Camera, show_composition_golden)
	BOOLEAN_PROPERTY(Camera, show_composition_golden_tria_a)
	BOOLEAN_PROPERTY(Camera, show_composition_golden_tria_b)
	BOOLEAN_PROPERTY(Camera, show_composition_harmony_tri_a)
	BOOLEAN_PROPERTY(Camera, show_composition_harmony_tri_b)
	ENUM_PROPERTY(panorama_type_enum, Camera, panorama_type)
	FLOAT_PROPERTY(Camera, fisheye_fov)
	FLOAT_PROPERTY(Camera, fisheye_lens)
	FLOAT_PROPERTY(Camera, latitude_min)
	FLOAT_PROPERTY(Camera, latitude_max)
	FLOAT_PROPERTY(Camera, longitude_min)
	FLOAT_PROPERTY(Camera, longitude_max)
	FLOAT_PROPERTY(Camera, fisheye_polynomial_k0)
	FLOAT_PROPERTY(Camera, fisheye_polynomial_k1)
	FLOAT_PROPERTY(Camera, fisheye_polynomial_k2)
	FLOAT_PROPERTY(Camera, fisheye_polynomial_k3)
	FLOAT_PROPERTY(Camera, fisheye_polynomial_k4)
	POINTER_PROPERTY(CameraDOFSettings, Camera, dof)

	POINTER_PROPERTY(AnimData, Camera, animation_data)

	inline void Camera::view_frame(Scene& scene, float result_1[3], float result_2[3], float result_3[3], float result_4[3]) {
		Camera_view_frame_func((::Camera *) this->ptr.data, (::Scene *) scene.ptr.data, result_1, result_2, result_3, result_4);
	}


	POINTER_PROPERTY(Struct, CameraBackgroundImage, rna_type)
	BOOLEAN_PROPERTY(CameraBackgroundImage, is_override_data)
	ENUM_PROPERTY(source_enum, CameraBackgroundImage, source)
	POINTER_PROPERTY(Image, CameraBackgroundImage, image)
	POINTER_PROPERTY(MovieClip, CameraBackgroundImage, clip)
	POINTER_PROPERTY(ImageUser, CameraBackgroundImage, image_user)
	POINTER_PROPERTY(MovieClipUser, CameraBackgroundImage, clip_user)
	FLOAT_ARRAY_PROPERTY(CameraBackgroundImage, 2, offset)
	FLOAT_PROPERTY(CameraBackgroundImage, scale)
	FLOAT_PROPERTY(CameraBackgroundImage, rotation)
	BOOLEAN_PROPERTY(CameraBackgroundImage, use_flip_x)
	BOOLEAN_PROPERTY(CameraBackgroundImage, use_flip_y)
	FLOAT_PROPERTY(CameraBackgroundImage, alpha)
	BOOLEAN_PROPERTY(CameraBackgroundImage, show_expanded)
	BOOLEAN_PROPERTY(CameraBackgroundImage, use_camera_clip)
	BOOLEAN_PROPERTY(CameraBackgroundImage, show_background_image)
	BOOLEAN_PROPERTY(CameraBackgroundImage, show_on_foreground)
	ENUM_PROPERTY(display_depth_enum, CameraBackgroundImage, display_depth)
	ENUM_PROPERTY(frame_method_enum, CameraBackgroundImage, frame_method)


	POINTER_PROPERTY(Struct, CameraBackgroundImages, rna_type)

	inline CameraBackgroundImage CameraBackgroundImages::create() {
		PointerRNA result;
		::CameraBGImage *retdata = CameraBackgroundImages_new_func((::Camera *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_CameraBackgroundImage, retdata);
		return CameraBackgroundImage(result);
	}

	inline void CameraBackgroundImages::remove(CameraBackgroundImage& image) {
		CameraBackgroundImages_remove_func((::Camera *) this->ptr.data, nullptr, (::PointerRNA *) &image.ptr);
	}

	inline void CameraBackgroundImages::clear() {
		CameraBackgroundImages_clear_func((::Camera *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, CameraStereoData, rna_type)
	ENUM_PROPERTY(convergence_mode_enum, CameraStereoData, convergence_mode)
	ENUM_PROPERTY(pivot_enum, CameraStereoData, pivot)
	FLOAT_PROPERTY(CameraStereoData, interocular_distance)
	FLOAT_PROPERTY(CameraStereoData, convergence_distance)
	BOOLEAN_PROPERTY(CameraStereoData, use_spherical_stereo)
	BOOLEAN_PROPERTY(CameraStereoData, use_pole_merge)
	FLOAT_PROPERTY(CameraStereoData, pole_merge_angle_from)
	FLOAT_PROPERTY(CameraStereoData, pole_merge_angle_to)


	POINTER_PROPERTY(Struct, CameraDOFSettings, rna_type)
	BOOLEAN_PROPERTY(CameraDOFSettings, use_dof)
	POINTER_PROPERTY(Object, CameraDOFSettings, focus_object)
	STRING_PROPERTY(CameraDOFSettings, focus_subtarget)
	FLOAT_PROPERTY(CameraDOFSettings, focus_distance)
	FLOAT_PROPERTY(CameraDOFSettings, aperture_fstop)
	INT_PROPERTY(CameraDOFSettings, aperture_blades)
	FLOAT_PROPERTY(CameraDOFSettings, aperture_rotation)
	FLOAT_PROPERTY(CameraDOFSettings, aperture_ratio)


	POINTER_PROPERTY(Struct, ClothSolverResult, rna_type)
	ENUM_PROPERTY(status_enum, ClothSolverResult, status)
	FLOAT_PROPERTY(ClothSolverResult, max_error)
	FLOAT_PROPERTY(ClothSolverResult, min_error)
	FLOAT_PROPERTY(ClothSolverResult, avg_error)
	INT_PROPERTY(ClothSolverResult, max_iterations)
	INT_PROPERTY(ClothSolverResult, min_iterations)
	FLOAT_PROPERTY(ClothSolverResult, avg_iterations)


	POINTER_PROPERTY(Struct, ClothSettings, rna_type)
	FLOAT_PROPERTY(ClothSettings, goal_min)
	FLOAT_PROPERTY(ClothSettings, goal_max)
	FLOAT_PROPERTY(ClothSettings, goal_default)
	FLOAT_PROPERTY(ClothSettings, goal_spring)
	FLOAT_PROPERTY(ClothSettings, goal_friction)
	FLOAT_PROPERTY(ClothSettings, internal_friction)
	FLOAT_PROPERTY(ClothSettings, collider_friction)
	FLOAT_PROPERTY(ClothSettings, density_target)
	FLOAT_PROPERTY(ClothSettings, density_strength)
	FLOAT_PROPERTY(ClothSettings, mass)
	STRING_PROPERTY(ClothSettings, vertex_group_mass)
	FLOAT_ARRAY_PROPERTY(ClothSettings, 3, gravity)
	FLOAT_PROPERTY(ClothSettings, air_damping)
	FLOAT_PROPERTY(ClothSettings, pin_stiffness)
	INT_PROPERTY(ClothSettings, quality)
	FLOAT_PROPERTY(ClothSettings, time_scale)
	STRING_PROPERTY(ClothSettings, vertex_group_shrink)
	FLOAT_PROPERTY(ClothSettings, shrink_min)
	FLOAT_PROPERTY(ClothSettings, shrink_max)
	FLOAT_PROPERTY(ClothSettings, voxel_cell_size)
	FLOAT_PROPERTY(ClothSettings, tension_damping)
	FLOAT_PROPERTY(ClothSettings, compression_damping)
	FLOAT_PROPERTY(ClothSettings, shear_damping)
	FLOAT_PROPERTY(ClothSettings, tension_stiffness)
	FLOAT_PROPERTY(ClothSettings, tension_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, compression_stiffness)
	FLOAT_PROPERTY(ClothSettings, compression_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, shear_stiffness)
	FLOAT_PROPERTY(ClothSettings, shear_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, sewing_force_max)
	STRING_PROPERTY(ClothSettings, vertex_group_structural_stiffness)
	STRING_PROPERTY(ClothSettings, vertex_group_shear_stiffness)
	FLOAT_PROPERTY(ClothSettings, bending_stiffness)
	FLOAT_PROPERTY(ClothSettings, bending_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, bending_damping)
	BOOLEAN_PROPERTY(ClothSettings, use_sewing_springs)
	STRING_PROPERTY(ClothSettings, vertex_group_bending)
	POINTER_PROPERTY(EffectorWeights, ClothSettings, effector_weights)
	POINTER_PROPERTY(ShapeKey, ClothSettings, rest_shape_key)
	BOOLEAN_PROPERTY(ClothSettings, use_dynamic_mesh)
	ENUM_PROPERTY(bending_model_enum, ClothSettings, bending_model)
	BOOLEAN_PROPERTY(ClothSettings, use_internal_springs)
	BOOLEAN_PROPERTY(ClothSettings, internal_spring_normal_check)
	FLOAT_PROPERTY(ClothSettings, internal_spring_max_length)
	FLOAT_PROPERTY(ClothSettings, internal_spring_max_diversion)
	FLOAT_PROPERTY(ClothSettings, internal_tension_stiffness)
	FLOAT_PROPERTY(ClothSettings, internal_tension_stiffness_max)
	FLOAT_PROPERTY(ClothSettings, internal_compression_stiffness)
	FLOAT_PROPERTY(ClothSettings, internal_compression_stiffness_max)
	STRING_PROPERTY(ClothSettings, vertex_group_intern)
	BOOLEAN_PROPERTY(ClothSettings, use_pressure)
	BOOLEAN_PROPERTY(ClothSettings, use_pressure_volume)
	FLOAT_PROPERTY(ClothSettings, uniform_pressure_force)
	FLOAT_PROPERTY(ClothSettings, target_volume)
	FLOAT_PROPERTY(ClothSettings, pressure_factor)
	FLOAT_PROPERTY(ClothSettings, fluid_density)
	STRING_PROPERTY(ClothSettings, vertex_group_pressure)


	POINTER_PROPERTY(Struct, ClothCollisionSettings, rna_type)
	BOOLEAN_PROPERTY(ClothCollisionSettings, use_collision)
	FLOAT_PROPERTY(ClothCollisionSettings, distance_min)
	FLOAT_PROPERTY(ClothCollisionSettings, friction)
	FLOAT_PROPERTY(ClothCollisionSettings, damping)
	INT_PROPERTY(ClothCollisionSettings, collision_quality)
	FLOAT_PROPERTY(ClothCollisionSettings, impulse_clamp)
	BOOLEAN_PROPERTY(ClothCollisionSettings, use_self_collision)
	FLOAT_PROPERTY(ClothCollisionSettings, self_distance_min)
	FLOAT_PROPERTY(ClothCollisionSettings, self_friction)
	POINTER_PROPERTY(Collection, ClothCollisionSettings, collection)
	STRING_PROPERTY(ClothCollisionSettings, vertex_group_self_collisions)
	STRING_PROPERTY(ClothCollisionSettings, vertex_group_object_collisions)
	FLOAT_PROPERTY(ClothCollisionSettings, self_impulse_clamp)


	FLOAT_ARRAY_PROPERTY(Collection, 3, instance_offset)





	BOOLEAN_PROPERTY(Collection, hide_select)
	BOOLEAN_PROPERTY(Collection, hide_viewport)
	BOOLEAN_PROPERTY(Collection, hide_render)
	ENUM_PROPERTY(lineart_usage_enum, Collection, lineart_usage)
	BOOLEAN_PROPERTY(Collection, lineart_use_intersection_mask)
	BOOLEAN_ARRAY_PROPERTY(Collection, 8, lineart_intersection_mask)
	INT_PROPERTY(Collection, lineart_intersection_priority)
	BOOLEAN_PROPERTY(Collection, use_lineart_intersection_priority)
	ENUM_PROPERTY(color_tag_enum, Collection, color_tag)


	POINTER_PROPERTY(Struct, CollectionObjects, rna_type)

	inline void CollectionObjects::link(void *main, Object& object) {
		CollectionObjects_link_func((::Collection *) this->ptr.data, (::Main *) main, nullptr, (::Object *) object.ptr.data);
	}

	inline void CollectionObjects::unlink(void *main, Object& object) {
		CollectionObjects_unlink_func((::Collection *) this->ptr.data, (::Main *) main, nullptr, (::Object *) object.ptr.data);
	}


	POINTER_PROPERTY(Struct, CollectionChildren, rna_type)

	inline void CollectionChildren::link(void *main, Collection& child) {
		CollectionChildren_link_func((::Collection *) this->ptr.data, (::Main *) main, nullptr, (::Collection *) child.ptr.data);
	}

	inline void CollectionChildren::unlink(void *main, Collection& child) {
		CollectionChildren_unlink_func((::Collection *) this->ptr.data, (::Main *) main, nullptr, (::Collection *) child.ptr.data);
	}


	POINTER_PROPERTY(Struct, CollectionLightLinking, rna_type)
	ENUM_PROPERTY(link_state_enum, CollectionLightLinking, link_state)


	POINTER_PROPERTY(Struct, CollectionObject, rna_type)
	POINTER_PROPERTY(CollectionLightLinking, CollectionObject, light_linking)


	POINTER_PROPERTY(Struct, CollectionChild, rna_type)
	POINTER_PROPERTY(CollectionLightLinking, CollectionChild, light_linking)


	POINTER_PROPERTY(Struct, CurveMapPoint, rna_type)
	FLOAT_ARRAY_PROPERTY(CurveMapPoint, 2, location)
	ENUM_PROPERTY(handle_type_enum, CurveMapPoint, handle_type)
	BOOLEAN_PROPERTY(CurveMapPoint, select)


	POINTER_PROPERTY(Struct, CurveMap, rna_type)



	POINTER_PROPERTY(Struct, CurveMapPoints, rna_type)

	inline CurveMapPoint CurveMapPoints::create(float position, float value) {
		PointerRNA result;
		::CurveMapPoint *retdata = CurveMapPoints_new_func((::CurveMap *) this->ptr.data, position, value);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_CurveMapPoint, retdata);
		return CurveMapPoint(result);
	}

	inline void CurveMapPoints::remove(CurveMapPoint& point) {
		CurveMapPoints_remove_func((::CurveMap *) this->ptr.data, nullptr, (::PointerRNA *) &point.ptr);
	}


	POINTER_PROPERTY(Struct, CurveMapping, rna_type)
	ENUM_PROPERTY(tone_enum, CurveMapping, tone)
	BOOLEAN_PROPERTY(CurveMapping, use_clip)
	FLOAT_PROPERTY(CurveMapping, clip_min_x)
	FLOAT_PROPERTY(CurveMapping, clip_min_y)
	FLOAT_PROPERTY(CurveMapping, clip_max_x)
	FLOAT_PROPERTY(CurveMapping, clip_max_y)
	ENUM_PROPERTY(extend_enum, CurveMapping, extend)

	FLOAT_ARRAY_PROPERTY(CurveMapping, 3, black_level)
	FLOAT_ARRAY_PROPERTY(CurveMapping, 3, white_level)

	inline void CurveMapping::update() {
		CurveMapping_update_func((::CurveMapping *) this->ptr.data);
	}

	inline void CurveMapping::reset_view() {
		CurveMapping_reset_view_func((::CurveMapping *) this->ptr.data);
	}

	inline void CurveMapping::initialize() {
		CurveMapping_initialize_func((::CurveMapping *) this->ptr.data);
	}

	inline float CurveMapping::evaluate(CurveMap& curve, float position) {
		return CurveMapping_evaluate_func((::CurveMapping *) this->ptr.data, nullptr, (::CurveMap *) curve.ptr.data, position);
	}


	POINTER_PROPERTY(Struct, ColorRampElement, rna_type)
	FLOAT_ARRAY_PROPERTY(ColorRampElement, 4, color)
	FLOAT_PROPERTY(ColorRampElement, alpha)
	FLOAT_PROPERTY(ColorRampElement, position)


	POINTER_PROPERTY(Struct, ColorRamp, rna_type)

	ENUM_PROPERTY(interpolation_enum, ColorRamp, interpolation)
	ENUM_PROPERTY(hue_interpolation_enum, ColorRamp, hue_interpolation)
	ENUM_PROPERTY(color_mode_enum, ColorRamp, color_mode)

	inline void ColorRamp::evaluate(float position, float color[4]) {
		ColorRamp_evaluate_func((::ColorBand *) this->ptr.data, position, color);
	}


	POINTER_PROPERTY(Struct, ColorRampElements, rna_type)

	inline ColorRampElement ColorRampElements::create(float position) {
		PointerRNA result;
		::CBData *retdata = ColorRampElements_new_func((::ColorBand *) this->ptr.data, nullptr, position);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ColorRampElement, retdata);
		return ColorRampElement(result);
	}

	inline void ColorRampElements::remove(ColorRampElement& element) {
		ColorRampElements_remove_func((::ColorBand *) this->ptr.data, nullptr, (::PointerRNA *) &element.ptr);
	}


	POINTER_PROPERTY(Struct, Histogram, rna_type)
	ENUM_PROPERTY(mode_enum, Histogram, mode)
	BOOLEAN_PROPERTY(Histogram, show_line)


	POINTER_PROPERTY(Struct, Scopes, rna_type)
	BOOLEAN_PROPERTY(Scopes, use_full_resolution)
	FLOAT_PROPERTY(Scopes, accuracy)
	POINTER_PROPERTY(Histogram, Scopes, histogram)
	ENUM_PROPERTY(waveform_mode_enum, Scopes, waveform_mode)
	FLOAT_PROPERTY(Scopes, waveform_alpha)
	FLOAT_PROPERTY(Scopes, vectorscope_alpha)


	POINTER_PROPERTY(Struct, ColorManagedDisplaySettings, rna_type)
	ENUM_PROPERTY(display_device_enum, ColorManagedDisplaySettings, display_device)


	POINTER_PROPERTY(Struct, ColorManagedViewSettings, rna_type)
	ENUM_PROPERTY(look_enum, ColorManagedViewSettings, look)
	ENUM_PROPERTY(view_transform_enum, ColorManagedViewSettings, view_transform)
	FLOAT_PROPERTY(ColorManagedViewSettings, exposure)
	FLOAT_PROPERTY(ColorManagedViewSettings, gamma)
	POINTER_PROPERTY(CurveMapping, ColorManagedViewSettings, curve_mapping)
	BOOLEAN_PROPERTY(ColorManagedViewSettings, use_curve_mapping)
	BOOLEAN_PROPERTY(ColorManagedViewSettings, use_hdr_view)


	POINTER_PROPERTY(Struct, ColorManagedInputColorspaceSettings, rna_type)
	ENUM_PROPERTY(name_enum, ColorManagedInputColorspaceSettings, name)
	BOOLEAN_PROPERTY(ColorManagedInputColorspaceSettings, is_data)


	POINTER_PROPERTY(Struct, ColorManagedSequencerColorspaceSettings, rna_type)
	ENUM_PROPERTY(name_enum, ColorManagedSequencerColorspaceSettings, name)


	POINTER_PROPERTY(Struct, Constraint, rna_type)
	STRING_PROPERTY(Constraint, name)
	ENUM_PROPERTY(type_enum, Constraint, type)
	BOOLEAN_PROPERTY(Constraint, is_override_data)
	ENUM_PROPERTY(owner_space_enum, Constraint, owner_space)
	ENUM_PROPERTY(target_space_enum, Constraint, target_space)
	POINTER_PROPERTY(Object, Constraint, space_object)
	STRING_PROPERTY(Constraint, space_subtarget)
	BOOLEAN_PROPERTY(Constraint, mute)
	BOOLEAN_PROPERTY(Constraint, enabled)
	BOOLEAN_PROPERTY(Constraint, show_expanded)
	BOOLEAN_PROPERTY(Constraint, is_valid)
	BOOLEAN_PROPERTY(Constraint, active)
	FLOAT_PROPERTY(Constraint, influence)
	FLOAT_PROPERTY(Constraint, error_location)
	FLOAT_PROPERTY(Constraint, error_rotation)


	POINTER_PROPERTY(Struct, ConstraintTarget, rna_type)
	POINTER_PROPERTY(Object, ConstraintTarget, target)
	STRING_PROPERTY(ConstraintTarget, subtarget)


	POINTER_PROPERTY(Struct, ConstraintTargetBone, rna_type)
	POINTER_PROPERTY(Object, ConstraintTargetBone, target)
	STRING_PROPERTY(ConstraintTargetBone, subtarget)
	FLOAT_PROPERTY(ConstraintTargetBone, weight)


	POINTER_PROPERTY(Object, ChildOfConstraint, target)
	STRING_PROPERTY(ChildOfConstraint, subtarget)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_location_x)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_location_y)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_location_z)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_rotation_x)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_rotation_y)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_rotation_z)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_scale_x)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_scale_y)
	BOOLEAN_PROPERTY(ChildOfConstraint, use_scale_z)
	BOOLEAN_PROPERTY(ChildOfConstraint, set_inverse_pending)
	FLOAT_ARRAY_PROPERTY(ChildOfConstraint, 16, inverse_matrix)



	INT_PROPERTY(PythonConstraint, target_count)
	POINTER_PROPERTY(Text, PythonConstraint, text)
	BOOLEAN_PROPERTY(PythonConstraint, use_targets)
	BOOLEAN_PROPERTY(PythonConstraint, has_script_error)



	BOOLEAN_PROPERTY(ArmatureConstraint, use_deform_preserve_volume)
	BOOLEAN_PROPERTY(ArmatureConstraint, use_bone_envelopes)
	BOOLEAN_PROPERTY(ArmatureConstraint, use_current_location)


	POINTER_PROPERTY(Struct, ArmatureConstraintTargets, rna_type)

	inline ConstraintTargetBone ArmatureConstraintTargets::create(void *main) {
		PointerRNA result;
		::bConstraintTarget *retdata = ArmatureConstraintTargets_new_func((::ID *) ptr.owner_id, (::bConstraint *) this->ptr.data, (::Main *) main);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ConstraintTargetBone, retdata);
		return ConstraintTargetBone(result);
	}

	inline void ArmatureConstraintTargets::remove(void *main, ConstraintTargetBone& target) {
		ArmatureConstraintTargets_remove_func((::ID *) ptr.owner_id, (::bConstraint *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &target.ptr);
	}

	inline void ArmatureConstraintTargets::clear(void *main) {
		ArmatureConstraintTargets_clear_func((::ID *) ptr.owner_id, (::bConstraint *) this->ptr.data, (::Main *) main);
	}


	FLOAT_PROPERTY(StretchToConstraint, head_tail)
	BOOLEAN_PROPERTY(StretchToConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, StretchToConstraint, target)
	STRING_PROPERTY(StretchToConstraint, subtarget)
	ENUM_PROPERTY(volume_enum, StretchToConstraint, volume)
	ENUM_PROPERTY(keep_axis_enum, StretchToConstraint, keep_axis)
	FLOAT_PROPERTY(StretchToConstraint, rest_length)
	FLOAT_PROPERTY(StretchToConstraint, bulge)
	BOOLEAN_PROPERTY(StretchToConstraint, use_bulge_min)
	BOOLEAN_PROPERTY(StretchToConstraint, use_bulge_max)
	FLOAT_PROPERTY(StretchToConstraint, bulge_min)
	FLOAT_PROPERTY(StretchToConstraint, bulge_max)
	FLOAT_PROPERTY(StretchToConstraint, bulge_smooth)


	POINTER_PROPERTY(Object, FollowPathConstraint, target)
	FLOAT_PROPERTY(FollowPathConstraint, offset)
	FLOAT_PROPERTY(FollowPathConstraint, offset_factor)
	ENUM_PROPERTY(forward_axis_enum, FollowPathConstraint, forward_axis)
	ENUM_PROPERTY(up_axis_enum, FollowPathConstraint, up_axis)
	BOOLEAN_PROPERTY(FollowPathConstraint, use_curve_follow)
	BOOLEAN_PROPERTY(FollowPathConstraint, use_fixed_location)
	BOOLEAN_PROPERTY(FollowPathConstraint, use_curve_radius)


	FLOAT_PROPERTY(LockedTrackConstraint, head_tail)
	BOOLEAN_PROPERTY(LockedTrackConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, LockedTrackConstraint, target)
	STRING_PROPERTY(LockedTrackConstraint, subtarget)
	ENUM_PROPERTY(track_axis_enum, LockedTrackConstraint, track_axis)
	ENUM_PROPERTY(lock_axis_enum, LockedTrackConstraint, lock_axis)


	POINTER_PROPERTY(Object, ActionConstraint, target)
	STRING_PROPERTY(ActionConstraint, subtarget)
	ENUM_PROPERTY(mix_mode_enum, ActionConstraint, mix_mode)
	ENUM_PROPERTY(transform_channel_enum, ActionConstraint, transform_channel)
	POINTER_PROPERTY(Action, ActionConstraint, action)
	BOOLEAN_PROPERTY(ActionConstraint, use_bone_object_action)
	INT_PROPERTY(ActionConstraint, frame_start)
	INT_PROPERTY(ActionConstraint, frame_end)
	FLOAT_PROPERTY(ActionConstraint, max)
	FLOAT_PROPERTY(ActionConstraint, min)
	FLOAT_PROPERTY(ActionConstraint, eval_time)
	BOOLEAN_PROPERTY(ActionConstraint, use_eval_time)


	POINTER_PROPERTY(Object, CopyScaleConstraint, target)
	STRING_PROPERTY(CopyScaleConstraint, subtarget)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_x)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_y)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_z)
	FLOAT_PROPERTY(CopyScaleConstraint, power)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_make_uniform)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_offset)
	BOOLEAN_PROPERTY(CopyScaleConstraint, use_add)


	ENUM_PROPERTY(free_axis_enum, MaintainVolumeConstraint, free_axis)
	ENUM_PROPERTY(mode_enum, MaintainVolumeConstraint, mode)
	FLOAT_PROPERTY(MaintainVolumeConstraint, volume)


	FLOAT_PROPERTY(CopyLocationConstraint, head_tail)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, CopyLocationConstraint, target)
	STRING_PROPERTY(CopyLocationConstraint, subtarget)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_x)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_y)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_z)
	BOOLEAN_PROPERTY(CopyLocationConstraint, invert_x)
	BOOLEAN_PROPERTY(CopyLocationConstraint, invert_y)
	BOOLEAN_PROPERTY(CopyLocationConstraint, invert_z)
	BOOLEAN_PROPERTY(CopyLocationConstraint, use_offset)


	POINTER_PROPERTY(Object, CopyRotationConstraint, target)
	STRING_PROPERTY(CopyRotationConstraint, subtarget)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_x)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_y)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_z)
	BOOLEAN_PROPERTY(CopyRotationConstraint, invert_x)
	BOOLEAN_PROPERTY(CopyRotationConstraint, invert_y)
	BOOLEAN_PROPERTY(CopyRotationConstraint, invert_z)
	ENUM_PROPERTY(euler_order_enum, CopyRotationConstraint, euler_order)
	ENUM_PROPERTY(mix_mode_enum, CopyRotationConstraint, mix_mode)
	BOOLEAN_PROPERTY(CopyRotationConstraint, use_offset)


	FLOAT_PROPERTY(CopyTransformsConstraint, head_tail)
	BOOLEAN_PROPERTY(CopyTransformsConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, CopyTransformsConstraint, target)
	STRING_PROPERTY(CopyTransformsConstraint, subtarget)
	BOOLEAN_PROPERTY(CopyTransformsConstraint, remove_target_shear)
	ENUM_PROPERTY(mix_mode_enum, CopyTransformsConstraint, mix_mode)


	POINTER_PROPERTY(Object, FloorConstraint, target)
	STRING_PROPERTY(FloorConstraint, subtarget)
	ENUM_PROPERTY(floor_location_enum, FloorConstraint, floor_location)
	BOOLEAN_PROPERTY(FloorConstraint, use_rotation)
	FLOAT_PROPERTY(FloorConstraint, offset)


	FLOAT_PROPERTY(TrackToConstraint, head_tail)
	BOOLEAN_PROPERTY(TrackToConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, TrackToConstraint, target)
	STRING_PROPERTY(TrackToConstraint, subtarget)
	ENUM_PROPERTY(track_axis_enum, TrackToConstraint, track_axis)
	ENUM_PROPERTY(up_axis_enum, TrackToConstraint, up_axis)
	BOOLEAN_PROPERTY(TrackToConstraint, use_target_z)


	POINTER_PROPERTY(Object, KinematicConstraint, target)
	STRING_PROPERTY(KinematicConstraint, subtarget)
	INT_PROPERTY(KinematicConstraint, iterations)
	POINTER_PROPERTY(Object, KinematicConstraint, pole_target)
	STRING_PROPERTY(KinematicConstraint, pole_subtarget)
	FLOAT_PROPERTY(KinematicConstraint, pole_angle)
	FLOAT_PROPERTY(KinematicConstraint, weight)
	FLOAT_PROPERTY(KinematicConstraint, orient_weight)
	INT_PROPERTY(KinematicConstraint, chain_count)
	BOOLEAN_PROPERTY(KinematicConstraint, use_tail)
	ENUM_PROPERTY(reference_axis_enum, KinematicConstraint, reference_axis)
	BOOLEAN_PROPERTY(KinematicConstraint, use_location)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_location_x)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_location_y)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_location_z)
	BOOLEAN_PROPERTY(KinematicConstraint, use_rotation)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_rotation_x)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_rotation_y)
	BOOLEAN_PROPERTY(KinematicConstraint, lock_rotation_z)
	BOOLEAN_PROPERTY(KinematicConstraint, use_stretch)
	ENUM_PROPERTY(ik_type_enum, KinematicConstraint, ik_type)
	ENUM_PROPERTY(limit_mode_enum, KinematicConstraint, limit_mode)
	FLOAT_PROPERTY(KinematicConstraint, distance)


	POINTER_PROPERTY(Object, ClampToConstraint, target)
	ENUM_PROPERTY(main_axis_enum, ClampToConstraint, main_axis)
	BOOLEAN_PROPERTY(ClampToConstraint, use_cyclic)


	FLOAT_PROPERTY(LimitDistanceConstraint, head_tail)
	BOOLEAN_PROPERTY(LimitDistanceConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, LimitDistanceConstraint, target)
	STRING_PROPERTY(LimitDistanceConstraint, subtarget)
	FLOAT_PROPERTY(LimitDistanceConstraint, distance)
	ENUM_PROPERTY(limit_mode_enum, LimitDistanceConstraint, limit_mode)
	BOOLEAN_PROPERTY(LimitDistanceConstraint, use_transform_limit)


	BOOLEAN_PROPERTY(LimitScaleConstraint, use_min_x)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_min_y)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_min_z)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_max_x)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_max_y)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_max_z)
	FLOAT_PROPERTY(LimitScaleConstraint, min_x)
	FLOAT_PROPERTY(LimitScaleConstraint, min_y)
	FLOAT_PROPERTY(LimitScaleConstraint, min_z)
	FLOAT_PROPERTY(LimitScaleConstraint, max_x)
	FLOAT_PROPERTY(LimitScaleConstraint, max_y)
	FLOAT_PROPERTY(LimitScaleConstraint, max_z)
	BOOLEAN_PROPERTY(LimitScaleConstraint, use_transform_limit)


	BOOLEAN_PROPERTY(LimitRotationConstraint, use_limit_x)
	BOOLEAN_PROPERTY(LimitRotationConstraint, use_limit_y)
	BOOLEAN_PROPERTY(LimitRotationConstraint, use_limit_z)
	FLOAT_PROPERTY(LimitRotationConstraint, min_x)
	FLOAT_PROPERTY(LimitRotationConstraint, min_y)
	FLOAT_PROPERTY(LimitRotationConstraint, min_z)
	FLOAT_PROPERTY(LimitRotationConstraint, max_x)
	FLOAT_PROPERTY(LimitRotationConstraint, max_y)
	FLOAT_PROPERTY(LimitRotationConstraint, max_z)
	ENUM_PROPERTY(euler_order_enum, LimitRotationConstraint, euler_order)
	BOOLEAN_PROPERTY(LimitRotationConstraint, use_transform_limit)


	BOOLEAN_PROPERTY(LimitLocationConstraint, use_min_x)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_min_y)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_min_z)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_max_x)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_max_y)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_max_z)
	FLOAT_PROPERTY(LimitLocationConstraint, min_x)
	FLOAT_PROPERTY(LimitLocationConstraint, min_y)
	FLOAT_PROPERTY(LimitLocationConstraint, min_z)
	FLOAT_PROPERTY(LimitLocationConstraint, max_x)
	FLOAT_PROPERTY(LimitLocationConstraint, max_y)
	FLOAT_PROPERTY(LimitLocationConstraint, max_z)
	BOOLEAN_PROPERTY(LimitLocationConstraint, use_transform_limit)


	POINTER_PROPERTY(Object, TransformConstraint, target)
	STRING_PROPERTY(TransformConstraint, subtarget)
	ENUM_PROPERTY(map_from_enum, TransformConstraint, map_from)
	ENUM_PROPERTY(map_to_enum, TransformConstraint, map_to)
	ENUM_PROPERTY(map_to_x_from_enum, TransformConstraint, map_to_x_from)
	ENUM_PROPERTY(map_to_y_from_enum, TransformConstraint, map_to_y_from)
	ENUM_PROPERTY(map_to_z_from_enum, TransformConstraint, map_to_z_from)
	BOOLEAN_PROPERTY(TransformConstraint, use_motion_extrapolate)
	ENUM_PROPERTY(from_rotation_mode_enum, TransformConstraint, from_rotation_mode)
	ENUM_PROPERTY(to_euler_order_enum, TransformConstraint, to_euler_order)
	FLOAT_PROPERTY(TransformConstraint, from_min_x)
	FLOAT_PROPERTY(TransformConstraint, from_min_y)
	FLOAT_PROPERTY(TransformConstraint, from_min_z)
	FLOAT_PROPERTY(TransformConstraint, from_max_x)
	FLOAT_PROPERTY(TransformConstraint, from_max_y)
	FLOAT_PROPERTY(TransformConstraint, from_max_z)
	FLOAT_PROPERTY(TransformConstraint, to_min_x)
	FLOAT_PROPERTY(TransformConstraint, to_min_y)
	FLOAT_PROPERTY(TransformConstraint, to_min_z)
	FLOAT_PROPERTY(TransformConstraint, to_max_x)
	FLOAT_PROPERTY(TransformConstraint, to_max_y)
	FLOAT_PROPERTY(TransformConstraint, to_max_z)
	ENUM_PROPERTY(mix_mode_enum, TransformConstraint, mix_mode)
	FLOAT_PROPERTY(TransformConstraint, from_min_x_rot)
	FLOAT_PROPERTY(TransformConstraint, from_min_y_rot)
	FLOAT_PROPERTY(TransformConstraint, from_min_z_rot)
	FLOAT_PROPERTY(TransformConstraint, from_max_x_rot)
	FLOAT_PROPERTY(TransformConstraint, from_max_y_rot)
	FLOAT_PROPERTY(TransformConstraint, from_max_z_rot)
	FLOAT_PROPERTY(TransformConstraint, to_min_x_rot)
	FLOAT_PROPERTY(TransformConstraint, to_min_y_rot)
	FLOAT_PROPERTY(TransformConstraint, to_min_z_rot)
	FLOAT_PROPERTY(TransformConstraint, to_max_x_rot)
	FLOAT_PROPERTY(TransformConstraint, to_max_y_rot)
	FLOAT_PROPERTY(TransformConstraint, to_max_z_rot)
	ENUM_PROPERTY(mix_mode_rot_enum, TransformConstraint, mix_mode_rot)
	FLOAT_PROPERTY(TransformConstraint, from_min_x_scale)
	FLOAT_PROPERTY(TransformConstraint, from_min_y_scale)
	FLOAT_PROPERTY(TransformConstraint, from_min_z_scale)
	FLOAT_PROPERTY(TransformConstraint, from_max_x_scale)
	FLOAT_PROPERTY(TransformConstraint, from_max_y_scale)
	FLOAT_PROPERTY(TransformConstraint, from_max_z_scale)
	FLOAT_PROPERTY(TransformConstraint, to_min_x_scale)
	FLOAT_PROPERTY(TransformConstraint, to_min_y_scale)
	FLOAT_PROPERTY(TransformConstraint, to_min_z_scale)
	FLOAT_PROPERTY(TransformConstraint, to_max_x_scale)
	FLOAT_PROPERTY(TransformConstraint, to_max_y_scale)
	FLOAT_PROPERTY(TransformConstraint, to_max_z_scale)
	ENUM_PROPERTY(mix_mode_scale_enum, TransformConstraint, mix_mode_scale)


	POINTER_PROPERTY(Object, ShrinkwrapConstraint, target)
	ENUM_PROPERTY(shrinkwrap_type_enum, ShrinkwrapConstraint, shrinkwrap_type)
	ENUM_PROPERTY(wrap_mode_enum, ShrinkwrapConstraint, wrap_mode)
	FLOAT_PROPERTY(ShrinkwrapConstraint, distance)
	ENUM_PROPERTY(project_axis_enum, ShrinkwrapConstraint, project_axis)
	ENUM_PROPERTY(project_axis_space_enum, ShrinkwrapConstraint, project_axis_space)
	FLOAT_PROPERTY(ShrinkwrapConstraint, project_limit)
	BOOLEAN_PROPERTY(ShrinkwrapConstraint, use_project_opposite)
	ENUM_PROPERTY(cull_face_enum, ShrinkwrapConstraint, cull_face)
	BOOLEAN_PROPERTY(ShrinkwrapConstraint, use_invert_cull)
	BOOLEAN_PROPERTY(ShrinkwrapConstraint, use_track_normal)
	ENUM_PROPERTY(track_axis_enum, ShrinkwrapConstraint, track_axis)


	FLOAT_PROPERTY(DampedTrackConstraint, head_tail)
	BOOLEAN_PROPERTY(DampedTrackConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, DampedTrackConstraint, target)
	STRING_PROPERTY(DampedTrackConstraint, subtarget)
	ENUM_PROPERTY(track_axis_enum, DampedTrackConstraint, track_axis)


	POINTER_PROPERTY(Object, SplineIKConstraint, target)
	INT_PROPERTY(SplineIKConstraint, chain_count)
	FLOAT_ARRAY_PROPERTY(SplineIKConstraint, 32, joint_bindings)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_chain_offset)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_even_divisions)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_curve_radius)
	ENUM_PROPERTY(xz_scale_mode_enum, SplineIKConstraint, xz_scale_mode)
	ENUM_PROPERTY(y_scale_mode_enum, SplineIKConstraint, y_scale_mode)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_original_scale)
	FLOAT_PROPERTY(SplineIKConstraint, bulge)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_bulge_min)
	BOOLEAN_PROPERTY(SplineIKConstraint, use_bulge_max)
	FLOAT_PROPERTY(SplineIKConstraint, bulge_min)
	FLOAT_PROPERTY(SplineIKConstraint, bulge_max)
	FLOAT_PROPERTY(SplineIKConstraint, bulge_smooth)


	FLOAT_PROPERTY(PivotConstraint, head_tail)
	BOOLEAN_PROPERTY(PivotConstraint, use_bbone_shape)
	POINTER_PROPERTY(Object, PivotConstraint, target)
	STRING_PROPERTY(PivotConstraint, subtarget)
	BOOLEAN_PROPERTY(PivotConstraint, use_relative_location)
	FLOAT_ARRAY_PROPERTY(PivotConstraint, 3, offset)
	ENUM_PROPERTY(rotation_range_enum, PivotConstraint, rotation_range)


	POINTER_PROPERTY(MovieClip, FollowTrackConstraint, clip)
	STRING_PROPERTY(FollowTrackConstraint, track)
	BOOLEAN_PROPERTY(FollowTrackConstraint, use_active_clip)
	BOOLEAN_PROPERTY(FollowTrackConstraint, use_3d_position)
	STRING_PROPERTY(FollowTrackConstraint, object)
	POINTER_PROPERTY(Object, FollowTrackConstraint, camera)
	POINTER_PROPERTY(Object, FollowTrackConstraint, depth_object)
	ENUM_PROPERTY(frame_method_enum, FollowTrackConstraint, frame_method)
	BOOLEAN_PROPERTY(FollowTrackConstraint, use_undistorted_position)


	POINTER_PROPERTY(MovieClip, CameraSolverConstraint, clip)
	BOOLEAN_PROPERTY(CameraSolverConstraint, use_active_clip)


	POINTER_PROPERTY(MovieClip, ObjectSolverConstraint, clip)
	BOOLEAN_PROPERTY(ObjectSolverConstraint, use_active_clip)
	BOOLEAN_PROPERTY(ObjectSolverConstraint, set_inverse_pending)
	STRING_PROPERTY(ObjectSolverConstraint, object)
	POINTER_PROPERTY(Object, ObjectSolverConstraint, camera)


	POINTER_PROPERTY(CacheFile, TransformCacheConstraint, cache_file)
	STRING_PROPERTY(TransformCacheConstraint, object_path)


	POINTER_PROPERTY(Struct, Context, rna_type)
	POINTER_PROPERTY(WindowManager, Context, window_manager)
	POINTER_PROPERTY(Window, Context, window)
	POINTER_PROPERTY(WorkSpace, Context, workspace)
	POINTER_PROPERTY(Screen, Context, screen)
	POINTER_PROPERTY(Area, Context, area)
	POINTER_PROPERTY(Space, Context, space_data)
	POINTER_PROPERTY(Region, Context, region)
	POINTER_PROPERTY(RegionView3D, Context, region_data)
	POINTER_PROPERTY(GizmoGroup, Context, gizmo_group)
	POINTER_PROPERTY(AssetRepresentation, Context, asset)
	POINTER_PROPERTY(BlendData, Context, blend_data)
	POINTER_PROPERTY(Scene, Context, scene)
	POINTER_PROPERTY(ViewLayer, Context, view_layer)
	STRING_PROPERTY(Context, engine)
	POINTER_PROPERTY(Collection, Context, collection)
	POINTER_PROPERTY(LayerCollection, Context, layer_collection)
	POINTER_PROPERTY(ToolSettings, Context, tool_settings)
	POINTER_PROPERTY(Preferences, Context, preferences)
	ENUM_PROPERTY(mode_enum, Context, mode)

	inline Depsgraph Context::evaluated_depsgraph_get() {
		PointerRNA result;
		::Depsgraph *retdata = Context_evaluated_depsgraph_get_func((::bContext *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Depsgraph, retdata);
		return Depsgraph(result);
	}


	POINTER_PROPERTY(Key, Curve, shape_keys)

	INT_PROPERTY(Curve, path_duration)
	BOOLEAN_PROPERTY(Curve, use_path)
	BOOLEAN_PROPERTY(Curve, use_path_follow)
	BOOLEAN_PROPERTY(Curve, use_path_clamp)
	BOOLEAN_PROPERTY(Curve, use_stretch)
	BOOLEAN_PROPERTY(Curve, use_deform_bounds)
	BOOLEAN_PROPERTY(Curve, use_radius)
	ENUM_PROPERTY(bevel_mode_enum, Curve, bevel_mode)
	POINTER_PROPERTY(CurveProfile, Curve, bevel_profile)
	INT_PROPERTY(Curve, bevel_resolution)
	FLOAT_PROPERTY(Curve, offset)
	FLOAT_PROPERTY(Curve, extrude)
	FLOAT_PROPERTY(Curve, bevel_depth)
	INT_PROPERTY(Curve, resolution_u)
	INT_PROPERTY(Curve, resolution_v)
	INT_PROPERTY(Curve, render_resolution_u)
	INT_PROPERTY(Curve, render_resolution_v)
	FLOAT_PROPERTY(Curve, eval_time)
	POINTER_PROPERTY(Object, Curve, bevel_object)
	POINTER_PROPERTY(Object, Curve, taper_object)
	ENUM_PROPERTY(dimensions_enum, Curve, dimensions)
	ENUM_PROPERTY(fill_mode_enum, Curve, fill_mode)
	ENUM_PROPERTY(twist_mode_enum, Curve, twist_mode)
	ENUM_PROPERTY(taper_radius_mode_enum, Curve, taper_radius_mode)
	ENUM_PROPERTY(bevel_factor_mapping_start_enum, Curve, bevel_factor_mapping_start)
	ENUM_PROPERTY(bevel_factor_mapping_end_enum, Curve, bevel_factor_mapping_end)
	FLOAT_PROPERTY(Curve, twist_smooth)
	BOOLEAN_PROPERTY(Curve, use_fill_caps)
	BOOLEAN_PROPERTY(Curve, use_map_taper)
	BOOLEAN_PROPERTY(Curve, use_auto_texspace)
	FLOAT_ARRAY_PROPERTY(Curve, 3, texspace_location)
	FLOAT_ARRAY_PROPERTY(Curve, 3, texspace_size)

	FLOAT_PROPERTY(Curve, bevel_factor_start)
	FLOAT_PROPERTY(Curve, bevel_factor_end)
	BOOLEAN_PROPERTY(Curve, is_editmode)
	POINTER_PROPERTY(AnimData, Curve, animation_data)

	inline void Curve::transform(float matrix[16], bool shape_keys) {
		Curve_transform_func((::Curve *) this->ptr.data, matrix, shape_keys);
	}

	inline bool Curve::validate_material_indices() {
		return Curve_validate_material_indices_func((::Curve *) this->ptr.data);
	}

	inline void Curve::update_gpu_tag() {
		Curve_update_gpu_tag_func((::Curve *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, CurveSplines, rna_type)
	POINTER_PROPERTY(Spline, CurveSplines, active)

	inline Spline CurveSplines::create(int type) {
		PointerRNA result;
		::Nurb *retdata = CurveSplines_new_func((::Curve *) this->ptr.data, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Spline, retdata);
		return Spline(result);
	}

	inline void CurveSplines::remove(Spline& spline) {
		CurveSplines_remove_func((::Curve *) this->ptr.data, nullptr, (::PointerRNA *) &spline.ptr);
	}

	inline void CurveSplines::clear() {
		CurveSplines_clear_func((::Curve *) this->ptr.data);
	}




	ENUM_PROPERTY(align_x_enum, TextCurve, align_x)
	ENUM_PROPERTY(align_y_enum, TextCurve, align_y)
	ENUM_PROPERTY(overflow_enum, TextCurve, overflow)
	FLOAT_PROPERTY(TextCurve, size)
	FLOAT_PROPERTY(TextCurve, small_caps_scale)
	FLOAT_PROPERTY(TextCurve, space_line)
	FLOAT_PROPERTY(TextCurve, space_word)
	FLOAT_PROPERTY(TextCurve, space_character)
	FLOAT_PROPERTY(TextCurve, shear)
	FLOAT_PROPERTY(TextCurve, offset_x)
	FLOAT_PROPERTY(TextCurve, offset_y)
	FLOAT_PROPERTY(TextCurve, underline_position)
	FLOAT_PROPERTY(TextCurve, underline_height)

	INT_PROPERTY(TextCurve, active_textbox)
	STRING_PROPERTY(TextCurve, family)
	STRING_PROPERTY(TextCurve, body)

	POINTER_PROPERTY(Object, TextCurve, follow_curve)
	POINTER_PROPERTY(VectorFont, TextCurve, font)
	POINTER_PROPERTY(VectorFont, TextCurve, font_bold)
	POINTER_PROPERTY(VectorFont, TextCurve, font_italic)
	POINTER_PROPERTY(VectorFont, TextCurve, font_bold_italic)
	POINTER_PROPERTY(TextCharacterFormat, TextCurve, edit_format)
	BOOLEAN_PROPERTY(TextCurve, use_fast_edit)
	BOOLEAN_PROPERTY(TextCurve, is_select_bold)
	BOOLEAN_PROPERTY(TextCurve, is_select_italic)
	BOOLEAN_PROPERTY(TextCurve, is_select_underline)
	BOOLEAN_PROPERTY(TextCurve, is_select_smallcaps)
	BOOLEAN_PROPERTY(TextCurve, has_selection)


	POINTER_PROPERTY(Struct, TextBox, rna_type)
	FLOAT_PROPERTY(TextBox, x)
	FLOAT_PROPERTY(TextBox, y)
	FLOAT_PROPERTY(TextBox, width)
	FLOAT_PROPERTY(TextBox, height)


	POINTER_PROPERTY(Struct, TextCharacterFormat, rna_type)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_bold)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_italic)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_underline)
	BOOLEAN_PROPERTY(TextCharacterFormat, use_small_caps)
	INT_PROPERTY(TextCharacterFormat, material_index)
	FLOAT_PROPERTY(TextCharacterFormat, kerning)


	POINTER_PROPERTY(Struct, SplinePoint, rna_type)
	BOOLEAN_PROPERTY(SplinePoint, select)
	BOOLEAN_PROPERTY(SplinePoint, hide)
	FLOAT_ARRAY_PROPERTY(SplinePoint, 4, co)
	FLOAT_PROPERTY(SplinePoint, weight)
	FLOAT_PROPERTY(SplinePoint, tilt)
	FLOAT_PROPERTY(SplinePoint, weight_softbody)
	FLOAT_PROPERTY(SplinePoint, radius)


	POINTER_PROPERTY(Struct, BezierSplinePoint, rna_type)
	BOOLEAN_PROPERTY(BezierSplinePoint, select_left_handle)
	BOOLEAN_PROPERTY(BezierSplinePoint, select_right_handle)
	BOOLEAN_PROPERTY(BezierSplinePoint, select_control_point)
	BOOLEAN_PROPERTY(BezierSplinePoint, hide)
	ENUM_PROPERTY(handle_left_type_enum, BezierSplinePoint, handle_left_type)
	ENUM_PROPERTY(handle_right_type_enum, BezierSplinePoint, handle_right_type)
	FLOAT_ARRAY_PROPERTY(BezierSplinePoint, 3, handle_left)
	FLOAT_ARRAY_PROPERTY(BezierSplinePoint, 3, co)
	FLOAT_ARRAY_PROPERTY(BezierSplinePoint, 3, handle_right)
	FLOAT_PROPERTY(BezierSplinePoint, tilt)
	FLOAT_PROPERTY(BezierSplinePoint, weight_softbody)
	FLOAT_PROPERTY(BezierSplinePoint, radius)


	POINTER_PROPERTY(Struct, Spline, rna_type)


	ENUM_PROPERTY(tilt_interpolation_enum, Spline, tilt_interpolation)
	ENUM_PROPERTY(radius_interpolation_enum, Spline, radius_interpolation)
	ENUM_PROPERTY(type_enum, Spline, type)
	INT_PROPERTY(Spline, point_count_u)
	INT_PROPERTY(Spline, point_count_v)
	INT_PROPERTY(Spline, order_u)
	INT_PROPERTY(Spline, order_v)
	INT_PROPERTY(Spline, resolution_u)
	INT_PROPERTY(Spline, resolution_v)
	BOOLEAN_PROPERTY(Spline, use_cyclic_u)
	BOOLEAN_PROPERTY(Spline, use_cyclic_v)
	BOOLEAN_PROPERTY(Spline, use_endpoint_u)
	BOOLEAN_PROPERTY(Spline, use_endpoint_v)
	BOOLEAN_PROPERTY(Spline, use_bezier_u)
	BOOLEAN_PROPERTY(Spline, use_bezier_v)
	BOOLEAN_PROPERTY(Spline, use_smooth)
	BOOLEAN_PROPERTY(Spline, hide)
	INT_PROPERTY(Spline, material_index)
	INT_PROPERTY(Spline, character_index)

	inline float Spline::calc_length(int resolution) {
		return Spline_calc_length_func((::Nurb *) this->ptr.data, resolution);
	}

	inline void Spline::valid_message(int direction, int *result_len, const char * *result) {
		Spline_valid_message_func((::Nurb *) this->ptr.data, direction, result_len, result);
	}


	POINTER_PROPERTY(Struct, SplinePoints, rna_type)

	inline void SplinePoints::add(int count) {
		SplinePoints_add_func((::ID *) ptr.owner_id, (::Nurb *) this->ptr.data, nullptr, count);
	}


	POINTER_PROPERTY(Struct, SplineBezierPoints, rna_type)

	inline void SplineBezierPoints::add(int count) {
		SplineBezierPoints_add_func((::ID *) ptr.owner_id, (::Nurb *) this->ptr.data, nullptr, count);
	}


	POINTER_PROPERTY(Struct, DynamicPaintCanvasSettings, rna_type)



	POINTER_PROPERTY(Struct, DynamicPaintSurfaces, rna_type)
	INT_PROPERTY(DynamicPaintSurfaces, active_index)
	POINTER_PROPERTY(DynamicPaintSurface, DynamicPaintSurfaces, active)


	POINTER_PROPERTY(Struct, DynamicPaintBrushSettings, rna_type)
	FLOAT_ARRAY_PROPERTY(DynamicPaintBrushSettings, 3, paint_color)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, paint_alpha)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_absolute_alpha)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, paint_wetness)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_paint_erase)
	ENUM_PROPERTY(wave_type_enum, DynamicPaintBrushSettings, wave_type)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, wave_factor)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, wave_clamp)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_smudge)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, smudge_strength)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, velocity_max)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_velocity_alpha)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_velocity_depth)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_velocity_color)
	ENUM_PROPERTY(paint_source_enum, DynamicPaintBrushSettings, paint_source)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, paint_distance)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_proximity_ramp_alpha)
	ENUM_PROPERTY(proximity_falloff_enum, DynamicPaintBrushSettings, proximity_falloff)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_proximity_project)
	ENUM_PROPERTY(ray_direction_enum, DynamicPaintBrushSettings, ray_direction)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, invert_proximity)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_negative_volume)
	POINTER_PROPERTY(ParticleSystem, DynamicPaintBrushSettings, particle_system)
	BOOLEAN_PROPERTY(DynamicPaintBrushSettings, use_particle_radius)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, solid_radius)
	FLOAT_PROPERTY(DynamicPaintBrushSettings, smooth_radius)
	POINTER_PROPERTY(ColorRamp, DynamicPaintBrushSettings, paint_ramp)
	POINTER_PROPERTY(ColorRamp, DynamicPaintBrushSettings, velocity_ramp)


	POINTER_PROPERTY(Struct, DynamicPaintSurface, rna_type)
	ENUM_PROPERTY(surface_format_enum, DynamicPaintSurface, surface_format)
	ENUM_PROPERTY(surface_type_enum, DynamicPaintSurface, surface_type)
	BOOLEAN_PROPERTY(DynamicPaintSurface, is_active)
	STRING_PROPERTY(DynamicPaintSurface, name)
	POINTER_PROPERTY(Collection, DynamicPaintSurface, brush_collection)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_dissolve)
	INT_PROPERTY(DynamicPaintSurface, dissolve_speed)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_drying)
	INT_PROPERTY(DynamicPaintSurface, dry_speed)
	INT_PROPERTY(DynamicPaintSurface, image_resolution)
	STRING_PROPERTY(DynamicPaintSurface, uv_layer)
	INT_PROPERTY(DynamicPaintSurface, frame_start)
	INT_PROPERTY(DynamicPaintSurface, frame_end)
	INT_PROPERTY(DynamicPaintSurface, frame_substeps)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_antialiasing)
	FLOAT_PROPERTY(DynamicPaintSurface, brush_influence_scale)
	FLOAT_PROPERTY(DynamicPaintSurface, brush_radius_scale)
	ENUM_PROPERTY(init_color_type_enum, DynamicPaintSurface, init_color_type)
	FLOAT_ARRAY_PROPERTY(DynamicPaintSurface, 4, init_color)
	POINTER_PROPERTY(Texture, DynamicPaintSurface, init_texture)
	STRING_PROPERTY(DynamicPaintSurface, init_layername)
	ENUM_PROPERTY(effect_ui_enum, DynamicPaintSurface, effect_ui)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_dry_log)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_dissolve_log)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_spread)
	FLOAT_PROPERTY(DynamicPaintSurface, spread_speed)
	FLOAT_PROPERTY(DynamicPaintSurface, color_dry_threshold)
	FLOAT_PROPERTY(DynamicPaintSurface, color_spread_speed)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_drip)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_shrink)
	FLOAT_PROPERTY(DynamicPaintSurface, shrink_speed)
	POINTER_PROPERTY(EffectorWeights, DynamicPaintSurface, effector_weights)
	FLOAT_PROPERTY(DynamicPaintSurface, drip_velocity)
	FLOAT_PROPERTY(DynamicPaintSurface, drip_acceleration)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_premultiply)
	STRING_PROPERTY(DynamicPaintSurface, image_output_path)
	STRING_PROPERTY(DynamicPaintSurface, output_name_a)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_output_a)
	STRING_PROPERTY(DynamicPaintSurface, output_name_b)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_output_b)
	FLOAT_PROPERTY(DynamicPaintSurface, depth_clamp)
	FLOAT_PROPERTY(DynamicPaintSurface, displace_factor)
	ENUM_PROPERTY(image_fileformat_enum, DynamicPaintSurface, image_fileformat)
	ENUM_PROPERTY(displace_type_enum, DynamicPaintSurface, displace_type)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_incremental_displace)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_damping)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_speed)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_timescale)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_spring)
	FLOAT_PROPERTY(DynamicPaintSurface, wave_smoothness)
	BOOLEAN_PROPERTY(DynamicPaintSurface, use_wave_open_border)
	POINTER_PROPERTY(PointCache, DynamicPaintSurface, point_cache)
	BOOLEAN_PROPERTY(DynamicPaintSurface, is_cache_user)

	inline bool DynamicPaintSurface::output_exists(Object& object, int index) {
		return DynamicPaintSurface_output_exists_func((::DynamicPaintSurface *) this->ptr.data, (::Object *) object.ptr.data, index);
	}


	POINTER_PROPERTY(Struct, FCurve, rna_type)
	ENUM_PROPERTY(extrapolation_enum, FCurve, extrapolation)
	POINTER_PROPERTY(Driver, FCurve, driver)
	POINTER_PROPERTY(ActionGroup, FCurve, group)
	STRING_PROPERTY(FCurve, data_path)
	INT_PROPERTY(FCurve, array_index)
	ENUM_PROPERTY(color_mode_enum, FCurve, color_mode)
	FLOAT_ARRAY_PROPERTY(FCurve, 3, color)
	BOOLEAN_PROPERTY(FCurve, select)
	BOOLEAN_PROPERTY(FCurve, lock)
	BOOLEAN_PROPERTY(FCurve, mute)
	BOOLEAN_PROPERTY(FCurve, hide)
	ENUM_PROPERTY(auto_smoothing_enum, FCurve, auto_smoothing)
	BOOLEAN_PROPERTY(FCurve, is_valid)
	BOOLEAN_PROPERTY(FCurve, is_empty)




	inline float FCurve::evaluate(float frame) {
		return FCurve_evaluate_func((::FCurve *) this->ptr.data, frame);
	}

	inline void FCurve::update(void *main) {
		FCurve_update_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main);
	}

	inline void FCurve::range(float range[2]) {
		FCurve_range_func((::FCurve *) this->ptr.data, range);
	}

	inline void FCurve::update_autoflags(Context C, AnyType& data) {
		FCurve_update_autoflags_func((::FCurve *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &data);
	}

	inline void FCurve::convert_to_samples(int start, int end) {
		FCurve_convert_to_samples_func((::FCurve *) this->ptr.data, nullptr, start, end);
	}

	inline void FCurve::convert_to_keyframes(int start, int end) {
		FCurve_convert_to_keyframes_func((::FCurve *) this->ptr.data, nullptr, start, end);
	}


	POINTER_PROPERTY(Struct, FCurveKeyframePoints, rna_type)

	inline Keyframe FCurveKeyframePoints::insert(void *main, float frame, float value, int options, int keyframe_type) {
		PointerRNA result;
		::BezTriple *retdata = FCurveKeyframePoints_insert_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main, frame, value, options, keyframe_type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Keyframe, retdata);
		return Keyframe(result);
	}

	inline void FCurveKeyframePoints::add(void *main, int count) {
		FCurveKeyframePoints_add_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main, count);
	}

	inline void FCurveKeyframePoints::remove(void *main, Keyframe& keyframe, bool fast) {
		FCurveKeyframePoints_remove_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &keyframe.ptr, fast);
	}

	inline void FCurveKeyframePoints::clear(void *main) {
		FCurveKeyframePoints_clear_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main);
	}

	inline void FCurveKeyframePoints::sort(void *main) {
		FCurveKeyframePoints_sort_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main);
	}

	inline void FCurveKeyframePoints::deduplicate(void *main) {
		FCurveKeyframePoints_deduplicate_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main);
	}

	inline void FCurveKeyframePoints::handles_recalc(void *main) {
		FCurveKeyframePoints_handles_recalc_func((::ID *) ptr.owner_id, (::FCurve *) this->ptr.data, (::Main *) main);
	}


	POINTER_PROPERTY(Struct, FCurveModifiers, rna_type)
	POINTER_PROPERTY(FModifier, FCurveModifiers, active)

	inline FModifier FCurveModifiers::create(int type) {
		PointerRNA result;
		::FModifier *retdata = FCurveModifiers_new_func((::FCurve *) this->ptr.data, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FModifier, retdata);
		return FModifier(result);
	}

	inline void FCurveModifiers::remove(FModifier& modifier) {
		FCurveModifiers_remove_func((::FCurve *) this->ptr.data, nullptr, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, Keyframe, rna_type)
	BOOLEAN_PROPERTY(Keyframe, select_left_handle)
	BOOLEAN_PROPERTY(Keyframe, select_right_handle)
	BOOLEAN_PROPERTY(Keyframe, select_control_point)
	ENUM_PROPERTY(handle_left_type_enum, Keyframe, handle_left_type)
	ENUM_PROPERTY(handle_right_type_enum, Keyframe, handle_right_type)
	ENUM_PROPERTY(interpolation_enum, Keyframe, interpolation)
	ENUM_PROPERTY(type_enum, Keyframe, type)
	ENUM_PROPERTY(easing_enum, Keyframe, easing)
	FLOAT_PROPERTY(Keyframe, back)
	FLOAT_PROPERTY(Keyframe, amplitude)
	FLOAT_PROPERTY(Keyframe, period)
	FLOAT_ARRAY_PROPERTY(Keyframe, 2, handle_left)
	FLOAT_ARRAY_PROPERTY(Keyframe, 2, co)
	FLOAT_ARRAY_PROPERTY(Keyframe, 2, co_ui)
	FLOAT_ARRAY_PROPERTY(Keyframe, 2, handle_right)


	POINTER_PROPERTY(Struct, FCurveSample, rna_type)
	BOOLEAN_PROPERTY(FCurveSample, select)
	FLOAT_ARRAY_PROPERTY(FCurveSample, 2, co)


	POINTER_PROPERTY(Struct, DriverTarget, rna_type)
	POINTER_PROPERTY(ID, DriverTarget, id)
	ENUM_PROPERTY(id_type_enum, DriverTarget, id_type)
	STRING_PROPERTY(DriverTarget, data_path)
	STRING_PROPERTY(DriverTarget, bone_target)
	ENUM_PROPERTY(transform_type_enum, DriverTarget, transform_type)
	ENUM_PROPERTY(rotation_mode_enum, DriverTarget, rotation_mode)
	ENUM_PROPERTY(transform_space_enum, DriverTarget, transform_space)
	ENUM_PROPERTY(context_property_enum, DriverTarget, context_property)


	POINTER_PROPERTY(Struct, DriverVariable, rna_type)
	STRING_PROPERTY(DriverVariable, name)
	ENUM_PROPERTY(type_enum, DriverVariable, type)

	BOOLEAN_PROPERTY(DriverVariable, is_name_valid)


	POINTER_PROPERTY(Struct, Driver, rna_type)
	ENUM_PROPERTY(type_enum, Driver, type)
	STRING_PROPERTY(Driver, expression)

	BOOLEAN_PROPERTY(Driver, use_self)
	BOOLEAN_PROPERTY(Driver, is_valid)
	BOOLEAN_PROPERTY(Driver, is_simple_expression)


	POINTER_PROPERTY(Struct, ChannelDriverVariables, rna_type)

	inline DriverVariable ChannelDriverVariables::create() {
		PointerRNA result;
		::DriverVar *retdata = ChannelDriverVariables_new_func((::ChannelDriver *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_DriverVariable, retdata);
		return DriverVariable(result);
	}

	inline void ChannelDriverVariables::remove(DriverVariable& variable) {
		ChannelDriverVariables_remove_func((::ChannelDriver *) this->ptr.data, nullptr, (::PointerRNA *) &variable.ptr);
	}


	POINTER_PROPERTY(Struct, FModifier, rna_type)
	STRING_PROPERTY(FModifier, name)
	ENUM_PROPERTY(type_enum, FModifier, type)
	BOOLEAN_PROPERTY(FModifier, show_expanded)
	BOOLEAN_PROPERTY(FModifier, mute)
	BOOLEAN_PROPERTY(FModifier, is_valid)
	BOOLEAN_PROPERTY(FModifier, active)
	BOOLEAN_PROPERTY(FModifier, use_restricted_range)
	FLOAT_PROPERTY(FModifier, frame_start)
	FLOAT_PROPERTY(FModifier, frame_end)
	FLOAT_PROPERTY(FModifier, blend_in)
	FLOAT_PROPERTY(FModifier, blend_out)
	BOOLEAN_PROPERTY(FModifier, use_influence)
	FLOAT_PROPERTY(FModifier, influence)


	BOOLEAN_PROPERTY(FModifierGenerator, use_additive)
	ENUM_PROPERTY(mode_enum, FModifierGenerator, mode)
	INT_PROPERTY(FModifierGenerator, poly_order)
	FLOAT_ARRAY_PROPERTY(FModifierGenerator, 32, coefficients)


	FLOAT_PROPERTY(FModifierFunctionGenerator, amplitude)
	FLOAT_PROPERTY(FModifierFunctionGenerator, phase_multiplier)
	FLOAT_PROPERTY(FModifierFunctionGenerator, phase_offset)
	FLOAT_PROPERTY(FModifierFunctionGenerator, value_offset)
	BOOLEAN_PROPERTY(FModifierFunctionGenerator, use_additive)
	ENUM_PROPERTY(function_type_enum, FModifierFunctionGenerator, function_type)



	FLOAT_PROPERTY(FModifierEnvelope, reference_value)
	FLOAT_PROPERTY(FModifierEnvelope, default_min)
	FLOAT_PROPERTY(FModifierEnvelope, default_max)


	POINTER_PROPERTY(Struct, FModifierEnvelopeControlPoints, rna_type)

	inline FModifierEnvelopeControlPoint FModifierEnvelopeControlPoints::add(void *main, float frame) {
		PointerRNA result;
		::FCM_EnvelopeData *retdata = FModifierEnvelopeControlPoints_add_func((::ID *) ptr.owner_id, (::FModifier *) this->ptr.data, (::Main *) main, nullptr, frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FModifierEnvelopeControlPoint, retdata);
		return FModifierEnvelopeControlPoint(result);
	}

	inline void FModifierEnvelopeControlPoints::remove(void *main, FModifierEnvelopeControlPoint& point) {
		FModifierEnvelopeControlPoints_remove_func((::ID *) ptr.owner_id, (::FModifier *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &point);
	}


	POINTER_PROPERTY(Struct, FModifierEnvelopeControlPoint, rna_type)
	FLOAT_PROPERTY(FModifierEnvelopeControlPoint, min)
	FLOAT_PROPERTY(FModifierEnvelopeControlPoint, max)
	FLOAT_PROPERTY(FModifierEnvelopeControlPoint, frame)


	ENUM_PROPERTY(mode_before_enum, FModifierCycles, mode_before)
	INT_PROPERTY(FModifierCycles, cycles_before)
	ENUM_PROPERTY(mode_after_enum, FModifierCycles, mode_after)
	INT_PROPERTY(FModifierCycles, cycles_after)




	BOOLEAN_PROPERTY(FModifierLimits, use_min_x)
	BOOLEAN_PROPERTY(FModifierLimits, use_min_y)
	BOOLEAN_PROPERTY(FModifierLimits, use_max_x)
	BOOLEAN_PROPERTY(FModifierLimits, use_max_y)
	FLOAT_PROPERTY(FModifierLimits, min_x)
	FLOAT_PROPERTY(FModifierLimits, min_y)
	FLOAT_PROPERTY(FModifierLimits, max_x)
	FLOAT_PROPERTY(FModifierLimits, max_y)


	ENUM_PROPERTY(blend_type_enum, FModifierNoise, blend_type)
	FLOAT_PROPERTY(FModifierNoise, scale)
	FLOAT_PROPERTY(FModifierNoise, strength)
	FLOAT_PROPERTY(FModifierNoise, phase)
	FLOAT_PROPERTY(FModifierNoise, offset)
	INT_PROPERTY(FModifierNoise, depth)


	FLOAT_PROPERTY(FModifierStepped, frame_step)
	FLOAT_PROPERTY(FModifierStepped, frame_offset)
	BOOLEAN_PROPERTY(FModifierStepped, use_frame_start)
	BOOLEAN_PROPERTY(FModifierStepped, use_frame_end)
	FLOAT_PROPERTY(FModifierStepped, frame_start)
	FLOAT_PROPERTY(FModifierStepped, frame_end)



	POINTER_PROPERTY(AnimData, GreasePencil, animation_data)

	ENUM_PROPERTY(stroke_depth_order_enum, GreasePencil, stroke_depth_order)
	BOOLEAN_PROPERTY(GreasePencil, use_stroke_edit_mode)
	BOOLEAN_PROPERTY(GreasePencil, is_stroke_paint_mode)
	BOOLEAN_PROPERTY(GreasePencil, is_stroke_sculpt_mode)
	BOOLEAN_PROPERTY(GreasePencil, is_stroke_weight_mode)
	BOOLEAN_PROPERTY(GreasePencil, is_stroke_vertex_mode)
	BOOLEAN_PROPERTY(GreasePencil, use_onion_skinning)
	ENUM_PROPERTY(stroke_thickness_space_enum, GreasePencil, stroke_thickness_space)
	FLOAT_PROPERTY(GreasePencil, pixel_factor)
	INT_PROPERTY(GreasePencil, edit_curve_resolution)
	BOOLEAN_PROPERTY(GreasePencil, use_adaptive_curve_resolution)
	FLOAT_PROPERTY(GreasePencil, curve_edit_threshold)
	FLOAT_PROPERTY(GreasePencil, curve_edit_corner_angle)
	BOOLEAN_PROPERTY(GreasePencil, use_multiedit)
	BOOLEAN_PROPERTY(GreasePencil, use_curve_edit)
	BOOLEAN_PROPERTY(GreasePencil, use_autolock_layers)
	FLOAT_ARRAY_PROPERTY(GreasePencil, 4, edit_line_color)
	INT_PROPERTY(GreasePencil, ghost_before_range)
	INT_PROPERTY(GreasePencil, ghost_after_range)
	BOOLEAN_PROPERTY(GreasePencil, use_ghost_custom_colors)
	FLOAT_ARRAY_PROPERTY(GreasePencil, 3, before_color)
	FLOAT_ARRAY_PROPERTY(GreasePencil, 3, after_color)
	BOOLEAN_PROPERTY(GreasePencil, use_ghosts_always)
	ENUM_PROPERTY(onion_mode_enum, GreasePencil, onion_mode)
	ENUM_PROPERTY(onion_keyframe_type_enum, GreasePencil, onion_keyframe_type)
	BOOLEAN_PROPERTY(GreasePencil, use_onion_fade)
	BOOLEAN_PROPERTY(GreasePencil, use_onion_loop)
	FLOAT_PROPERTY(GreasePencil, onion_factor)
	FLOAT_PROPERTY(GreasePencil, zdepth_offset)
	BOOLEAN_PROPERTY(GreasePencil, is_annotation)
	POINTER_PROPERTY(GreasePencilGrid, GreasePencil, grid)

	inline void GreasePencil::clear() {
		GreasePencil_clear_func((::bGPdata *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, GreasePencilLayers, rna_type)
	POINTER_PROPERTY(GPencilLayer, GreasePencilLayers, active)
	INT_PROPERTY(GreasePencilLayers, active_index)
	ENUM_PROPERTY(active_note_enum, GreasePencilLayers, active_note)

	inline GPencilLayer GreasePencilLayers::create(const char * name, bool set_active) {
		PointerRNA result;
		::bGPDlayer *retdata = GreasePencilLayers_new_func((::bGPdata *) this->ptr.data, name, set_active);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_GPencilLayer, retdata);
		return GPencilLayer(result);
	}

	inline void GreasePencilLayers::remove(GPencilLayer& layer) {
		GreasePencilLayers_remove_func((::bGPdata *) this->ptr.data, nullptr, (::PointerRNA *) &layer.ptr);
	}

	inline void GreasePencilLayers::move(GPencilLayer& layer, int type) {
		GreasePencilLayers_move_func((::bGPdata *) this->ptr.data, nullptr, (::PointerRNA *) &layer.ptr, type);
	}


	POINTER_PROPERTY(Struct, GreasePencilGrid, rna_type)
	FLOAT_ARRAY_PROPERTY(GreasePencilGrid, 2, scale)
	FLOAT_ARRAY_PROPERTY(GreasePencilGrid, 3, color)
	INT_PROPERTY(GreasePencilGrid, lines)
	FLOAT_ARRAY_PROPERTY(GreasePencilGrid, 2, offset)


	POINTER_PROPERTY(Struct, GPencilLayer, rna_type)
	STRING_PROPERTY(GPencilLayer, info)


	POINTER_PROPERTY(GPencilFrame, GPencilLayer, active_frame)
	FLOAT_PROPERTY(GPencilLayer, opacity)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, channel_color)
	FLOAT_PROPERTY(GPencilLayer, annotation_opacity)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, color)
	INT_PROPERTY(GPencilLayer, thickness)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, tint_color)
	FLOAT_PROPERTY(GPencilLayer, tint_factor)
	FLOAT_PROPERTY(GPencilLayer, vertex_paint_opacity)
	INT_PROPERTY(GPencilLayer, line_change)
	BOOLEAN_PROPERTY(GPencilLayer, use_onion_skinning)
	BOOLEAN_PROPERTY(GPencilLayer, use_annotation_onion_skinning)
	INT_PROPERTY(GPencilLayer, annotation_onion_before_range)
	INT_PROPERTY(GPencilLayer, annotation_onion_after_range)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, annotation_onion_before_color)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, annotation_onion_after_color)
	INT_PROPERTY(GPencilLayer, pass_index)
	STRING_PROPERTY(GPencilLayer, viewlayer_render)
	BOOLEAN_PROPERTY(GPencilLayer, use_viewlayer_masks)
	ENUM_PROPERTY(blend_mode_enum, GPencilLayer, blend_mode)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, location)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, rotation)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 3, scale)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 16, matrix_layer)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 16, matrix_inverse_layer)
	BOOLEAN_PROPERTY(GPencilLayer, hide)
	BOOLEAN_PROPERTY(GPencilLayer, annotation_hide)
	BOOLEAN_PROPERTY(GPencilLayer, lock)
	BOOLEAN_PROPERTY(GPencilLayer, lock_frame)
	BOOLEAN_PROPERTY(GPencilLayer, lock_material)
	BOOLEAN_PROPERTY(GPencilLayer, use_mask_layer)
	BOOLEAN_PROPERTY(GPencilLayer, use_lights)
	BOOLEAN_PROPERTY(GPencilLayer, use_solo_mode)
	BOOLEAN_PROPERTY(GPencilLayer, is_ruler)
	BOOLEAN_PROPERTY(GPencilLayer, select)
	BOOLEAN_PROPERTY(GPencilLayer, show_points)
	BOOLEAN_PROPERTY(GPencilLayer, show_in_front)
	POINTER_PROPERTY(Object, GPencilLayer, parent)
	ENUM_PROPERTY(parent_type_enum, GPencilLayer, parent_type)
	STRING_PROPERTY(GPencilLayer, parent_bone)
	FLOAT_ARRAY_PROPERTY(GPencilLayer, 16, matrix_inverse)
	BOOLEAN_PROPERTY(GPencilLayer, is_parented)

	inline void GPencilLayer::clear() {
		GPencilLayer_clear_func((::ID *) ptr.owner_id, (::bGPDlayer *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, GPencilFrames, rna_type)

	inline GPencilFrame GPencilFrames::create(int frame_number, bool active) {
		PointerRNA result;
		::bGPDframe *retdata = GPencilFrames_new_func((::bGPDlayer *) this->ptr.data, nullptr, frame_number, active);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_GPencilFrame, retdata);
		return GPencilFrame(result);
	}

	inline void GPencilFrames::remove(GPencilFrame& frame) {
		GPencilFrames_remove_func((::bGPDlayer *) this->ptr.data, nullptr, (::PointerRNA *) &frame.ptr);
	}

	inline GPencilFrame GPencilFrames::copy(GPencilFrame& source) {
		PointerRNA result;
		::bGPDframe *retdata = GPencilFrames_copy_func((::bGPDlayer *) this->ptr.data, (::bGPDframe *) source.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_GPencilFrame, retdata);
		return GPencilFrame(result);
	}


	POINTER_PROPERTY(Struct, GreasePencilMaskLayers, rna_type)
	INT_PROPERTY(GreasePencilMaskLayers, active_mask_index)

	inline void GreasePencilMaskLayers::add(GPencilLayer& layer) {
		GreasePencilMaskLayers_add_func((::bGPDlayer *) this->ptr.data, (::PointerRNA *) &layer.ptr);
	}

	inline void GreasePencilMaskLayers::remove(GPencilLayerMask& mask) {
		GreasePencilMaskLayers_remove_func((::bGPDlayer *) this->ptr.data, nullptr, (::PointerRNA *) &mask.ptr);
	}


	POINTER_PROPERTY(Struct, GPencilLayerMask, rna_type)
	STRING_PROPERTY(GPencilLayerMask, name)
	BOOLEAN_PROPERTY(GPencilLayerMask, hide)
	BOOLEAN_PROPERTY(GPencilLayerMask, invert)


	POINTER_PROPERTY(Struct, GPencilFrame, rna_type)

	INT_PROPERTY(GPencilFrame, frame_number)
	ENUM_PROPERTY(keyframe_type_enum, GPencilFrame, keyframe_type)
	BOOLEAN_PROPERTY(GPencilFrame, is_edited)
	BOOLEAN_PROPERTY(GPencilFrame, select)

	inline void GPencilFrame::clear() {
		GPencilFrame_clear_func((::ID *) ptr.owner_id, (::bGPDframe *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, GPencilStrokes, rna_type)

	inline GPencilStroke GPencilStrokes::create() {
		PointerRNA result;
		::bGPDstroke *retdata = GPencilStrokes_new_func((::bGPDframe *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_GPencilStroke, retdata);
		return GPencilStroke(result);
	}

	inline void GPencilStrokes::remove(GPencilStroke& stroke) {
		GPencilStrokes_remove_func((::ID *) ptr.owner_id, (::bGPDframe *) this->ptr.data, nullptr, (::PointerRNA *) &stroke.ptr);
	}

	inline void GPencilStrokes::close(GPencilStroke& stroke) {
		GPencilStrokes_close_func((::ID *) ptr.owner_id, (::bGPDframe *) this->ptr.data, nullptr, (::PointerRNA *) &stroke.ptr);
	}


	POINTER_PROPERTY(Struct, GPencilStroke, rna_type)


	POINTER_PROPERTY(GPencilEditCurve, GPencilStroke, edit_curve)
	INT_PROPERTY(GPencilStroke, material_index)
	ENUM_PROPERTY(display_mode_enum, GPencilStroke, display_mode)
	BOOLEAN_PROPERTY(GPencilStroke, select)
	BOOLEAN_PROPERTY(GPencilStroke, use_cyclic)
	BOOLEAN_PROPERTY(GPencilStroke, has_edit_curve)
	ENUM_PROPERTY(start_cap_mode_enum, GPencilStroke, start_cap_mode)
	ENUM_PROPERTY(end_cap_mode_enum, GPencilStroke, end_cap_mode)
	BOOLEAN_PROPERTY(GPencilStroke, is_nofill_stroke)
	INT_PROPERTY(GPencilStroke, line_width)
	FLOAT_PROPERTY(GPencilStroke, hardness)
	FLOAT_ARRAY_PROPERTY(GPencilStroke, 3, bound_box_min)
	FLOAT_ARRAY_PROPERTY(GPencilStroke, 3, bound_box_max)
	FLOAT_ARRAY_PROPERTY(GPencilStroke, 2, aspect)
	FLOAT_ARRAY_PROPERTY(GPencilStroke, 2, uv_translation)
	FLOAT_PROPERTY(GPencilStroke, uv_rotation)
	FLOAT_PROPERTY(GPencilStroke, uv_scale)
	FLOAT_ARRAY_PROPERTY(GPencilStroke, 4, vertex_color_fill)
	INT_PROPERTY(GPencilStroke, select_index)
	FLOAT_PROPERTY(GPencilStroke, time_start)


	POINTER_PROPERTY(Struct, GPencilStrokePoints, rna_type)

	inline void GPencilStrokePoints::add(int count, float pressure, float strength) {
		GPencilStrokePoints_add_func((::ID *) ptr.owner_id, (::bGPDstroke *) this->ptr.data, count, pressure, strength);
	}

	inline void GPencilStrokePoints::pop(int index) {
		GPencilStrokePoints_pop_func((::ID *) ptr.owner_id, (::bGPDstroke *) this->ptr.data, nullptr, index);
	}

	inline void GPencilStrokePoints::update() {
		GPencilStrokePoints_update_func((::ID *) ptr.owner_id, (::bGPDstroke *) this->ptr.data);
	}

	inline float GPencilStrokePoints::weight_get(int vertex_group_index, int point_index) {
		return GPencilStrokePoints_weight_get_func((::bGPDstroke *) this->ptr.data, nullptr, vertex_group_index, point_index);
	}

	inline void GPencilStrokePoints::weight_set(int vertex_group_index, int point_index, float weight) {
		GPencilStrokePoints_weight_set_func((::bGPDstroke *) this->ptr.data, nullptr, vertex_group_index, point_index, weight);
	}


	POINTER_PROPERTY(Struct, GPencilStrokePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(GPencilStrokePoint, 3, co)
	FLOAT_PROPERTY(GPencilStrokePoint, pressure)
	FLOAT_PROPERTY(GPencilStrokePoint, strength)
	FLOAT_PROPERTY(GPencilStrokePoint, uv_factor)
	FLOAT_PROPERTY(GPencilStrokePoint, uv_rotation)
	FLOAT_ARRAY_PROPERTY(GPencilStrokePoint, 2, uv_fill)
	BOOLEAN_PROPERTY(GPencilStrokePoint, select)
	FLOAT_PROPERTY(GPencilStrokePoint, time)
	FLOAT_ARRAY_PROPERTY(GPencilStrokePoint, 4, vertex_color)


	POINTER_PROPERTY(Struct, GPencilTriangle, rna_type)
	INT_PROPERTY(GPencilTriangle, v1)
	INT_PROPERTY(GPencilTriangle, v2)
	INT_PROPERTY(GPencilTriangle, v3)


	POINTER_PROPERTY(Struct, GPencilEditCurve, rna_type)

	BOOLEAN_PROPERTY(GPencilEditCurve, select)


	POINTER_PROPERTY(Struct, GPencilEditCurvePoint, rna_type)
	BOOLEAN_PROPERTY(GPencilEditCurvePoint, select_left_handle)
	BOOLEAN_PROPERTY(GPencilEditCurvePoint, select_right_handle)
	BOOLEAN_PROPERTY(GPencilEditCurvePoint, select_control_point)
	BOOLEAN_PROPERTY(GPencilEditCurvePoint, hide)
	FLOAT_ARRAY_PROPERTY(GPencilEditCurvePoint, 3, handle_left)
	FLOAT_ARRAY_PROPERTY(GPencilEditCurvePoint, 3, co)
	FLOAT_ARRAY_PROPERTY(GPencilEditCurvePoint, 3, handle_right)
	FLOAT_PROPERTY(GPencilEditCurvePoint, pressure)
	FLOAT_PROPERTY(GPencilEditCurvePoint, strength)
	INT_PROPERTY(GPencilEditCurvePoint, point_index)
	FLOAT_PROPERTY(GPencilEditCurvePoint, uv_factor)
	FLOAT_PROPERTY(GPencilEditCurvePoint, uv_rotation)
	FLOAT_ARRAY_PROPERTY(GPencilEditCurvePoint, 4, vertex_color)


	POINTER_PROPERTY(Struct, GpencilVertexGroupElement, rna_type)
	INT_PROPERTY(GpencilVertexGroupElement, group)
	FLOAT_PROPERTY(GpencilVertexGroupElement, weight)




	POINTER_PROPERTY(AnimData, GreasePencilv3, animation_data)




	POINTER_PROPERTY(Struct, GreasePencilv3Layers, rna_type)
	POINTER_PROPERTY(GreasePencilLayer, GreasePencilv3Layers, active)


	POINTER_PROPERTY(Struct, GreasePencilLayer, rna_type)
	STRING_PROPERTY(GreasePencilLayer, name)
	BOOLEAN_PROPERTY(GreasePencilLayer, hide)
	BOOLEAN_PROPERTY(GreasePencilLayer, lock)
	FLOAT_PROPERTY(GreasePencilLayer, opacity)
	BOOLEAN_PROPERTY(GreasePencilLayer, use_onion_skinning)


	POINTER_PROPERTY(Struct, GreasePencilLayerGroup, rna_type)
	STRING_PROPERTY(GreasePencilLayerGroup, name)
	BOOLEAN_PROPERTY(GreasePencilLayerGroup, hide)
	BOOLEAN_PROPERTY(GreasePencilLayerGroup, lock)


	POINTER_PROPERTY(Struct, CurvePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(CurvePoint, 3, position)
	FLOAT_PROPERTY(CurvePoint, radius)
	INT_PROPERTY(CurvePoint, index)


	POINTER_PROPERTY(Struct, CurveSlice, rna_type)

	INT_PROPERTY(CurveSlice, first_point_index)
	INT_PROPERTY(CurveSlice, points_length)
	INT_PROPERTY(CurveSlice, index)








	POINTER_PROPERTY(Object, Curves, surface)
	STRING_PROPERTY(Curves, surface_uv_map)
	BOOLEAN_PROPERTY(Curves, use_mirror_x)
	BOOLEAN_PROPERTY(Curves, use_mirror_y)
	BOOLEAN_PROPERTY(Curves, use_mirror_z)
	ENUM_PROPERTY(selection_domain_enum, Curves, selection_domain)
	BOOLEAN_PROPERTY(Curves, use_sculpt_collision)


	POINTER_PROPERTY(AnimData, Curves, animation_data)

	inline void Curves::add_curves(int sizes_len, int *sizes) {
		Curves_add_curves_func((::Curves *) this->ptr.data, nullptr, sizes_len, sizes);
	}


	POINTER_PROPERTY(Struct, FloatVectorValueReadOnly, rna_type)
	FLOAT_ARRAY_PROPERTY(FloatVectorValueReadOnly, 3, vector)


	POINTER_PROPERTY(Struct, RenderSlot, rna_type)
	STRING_PROPERTY(RenderSlot, name)

	inline void RenderSlot::clear(ImageUser& iuser) {
		RenderSlot_clear_func((::ID *) ptr.owner_id, (::RenderSlot *) this->ptr.data, (::ImageUser *) iuser.ptr.data);
	}


	POINTER_PROPERTY(Struct, UDIMTile, rna_type)
	STRING_PROPERTY(UDIMTile, label)
	INT_PROPERTY(UDIMTile, number)
	INT_ARRAY_PROPERTY(UDIMTile, 2, size)
	INT_PROPERTY(UDIMTile, channels)
	ENUM_PROPERTY(generated_type_enum, UDIMTile, generated_type)
	INT_PROPERTY(UDIMTile, generated_width)
	INT_PROPERTY(UDIMTile, generated_height)
	BOOLEAN_PROPERTY(UDIMTile, use_generated_float)
	FLOAT_ARRAY_PROPERTY(UDIMTile, 4, generated_color)


	STRING_PROPERTY(Image, filepath)
	STRING_PROPERTY(Image, filepath_raw)
	ENUM_PROPERTY(file_format_enum, Image, file_format)
	ENUM_PROPERTY(source_enum, Image, source)
	ENUM_PROPERTY(type_enum, Image, type)
	POINTER_PROPERTY(PackedFile, Image, packed_file)

	BOOLEAN_PROPERTY(Image, use_view_as_render)
	BOOLEAN_PROPERTY(Image, use_deinterlace)
	BOOLEAN_PROPERTY(Image, use_multiview)
	BOOLEAN_PROPERTY(Image, is_stereo_3d)
	BOOLEAN_PROPERTY(Image, is_multiview)
	BOOLEAN_PROPERTY(Image, is_dirty)
	ENUM_PROPERTY(generated_type_enum, Image, generated_type)
	INT_PROPERTY(Image, generated_width)
	INT_PROPERTY(Image, generated_height)
	BOOLEAN_PROPERTY(Image, use_generated_float)
	FLOAT_ARRAY_PROPERTY(Image, 4, generated_color)
	FLOAT_ARRAY_PROPERTY(Image, 2, display_aspect)
	INT_PROPERTY(Image, bindcode)


	BOOLEAN_PROPERTY(Image, has_data)
	INT_PROPERTY(Image, depth)
	INT_ARRAY_PROPERTY(Image, 2, size)
	FLOAT_ARRAY_PROPERTY(Image, 2, resolution)
	INT_PROPERTY(Image, frame_duration)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(Image, pixels)
	INT_PROPERTY(Image, channels)
	BOOLEAN_PROPERTY(Image, is_float)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, Image, colorspace_settings)
	ENUM_PROPERTY(alpha_mode_enum, Image, alpha_mode)
	BOOLEAN_PROPERTY(Image, use_half_precision)
	INT_PROPERTY(Image, seam_margin)
	ENUM_PROPERTY(views_format_enum, Image, views_format)
	POINTER_PROPERTY(Stereo3dFormat, Image, stereo_3d_format)

	inline void Image::save_render(Context C, const char * filepath, Scene& scene, int quality) {
		Image_save_render_func((::Image *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, filepath, (::Scene *) scene.ptr.data, quality);
	}

	inline void Image::save(void *main, Context C, const char * filepath, int quality) {
		Image_save_func((::Image *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, nullptr, filepath, quality);
	}

	inline void Image::pack(void *main, Context C, const char * data, int data_len) {
		Image_pack_func((::Image *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, nullptr, data, data_len);
	}

	inline void Image::unpack(void *main, int method) {
		Image_unpack_func((::Image *) this->ptr.data, (::Main *) main, nullptr, method);
	}

	inline void Image::reload(void *main) {
		Image_reload_func((::Image *) this->ptr.data, (::Main *) main);
	}

	inline void Image::update() {
		Image_update_func((::Image *) this->ptr.data, nullptr);
	}

	inline void Image::scale(int width, int height) {
		Image_scale_func((::Image *) this->ptr.data, nullptr, width, height);
	}

	inline int Image::gl_touch(int frame, int layer_index, int pass_index) {
		return Image_gl_touch_func((::Image *) this->ptr.data, nullptr, frame, layer_index, pass_index);
	}

	inline int Image::gl_load(int frame, int layer_index, int pass_index) {
		return Image_gl_load_func((::Image *) this->ptr.data, nullptr, frame, layer_index, pass_index);
	}

	inline void Image::gl_free() {
		Image_gl_free_func((::Image *) this->ptr.data);
	}

	inline void Image::filepath_from_user(ImageUser& image_user, char * filepath) {
		Image_filepath_from_user_func((::Image *) this->ptr.data, (::ImageUser *) image_user.ptr.data, filepath);
	}

	inline void Image::buffers_free() {
		Image_buffers_free_func((::Image *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, RenderSlots, rna_type)
	INT_PROPERTY(RenderSlots, active_index)
	POINTER_PROPERTY(RenderSlot, RenderSlots, active)

	inline RenderSlot RenderSlots::create(const char * name) {
		PointerRNA result;
		::RenderSlot *retdata = RenderSlots_new_func((::Image *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RenderSlot, retdata);
		return RenderSlot(result);
	}


	POINTER_PROPERTY(Struct, UDIMTiles, rna_type)
	INT_PROPERTY(UDIMTiles, active_index)
	POINTER_PROPERTY(UDIMTile, UDIMTiles, active)

	inline UDIMTile UDIMTiles::create(int tile_number, const char * label) {
		PointerRNA result;
		::ImageTile *retdata = UDIMTiles_new_func((::Image *) this->ptr.data, tile_number, label);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UDIMTile, retdata);
		return UDIMTile(result);
	}

	inline UDIMTile UDIMTiles::get(int tile_number) {
		PointerRNA result;
		::ImageTile *retdata = UDIMTiles_get_func((::Image *) this->ptr.data, tile_number);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UDIMTile, retdata);
		return UDIMTile(result);
	}

	inline void UDIMTiles::remove(UDIMTile& tile) {
		UDIMTiles_remove_func((::Image *) this->ptr.data, (::PointerRNA *) &tile.ptr);
	}


	POINTER_PROPERTY(Struct, ImageUser, rna_type)
	BOOLEAN_PROPERTY(ImageUser, use_auto_refresh)
	INT_PROPERTY(ImageUser, frame_current)
	BOOLEAN_PROPERTY(ImageUser, use_cyclic)
	INT_PROPERTY(ImageUser, frame_duration)
	INT_PROPERTY(ImageUser, frame_offset)
	INT_PROPERTY(ImageUser, frame_start)
	INT_PROPERTY(ImageUser, multilayer_layer)
	INT_PROPERTY(ImageUser, multilayer_pass)
	INT_PROPERTY(ImageUser, multilayer_view)
	INT_PROPERTY(ImageUser, tile)


	POINTER_PROPERTY(Struct, ImagePackedFile, rna_type)
	POINTER_PROPERTY(PackedFile, ImagePackedFile, packed_file)
	STRING_PROPERTY(ImagePackedFile, filepath)
	INT_PROPERTY(ImagePackedFile, view)
	INT_PROPERTY(ImagePackedFile, tile_number)

	inline void ImagePackedFile::save(void *main) {
		ImagePackedFile_save_func((::ImagePackedFile *) this->ptr.data, (::Main *) main, nullptr);
	}


	POINTER_PROPERTY(ShapeKey, Key, reference_key)

	POINTER_PROPERTY(AnimData, Key, animation_data)
	POINTER_PROPERTY(ID, Key, user)
	BOOLEAN_PROPERTY(Key, use_relative)
	FLOAT_PROPERTY(Key, eval_time)


	POINTER_PROPERTY(Struct, ShapeKey, rna_type)
	STRING_PROPERTY(ShapeKey, name)
	FLOAT_PROPERTY(ShapeKey, frame)
	FLOAT_PROPERTY(ShapeKey, value)
	ENUM_PROPERTY(interpolation_enum, ShapeKey, interpolation)
	STRING_PROPERTY(ShapeKey, vertex_group)
	POINTER_PROPERTY(ShapeKey, ShapeKey, relative_key)
	BOOLEAN_PROPERTY(ShapeKey, mute)
	FLOAT_PROPERTY(ShapeKey, slider_min)
	FLOAT_PROPERTY(ShapeKey, slider_max)


	inline void ShapeKey::normals_vertex_get(int *normals_len, float **normals) {
		ShapeKey_normals_vertex_get_func((::ID *) ptr.owner_id, (::KeyBlock *) this->ptr.data, normals_len, normals);
	}

	inline void ShapeKey::normals_polygon_get(int *normals_len, float **normals) {
		ShapeKey_normals_polygon_get_func((::ID *) ptr.owner_id, (::KeyBlock *) this->ptr.data, normals_len, normals);
	}

	inline void ShapeKey::normals_split_get(int *normals_len, float **normals) {
		ShapeKey_normals_split_get_func((::ID *) ptr.owner_id, (::KeyBlock *) this->ptr.data, normals_len, normals);
	}


	POINTER_PROPERTY(Struct, ShapeKeyPoint, rna_type)
	FLOAT_ARRAY_PROPERTY(ShapeKeyPoint, 3, co)


	POINTER_PROPERTY(Struct, ShapeKeyCurvePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(ShapeKeyCurvePoint, 3, co)
	FLOAT_PROPERTY(ShapeKeyCurvePoint, tilt)
	FLOAT_PROPERTY(ShapeKeyCurvePoint, radius)


	POINTER_PROPERTY(Struct, ShapeKeyBezierPoint, rna_type)
	FLOAT_ARRAY_PROPERTY(ShapeKeyBezierPoint, 3, co)
	FLOAT_ARRAY_PROPERTY(ShapeKeyBezierPoint, 3, handle_left)
	FLOAT_ARRAY_PROPERTY(ShapeKeyBezierPoint, 3, handle_right)
	FLOAT_PROPERTY(ShapeKeyBezierPoint, tilt)
	FLOAT_PROPERTY(ShapeKeyBezierPoint, radius)


	ENUM_PROPERTY(type_enum, Light, type)
	FLOAT_ARRAY_PROPERTY(Light, 3, color)
	FLOAT_PROPERTY(Light, specular_factor)
	FLOAT_PROPERTY(Light, diffuse_factor)
	FLOAT_PROPERTY(Light, volume_factor)
	BOOLEAN_PROPERTY(Light, use_custom_distance)
	FLOAT_PROPERTY(Light, cutoff_distance)
	POINTER_PROPERTY(NodeTree, Light, node_tree)
	BOOLEAN_PROPERTY(Light, use_nodes)
	POINTER_PROPERTY(AnimData, Light, animation_data)


	FLOAT_PROPERTY(PointLight, energy)
	BOOLEAN_PROPERTY(PointLight, use_shadow)
	FLOAT_PROPERTY(PointLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(PointLight, shadow_buffer_bias)
	FLOAT_ARRAY_PROPERTY(PointLight, 3, shadow_color)
	FLOAT_PROPERTY(PointLight, shadow_soft_size)
	BOOLEAN_PROPERTY(PointLight, use_contact_shadow)
	FLOAT_PROPERTY(PointLight, contact_shadow_distance)
	FLOAT_PROPERTY(PointLight, contact_shadow_bias)
	FLOAT_PROPERTY(PointLight, contact_shadow_thickness)
	FLOAT_PROPERTY(PointLight, shadow_softness_factor)


	FLOAT_PROPERTY(AreaLight, energy)
	BOOLEAN_PROPERTY(AreaLight, use_shadow)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(AreaLight, shadow_buffer_bias)
	FLOAT_ARRAY_PROPERTY(AreaLight, 3, shadow_color)
	FLOAT_PROPERTY(AreaLight, shadow_soft_size)
	BOOLEAN_PROPERTY(AreaLight, use_contact_shadow)
	FLOAT_PROPERTY(AreaLight, contact_shadow_distance)
	FLOAT_PROPERTY(AreaLight, contact_shadow_bias)
	FLOAT_PROPERTY(AreaLight, contact_shadow_thickness)
	FLOAT_PROPERTY(AreaLight, shadow_softness_factor)
	ENUM_PROPERTY(shape_enum, AreaLight, shape)
	FLOAT_PROPERTY(AreaLight, size)
	FLOAT_PROPERTY(AreaLight, size_y)
	FLOAT_PROPERTY(AreaLight, spread)


	FLOAT_PROPERTY(SpotLight, energy)
	BOOLEAN_PROPERTY(SpotLight, use_shadow)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(SpotLight, shadow_buffer_bias)
	FLOAT_ARRAY_PROPERTY(SpotLight, 3, shadow_color)
	FLOAT_PROPERTY(SpotLight, shadow_soft_size)
	BOOLEAN_PROPERTY(SpotLight, use_contact_shadow)
	FLOAT_PROPERTY(SpotLight, contact_shadow_distance)
	FLOAT_PROPERTY(SpotLight, contact_shadow_bias)
	FLOAT_PROPERTY(SpotLight, contact_shadow_thickness)
	FLOAT_PROPERTY(SpotLight, shadow_softness_factor)
	BOOLEAN_PROPERTY(SpotLight, use_square)
	FLOAT_PROPERTY(SpotLight, spot_blend)
	FLOAT_PROPERTY(SpotLight, spot_size)
	BOOLEAN_PROPERTY(SpotLight, show_cone)


	FLOAT_PROPERTY(SunLight, angle)
	FLOAT_PROPERTY(SunLight, energy)
	BOOLEAN_PROPERTY(SunLight, use_shadow)
	FLOAT_PROPERTY(SunLight, shadow_buffer_clip_start)
	FLOAT_PROPERTY(SunLight, shadow_buffer_bias)
	FLOAT_ARRAY_PROPERTY(SunLight, 3, shadow_color)
	FLOAT_PROPERTY(SunLight, shadow_soft_size)
	BOOLEAN_PROPERTY(SunLight, use_contact_shadow)
	FLOAT_PROPERTY(SunLight, contact_shadow_distance)
	FLOAT_PROPERTY(SunLight, contact_shadow_bias)
	FLOAT_PROPERTY(SunLight, contact_shadow_thickness)
	FLOAT_PROPERTY(SunLight, shadow_softness_factor)
	FLOAT_PROPERTY(SunLight, shadow_cascade_max_distance)
	INT_PROPERTY(SunLight, shadow_cascade_count)
	FLOAT_PROPERTY(SunLight, shadow_cascade_exponent)
	FLOAT_PROPERTY(SunLight, shadow_cascade_fade)
	FLOAT_PROPERTY(SunLight, shadow_trace_distance)


	INT_PROPERTY(Lattice, points_u)
	INT_PROPERTY(Lattice, points_v)
	INT_PROPERTY(Lattice, points_w)
	ENUM_PROPERTY(interpolation_type_u_enum, Lattice, interpolation_type_u)
	ENUM_PROPERTY(interpolation_type_v_enum, Lattice, interpolation_type_v)
	ENUM_PROPERTY(interpolation_type_w_enum, Lattice, interpolation_type_w)
	BOOLEAN_PROPERTY(Lattice, use_outside)
	STRING_PROPERTY(Lattice, vertex_group)
	POINTER_PROPERTY(Key, Lattice, shape_keys)

	BOOLEAN_PROPERTY(Lattice, is_editmode)
	POINTER_PROPERTY(AnimData, Lattice, animation_data)

	inline void Lattice::transform(float matrix[16], bool shape_keys) {
		Lattice_transform_func((::Lattice *) this->ptr.data, matrix, shape_keys);
	}

	inline void Lattice::update_gpu_tag() {
		Lattice_update_gpu_tag_func((::Lattice *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, LatticePoint, rna_type)
	BOOLEAN_PROPERTY(LatticePoint, select)
	FLOAT_ARRAY_PROPERTY(LatticePoint, 3, co)
	FLOAT_ARRAY_PROPERTY(LatticePoint, 3, co_deform)
	FLOAT_PROPERTY(LatticePoint, weight_softbody)



	POINTER_PROPERTY(Struct, ViewLayer, rna_type)
	STRING_PROPERTY(ViewLayer, name)
	POINTER_PROPERTY(Material, ViewLayer, material_override)
	INT_PROPERTY(ViewLayer, samples)
	FLOAT_PROPERTY(ViewLayer, pass_alpha_threshold)
	POINTER_PROPERTY(ViewLayerEEVEE, ViewLayer, eevee)

	POINTER_PROPERTY(AOV, ViewLayer, active_aov)
	INT_PROPERTY(ViewLayer, active_aov_index)

	POINTER_PROPERTY(Lightgroup, ViewLayer, active_lightgroup)
	INT_PROPERTY(ViewLayer, active_lightgroup_index)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_cryptomatte_object)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_cryptomatte_material)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_cryptomatte_asset)
	INT_PROPERTY(ViewLayer, pass_cryptomatte_depth)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_cryptomatte_accurate)
	BOOLEAN_PROPERTY(ViewLayer, use_solid)
	BOOLEAN_PROPERTY(ViewLayer, use_sky)
	BOOLEAN_PROPERTY(ViewLayer, use_ao)
	BOOLEAN_PROPERTY(ViewLayer, use_strand)
	BOOLEAN_PROPERTY(ViewLayer, use_volumes)
	BOOLEAN_PROPERTY(ViewLayer, use_motion_blur)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_combined)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_z)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_vector)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_position)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_normal)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_uv)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_mist)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_object_index)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_material_index)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_shadow)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_ambient_occlusion)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_emit)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_environment)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_diffuse_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_diffuse_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_diffuse_color)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_glossy_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_glossy_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_glossy_color)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_transmission_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_transmission_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_transmission_color)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_subsurface_direct)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_subsurface_indirect)
	BOOLEAN_PROPERTY(ViewLayer, use_pass_subsurface_color)
	POINTER_PROPERTY(LayerCollection, ViewLayer, layer_collection)
	POINTER_PROPERTY(LayerCollection, ViewLayer, active_layer_collection)

	BOOLEAN_PROPERTY(ViewLayer, use)
	BOOLEAN_PROPERTY(ViewLayer, use_freestyle)
	POINTER_PROPERTY(FreestyleSettings, ViewLayer, freestyle_settings)
	POINTER_PROPERTY(Depsgraph, ViewLayer, depsgraph)

	inline void ViewLayer::update_render_passes() {
		ViewLayer_update_render_passes_func((::ID *) ptr.owner_id);
	}

	inline void ViewLayer::update(void *main) {
		ViewLayer_update_func((::ID *) ptr.owner_id, (::ViewLayer *) this->ptr.data, (::Main *) main, nullptr);
	}


	POINTER_PROPERTY(Struct, AOVs, rna_type)

	inline AOV AOVs::add() {
		PointerRNA result;
		::ViewLayerAOV *retdata = AOVs_add_func((::ViewLayer *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_AOV, retdata);
		return AOV(result);
	}

	inline void AOVs::remove(AOV& aov) {
		AOVs_remove_func((::ViewLayer *) this->ptr.data, nullptr, (::ViewLayerAOV *) aov.ptr.data);
	}


	POINTER_PROPERTY(Struct, Lightgroups, rna_type)

	inline Lightgroup Lightgroups::add(const char * name) {
		PointerRNA result;
		::ViewLayerLightgroup *retdata = Lightgroups_add_func((::ViewLayer *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Lightgroup, retdata);
		return Lightgroup(result);
	}


	POINTER_PROPERTY(Struct, LayerObjects, rna_type)
	POINTER_PROPERTY(Object, LayerObjects, active)



	POINTER_PROPERTY(Struct, FreestyleLineSet, rna_type)
	POINTER_PROPERTY(FreestyleLineStyle, FreestyleLineSet, linestyle)
	STRING_PROPERTY(FreestyleLineSet, name)
	BOOLEAN_PROPERTY(FreestyleLineSet, show_render)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_visibility)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_edge_types)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_collection)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_image_border)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_by_face_marks)
	ENUM_PROPERTY(edge_type_negation_enum, FreestyleLineSet, edge_type_negation)
	ENUM_PROPERTY(edge_type_combination_enum, FreestyleLineSet, edge_type_combination)
	POINTER_PROPERTY(Collection, FreestyleLineSet, collection)
	ENUM_PROPERTY(collection_negation_enum, FreestyleLineSet, collection_negation)
	ENUM_PROPERTY(face_mark_negation_enum, FreestyleLineSet, face_mark_negation)
	ENUM_PROPERTY(face_mark_condition_enum, FreestyleLineSet, face_mark_condition)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_silhouette)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_border)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_crease)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_ridge_valley)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_suggestive_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_material_boundary)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_external_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, select_edge_mark)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_silhouette)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_border)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_crease)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_ridge_valley)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_suggestive_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_material_boundary)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_external_contour)
	BOOLEAN_PROPERTY(FreestyleLineSet, exclude_edge_mark)
	ENUM_PROPERTY(visibility_enum, FreestyleLineSet, visibility)
	INT_PROPERTY(FreestyleLineSet, qi_start)
	INT_PROPERTY(FreestyleLineSet, qi_end)


	POINTER_PROPERTY(Struct, FreestyleModuleSettings, rna_type)
	POINTER_PROPERTY(Text, FreestyleModuleSettings, script)
	BOOLEAN_PROPERTY(FreestyleModuleSettings, use)


	POINTER_PROPERTY(Struct, FreestyleSettings, rna_type)

	ENUM_PROPERTY(mode_enum, FreestyleSettings, mode)
	BOOLEAN_PROPERTY(FreestyleSettings, use_culling)
	BOOLEAN_PROPERTY(FreestyleSettings, use_suggestive_contours)
	BOOLEAN_PROPERTY(FreestyleSettings, use_ridges_and_valleys)
	BOOLEAN_PROPERTY(FreestyleSettings, use_material_boundaries)
	BOOLEAN_PROPERTY(FreestyleSettings, use_smoothness)
	BOOLEAN_PROPERTY(FreestyleSettings, use_view_map_cache)
	BOOLEAN_PROPERTY(FreestyleSettings, as_render_pass)
	FLOAT_PROPERTY(FreestyleSettings, sphere_radius)
	FLOAT_PROPERTY(FreestyleSettings, kr_derivative_epsilon)
	FLOAT_PROPERTY(FreestyleSettings, crease_angle)



	POINTER_PROPERTY(Struct, FreestyleModules, rna_type)

	inline FreestyleModuleSettings FreestyleModules::create() {
		PointerRNA result;
		::FreestyleModuleConfig *retdata = FreestyleModules_new_func((::ID *) ptr.owner_id, (::FreestyleSettings *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FreestyleModuleSettings, retdata);
		return FreestyleModuleSettings(result);
	}

	inline void FreestyleModules::remove(FreestyleModuleSettings& module) {
		FreestyleModules_remove_func((::ID *) ptr.owner_id, (::FreestyleSettings *) this->ptr.data, nullptr, (::PointerRNA *) &module.ptr);
	}


	POINTER_PROPERTY(Struct, Linesets, rna_type)
	POINTER_PROPERTY(FreestyleLineSet, Linesets, active)
	INT_PROPERTY(Linesets, active_index)

	inline FreestyleLineSet Linesets::create(void *main, const char * name) {
		PointerRNA result;
		::FreestyleLineSet *retdata = Linesets_new_func((::ID *) ptr.owner_id, (::FreestyleSettings *) this->ptr.data, (::Main *) main, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FreestyleLineSet, retdata);
		return FreestyleLineSet(result);
	}

	inline void Linesets::remove(FreestyleLineSet& lineset) {
		Linesets_remove_func((::ID *) ptr.owner_id, (::FreestyleSettings *) this->ptr.data, nullptr, (::PointerRNA *) &lineset.ptr);
	}


	POINTER_PROPERTY(Struct, LayerCollection, rna_type)
	POINTER_PROPERTY(Collection, LayerCollection, collection)
	STRING_PROPERTY(LayerCollection, name)

	BOOLEAN_PROPERTY(LayerCollection, exclude)
	BOOLEAN_PROPERTY(LayerCollection, holdout)
	BOOLEAN_PROPERTY(LayerCollection, indirect_only)
	BOOLEAN_PROPERTY(LayerCollection, hide_viewport)
	BOOLEAN_PROPERTY(LayerCollection, is_visible)

	inline bool LayerCollection::visible_get(Context C) {
		return LayerCollection_visible_get_func((::LayerCollection *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline bool LayerCollection::has_objects() {
		return LayerCollection_has_objects_func((::LayerCollection *) this->ptr.data);
	}

	inline bool LayerCollection::has_selected_objects(void *main, ViewLayer& view_layer) {
		return LayerCollection_has_selected_objects_func((::LayerCollection *) this->ptr.data, (::Main *) main, (::ViewLayer *) view_layer.ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectBase, rna_type)
	POINTER_PROPERTY(Object, ObjectBase, object)
	BOOLEAN_PROPERTY(ObjectBase, select)
	BOOLEAN_PROPERTY(ObjectBase, hide_viewport)


	POINTER_PROPERTY(Struct, LineStyleModifier, rna_type)


	STRING_PROPERTY(LineStyleColorModifier, name)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_AlongStroke, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_AlongStroke, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_AlongStroke, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_AlongStroke, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_AlongStroke, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_AlongStroke, color_ramp)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_DistanceFromCamera, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_DistanceFromCamera, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromCamera, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromCamera, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromCamera, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_DistanceFromCamera, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromCamera, range_min)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromCamera, range_max)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_DistanceFromObject, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_DistanceFromObject, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromObject, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromObject, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_DistanceFromObject, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_DistanceFromObject, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromObject, range_min)
	FLOAT_PROPERTY(LineStyleColorModifier_DistanceFromObject, range_max)
	POINTER_PROPERTY(Object, LineStyleColorModifier_DistanceFromObject, target)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Material, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Material, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Material, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Material, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Material, expanded)
	ENUM_PROPERTY(material_attribute_enum, LineStyleColorModifier_Material, material_attribute)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Material, color_ramp)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Material, use_ramp)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Tangent, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Tangent, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Tangent, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Tangent, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Tangent, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Tangent, color_ramp)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Noise, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Noise, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Noise, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Noise, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Noise, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Noise, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_Noise, amplitude)
	FLOAT_PROPERTY(LineStyleColorModifier_Noise, period)
	INT_PROPERTY(LineStyleColorModifier_Noise, seed)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_CreaseAngle, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_CreaseAngle, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_CreaseAngle, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_CreaseAngle, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_CreaseAngle, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_CreaseAngle, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_CreaseAngle, angle_min)
	FLOAT_PROPERTY(LineStyleColorModifier_CreaseAngle, angle_max)


	ENUM_PROPERTY(type_enum, LineStyleColorModifier_Curvature_3D, type)
	ENUM_PROPERTY(blend_enum, LineStyleColorModifier_Curvature_3D, blend)
	FLOAT_PROPERTY(LineStyleColorModifier_Curvature_3D, influence)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Curvature_3D, use)
	BOOLEAN_PROPERTY(LineStyleColorModifier_Curvature_3D, expanded)
	POINTER_PROPERTY(ColorRamp, LineStyleColorModifier_Curvature_3D, color_ramp)
	FLOAT_PROPERTY(LineStyleColorModifier_Curvature_3D, curvature_min)
	FLOAT_PROPERTY(LineStyleColorModifier_Curvature_3D, curvature_max)


	STRING_PROPERTY(LineStyleAlphaModifier, name)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_AlongStroke, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_AlongStroke, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_AlongStroke, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_AlongStroke, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_AlongStroke, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_AlongStroke, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_AlongStroke, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_AlongStroke, curve)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_DistanceFromCamera, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_DistanceFromCamera, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_DistanceFromCamera, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_DistanceFromCamera, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, range_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromCamera, range_max)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_DistanceFromObject, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_DistanceFromObject, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_DistanceFromObject, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_DistanceFromObject, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, range_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_DistanceFromObject, range_max)
	POINTER_PROPERTY(Object, LineStyleAlphaModifier_DistanceFromObject, target)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Material, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Material, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Material, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Material, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Material, expanded)
	ENUM_PROPERTY(material_attribute_enum, LineStyleAlphaModifier_Material, material_attribute)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Material, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Material, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Material, curve)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Tangent, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Tangent, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Tangent, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Tangent, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Tangent, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Tangent, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Tangent, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Tangent, curve)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Noise, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Noise, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Noise, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Noise, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Noise, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Noise, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Noise, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Noise, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Noise, amplitude)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Noise, period)
	INT_PROPERTY(LineStyleAlphaModifier_Noise, seed)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_CreaseAngle, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_CreaseAngle, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_CreaseAngle, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_CreaseAngle, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_CreaseAngle, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_CreaseAngle, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_CreaseAngle, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_CreaseAngle, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_CreaseAngle, angle_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_CreaseAngle, angle_max)


	ENUM_PROPERTY(type_enum, LineStyleAlphaModifier_Curvature_3D, type)
	ENUM_PROPERTY(blend_enum, LineStyleAlphaModifier_Curvature_3D, blend)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Curvature_3D, influence)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Curvature_3D, use)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Curvature_3D, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleAlphaModifier_Curvature_3D, mapping)
	BOOLEAN_PROPERTY(LineStyleAlphaModifier_Curvature_3D, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleAlphaModifier_Curvature_3D, curve)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Curvature_3D, curvature_min)
	FLOAT_PROPERTY(LineStyleAlphaModifier_Curvature_3D, curvature_max)


	STRING_PROPERTY(LineStyleThicknessModifier, name)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Tangent, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Tangent, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Tangent, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Tangent, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Tangent, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_Tangent, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Tangent, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_Tangent, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Tangent, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Tangent, thickness_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_AlongStroke, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_AlongStroke, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_AlongStroke, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_AlongStroke, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_AlongStroke, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_AlongStroke, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_AlongStroke, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_AlongStroke, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_AlongStroke, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_AlongStroke, value_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_DistanceFromCamera, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_DistanceFromCamera, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_DistanceFromCamera, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_DistanceFromCamera, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, range_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, range_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromCamera, value_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_DistanceFromObject, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_DistanceFromObject, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_DistanceFromObject, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_DistanceFromObject, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, range_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, range_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_DistanceFromObject, value_max)
	POINTER_PROPERTY(Object, LineStyleThicknessModifier_DistanceFromObject, target)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Material, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Material, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Material, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Material, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Material, expanded)
	ENUM_PROPERTY(material_attribute_enum, LineStyleThicknessModifier_Material, material_attribute)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_Material, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Material, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_Material, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Material, value_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Material, value_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Calligraphy, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Calligraphy, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Calligraphy, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Calligraphy, expanded)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, orientation)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Calligraphy, thickness_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Noise, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Noise, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Noise, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Noise, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Noise, expanded)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Noise, amplitude)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Noise, period)
	INT_PROPERTY(LineStyleThicknessModifier_Noise, seed)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Noise, use_asymmetric)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_Curvature_3D, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_Curvature_3D, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Curvature_3D, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Curvature_3D, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_Curvature_3D, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_Curvature_3D, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_Curvature_3D, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, thickness_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, curvature_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_Curvature_3D, curvature_max)


	ENUM_PROPERTY(type_enum, LineStyleThicknessModifier_CreaseAngle, type)
	ENUM_PROPERTY(blend_enum, LineStyleThicknessModifier_CreaseAngle, blend)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, influence)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_CreaseAngle, use)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_CreaseAngle, expanded)
	ENUM_PROPERTY(mapping_enum, LineStyleThicknessModifier_CreaseAngle, mapping)
	BOOLEAN_PROPERTY(LineStyleThicknessModifier_CreaseAngle, invert)
	POINTER_PROPERTY(CurveMapping, LineStyleThicknessModifier_CreaseAngle, curve)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, angle_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, angle_max)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, thickness_min)
	FLOAT_PROPERTY(LineStyleThicknessModifier_CreaseAngle, thickness_max)


	STRING_PROPERTY(LineStyleGeometryModifier, name)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Sampling, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Sampling, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Sampling, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Sampling, sampling)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_BezierCurve, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BezierCurve, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BezierCurve, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_BezierCurve, error)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_SinusDisplacement, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, wavelength)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, amplitude)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SinusDisplacement, phase)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_SpatialNoise, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SpatialNoise, amplitude)
	FLOAT_PROPERTY(LineStyleGeometryModifier_SpatialNoise, scale)
	INT_PROPERTY(LineStyleGeometryModifier_SpatialNoise, octaves)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, smooth)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_SpatialNoise, use_pure_random)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_PerlinNoise1D, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, frequency)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, amplitude)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, octaves)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, angle)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise1D, seed)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_PerlinNoise2D, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, frequency)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, amplitude)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, octaves)
	FLOAT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, angle)
	INT_PROPERTY(LineStyleGeometryModifier_PerlinNoise2D, seed)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_BackboneStretcher, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BackboneStretcher, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_BackboneStretcher, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_BackboneStretcher, backbone_length)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_TipRemover, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_TipRemover, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_TipRemover, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_TipRemover, tip_length)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Polygonalization, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Polygonalization, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Polygonalization, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Polygonalization, error)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_GuidingLines, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_GuidingLines, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_GuidingLines, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_GuidingLines, offset)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Blueprint, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Blueprint, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Blueprint, expanded)
	ENUM_PROPERTY(shape_enum, LineStyleGeometryModifier_Blueprint, shape)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, rounds)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Blueprint, backbone_length)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, random_radius)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, random_center)
	INT_PROPERTY(LineStyleGeometryModifier_Blueprint, random_backbone)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_2DOffset, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DOffset, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DOffset, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, start)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, end)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, x)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DOffset, y)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_2DTransform, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DTransform, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_2DTransform, expanded)
	ENUM_PROPERTY(pivot_enum, LineStyleGeometryModifier_2DTransform, pivot)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, scale_x)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, scale_y)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, angle)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, pivot_u)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, pivot_x)
	FLOAT_PROPERTY(LineStyleGeometryModifier_2DTransform, pivot_y)


	ENUM_PROPERTY(type_enum, LineStyleGeometryModifier_Simplification, type)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Simplification, use)
	BOOLEAN_PROPERTY(LineStyleGeometryModifier_Simplification, expanded)
	FLOAT_PROPERTY(LineStyleGeometryModifier_Simplification, tolerance)



	POINTER_PROPERTY(Texture, FreestyleLineStyle, active_texture)
	INT_PROPERTY(FreestyleLineStyle, active_texture_index)
	ENUM_PROPERTY(panel_enum, FreestyleLineStyle, panel)
	FLOAT_ARRAY_PROPERTY(FreestyleLineStyle, 3, color)
	FLOAT_PROPERTY(FreestyleLineStyle, alpha)
	FLOAT_PROPERTY(FreestyleLineStyle, thickness)
	ENUM_PROPERTY(thickness_position_enum, FreestyleLineStyle, thickness_position)
	FLOAT_PROPERTY(FreestyleLineStyle, thickness_ratio)




	BOOLEAN_PROPERTY(FreestyleLineStyle, use_chaining)
	ENUM_PROPERTY(chaining_enum, FreestyleLineStyle, chaining)
	INT_PROPERTY(FreestyleLineStyle, rounds)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_same_object)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_split_length)
	FLOAT_PROPERTY(FreestyleLineStyle, split_length)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_angle_min)
	FLOAT_PROPERTY(FreestyleLineStyle, angle_min)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_angle_max)
	FLOAT_PROPERTY(FreestyleLineStyle, angle_max)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_length_min)
	FLOAT_PROPERTY(FreestyleLineStyle, length_min)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_length_max)
	FLOAT_PROPERTY(FreestyleLineStyle, length_max)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_chain_count)
	INT_PROPERTY(FreestyleLineStyle, chain_count)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_split_pattern)
	INT_PROPERTY(FreestyleLineStyle, split_dash1)
	INT_PROPERTY(FreestyleLineStyle, split_gap1)
	INT_PROPERTY(FreestyleLineStyle, split_dash2)
	INT_PROPERTY(FreestyleLineStyle, split_gap2)
	INT_PROPERTY(FreestyleLineStyle, split_dash3)
	INT_PROPERTY(FreestyleLineStyle, split_gap3)
	BOOLEAN_PROPERTY(FreestyleLineStyle, material_boundary)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_sorting)
	ENUM_PROPERTY(sort_key_enum, FreestyleLineStyle, sort_key)
	ENUM_PROPERTY(sort_order_enum, FreestyleLineStyle, sort_order)
	ENUM_PROPERTY(integration_type_enum, FreestyleLineStyle, integration_type)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_dashed_line)
	ENUM_PROPERTY(caps_enum, FreestyleLineStyle, caps)
	INT_PROPERTY(FreestyleLineStyle, dash1)
	INT_PROPERTY(FreestyleLineStyle, gap1)
	INT_PROPERTY(FreestyleLineStyle, dash2)
	INT_PROPERTY(FreestyleLineStyle, gap2)
	INT_PROPERTY(FreestyleLineStyle, dash3)
	INT_PROPERTY(FreestyleLineStyle, gap3)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_texture)
	FLOAT_PROPERTY(FreestyleLineStyle, texture_spacing)
	POINTER_PROPERTY(AnimData, FreestyleLineStyle, animation_data)
	POINTER_PROPERTY(NodeTree, FreestyleLineStyle, node_tree)
	BOOLEAN_PROPERTY(FreestyleLineStyle, use_nodes)


	POINTER_PROPERTY(Struct, LineStyleTextureSlots, rna_type)

	inline LineStyleTextureSlot LineStyleTextureSlots::add(Context C) {
		PointerRNA result;
		::MTex *retdata = LineStyleTextureSlots_add_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, nullptr);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_LineStyleTextureSlot, retdata);
		return LineStyleTextureSlot(result);
	}

	inline LineStyleTextureSlot LineStyleTextureSlots::create(Context C, int index) {
		PointerRNA result;
		::MTex *retdata = LineStyleTextureSlots_create_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, nullptr, index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_LineStyleTextureSlot, retdata);
		return LineStyleTextureSlot(result);
	}

	inline void LineStyleTextureSlots::clear(Context C, int index) {
		LineStyleTextureSlots_clear_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, nullptr, index);
	}


	POINTER_PROPERTY(Struct, LineStyleColorModifiers, rna_type)

	inline LineStyleColorModifier LineStyleColorModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleColorModifiers_new_func((::FreestyleLineStyle *) this->ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_LineStyleColorModifier, retdata);
		return LineStyleColorModifier(result);
	}

	inline void LineStyleColorModifiers::remove(LineStyleColorModifier& modifier) {
		LineStyleColorModifiers_remove_func((::FreestyleLineStyle *) this->ptr.data, nullptr, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, LineStyleAlphaModifiers, rna_type)

	inline LineStyleAlphaModifier LineStyleAlphaModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleAlphaModifiers_new_func((::FreestyleLineStyle *) this->ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_LineStyleAlphaModifier, retdata);
		return LineStyleAlphaModifier(result);
	}

	inline void LineStyleAlphaModifiers::remove(LineStyleAlphaModifier& modifier) {
		LineStyleAlphaModifiers_remove_func((::FreestyleLineStyle *) this->ptr.data, nullptr, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, LineStyleThicknessModifiers, rna_type)

	inline LineStyleThicknessModifier LineStyleThicknessModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleThicknessModifiers_new_func((::FreestyleLineStyle *) this->ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_LineStyleThicknessModifier, retdata);
		return LineStyleThicknessModifier(result);
	}

	inline void LineStyleThicknessModifiers::remove(LineStyleThicknessModifier& modifier) {
		LineStyleThicknessModifiers_remove_func((::FreestyleLineStyle *) this->ptr.data, nullptr, (::PointerRNA *) &modifier.ptr);
	}


	POINTER_PROPERTY(Struct, LineStyleGeometryModifiers, rna_type)

	inline LineStyleGeometryModifier LineStyleGeometryModifiers::create(const char * name, int type) {
		PointerRNA result;
		::LineStyleModifier *retdata = LineStyleGeometryModifiers_new_func((::FreestyleLineStyle *) this->ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_LineStyleGeometryModifier, retdata);
		return LineStyleGeometryModifier(result);
	}

	inline void LineStyleGeometryModifiers::remove(LineStyleGeometryModifier& modifier) {
		LineStyleGeometryModifiers_remove_func((::FreestyleLineStyle *) this->ptr.data, nullptr, (::PointerRNA *) &modifier.ptr);
	}


	ENUM_PROPERTY(mapping_x_enum, LineStyleTextureSlot, mapping_x)
	ENUM_PROPERTY(mapping_y_enum, LineStyleTextureSlot, mapping_y)
	ENUM_PROPERTY(mapping_z_enum, LineStyleTextureSlot, mapping_z)
	ENUM_PROPERTY(mapping_enum, LineStyleTextureSlot, mapping)
	BOOLEAN_PROPERTY(LineStyleTextureSlot, use_map_color_diffuse)
	BOOLEAN_PROPERTY(LineStyleTextureSlot, use_map_alpha)
	ENUM_PROPERTY(texture_coords_enum, LineStyleTextureSlot, texture_coords)
	FLOAT_PROPERTY(LineStyleTextureSlot, alpha_factor)
	FLOAT_PROPERTY(LineStyleTextureSlot, diffuse_color_factor)


	POINTER_PROPERTY(Struct, BlendData, rna_type)
	STRING_PROPERTY(BlendData, filepath)
	BOOLEAN_PROPERTY(BlendData, is_dirty)
	BOOLEAN_PROPERTY(BlendData, is_saved)
	BOOLEAN_PROPERTY(BlendData, use_autopack)
	INT_ARRAY_PROPERTY(BlendData, 3, version)









































	POINTER_PROPERTY(Struct, BlendDataCameras, rna_type)

	inline Camera BlendDataCameras::create(const char * name) {
		PointerRNA result;
		::Camera *retdata = BlendDataCameras_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Camera(result);
	}

	inline void BlendDataCameras::remove(Camera& camera, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataCameras_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &camera.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataCameras::tag(bool value) {
		BlendDataCameras_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataScenes, rna_type)

	inline Scene BlendDataScenes::create(const char * name) {
		PointerRNA result;
		::Scene *retdata = BlendDataScenes_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Scene(result);
	}

	inline void BlendDataScenes::remove(Context C, Scene& scene, bool do_unlink) {
		BlendDataScenes_remove_func((::Main *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &scene.ptr, do_unlink);
	}

	inline void BlendDataScenes::tag(bool value) {
		BlendDataScenes_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataObjects, rna_type)

	inline Object BlendDataObjects::create(const char * name, ID& object_data) {
		PointerRNA result;
		::Object *retdata = BlendDataObjects_new_func((::Main *) this->ptr.data, nullptr, name, (::ID *) object_data.ptr.data);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Object(result);
	}

	inline void BlendDataObjects::remove(Object& object, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataObjects_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &object.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataObjects::tag(bool value) {
		BlendDataObjects_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataMaterials, rna_type)

	inline Material BlendDataMaterials::create(const char * name) {
		PointerRNA result;
		::Material *retdata = BlendDataMaterials_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Material(result);
	}

	inline void BlendDataMaterials::create_gpencil_data(Material& material) {
		BlendDataMaterials_create_gpencil_data_func((::Main *) this->ptr.data, (::PointerRNA *) &material);
	}

	inline void BlendDataMaterials::remove_gpencil_data(Material& material) {
		BlendDataMaterials_remove_gpencil_data_func((::Main *) this->ptr.data, (::PointerRNA *) &material);
	}

	inline void BlendDataMaterials::remove(Material& material, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMaterials_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &material.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataMaterials::tag(bool value) {
		BlendDataMaterials_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataNodeTrees, rna_type)

	inline NodeTree BlendDataNodeTrees::create(const char * name, int type) {
		PointerRNA result;
		::bNodeTree *retdata = BlendDataNodeTrees_new_func((::Main *) this->ptr.data, name, type);
		result = RNA_id_pointer_create((::ID *) retdata);
		return NodeTree(result);
	}

	inline void BlendDataNodeTrees::remove(NodeTree& tree, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataNodeTrees_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &tree.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataNodeTrees::tag(bool value) {
		BlendDataNodeTrees_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataMeshes, rna_type)

	inline Mesh BlendDataMeshes::create(const char * name) {
		PointerRNA result;
		::Mesh *retdata = BlendDataMeshes_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Mesh(result);
	}

	inline Mesh BlendDataMeshes::new_from_object(Object& object, bool preserve_all_data_layers, Depsgraph& depsgraph) {
		PointerRNA result;
		::Mesh *retdata = BlendDataMeshes_new_from_object_func((::Main *) this->ptr.data, nullptr, (::Object *) object.ptr.data, preserve_all_data_layers, (::Depsgraph *) depsgraph.ptr.data);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Mesh(result);
	}

	inline void BlendDataMeshes::remove(Mesh& mesh, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMeshes_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &mesh.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataMeshes::tag(bool value) {
		BlendDataMeshes_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataLights, rna_type)

	inline Light BlendDataLights::create(const char * name, int type) {
		PointerRNA result;
		::Light *retdata = BlendDataLights_new_func((::Main *) this->ptr.data, name, type);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Light(result);
	}

	inline void BlendDataLights::remove(Light& light, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataLights_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &light.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataLights::tag(bool value) {
		BlendDataLights_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataLibraries, rna_type)

	inline void BlendDataLibraries::tag(bool value) {
		BlendDataLibraries_tag_func((::Main *) this->ptr.data, value);
	}

	inline void BlendDataLibraries::remove(Library& library, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataLibraries_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &library.ptr, do_unlink, do_id_user, do_ui_user);
	}


	POINTER_PROPERTY(Struct, BlendDataScreens, rna_type)

	inline void BlendDataScreens::tag(bool value) {
		BlendDataScreens_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataWindowManagers, rna_type)

	inline void BlendDataWindowManagers::tag(bool value) {
		BlendDataWindowManagers_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataImages, rna_type)

	inline Image BlendDataImages::create(const char * name, int width, int height, bool alpha, bool float_buffer, bool stereo3d, bool is_data, bool tiled) {
		PointerRNA result;
		::Image *retdata = BlendDataImages_new_func((::Main *) this->ptr.data, name, width, height, alpha, float_buffer, stereo3d, is_data, tiled);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Image(result);
	}

	inline Image BlendDataImages::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::Image *retdata = BlendDataImages_load_func((::Main *) this->ptr.data, nullptr, filepath, check_existing);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Image(result);
	}

	inline void BlendDataImages::remove(Image& image, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataImages_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &image.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataImages::tag(bool value) {
		BlendDataImages_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataLattices, rna_type)

	inline Lattice BlendDataLattices::create(const char * name) {
		PointerRNA result;
		::Lattice *retdata = BlendDataLattices_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Lattice(result);
	}

	inline void BlendDataLattices::remove(Lattice& lattice, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataLattices_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &lattice.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataLattices::tag(bool value) {
		BlendDataLattices_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataCurves, rna_type)

	inline Curve BlendDataCurves::create(const char * name, int type) {
		PointerRNA result;
		::Curve *retdata = BlendDataCurves_new_func((::Main *) this->ptr.data, name, type);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Curve(result);
	}

	inline void BlendDataCurves::remove(Curve& curve, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataCurves_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &curve.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataCurves::tag(bool value) {
		BlendDataCurves_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataMetaBalls, rna_type)

	inline MetaBall BlendDataMetaBalls::create(const char * name) {
		PointerRNA result;
		::MetaBall *retdata = BlendDataMetaBalls_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return MetaBall(result);
	}

	inline void BlendDataMetaBalls::remove(MetaBall& metaball, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMetaBalls_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &metaball.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataMetaBalls::tag(bool value) {
		BlendDataMetaBalls_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataFonts, rna_type)

	inline VectorFont BlendDataFonts::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::VFont *retdata = BlendDataFonts_load_func((::Main *) this->ptr.data, nullptr, filepath, check_existing);
		result = RNA_id_pointer_create((::ID *) retdata);
		return VectorFont(result);
	}

	inline void BlendDataFonts::remove(VectorFont& vfont, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataFonts_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &vfont.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataFonts::tag(bool value) {
		BlendDataFonts_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataTextures, rna_type)

	inline Texture BlendDataTextures::create(const char * name, int type) {
		PointerRNA result;
		::Tex *retdata = BlendDataTextures_new_func((::Main *) this->ptr.data, name, type);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Texture(result);
	}

	inline void BlendDataTextures::remove(Texture& texture, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataTextures_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &texture.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataTextures::tag(bool value) {
		BlendDataTextures_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataBrushes, rna_type)

	inline Brush BlendDataBrushes::create(const char * name, int mode) {
		PointerRNA result;
		::Brush *retdata = BlendDataBrushes_new_func((::Main *) this->ptr.data, name, mode);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Brush(result);
	}

	inline void BlendDataBrushes::remove(Brush& brush, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataBrushes_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &brush.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataBrushes::tag(bool value) {
		BlendDataBrushes_tag_func((::Main *) this->ptr.data, value);
	}

	inline void BlendDataBrushes::create_gpencil_data(Brush& brush) {
		BlendDataBrushes_create_gpencil_data_func((::Main *) this->ptr.data, (::PointerRNA *) &brush);
	}


	POINTER_PROPERTY(Struct, BlendDataWorlds, rna_type)

	inline World BlendDataWorlds::create(const char * name) {
		PointerRNA result;
		::World *retdata = BlendDataWorlds_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return World(result);
	}

	inline void BlendDataWorlds::remove(World& world, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataWorlds_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &world.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataWorlds::tag(bool value) {
		BlendDataWorlds_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataCollections, rna_type)

	inline Collection BlendDataCollections::create(const char * name) {
		PointerRNA result;
		::Collection *retdata = BlendDataCollections_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Collection(result);
	}

	inline void BlendDataCollections::remove(Collection& collection, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataCollections_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &collection.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataCollections::tag(bool value) {
		BlendDataCollections_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataTexts, rna_type)

	inline Text BlendDataTexts::create(const char * name) {
		PointerRNA result;
		::Text *retdata = BlendDataTexts_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Text(result);
	}

	inline void BlendDataTexts::remove(Text& text, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataTexts_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &text.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline Text BlendDataTexts::load(const char * filepath, bool internal) {
		PointerRNA result;
		::Text *retdata = BlendDataTexts_load_func((::Main *) this->ptr.data, nullptr, filepath, internal);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Text(result);
	}

	inline void BlendDataTexts::tag(bool value) {
		BlendDataTexts_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataSpeakers, rna_type)

	inline Speaker BlendDataSpeakers::create(const char * name) {
		PointerRNA result;
		::Speaker *retdata = BlendDataSpeakers_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Speaker(result);
	}

	inline void BlendDataSpeakers::remove(Speaker& speaker, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataSpeakers_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &speaker.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataSpeakers::tag(bool value) {
		BlendDataSpeakers_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataSounds, rna_type)

	inline Sound BlendDataSounds::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::bSound *retdata = BlendDataSounds_load_func((::Main *) this->ptr.data, filepath, check_existing);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Sound(result);
	}

	inline void BlendDataSounds::remove(Sound& sound, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataSounds_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &sound.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataSounds::tag(bool value) {
		BlendDataSounds_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataArmatures, rna_type)

	inline Armature BlendDataArmatures::create(const char * name) {
		PointerRNA result;
		::bArmature *retdata = BlendDataArmatures_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Armature(result);
	}

	inline void BlendDataArmatures::remove(Armature& armature, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataArmatures_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &armature.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataArmatures::tag(bool value) {
		BlendDataArmatures_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataActions, rna_type)

	inline Action BlendDataActions::create(const char * name) {
		PointerRNA result;
		::bAction *retdata = BlendDataActions_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Action(result);
	}

	inline void BlendDataActions::remove(Action& action, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataActions_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &action.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataActions::tag(bool value) {
		BlendDataActions_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataParticles, rna_type)

	inline ParticleSettings BlendDataParticles::create(const char * name) {
		PointerRNA result;
		::ParticleSettings *retdata = BlendDataParticles_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return ParticleSettings(result);
	}

	inline void BlendDataParticles::remove(ParticleSettings& particle, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataParticles_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &particle.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataParticles::tag(bool value) {
		BlendDataParticles_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataPalettes, rna_type)

	inline Palette BlendDataPalettes::create(const char * name) {
		PointerRNA result;
		::Palette *retdata = BlendDataPalettes_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Palette(result);
	}

	inline void BlendDataPalettes::remove(Palette& palette, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataPalettes_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &palette.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataPalettes::tag(bool value) {
		BlendDataPalettes_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataGreasePencils, rna_type)

	inline void BlendDataGreasePencils::tag(bool value) {
		BlendDataGreasePencils_tag_func((::Main *) this->ptr.data, value);
	}

	inline GreasePencil BlendDataGreasePencils::create(const char * name) {
		PointerRNA result;
		::bGPdata *retdata = BlendDataGreasePencils_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return GreasePencil(result);
	}

	inline void BlendDataGreasePencils::remove(GreasePencil& grease_pencil, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataGreasePencils_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &grease_pencil.ptr, do_unlink, do_id_user, do_ui_user);
	}


	POINTER_PROPERTY(Struct, BlendDataGreasePencilsV3, rna_type)


	POINTER_PROPERTY(Struct, BlendDataMovieClips, rna_type)

	inline void BlendDataMovieClips::tag(bool value) {
		BlendDataMovieClips_tag_func((::Main *) this->ptr.data, value);
	}

	inline void BlendDataMovieClips::remove(MovieClip& clip, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMovieClips_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &clip.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline MovieClip BlendDataMovieClips::load(const char * filepath, bool check_existing) {
		PointerRNA result;
		::MovieClip *retdata = BlendDataMovieClips_load_func((::Main *) this->ptr.data, nullptr, filepath, check_existing);
		result = RNA_id_pointer_create((::ID *) retdata);
		return MovieClip(result);
	}


	POINTER_PROPERTY(Struct, BlendDataMasks, rna_type)

	inline void BlendDataMasks::tag(bool value) {
		BlendDataMasks_tag_func((::Main *) this->ptr.data, value);
	}

	inline Mask BlendDataMasks::create(const char * name) {
		PointerRNA result;
		::Mask *retdata = BlendDataMasks_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Mask(result);
	}

	inline void BlendDataMasks::remove(Mask& mask, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataMasks_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &mask.ptr, do_unlink, do_id_user, do_ui_user);
	}


	POINTER_PROPERTY(Struct, BlendDataLineStyles, rna_type)

	inline void BlendDataLineStyles::tag(bool value) {
		BlendDataLineStyles_tag_func((::Main *) this->ptr.data, value);
	}

	inline FreestyleLineStyle BlendDataLineStyles::create(const char * name) {
		PointerRNA result;
		::FreestyleLineStyle *retdata = BlendDataLineStyles_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return FreestyleLineStyle(result);
	}

	inline void BlendDataLineStyles::remove(FreestyleLineStyle& linestyle, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataLineStyles_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &linestyle.ptr, do_unlink, do_id_user, do_ui_user);
	}


	POINTER_PROPERTY(Struct, BlendDataCacheFiles, rna_type)

	inline void BlendDataCacheFiles::tag(bool value) {
		BlendDataCacheFiles_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataPaintCurves, rna_type)

	inline void BlendDataPaintCurves::tag(bool value) {
		BlendDataPaintCurves_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataWorkSpaces, rna_type)

	inline void BlendDataWorkSpaces::tag(bool value) {
		BlendDataWorkSpaces_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataProbes, rna_type)

	inline LightProbe BlendDataProbes::create(const char * name, int type) {
		PointerRNA result;
		::LightProbe *retdata = BlendDataProbes_new_func((::Main *) this->ptr.data, name, type);
		result = RNA_id_pointer_create((::ID *) retdata);
		return LightProbe(result);
	}

	inline void BlendDataProbes::remove(LightProbe& lightprobe, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataProbes_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &lightprobe.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataProbes::tag(bool value) {
		BlendDataProbes_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataHairCurves, rna_type)

	inline Curves BlendDataHairCurves::create(const char * name) {
		PointerRNA result;
		::Curves *retdata = BlendDataHairCurves_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Curves(result);
	}

	inline void BlendDataHairCurves::remove(Curves& curves, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataHairCurves_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &curves.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataHairCurves::tag(bool value) {
		BlendDataHairCurves_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataPointClouds, rna_type)

	inline PointCloud BlendDataPointClouds::create(const char * name) {
		PointerRNA result;
		::PointCloud *retdata = BlendDataPointClouds_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return PointCloud(result);
	}

	inline void BlendDataPointClouds::remove(PointCloud& pointcloud, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataPointClouds_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &pointcloud.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataPointClouds::tag(bool value) {
		BlendDataPointClouds_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, BlendDataVolumes, rna_type)

	inline Volume BlendDataVolumes::create(const char * name) {
		PointerRNA result;
		::Volume *retdata = BlendDataVolumes_new_func((::Main *) this->ptr.data, name);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Volume(result);
	}

	inline void BlendDataVolumes::remove(Volume& volume, bool do_unlink, bool do_id_user, bool do_ui_user) {
		BlendDataVolumes_remove_func((::Main *) this->ptr.data, nullptr, (::PointerRNA *) &volume.ptr, do_unlink, do_id_user, do_ui_user);
	}

	inline void BlendDataVolumes::tag(bool value) {
		BlendDataVolumes_tag_func((::Main *) this->ptr.data, value);
	}


	POINTER_PROPERTY(Struct, FluidDomainSettings, rna_type)
	POINTER_PROPERTY(EffectorWeights, FluidDomainSettings, effector_weights)
	POINTER_PROPERTY(Collection, FluidDomainSettings, effector_group)
	POINTER_PROPERTY(Collection, FluidDomainSettings, fluid_group)
	POINTER_PROPERTY(Collection, FluidDomainSettings, force_collection)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 32, density_grid)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 32, velocity_grid)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 32, flame_grid)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 32, color_grid)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 32, heat_grid)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 32, temperature_grid)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 3, start_point)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 3, cell_size)
	INT_ARRAY_PROPERTY(FluidDomainSettings, 3, domain_resolution)
	INT_PROPERTY(FluidDomainSettings, additional_res)
	INT_PROPERTY(FluidDomainSettings, adapt_margin)
	FLOAT_PROPERTY(FluidDomainSettings, adapt_threshold)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_adaptive_domain)
	INT_PROPERTY(FluidDomainSettings, resolution_max)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_collision_border_front)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_collision_border_back)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_collision_border_right)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_collision_border_left)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_collision_border_top)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_collision_border_bottom)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 3, gravity)
	ENUM_PROPERTY(domain_type_enum, FluidDomainSettings, domain_type)
	BOOLEAN_PROPERTY(FluidDomainSettings, delete_in_obstacle)
	FLOAT_PROPERTY(FluidDomainSettings, alpha)
	FLOAT_PROPERTY(FluidDomainSettings, beta)
	INT_PROPERTY(FluidDomainSettings, dissolve_speed)
	FLOAT_PROPERTY(FluidDomainSettings, vorticity)
	ENUM_PROPERTY(highres_sampling_enum, FluidDomainSettings, highres_sampling)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_dissolve_smoke)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_dissolve_smoke_log)
	FLOAT_PROPERTY(FluidDomainSettings, burning_rate)
	FLOAT_PROPERTY(FluidDomainSettings, flame_smoke)
	FLOAT_PROPERTY(FluidDomainSettings, flame_vorticity)
	FLOAT_PROPERTY(FluidDomainSettings, flame_ignition)
	FLOAT_PROPERTY(FluidDomainSettings, flame_max_temp)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 3, flame_smoke_color)
	FLOAT_PROPERTY(FluidDomainSettings, noise_strength)
	FLOAT_PROPERTY(FluidDomainSettings, noise_pos_scale)
	FLOAT_PROPERTY(FluidDomainSettings, noise_time_anim)
	INT_PROPERTY(FluidDomainSettings, noise_scale)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_noise)
	ENUM_PROPERTY(simulation_method_enum, FluidDomainSettings, simulation_method)
	FLOAT_PROPERTY(FluidDomainSettings, flip_ratio)
	FLOAT_PROPERTY(FluidDomainSettings, particle_randomness)
	INT_PROPERTY(FluidDomainSettings, particle_number)
	INT_PROPERTY(FluidDomainSettings, particle_min)
	INT_PROPERTY(FluidDomainSettings, particle_max)
	FLOAT_PROPERTY(FluidDomainSettings, particle_radius)
	FLOAT_PROPERTY(FluidDomainSettings, particle_band_width)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_flip_particles)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_fractions)
	FLOAT_PROPERTY(FluidDomainSettings, fractions_threshold)
	FLOAT_PROPERTY(FluidDomainSettings, fractions_distance)
	INT_PROPERTY(FluidDomainSettings, sys_particle_maximum)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_viscosity)
	FLOAT_PROPERTY(FluidDomainSettings, viscosity_value)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_diffusion)
	FLOAT_PROPERTY(FluidDomainSettings, surface_tension)
	FLOAT_PROPERTY(FluidDomainSettings, viscosity_base)
	INT_PROPERTY(FluidDomainSettings, viscosity_exponent)
	FLOAT_PROPERTY(FluidDomainSettings, mesh_concave_upper)
	FLOAT_PROPERTY(FluidDomainSettings, mesh_concave_lower)
	INT_PROPERTY(FluidDomainSettings, mesh_smoothen_pos)
	INT_PROPERTY(FluidDomainSettings, mesh_smoothen_neg)
	INT_PROPERTY(FluidDomainSettings, mesh_scale)
	ENUM_PROPERTY(mesh_generator_enum, FluidDomainSettings, mesh_generator)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_mesh)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_speed_vectors)
	FLOAT_PROPERTY(FluidDomainSettings, mesh_particle_radius)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_potential_min_wavecrest)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_potential_max_wavecrest)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_potential_min_trappedair)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_potential_max_trappedair)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_potential_min_energy)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_potential_max_energy)
	INT_PROPERTY(FluidDomainSettings, sndparticle_sampling_wavecrest)
	INT_PROPERTY(FluidDomainSettings, sndparticle_sampling_trappedair)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_bubble_buoyancy)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_bubble_drag)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_life_min)
	FLOAT_PROPERTY(FluidDomainSettings, sndparticle_life_max)
	ENUM_PROPERTY(sndparticle_boundary_enum, FluidDomainSettings, sndparticle_boundary)
	ENUM_PROPERTY(sndparticle_combined_export_enum, FluidDomainSettings, sndparticle_combined_export)
	INT_PROPERTY(FluidDomainSettings, sndparticle_potential_radius)
	INT_PROPERTY(FluidDomainSettings, sndparticle_update_radius)
	INT_PROPERTY(FluidDomainSettings, particle_scale)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_spray_particles)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_bubble_particles)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_foam_particles)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_tracer_particles)
	FLOAT_PROPERTY(FluidDomainSettings, guide_alpha)
	INT_PROPERTY(FluidDomainSettings, guide_beta)
	FLOAT_PROPERTY(FluidDomainSettings, guide_vel_factor)
	ENUM_PROPERTY(guide_source_enum, FluidDomainSettings, guide_source)
	POINTER_PROPERTY(Object, FluidDomainSettings, guide_parent)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_guide)
	INT_PROPERTY(FluidDomainSettings, cache_frame_start)
	INT_PROPERTY(FluidDomainSettings, cache_frame_end)
	INT_PROPERTY(FluidDomainSettings, cache_frame_offset)
	INT_PROPERTY(FluidDomainSettings, cache_frame_pause_data)
	INT_PROPERTY(FluidDomainSettings, cache_frame_pause_noise)
	INT_PROPERTY(FluidDomainSettings, cache_frame_pause_mesh)
	INT_PROPERTY(FluidDomainSettings, cache_frame_pause_particles)
	INT_PROPERTY(FluidDomainSettings, cache_frame_pause_guide)
	ENUM_PROPERTY(cache_mesh_format_enum, FluidDomainSettings, cache_mesh_format)
	ENUM_PROPERTY(cache_data_format_enum, FluidDomainSettings, cache_data_format)
	ENUM_PROPERTY(cache_particle_format_enum, FluidDomainSettings, cache_particle_format)
	ENUM_PROPERTY(cache_noise_format_enum, FluidDomainSettings, cache_noise_format)
	ENUM_PROPERTY(cache_type_enum, FluidDomainSettings, cache_type)
	BOOLEAN_PROPERTY(FluidDomainSettings, cache_resumable)
	STRING_PROPERTY(FluidDomainSettings, cache_directory)
	BOOLEAN_PROPERTY(FluidDomainSettings, is_cache_baking_data)
	BOOLEAN_PROPERTY(FluidDomainSettings, has_cache_baked_data)
	BOOLEAN_PROPERTY(FluidDomainSettings, is_cache_baking_noise)
	BOOLEAN_PROPERTY(FluidDomainSettings, has_cache_baked_noise)
	BOOLEAN_PROPERTY(FluidDomainSettings, is_cache_baking_mesh)
	BOOLEAN_PROPERTY(FluidDomainSettings, has_cache_baked_mesh)
	BOOLEAN_PROPERTY(FluidDomainSettings, is_cache_baking_particles)
	BOOLEAN_PROPERTY(FluidDomainSettings, has_cache_baked_particles)
	BOOLEAN_PROPERTY(FluidDomainSettings, is_cache_baking_guide)
	BOOLEAN_PROPERTY(FluidDomainSettings, has_cache_baked_guide)
	BOOLEAN_PROPERTY(FluidDomainSettings, is_cache_baking_any)
	BOOLEAN_PROPERTY(FluidDomainSettings, has_cache_baked_any)
	BOOLEAN_PROPERTY(FluidDomainSettings, export_manta_script)
	ENUM_PROPERTY(openvdb_cache_compress_type_enum, FluidDomainSettings, openvdb_cache_compress_type)
	ENUM_PROPERTY(openvdb_data_depth_enum, FluidDomainSettings, openvdb_data_depth)
	FLOAT_PROPERTY(FluidDomainSettings, time_scale)
	FLOAT_PROPERTY(FluidDomainSettings, cfl_condition)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_adaptive_timesteps)
	INT_PROPERTY(FluidDomainSettings, timesteps_min)
	INT_PROPERTY(FluidDomainSettings, timesteps_max)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_slice)
	ENUM_PROPERTY(slice_axis_enum, FluidDomainSettings, slice_axis)
	FLOAT_PROPERTY(FluidDomainSettings, slice_per_voxel)
	FLOAT_PROPERTY(FluidDomainSettings, slice_depth)
	FLOAT_PROPERTY(FluidDomainSettings, display_thickness)
	ENUM_PROPERTY(display_interpolation_enum, FluidDomainSettings, display_interpolation)
	BOOLEAN_PROPERTY(FluidDomainSettings, show_gridlines)
	BOOLEAN_PROPERTY(FluidDomainSettings, show_velocity)
	ENUM_PROPERTY(vector_display_type_enum, FluidDomainSettings, vector_display_type)
	ENUM_PROPERTY(vector_field_enum, FluidDomainSettings, vector_field)
	BOOLEAN_PROPERTY(FluidDomainSettings, vector_scale_with_magnitude)
	BOOLEAN_PROPERTY(FluidDomainSettings, vector_show_mac_x)
	BOOLEAN_PROPERTY(FluidDomainSettings, vector_show_mac_y)
	BOOLEAN_PROPERTY(FluidDomainSettings, vector_show_mac_z)
	FLOAT_PROPERTY(FluidDomainSettings, vector_scale)
	BOOLEAN_PROPERTY(FluidDomainSettings, use_color_ramp)
	ENUM_PROPERTY(color_ramp_field_enum, FluidDomainSettings, color_ramp_field)
	FLOAT_PROPERTY(FluidDomainSettings, color_ramp_field_scale)
	POINTER_PROPERTY(ColorRamp, FluidDomainSettings, color_ramp)
	FLOAT_PROPERTY(FluidDomainSettings, clipping)
	ENUM_PROPERTY(gridlines_color_field_enum, FluidDomainSettings, gridlines_color_field)
	FLOAT_PROPERTY(FluidDomainSettings, gridlines_lower_bound)
	FLOAT_PROPERTY(FluidDomainSettings, gridlines_upper_bound)
	FLOAT_ARRAY_PROPERTY(FluidDomainSettings, 4, gridlines_range_color)
	ENUM_PROPERTY(gridlines_cell_filter_enum, FluidDomainSettings, gridlines_cell_filter)
	FLOAT_PROPERTY(FluidDomainSettings, velocity_scale)


	POINTER_PROPERTY(Struct, FluidFlowSettings, rna_type)
	FLOAT_PROPERTY(FluidFlowSettings, density)
	FLOAT_ARRAY_PROPERTY(FluidFlowSettings, 3, smoke_color)
	FLOAT_PROPERTY(FluidFlowSettings, fuel_amount)
	FLOAT_PROPERTY(FluidFlowSettings, temperature)
	POINTER_PROPERTY(ParticleSystem, FluidFlowSettings, particle_system)
	ENUM_PROPERTY(flow_type_enum, FluidFlowSettings, flow_type)
	ENUM_PROPERTY(flow_behavior_enum, FluidFlowSettings, flow_behavior)
	ENUM_PROPERTY(flow_source_enum, FluidFlowSettings, flow_source)
	BOOLEAN_PROPERTY(FluidFlowSettings, use_absolute)
	BOOLEAN_PROPERTY(FluidFlowSettings, use_initial_velocity)
	FLOAT_PROPERTY(FluidFlowSettings, velocity_factor)
	FLOAT_PROPERTY(FluidFlowSettings, velocity_normal)
	FLOAT_PROPERTY(FluidFlowSettings, velocity_random)
	FLOAT_ARRAY_PROPERTY(FluidFlowSettings, 3, velocity_coord)
	FLOAT_PROPERTY(FluidFlowSettings, volume_density)
	FLOAT_PROPERTY(FluidFlowSettings, surface_distance)
	BOOLEAN_PROPERTY(FluidFlowSettings, use_plane_init)
	FLOAT_PROPERTY(FluidFlowSettings, particle_size)
	BOOLEAN_PROPERTY(FluidFlowSettings, use_particle_size)
	BOOLEAN_PROPERTY(FluidFlowSettings, use_inflow)
	INT_PROPERTY(FluidFlowSettings, subframes)
	STRING_PROPERTY(FluidFlowSettings, density_vertex_group)
	BOOLEAN_PROPERTY(FluidFlowSettings, use_texture)
	ENUM_PROPERTY(texture_map_type_enum, FluidFlowSettings, texture_map_type)
	STRING_PROPERTY(FluidFlowSettings, uv_layer)
	POINTER_PROPERTY(Texture, FluidFlowSettings, noise_texture)
	FLOAT_PROPERTY(FluidFlowSettings, texture_size)
	FLOAT_PROPERTY(FluidFlowSettings, texture_offset)


	POINTER_PROPERTY(Struct, FluidEffectorSettings, rna_type)
	ENUM_PROPERTY(effector_type_enum, FluidEffectorSettings, effector_type)
	FLOAT_PROPERTY(FluidEffectorSettings, surface_distance)
	BOOLEAN_PROPERTY(FluidEffectorSettings, use_plane_init)
	FLOAT_PROPERTY(FluidEffectorSettings, velocity_factor)
	ENUM_PROPERTY(guide_mode_enum, FluidEffectorSettings, guide_mode)
	BOOLEAN_PROPERTY(FluidEffectorSettings, use_effector)
	INT_PROPERTY(FluidEffectorSettings, subframes)


	ENUM_PROPERTY(surface_render_method_enum, Material, surface_render_method)
	ENUM_PROPERTY(blend_method_enum, Material, blend_method)
	ENUM_PROPERTY(shadow_method_enum, Material, shadow_method)
	FLOAT_PROPERTY(Material, alpha_threshold)
	BOOLEAN_PROPERTY(Material, show_transparent_back)
	BOOLEAN_PROPERTY(Material, use_backface_culling)
	BOOLEAN_PROPERTY(Material, use_backface_culling_shadow)
	BOOLEAN_PROPERTY(Material, use_transparent_shadow)
	BOOLEAN_PROPERTY(Material, lightprobe_volume_single_sided)
	BOOLEAN_PROPERTY(Material, use_screen_refraction)
	BOOLEAN_PROPERTY(Material, use_sss_translucency)
	FLOAT_PROPERTY(Material, refraction_depth)
	ENUM_PROPERTY(volume_intersection_method_enum, Material, volume_intersection_method)
	FLOAT_PROPERTY(Material, max_vertex_displacement)
	ENUM_PROPERTY(preview_render_type_enum, Material, preview_render_type)
	BOOLEAN_PROPERTY(Material, use_preview_world)
	INT_PROPERTY(Material, pass_index)
	POINTER_PROPERTY(NodeTree, Material, node_tree)
	BOOLEAN_PROPERTY(Material, use_nodes)
	POINTER_PROPERTY(AnimData, Material, animation_data)


	INT_PROPERTY(Material, paint_active_slot)
	INT_PROPERTY(Material, paint_clone_slot)
	FLOAT_ARRAY_PROPERTY(Material, 4, diffuse_color)
	FLOAT_ARRAY_PROPERTY(Material, 3, specular_color)
	FLOAT_PROPERTY(Material, roughness)
	FLOAT_PROPERTY(Material, specular_intensity)
	FLOAT_PROPERTY(Material, metallic)
	FLOAT_ARRAY_PROPERTY(Material, 4, line_color)
	INT_PROPERTY(Material, line_priority)
	POINTER_PROPERTY(MaterialGPencilStyle, Material, grease_pencil)
	BOOLEAN_PROPERTY(Material, is_grease_pencil)
	POINTER_PROPERTY(MaterialLineArt, Material, lineart)


	POINTER_PROPERTY(Struct, TexPaintSlot, rna_type)
	STRING_PROPERTY(TexPaintSlot, name)
	INT_PROPERTY(TexPaintSlot, icon_value)
	STRING_PROPERTY(TexPaintSlot, uv_layer)
	BOOLEAN_PROPERTY(TexPaintSlot, is_valid)


	POINTER_PROPERTY(Struct, MaterialGPencilStyle, rna_type)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 4, color)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 4, fill_color)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 4, mix_color)
	FLOAT_PROPERTY(MaterialGPencilStyle, mix_factor)
	FLOAT_PROPERTY(MaterialGPencilStyle, mix_stroke_factor)
	FLOAT_PROPERTY(MaterialGPencilStyle, texture_angle)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 2, texture_scale)
	FLOAT_ARRAY_PROPERTY(MaterialGPencilStyle, 2, texture_offset)
	FLOAT_PROPERTY(MaterialGPencilStyle, pixel_size)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, hide)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, lock)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, ghost)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, texture_clamp)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, flip)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, use_overlap_strokes)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, use_stroke_holdout)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, use_fill_holdout)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, show_stroke)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, show_fill)
	ENUM_PROPERTY(alignment_mode_enum, MaterialGPencilStyle, alignment_mode)
	FLOAT_PROPERTY(MaterialGPencilStyle, alignment_rotation)
	INT_PROPERTY(MaterialGPencilStyle, pass_index)
	ENUM_PROPERTY(mode_enum, MaterialGPencilStyle, mode)
	ENUM_PROPERTY(stroke_style_enum, MaterialGPencilStyle, stroke_style)
	POINTER_PROPERTY(Image, MaterialGPencilStyle, stroke_image)
	ENUM_PROPERTY(fill_style_enum, MaterialGPencilStyle, fill_style)
	ENUM_PROPERTY(gradient_type_enum, MaterialGPencilStyle, gradient_type)
	POINTER_PROPERTY(Image, MaterialGPencilStyle, fill_image)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, is_stroke_visible)
	BOOLEAN_PROPERTY(MaterialGPencilStyle, is_fill_visible)


	POINTER_PROPERTY(Struct, MaterialLineArt, rna_type)
	BOOLEAN_PROPERTY(MaterialLineArt, use_material_mask)
	BOOLEAN_ARRAY_PROPERTY(MaterialLineArt, 8, use_material_mask_bits)
	INT_PROPERTY(MaterialLineArt, mat_occlusion)
	INT_PROPERTY(MaterialLineArt, intersection_priority)
	BOOLEAN_PROPERTY(MaterialLineArt, use_intersection_priority_override)






	ENUM_PROPERTY(normals_domain_enum, Mesh, normals_domain)





	POINTER_PROPERTY(Mesh, Mesh, texture_mesh)

	POINTER_PROPERTY(MeshUVLoopLayer, Mesh, uv_layer_clone)
	INT_PROPERTY(Mesh, uv_layer_clone_index)
	POINTER_PROPERTY(MeshUVLoopLayer, Mesh, uv_layer_stencil)
	INT_PROPERTY(Mesh, uv_layer_stencil_index)





	FLOAT_PROPERTY(Mesh, remesh_voxel_size)
	FLOAT_PROPERTY(Mesh, remesh_voxel_adaptivity)
	BOOLEAN_PROPERTY(Mesh, use_remesh_fix_poles)
	BOOLEAN_PROPERTY(Mesh, use_remesh_preserve_volume)
	BOOLEAN_PROPERTY(Mesh, use_remesh_preserve_paint_mask)
	BOOLEAN_PROPERTY(Mesh, use_remesh_preserve_sculpt_face_sets)
	BOOLEAN_PROPERTY(Mesh, use_remesh_preserve_vertex_colors)
	ENUM_PROPERTY(remesh_mode_enum, Mesh, remesh_mode)
	BOOLEAN_PROPERTY(Mesh, use_mirror_x)
	BOOLEAN_PROPERTY(Mesh, use_mirror_y)
	BOOLEAN_PROPERTY(Mesh, use_mirror_z)
	BOOLEAN_PROPERTY(Mesh, use_mirror_vertex_groups)
	BOOLEAN_PROPERTY(Mesh, has_custom_normals)
	POINTER_PROPERTY(Mesh, Mesh, texco_mesh)
	POINTER_PROPERTY(Key, Mesh, shape_keys)
	BOOLEAN_PROPERTY(Mesh, use_auto_texspace)
	BOOLEAN_PROPERTY(Mesh, use_mirror_topology)
	BOOLEAN_PROPERTY(Mesh, use_paint_mask)
	BOOLEAN_PROPERTY(Mesh, use_paint_mask_vertex)
	INT_PROPERTY(Mesh, total_vert_sel)
	INT_PROPERTY(Mesh, total_edge_sel)
	INT_PROPERTY(Mesh, total_face_sel)
	BOOLEAN_PROPERTY(Mesh, is_editmode)
	POINTER_PROPERTY(AnimData, Mesh, animation_data)
	BOOLEAN_PROPERTY(Mesh, auto_texspace)
	FLOAT_ARRAY_PROPERTY(Mesh, 3, texspace_location)
	FLOAT_ARRAY_PROPERTY(Mesh, 3, texspace_size)


	inline void Mesh::transform(float matrix[16], bool shape_keys) {
		Mesh_transform_func((::Mesh *) this->ptr.data, matrix, shape_keys);
	}

	inline void Mesh::flip_normals() {
		Mesh_flip_normals_func((::Mesh *) this->ptr.data);
	}

	inline void Mesh::set_sharp_from_angle(float angle) {
		Mesh_set_sharp_from_angle_func((::Mesh *) this->ptr.data, angle);
	}

	inline void Mesh::split_faces() {
		Mesh_split_faces_func((::Mesh *) this->ptr.data);
	}

	inline void Mesh::calc_tangents(const char * uvmap) {
		Mesh_calc_tangents_func((::Mesh *) this->ptr.data, nullptr, uvmap);
	}

	inline void Mesh::free_tangents() {
		Mesh_free_tangents_func((::Mesh *) this->ptr.data);
	}

	inline void Mesh::calc_loop_triangles() {
		Mesh_calc_loop_triangles_func((::Mesh *) this->ptr.data);
	}

	inline void Mesh::calc_smooth_groups(bool use_bitflags, int *poly_groups_len, int **poly_groups, int *groups) {
		Mesh_calc_smooth_groups_func((::Mesh *) this->ptr.data, use_bitflags, poly_groups_len, poly_groups, groups);
	}

	inline void Mesh::normals_split_custom_set(int normals_len, float *normals) {
		Mesh_normals_split_custom_set_func((::Mesh *) this->ptr.data, nullptr, normals_len, normals);
	}

	inline void Mesh::normals_split_custom_set_from_vertices(int normals_len, float *normals) {
		Mesh_normals_split_custom_set_from_vertices_func((::Mesh *) this->ptr.data, nullptr, normals_len, normals);
	}

	inline void Mesh::update(Context C, bool calc_edges, bool calc_edges_loose) {
		Mesh_update_func((::Mesh *) this->ptr.data, (::bContext *) C.ptr.data, calc_edges, calc_edges_loose);
	}

	inline void Mesh::update_gpu_tag() {
		Mesh_update_gpu_tag_func((::Mesh *) this->ptr.data);
	}

	inline const char * Mesh::unit_test_compare(Mesh& mesh, float threshold) {
		return Mesh_unit_test_compare_func((::Mesh *) this->ptr.data, (::Mesh *) mesh.ptr.data, threshold);
	}

	inline void Mesh::clear_geometry() {
		Mesh_clear_geometry_func((::Mesh *) this->ptr.data);
	}

	inline bool Mesh::validate(bool verbose, bool clean_customdata) {
		return Mesh_validate_func((::Mesh *) this->ptr.data, verbose, clean_customdata);
	}

	inline bool Mesh::validate_material_indices() {
		return Mesh_validate_material_indices_func((::Mesh *) this->ptr.data);
	}

	inline void Mesh::count_selected_items(int result[3]) {
		Mesh_count_selected_items_func((::Mesh *) this->ptr.data, result);
	}


	POINTER_PROPERTY(Struct, MeshVertices, rna_type)

	inline void MeshVertices::add(int count) {
		MeshVertices_add_func((::Mesh *) this->ptr.data, nullptr, count);
	}


	POINTER_PROPERTY(Struct, MeshEdges, rna_type)

	inline void MeshEdges::add(int count) {
		MeshEdges_add_func((::Mesh *) this->ptr.data, nullptr, count);
	}


	POINTER_PROPERTY(Struct, MeshLoops, rna_type)

	inline void MeshLoops::add(int count) {
		MeshLoops_add_func((::Mesh *) this->ptr.data, nullptr, count);
	}


	POINTER_PROPERTY(Struct, MeshPolygons, rna_type)
	INT_PROPERTY(MeshPolygons, active)

	inline void MeshPolygons::add(int count) {
		MeshPolygons_add_func((::Mesh *) this->ptr.data, nullptr, count);
	}


	POINTER_PROPERTY(Struct, MeshNormalValue, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshNormalValue, 3, vector)


	POINTER_PROPERTY(Struct, MeshLoopTriangles, rna_type)


	POINTER_PROPERTY(Struct, ReadOnlyInteger, rna_type)
	INT_PROPERTY(ReadOnlyInteger, value)


	POINTER_PROPERTY(Struct, UVLoopLayers, rna_type)
	POINTER_PROPERTY(MeshUVLoopLayer, UVLoopLayers, active)
	INT_PROPERTY(UVLoopLayers, active_index)

	inline MeshUVLoopLayer UVLoopLayers::create(const char * name, bool do_init) {
		PointerRNA result;
		result = UVLoopLayers_new_func((::Mesh *) this->ptr.data, nullptr, name, do_init);
		return MeshUVLoopLayer(result);
	}

	inline void UVLoopLayers::remove(MeshUVLoopLayer& layer) {
		UVLoopLayers_remove_func((::Mesh *) this->ptr.data, nullptr, (::CustomDataLayer *) layer.ptr.data);
	}


	POINTER_PROPERTY(Struct, LoopColors, rna_type)
	POINTER_PROPERTY(MeshLoopColorLayer, LoopColors, active)
	INT_PROPERTY(LoopColors, active_index)

	inline MeshLoopColorLayer LoopColors::create(const char * name, bool do_init) {
		PointerRNA result;
		result = LoopColors_new_func((::Mesh *) this->ptr.data, nullptr, name, do_init);
		return MeshLoopColorLayer(result);
	}

	inline void LoopColors::remove(MeshLoopColorLayer& layer) {
		LoopColors_remove_func((::Mesh *) this->ptr.data, nullptr, (::CustomDataLayer *) layer.ptr.data);
	}


	POINTER_PROPERTY(Struct, MeshSkinVertexLayer, rna_type)
	STRING_PROPERTY(MeshSkinVertexLayer, name)



	POINTER_PROPERTY(Struct, MeshSkinVertex, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshSkinVertex, 2, radius)
	BOOLEAN_PROPERTY(MeshSkinVertex, use_root)
	BOOLEAN_PROPERTY(MeshSkinVertex, use_loose)


	POINTER_PROPERTY(Struct, MeshPaintMaskLayer, rna_type)



	POINTER_PROPERTY(Struct, MeshPaintMaskProperty, rna_type)
	FLOAT_PROPERTY(MeshPaintMaskProperty, value)


	POINTER_PROPERTY(Struct, MeshVertex, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshVertex, 3, co)
	FLOAT_ARRAY_PROPERTY(MeshVertex, 3, normal)
	BOOLEAN_PROPERTY(MeshVertex, select)
	BOOLEAN_PROPERTY(MeshVertex, hide)

	INT_PROPERTY(MeshVertex, index)
	FLOAT_ARRAY_PROPERTY(MeshVertex, 3, undeformed_co)


	POINTER_PROPERTY(Struct, VertexGroupElement, rna_type)
	INT_PROPERTY(VertexGroupElement, group)
	FLOAT_PROPERTY(VertexGroupElement, weight)


	POINTER_PROPERTY(Struct, MeshEdge, rna_type)
	INT_ARRAY_PROPERTY(MeshEdge, 2, vertices)
	BOOLEAN_PROPERTY(MeshEdge, select)
	BOOLEAN_PROPERTY(MeshEdge, hide)
	BOOLEAN_PROPERTY(MeshEdge, use_seam)
	BOOLEAN_PROPERTY(MeshEdge, use_edge_sharp)
	BOOLEAN_PROPERTY(MeshEdge, is_loose)
	BOOLEAN_PROPERTY(MeshEdge, use_freestyle_mark)
	INT_PROPERTY(MeshEdge, index)


	POINTER_PROPERTY(Struct, MeshLoopTriangle, rna_type)
	INT_ARRAY_PROPERTY(MeshLoopTriangle, 3, vertices)
	INT_ARRAY_PROPERTY(MeshLoopTriangle, 3, loops)
	INT_PROPERTY(MeshLoopTriangle, polygon_index)
	FLOAT_ARRAY_PROPERTY(MeshLoopTriangle, 3, normal)
	FLOAT_ARRAY_PROPERTY(MeshLoopTriangle, 9, split_normals)
	FLOAT_PROPERTY(MeshLoopTriangle, area)
	INT_PROPERTY(MeshLoopTriangle, index)
	INT_PROPERTY(MeshLoopTriangle, material_index)
	BOOLEAN_PROPERTY(MeshLoopTriangle, use_smooth)


	POINTER_PROPERTY(Struct, MeshLoop, rna_type)
	INT_PROPERTY(MeshLoop, vertex_index)
	INT_PROPERTY(MeshLoop, edge_index)
	INT_PROPERTY(MeshLoop, index)
	FLOAT_ARRAY_PROPERTY(MeshLoop, 3, normal)
	FLOAT_ARRAY_PROPERTY(MeshLoop, 3, tangent)
	FLOAT_PROPERTY(MeshLoop, bitangent_sign)
	FLOAT_ARRAY_PROPERTY(MeshLoop, 3, bitangent)


	POINTER_PROPERTY(Struct, MeshPolygon, rna_type)
	INT_ARRAY_PROPERTY(MeshPolygon, 3, vertices)
	INT_PROPERTY(MeshPolygon, loop_start)
	INT_PROPERTY(MeshPolygon, loop_total)
	INT_PROPERTY(MeshPolygon, material_index)
	BOOLEAN_PROPERTY(MeshPolygon, select)
	BOOLEAN_PROPERTY(MeshPolygon, hide)
	BOOLEAN_PROPERTY(MeshPolygon, use_smooth)
	BOOLEAN_PROPERTY(MeshPolygon, use_freestyle_mark)
	FLOAT_ARRAY_PROPERTY(MeshPolygon, 3, normal)
	FLOAT_ARRAY_PROPERTY(MeshPolygon, 3, center)
	FLOAT_PROPERTY(MeshPolygon, area)
	INT_PROPERTY(MeshPolygon, index)

	inline void MeshPolygon::flip() {
		MeshPolygon_flip_func((::ID *) ptr.owner_id, (::MIntProperty *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, MeshUVLoopLayer, rna_type)

	STRING_PROPERTY(MeshUVLoopLayer, name)
	BOOLEAN_PROPERTY(MeshUVLoopLayer, active)
	BOOLEAN_PROPERTY(MeshUVLoopLayer, active_render)
	BOOLEAN_PROPERTY(MeshUVLoopLayer, active_clone)






	POINTER_PROPERTY(Struct, MeshUVLoop, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshUVLoop, 2, uv)
	BOOLEAN_PROPERTY(MeshUVLoop, pin_uv)
	BOOLEAN_PROPERTY(MeshUVLoop, select)
	BOOLEAN_PROPERTY(MeshUVLoop, select_edge)


	POINTER_PROPERTY(Struct, MeshLoopColorLayer, rna_type)
	STRING_PROPERTY(MeshLoopColorLayer, name)
	BOOLEAN_PROPERTY(MeshLoopColorLayer, active)
	BOOLEAN_PROPERTY(MeshLoopColorLayer, active_render)



	POINTER_PROPERTY(Struct, MeshLoopColor, rna_type)
	FLOAT_ARRAY_PROPERTY(MeshLoopColor, 4, color)


	POINTER_PROPERTY(Struct, MetaElement, rna_type)
	ENUM_PROPERTY(type_enum, MetaElement, type)
	FLOAT_ARRAY_PROPERTY(MetaElement, 3, co)
	FLOAT_ARRAY_PROPERTY(MetaElement, 4, rotation)
	FLOAT_PROPERTY(MetaElement, radius)
	FLOAT_PROPERTY(MetaElement, size_x)
	FLOAT_PROPERTY(MetaElement, size_y)
	FLOAT_PROPERTY(MetaElement, size_z)
	FLOAT_PROPERTY(MetaElement, stiffness)
	BOOLEAN_PROPERTY(MetaElement, use_negative)
	BOOLEAN_PROPERTY(MetaElement, use_scale_stiffness)
	BOOLEAN_PROPERTY(MetaElement, select)
	BOOLEAN_PROPERTY(MetaElement, hide)



	ENUM_PROPERTY(update_method_enum, MetaBall, update_method)
	FLOAT_PROPERTY(MetaBall, resolution)
	FLOAT_PROPERTY(MetaBall, render_resolution)
	FLOAT_PROPERTY(MetaBall, threshold)
	BOOLEAN_PROPERTY(MetaBall, use_auto_texspace)
	FLOAT_ARRAY_PROPERTY(MetaBall, 3, texspace_location)
	FLOAT_ARRAY_PROPERTY(MetaBall, 3, texspace_size)

	BOOLEAN_PROPERTY(MetaBall, is_editmode)
	POINTER_PROPERTY(AnimData, MetaBall, animation_data)

	inline void MetaBall::transform(float matrix[16]) {
		MetaBall_transform_func((::MetaBall *) this->ptr.data, matrix);
	}

	inline void MetaBall::update_gpu_tag() {
		MetaBall_update_gpu_tag_func((::MetaBall *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, MetaBallElements, rna_type)
	POINTER_PROPERTY(MetaElement, MetaBallElements, active)

	inline MetaElement MetaBallElements::create(int type) {
		PointerRNA result;
		::MetaElem *retdata = MetaBallElements_new_func((::MetaBall *) this->ptr.data, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MetaElement, retdata);
		return MetaElement(result);
	}

	inline void MetaBallElements::remove(MetaElement& element) {
		MetaBallElements_remove_func((::MetaBall *) this->ptr.data, nullptr, (::PointerRNA *) &element.ptr);
	}

	inline void MetaBallElements::clear() {
		MetaBallElements_clear_func((::MetaBall *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, Modifier, rna_type)
	STRING_PROPERTY(Modifier, name)
	ENUM_PROPERTY(type_enum, Modifier, type)
	BOOLEAN_PROPERTY(Modifier, show_viewport)
	BOOLEAN_PROPERTY(Modifier, show_render)
	BOOLEAN_PROPERTY(Modifier, show_in_editmode)
	BOOLEAN_PROPERTY(Modifier, show_on_cage)
	BOOLEAN_PROPERTY(Modifier, show_expanded)
	BOOLEAN_PROPERTY(Modifier, is_active)
	BOOLEAN_PROPERTY(Modifier, is_override_data)
	BOOLEAN_PROPERTY(Modifier, use_apply_on_spline)
	FLOAT_PROPERTY(Modifier, execution_time)


	ENUM_PROPERTY(uv_smooth_enum, SubsurfModifier, uv_smooth)
	INT_PROPERTY(SubsurfModifier, quality)
	ENUM_PROPERTY(boundary_smooth_enum, SubsurfModifier, boundary_smooth)
	ENUM_PROPERTY(subdivision_type_enum, SubsurfModifier, subdivision_type)
	INT_PROPERTY(SubsurfModifier, levels)
	INT_PROPERTY(SubsurfModifier, render_levels)
	BOOLEAN_PROPERTY(SubsurfModifier, show_only_control_edges)
	BOOLEAN_PROPERTY(SubsurfModifier, use_creases)
	BOOLEAN_PROPERTY(SubsurfModifier, use_custom_normals)
	BOOLEAN_PROPERTY(SubsurfModifier, use_limit_surface)


	POINTER_PROPERTY(Object, LatticeModifier, object)
	STRING_PROPERTY(LatticeModifier, vertex_group)
	BOOLEAN_PROPERTY(LatticeModifier, invert_vertex_group)
	FLOAT_PROPERTY(LatticeModifier, strength)


	POINTER_PROPERTY(Object, CurveModifier, object)
	STRING_PROPERTY(CurveModifier, vertex_group)
	BOOLEAN_PROPERTY(CurveModifier, invert_vertex_group)
	ENUM_PROPERTY(deform_axis_enum, CurveModifier, deform_axis)


	FLOAT_PROPERTY(BuildModifier, frame_start)
	FLOAT_PROPERTY(BuildModifier, frame_duration)
	BOOLEAN_PROPERTY(BuildModifier, use_reverse)
	BOOLEAN_PROPERTY(BuildModifier, use_random_order)
	INT_PROPERTY(BuildModifier, seed)


	BOOLEAN_ARRAY_PROPERTY(MirrorModifier, 3, use_axis)
	BOOLEAN_ARRAY_PROPERTY(MirrorModifier, 3, use_bisect_axis)
	BOOLEAN_ARRAY_PROPERTY(MirrorModifier, 3, use_bisect_flip_axis)
	BOOLEAN_PROPERTY(MirrorModifier, use_clip)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_vertex_groups)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_merge)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_u)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_v)
	BOOLEAN_PROPERTY(MirrorModifier, use_mirror_udim)
	FLOAT_PROPERTY(MirrorModifier, mirror_offset_u)
	FLOAT_PROPERTY(MirrorModifier, mirror_offset_v)
	FLOAT_PROPERTY(MirrorModifier, offset_u)
	FLOAT_PROPERTY(MirrorModifier, offset_v)
	FLOAT_PROPERTY(MirrorModifier, merge_threshold)
	FLOAT_PROPERTY(MirrorModifier, bisect_threshold)
	POINTER_PROPERTY(Object, MirrorModifier, mirror_object)


	ENUM_PROPERTY(decimate_type_enum, DecimateModifier, decimate_type)
	FLOAT_PROPERTY(DecimateModifier, ratio)
	INT_PROPERTY(DecimateModifier, iterations)
	FLOAT_PROPERTY(DecimateModifier, angle_limit)
	STRING_PROPERTY(DecimateModifier, vertex_group)
	BOOLEAN_PROPERTY(DecimateModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(DecimateModifier, use_collapse_triangulate)
	BOOLEAN_PROPERTY(DecimateModifier, use_symmetry)
	ENUM_PROPERTY(symmetry_axis_enum, DecimateModifier, symmetry_axis)
	FLOAT_PROPERTY(DecimateModifier, vertex_group_factor)
	BOOLEAN_PROPERTY(DecimateModifier, use_dissolve_boundaries)
	ENUM_PROPERTY(delimit_enum, DecimateModifier, delimit)
	INT_PROPERTY(DecimateModifier, face_count)


	BOOLEAN_PROPERTY(WaveModifier, use_x)
	BOOLEAN_PROPERTY(WaveModifier, use_y)
	BOOLEAN_PROPERTY(WaveModifier, use_cyclic)
	BOOLEAN_PROPERTY(WaveModifier, use_normal)
	BOOLEAN_PROPERTY(WaveModifier, use_normal_x)
	BOOLEAN_PROPERTY(WaveModifier, use_normal_y)
	BOOLEAN_PROPERTY(WaveModifier, use_normal_z)
	FLOAT_PROPERTY(WaveModifier, time_offset)
	FLOAT_PROPERTY(WaveModifier, lifetime)
	FLOAT_PROPERTY(WaveModifier, damping_time)
	FLOAT_PROPERTY(WaveModifier, falloff_radius)
	FLOAT_PROPERTY(WaveModifier, start_position_x)
	FLOAT_PROPERTY(WaveModifier, start_position_y)
	POINTER_PROPERTY(Object, WaveModifier, start_position_object)
	STRING_PROPERTY(WaveModifier, vertex_group)
	BOOLEAN_PROPERTY(WaveModifier, invert_vertex_group)
	FLOAT_PROPERTY(WaveModifier, speed)
	FLOAT_PROPERTY(WaveModifier, height)
	FLOAT_PROPERTY(WaveModifier, width)
	FLOAT_PROPERTY(WaveModifier, narrowness)
	POINTER_PROPERTY(Texture, WaveModifier, texture)
	ENUM_PROPERTY(texture_coords_enum, WaveModifier, texture_coords)
	STRING_PROPERTY(WaveModifier, uv_layer)
	POINTER_PROPERTY(Object, WaveModifier, texture_coords_object)
	STRING_PROPERTY(WaveModifier, texture_coords_bone)


	POINTER_PROPERTY(Object, ArmatureModifier, object)
	BOOLEAN_PROPERTY(ArmatureModifier, use_bone_envelopes)
	BOOLEAN_PROPERTY(ArmatureModifier, use_vertex_groups)
	BOOLEAN_PROPERTY(ArmatureModifier, use_deform_preserve_volume)
	BOOLEAN_PROPERTY(ArmatureModifier, use_multi_modifier)
	STRING_PROPERTY(ArmatureModifier, vertex_group)
	BOOLEAN_PROPERTY(ArmatureModifier, invert_vertex_group)


	FLOAT_PROPERTY(HookModifier, strength)
	ENUM_PROPERTY(falloff_type_enum, HookModifier, falloff_type)
	FLOAT_PROPERTY(HookModifier, falloff_radius)
	POINTER_PROPERTY(CurveMapping, HookModifier, falloff_curve)
	FLOAT_ARRAY_PROPERTY(HookModifier, 3, center)
	FLOAT_ARRAY_PROPERTY(HookModifier, 16, matrix_inverse)
	POINTER_PROPERTY(Object, HookModifier, object)
	STRING_PROPERTY(HookModifier, subtarget)
	BOOLEAN_PROPERTY(HookModifier, use_falloff_uniform)
	STRING_PROPERTY(HookModifier, vertex_group)
	INT_ARRAY_PROPERTY(HookModifier, 32, vertex_indices)
	BOOLEAN_PROPERTY(HookModifier, invert_vertex_group)

	inline void HookModifier::vertex_indices_set(int indices_len, int *indices) {
		HookModifier_vertex_indices_set_func((::HookModifierData *) this->ptr.data, nullptr, indices_len, indices);
	}


	POINTER_PROPERTY(SoftBodySettings, SoftBodyModifier, settings)
	POINTER_PROPERTY(PointCache, SoftBodyModifier, point_cache)


	POINTER_PROPERTY(Object, BooleanModifier, object)
	POINTER_PROPERTY(Collection, BooleanModifier, collection)
	ENUM_PROPERTY(operation_enum, BooleanModifier, operation)
	ENUM_PROPERTY(operand_type_enum, BooleanModifier, operand_type)
	FLOAT_PROPERTY(BooleanModifier, double_threshold)
	ENUM_PROPERTY(solver_enum, BooleanModifier, solver)
	BOOLEAN_PROPERTY(BooleanModifier, use_self)
	BOOLEAN_PROPERTY(BooleanModifier, use_hole_tolerant)
	ENUM_PROPERTY(material_mode_enum, BooleanModifier, material_mode)
	ENUM_PROPERTY(debug_options_enum, BooleanModifier, debug_options)


	ENUM_PROPERTY(fit_type_enum, ArrayModifier, fit_type)
	INT_PROPERTY(ArrayModifier, count)
	FLOAT_PROPERTY(ArrayModifier, fit_length)
	POINTER_PROPERTY(Object, ArrayModifier, curve)
	BOOLEAN_PROPERTY(ArrayModifier, use_constant_offset)
	FLOAT_ARRAY_PROPERTY(ArrayModifier, 3, constant_offset_displace)
	BOOLEAN_PROPERTY(ArrayModifier, use_relative_offset)
	FLOAT_ARRAY_PROPERTY(ArrayModifier, 3, relative_offset_displace)
	BOOLEAN_PROPERTY(ArrayModifier, use_merge_vertices)
	BOOLEAN_PROPERTY(ArrayModifier, use_merge_vertices_cap)
	FLOAT_PROPERTY(ArrayModifier, merge_threshold)
	BOOLEAN_PROPERTY(ArrayModifier, use_object_offset)
	POINTER_PROPERTY(Object, ArrayModifier, offset_object)
	POINTER_PROPERTY(Object, ArrayModifier, start_cap)
	POINTER_PROPERTY(Object, ArrayModifier, end_cap)
	FLOAT_PROPERTY(ArrayModifier, offset_u)
	FLOAT_PROPERTY(ArrayModifier, offset_v)


	FLOAT_PROPERTY(EdgeSplitModifier, split_angle)
	BOOLEAN_PROPERTY(EdgeSplitModifier, use_edge_angle)
	BOOLEAN_PROPERTY(EdgeSplitModifier, use_edge_sharp)


	STRING_PROPERTY(DisplaceModifier, vertex_group)
	FLOAT_PROPERTY(DisplaceModifier, mid_level)
	FLOAT_PROPERTY(DisplaceModifier, strength)
	ENUM_PROPERTY(direction_enum, DisplaceModifier, direction)
	ENUM_PROPERTY(space_enum, DisplaceModifier, space)
	BOOLEAN_PROPERTY(DisplaceModifier, invert_vertex_group)
	POINTER_PROPERTY(Texture, DisplaceModifier, texture)
	ENUM_PROPERTY(texture_coords_enum, DisplaceModifier, texture_coords)
	STRING_PROPERTY(DisplaceModifier, uv_layer)
	POINTER_PROPERTY(Object, DisplaceModifier, texture_coords_object)
	STRING_PROPERTY(DisplaceModifier, texture_coords_bone)


	STRING_PROPERTY(UVProjectModifier, uv_layer)
	INT_PROPERTY(UVProjectModifier, projector_count)

	FLOAT_PROPERTY(UVProjectModifier, aspect_x)
	FLOAT_PROPERTY(UVProjectModifier, aspect_y)
	FLOAT_PROPERTY(UVProjectModifier, scale_x)
	FLOAT_PROPERTY(UVProjectModifier, scale_y)


	POINTER_PROPERTY(Struct, UVProjector, rna_type)
	POINTER_PROPERTY(Object, UVProjector, object)


	BOOLEAN_PROPERTY(SmoothModifier, use_x)
	BOOLEAN_PROPERTY(SmoothModifier, use_y)
	BOOLEAN_PROPERTY(SmoothModifier, use_z)
	FLOAT_PROPERTY(SmoothModifier, factor)
	INT_PROPERTY(SmoothModifier, iterations)
	STRING_PROPERTY(SmoothModifier, vertex_group)
	BOOLEAN_PROPERTY(SmoothModifier, invert_vertex_group)


	FLOAT_PROPERTY(CorrectiveSmoothModifier, factor)
	INT_PROPERTY(CorrectiveSmoothModifier, iterations)
	FLOAT_PROPERTY(CorrectiveSmoothModifier, scale)
	ENUM_PROPERTY(rest_source_enum, CorrectiveSmoothModifier, rest_source)
	ENUM_PROPERTY(smooth_type_enum, CorrectiveSmoothModifier, smooth_type)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, invert_vertex_group)
	STRING_PROPERTY(CorrectiveSmoothModifier, vertex_group)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, is_bind)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, use_only_smooth)
	BOOLEAN_PROPERTY(CorrectiveSmoothModifier, use_pin_boundary)


	ENUM_PROPERTY(cast_type_enum, CastModifier, cast_type)
	POINTER_PROPERTY(Object, CastModifier, object)
	BOOLEAN_PROPERTY(CastModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(CastModifier, use_x)
	BOOLEAN_PROPERTY(CastModifier, use_y)
	BOOLEAN_PROPERTY(CastModifier, use_z)
	BOOLEAN_PROPERTY(CastModifier, use_radius_as_size)
	BOOLEAN_PROPERTY(CastModifier, use_transform)
	FLOAT_PROPERTY(CastModifier, factor)
	FLOAT_PROPERTY(CastModifier, radius)
	FLOAT_PROPERTY(CastModifier, size)
	STRING_PROPERTY(CastModifier, vertex_group)


	POINTER_PROPERTY(Object, MeshDeformModifier, object)
	BOOLEAN_PROPERTY(MeshDeformModifier, is_bound)
	BOOLEAN_PROPERTY(MeshDeformModifier, invert_vertex_group)
	STRING_PROPERTY(MeshDeformModifier, vertex_group)
	INT_PROPERTY(MeshDeformModifier, precision)
	BOOLEAN_PROPERTY(MeshDeformModifier, use_dynamic_bind)


	POINTER_PROPERTY(ParticleSystem, ParticleSystemModifier, particle_system)


	POINTER_PROPERTY(Object, ParticleInstanceModifier, object)
	INT_PROPERTY(ParticleInstanceModifier, particle_system_index)
	POINTER_PROPERTY(ParticleSystem, ParticleInstanceModifier, particle_system)
	ENUM_PROPERTY(axis_enum, ParticleInstanceModifier, axis)
	ENUM_PROPERTY(space_enum, ParticleInstanceModifier, space)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_normal)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_children)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_path)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, show_unborn)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, show_alive)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, show_dead)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_preserve_shape)
	BOOLEAN_PROPERTY(ParticleInstanceModifier, use_size)
	FLOAT_PROPERTY(ParticleInstanceModifier, position)
	FLOAT_PROPERTY(ParticleInstanceModifier, random_position)
	FLOAT_PROPERTY(ParticleInstanceModifier, rotation)
	FLOAT_PROPERTY(ParticleInstanceModifier, random_rotation)
	FLOAT_PROPERTY(ParticleInstanceModifier, particle_amount)
	FLOAT_PROPERTY(ParticleInstanceModifier, particle_offset)
	STRING_PROPERTY(ParticleInstanceModifier, index_layer_name)
	STRING_PROPERTY(ParticleInstanceModifier, value_layer_name)


	STRING_PROPERTY(ExplodeModifier, vertex_group)
	FLOAT_PROPERTY(ExplodeModifier, protect)
	BOOLEAN_PROPERTY(ExplodeModifier, use_edge_cut)
	BOOLEAN_PROPERTY(ExplodeModifier, show_unborn)
	BOOLEAN_PROPERTY(ExplodeModifier, show_alive)
	BOOLEAN_PROPERTY(ExplodeModifier, show_dead)
	BOOLEAN_PROPERTY(ExplodeModifier, use_size)
	STRING_PROPERTY(ExplodeModifier, particle_uv)
	BOOLEAN_PROPERTY(ExplodeModifier, invert_vertex_group)


	POINTER_PROPERTY(ClothSettings, ClothModifier, settings)
	POINTER_PROPERTY(ClothCollisionSettings, ClothModifier, collision_settings)
	POINTER_PROPERTY(ClothSolverResult, ClothModifier, solver_result)
	POINTER_PROPERTY(PointCache, ClothModifier, point_cache)
	FLOAT_ARRAY_PROPERTY(ClothModifier, 3, hair_grid_min)
	FLOAT_ARRAY_PROPERTY(ClothModifier, 3, hair_grid_max)
	INT_ARRAY_PROPERTY(ClothModifier, 3, hair_grid_resolution)


	POINTER_PROPERTY(CollisionSettings, CollisionModifier, settings)


	FLOAT_PROPERTY(BevelModifier, width)
	FLOAT_PROPERTY(BevelModifier, width_pct)
	INT_PROPERTY(BevelModifier, segments)
	ENUM_PROPERTY(affect_enum, BevelModifier, affect)
	ENUM_PROPERTY(limit_method_enum, BevelModifier, limit_method)
	FLOAT_PROPERTY(BevelModifier, angle_limit)
	STRING_PROPERTY(BevelModifier, vertex_group)
	BOOLEAN_PROPERTY(BevelModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(BevelModifier, use_clamp_overlap)
	ENUM_PROPERTY(offset_type_enum, BevelModifier, offset_type)
	ENUM_PROPERTY(profile_type_enum, BevelModifier, profile_type)
	FLOAT_PROPERTY(BevelModifier, profile)
	INT_PROPERTY(BevelModifier, material)
	BOOLEAN_PROPERTY(BevelModifier, loop_slide)
	BOOLEAN_PROPERTY(BevelModifier, mark_seam)
	BOOLEAN_PROPERTY(BevelModifier, mark_sharp)
	BOOLEAN_PROPERTY(BevelModifier, harden_normals)
	ENUM_PROPERTY(face_strength_mode_enum, BevelModifier, face_strength_mode)
	ENUM_PROPERTY(miter_outer_enum, BevelModifier, miter_outer)
	ENUM_PROPERTY(miter_inner_enum, BevelModifier, miter_inner)
	FLOAT_PROPERTY(BevelModifier, spread)
	POINTER_PROPERTY(CurveProfile, BevelModifier, custom_profile)
	ENUM_PROPERTY(vmesh_method_enum, BevelModifier, vmesh_method)


	ENUM_PROPERTY(wrap_method_enum, ShrinkwrapModifier, wrap_method)
	ENUM_PROPERTY(wrap_mode_enum, ShrinkwrapModifier, wrap_mode)
	ENUM_PROPERTY(cull_face_enum, ShrinkwrapModifier, cull_face)
	POINTER_PROPERTY(Object, ShrinkwrapModifier, target)
	POINTER_PROPERTY(Object, ShrinkwrapModifier, auxiliary_target)
	STRING_PROPERTY(ShrinkwrapModifier, vertex_group)
	FLOAT_PROPERTY(ShrinkwrapModifier, offset)
	FLOAT_PROPERTY(ShrinkwrapModifier, project_limit)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_project_x)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_project_y)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_project_z)
	INT_PROPERTY(ShrinkwrapModifier, subsurf_levels)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_negative_direction)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_positive_direction)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, use_invert_cull)
	BOOLEAN_PROPERTY(ShrinkwrapModifier, invert_vertex_group)


	ENUM_PROPERTY(mode_enum, MaskModifier, mode)
	POINTER_PROPERTY(Object, MaskModifier, armature)
	STRING_PROPERTY(MaskModifier, vertex_group)
	BOOLEAN_PROPERTY(MaskModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(MaskModifier, use_smooth)
	FLOAT_PROPERTY(MaskModifier, threshold)


	ENUM_PROPERTY(deform_method_enum, SimpleDeformModifier, deform_method)
	STRING_PROPERTY(SimpleDeformModifier, vertex_group)
	ENUM_PROPERTY(deform_axis_enum, SimpleDeformModifier, deform_axis)
	POINTER_PROPERTY(Object, SimpleDeformModifier, origin)
	FLOAT_PROPERTY(SimpleDeformModifier, factor)
	FLOAT_PROPERTY(SimpleDeformModifier, angle)
	FLOAT_ARRAY_PROPERTY(SimpleDeformModifier, 2, limits)
	BOOLEAN_PROPERTY(SimpleDeformModifier, lock_x)
	BOOLEAN_PROPERTY(SimpleDeformModifier, lock_y)
	BOOLEAN_PROPERTY(SimpleDeformModifier, lock_z)
	BOOLEAN_PROPERTY(SimpleDeformModifier, invert_vertex_group)


	POINTER_PROPERTY(Object, WarpModifier, object_from)
	STRING_PROPERTY(WarpModifier, bone_from)
	POINTER_PROPERTY(Object, WarpModifier, object_to)
	STRING_PROPERTY(WarpModifier, bone_to)
	FLOAT_PROPERTY(WarpModifier, strength)
	ENUM_PROPERTY(falloff_type_enum, WarpModifier, falloff_type)
	FLOAT_PROPERTY(WarpModifier, falloff_radius)
	POINTER_PROPERTY(CurveMapping, WarpModifier, falloff_curve)
	BOOLEAN_PROPERTY(WarpModifier, use_volume_preserve)
	STRING_PROPERTY(WarpModifier, vertex_group)
	BOOLEAN_PROPERTY(WarpModifier, invert_vertex_group)
	POINTER_PROPERTY(Texture, WarpModifier, texture)
	ENUM_PROPERTY(texture_coords_enum, WarpModifier, texture_coords)
	STRING_PROPERTY(WarpModifier, uv_layer)
	POINTER_PROPERTY(Object, WarpModifier, texture_coords_object)
	STRING_PROPERTY(WarpModifier, texture_coords_bone)


	ENUM_PROPERTY(uv_smooth_enum, MultiresModifier, uv_smooth)
	INT_PROPERTY(MultiresModifier, quality)
	ENUM_PROPERTY(boundary_smooth_enum, MultiresModifier, boundary_smooth)
	INT_PROPERTY(MultiresModifier, levels)
	INT_PROPERTY(MultiresModifier, sculpt_levels)
	INT_PROPERTY(MultiresModifier, render_levels)
	INT_PROPERTY(MultiresModifier, total_levels)
	BOOLEAN_PROPERTY(MultiresModifier, is_external)
	STRING_PROPERTY(MultiresModifier, filepath)
	BOOLEAN_PROPERTY(MultiresModifier, show_only_control_edges)
	BOOLEAN_PROPERTY(MultiresModifier, use_creases)
	BOOLEAN_PROPERTY(MultiresModifier, use_custom_normals)
	BOOLEAN_PROPERTY(MultiresModifier, use_sculpt_base_mesh)




	POINTER_PROPERTY(FluidDomainSettings, FluidModifier, domain_settings)
	POINTER_PROPERTY(FluidFlowSettings, FluidModifier, flow_settings)
	POINTER_PROPERTY(FluidEffectorSettings, FluidModifier, effector_settings)
	ENUM_PROPERTY(fluid_type_enum, FluidModifier, fluid_type)


	ENUM_PROPERTY(solidify_mode_enum, SolidifyModifier, solidify_mode)
	FLOAT_PROPERTY(SolidifyModifier, thickness)
	FLOAT_PROPERTY(SolidifyModifier, thickness_clamp)
	BOOLEAN_PROPERTY(SolidifyModifier, use_thickness_angle_clamp)
	FLOAT_PROPERTY(SolidifyModifier, thickness_vertex_group)
	FLOAT_PROPERTY(SolidifyModifier, offset)
	FLOAT_PROPERTY(SolidifyModifier, edge_crease_inner)
	FLOAT_PROPERTY(SolidifyModifier, edge_crease_outer)
	FLOAT_PROPERTY(SolidifyModifier, edge_crease_rim)
	INT_PROPERTY(SolidifyModifier, material_offset)
	INT_PROPERTY(SolidifyModifier, material_offset_rim)
	STRING_PROPERTY(SolidifyModifier, vertex_group)
	STRING_PROPERTY(SolidifyModifier, shell_vertex_group)
	STRING_PROPERTY(SolidifyModifier, rim_vertex_group)
	BOOLEAN_PROPERTY(SolidifyModifier, use_rim)
	BOOLEAN_PROPERTY(SolidifyModifier, use_even_offset)
	BOOLEAN_PROPERTY(SolidifyModifier, use_quality_normals)
	BOOLEAN_PROPERTY(SolidifyModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(SolidifyModifier, use_flat_faces)
	BOOLEAN_PROPERTY(SolidifyModifier, use_flip_normals)
	BOOLEAN_PROPERTY(SolidifyModifier, use_rim_only)
	ENUM_PROPERTY(nonmanifold_thickness_mode_enum, SolidifyModifier, nonmanifold_thickness_mode)
	ENUM_PROPERTY(nonmanifold_boundary_mode_enum, SolidifyModifier, nonmanifold_boundary_mode)
	FLOAT_PROPERTY(SolidifyModifier, nonmanifold_merge_threshold)
	FLOAT_PROPERTY(SolidifyModifier, bevel_convex)


	POINTER_PROPERTY(Object, ScrewModifier, object)
	INT_PROPERTY(ScrewModifier, steps)
	INT_PROPERTY(ScrewModifier, render_steps)
	INT_PROPERTY(ScrewModifier, iterations)
	ENUM_PROPERTY(axis_enum, ScrewModifier, axis)
	FLOAT_PROPERTY(ScrewModifier, angle)
	FLOAT_PROPERTY(ScrewModifier, screw_offset)
	FLOAT_PROPERTY(ScrewModifier, merge_threshold)
	BOOLEAN_PROPERTY(ScrewModifier, use_normal_flip)
	BOOLEAN_PROPERTY(ScrewModifier, use_normal_calculate)
	BOOLEAN_PROPERTY(ScrewModifier, use_object_screw_offset)
	BOOLEAN_PROPERTY(ScrewModifier, use_merge_vertices)
	BOOLEAN_PROPERTY(ScrewModifier, use_smooth_shade)
	BOOLEAN_PROPERTY(ScrewModifier, use_stretch_u)
	BOOLEAN_PROPERTY(ScrewModifier, use_stretch_v)


	ENUM_PROPERTY(axis_u_enum, UVWarpModifier, axis_u)
	ENUM_PROPERTY(axis_v_enum, UVWarpModifier, axis_v)
	FLOAT_ARRAY_PROPERTY(UVWarpModifier, 2, center)
	FLOAT_ARRAY_PROPERTY(UVWarpModifier, 2, offset)
	FLOAT_ARRAY_PROPERTY(UVWarpModifier, 2, scale)
	FLOAT_PROPERTY(UVWarpModifier, rotation)
	POINTER_PROPERTY(Object, UVWarpModifier, object_from)
	STRING_PROPERTY(UVWarpModifier, bone_from)
	POINTER_PROPERTY(Object, UVWarpModifier, object_to)
	STRING_PROPERTY(UVWarpModifier, bone_to)
	STRING_PROPERTY(UVWarpModifier, vertex_group)
	BOOLEAN_PROPERTY(UVWarpModifier, invert_vertex_group)
	STRING_PROPERTY(UVWarpModifier, uv_layer)


	STRING_PROPERTY(VertexWeightEditModifier, vertex_group)
	ENUM_PROPERTY(falloff_type_enum, VertexWeightEditModifier, falloff_type)
	BOOLEAN_PROPERTY(VertexWeightEditModifier, invert_falloff)
	BOOLEAN_PROPERTY(VertexWeightEditModifier, normalize)
	POINTER_PROPERTY(CurveMapping, VertexWeightEditModifier, map_curve)
	BOOLEAN_PROPERTY(VertexWeightEditModifier, use_add)
	BOOLEAN_PROPERTY(VertexWeightEditModifier, use_remove)
	FLOAT_PROPERTY(VertexWeightEditModifier, default_weight)
	FLOAT_PROPERTY(VertexWeightEditModifier, add_threshold)
	FLOAT_PROPERTY(VertexWeightEditModifier, remove_threshold)
	FLOAT_PROPERTY(VertexWeightEditModifier, mask_constant)
	STRING_PROPERTY(VertexWeightEditModifier, mask_vertex_group)
	BOOLEAN_PROPERTY(VertexWeightEditModifier, invert_mask_vertex_group)
	POINTER_PROPERTY(Texture, VertexWeightEditModifier, mask_texture)
	ENUM_PROPERTY(mask_tex_use_channel_enum, VertexWeightEditModifier, mask_tex_use_channel)
	ENUM_PROPERTY(mask_tex_mapping_enum, VertexWeightEditModifier, mask_tex_mapping)
	STRING_PROPERTY(VertexWeightEditModifier, mask_tex_uv_layer)
	POINTER_PROPERTY(Object, VertexWeightEditModifier, mask_tex_map_object)
	STRING_PROPERTY(VertexWeightEditModifier, mask_tex_map_bone)


	STRING_PROPERTY(VertexWeightMixModifier, vertex_group_a)
	STRING_PROPERTY(VertexWeightMixModifier, vertex_group_b)
	BOOLEAN_PROPERTY(VertexWeightMixModifier, invert_vertex_group_a)
	BOOLEAN_PROPERTY(VertexWeightMixModifier, invert_vertex_group_b)
	FLOAT_PROPERTY(VertexWeightMixModifier, default_weight_a)
	FLOAT_PROPERTY(VertexWeightMixModifier, default_weight_b)
	ENUM_PROPERTY(mix_mode_enum, VertexWeightMixModifier, mix_mode)
	ENUM_PROPERTY(mix_set_enum, VertexWeightMixModifier, mix_set)
	BOOLEAN_PROPERTY(VertexWeightMixModifier, normalize)
	FLOAT_PROPERTY(VertexWeightMixModifier, mask_constant)
	STRING_PROPERTY(VertexWeightMixModifier, mask_vertex_group)
	BOOLEAN_PROPERTY(VertexWeightMixModifier, invert_mask_vertex_group)
	POINTER_PROPERTY(Texture, VertexWeightMixModifier, mask_texture)
	ENUM_PROPERTY(mask_tex_use_channel_enum, VertexWeightMixModifier, mask_tex_use_channel)
	ENUM_PROPERTY(mask_tex_mapping_enum, VertexWeightMixModifier, mask_tex_mapping)
	STRING_PROPERTY(VertexWeightMixModifier, mask_tex_uv_layer)
	POINTER_PROPERTY(Object, VertexWeightMixModifier, mask_tex_map_object)
	STRING_PROPERTY(VertexWeightMixModifier, mask_tex_map_bone)


	STRING_PROPERTY(VertexWeightProximityModifier, vertex_group)
	ENUM_PROPERTY(proximity_mode_enum, VertexWeightProximityModifier, proximity_mode)
	ENUM_PROPERTY(proximity_geometry_enum, VertexWeightProximityModifier, proximity_geometry)
	POINTER_PROPERTY(Object, VertexWeightProximityModifier, target)
	FLOAT_PROPERTY(VertexWeightProximityModifier, min_dist)
	FLOAT_PROPERTY(VertexWeightProximityModifier, max_dist)
	ENUM_PROPERTY(falloff_type_enum, VertexWeightProximityModifier, falloff_type)
	BOOLEAN_PROPERTY(VertexWeightProximityModifier, invert_falloff)
	BOOLEAN_PROPERTY(VertexWeightProximityModifier, normalize)
	POINTER_PROPERTY(CurveMapping, VertexWeightProximityModifier, map_curve)
	FLOAT_PROPERTY(VertexWeightProximityModifier, mask_constant)
	STRING_PROPERTY(VertexWeightProximityModifier, mask_vertex_group)
	BOOLEAN_PROPERTY(VertexWeightProximityModifier, invert_mask_vertex_group)
	POINTER_PROPERTY(Texture, VertexWeightProximityModifier, mask_texture)
	ENUM_PROPERTY(mask_tex_use_channel_enum, VertexWeightProximityModifier, mask_tex_use_channel)
	ENUM_PROPERTY(mask_tex_mapping_enum, VertexWeightProximityModifier, mask_tex_mapping)
	STRING_PROPERTY(VertexWeightProximityModifier, mask_tex_uv_layer)
	POINTER_PROPERTY(Object, VertexWeightProximityModifier, mask_tex_map_object)
	STRING_PROPERTY(VertexWeightProximityModifier, mask_tex_map_bone)


	POINTER_PROPERTY(DynamicPaintCanvasSettings, DynamicPaintModifier, canvas_settings)
	POINTER_PROPERTY(DynamicPaintBrushSettings, DynamicPaintModifier, brush_settings)
	ENUM_PROPERTY(ui_type_enum, DynamicPaintModifier, ui_type)


	ENUM_PROPERTY(geometry_mode_enum, OceanModifier, geometry_mode)
	FLOAT_PROPERTY(OceanModifier, size)
	INT_PROPERTY(OceanModifier, repeat_x)
	INT_PROPERTY(OceanModifier, repeat_y)
	BOOLEAN_PROPERTY(OceanModifier, use_normals)
	BOOLEAN_PROPERTY(OceanModifier, use_foam)
	BOOLEAN_PROPERTY(OceanModifier, use_spray)
	BOOLEAN_PROPERTY(OceanModifier, invert_spray)
	STRING_PROPERTY(OceanModifier, spray_layer_name)
	INT_PROPERTY(OceanModifier, resolution)
	INT_PROPERTY(OceanModifier, viewport_resolution)
	INT_PROPERTY(OceanModifier, spatial_size)
	FLOAT_PROPERTY(OceanModifier, wind_velocity)
	FLOAT_PROPERTY(OceanModifier, damping)
	FLOAT_PROPERTY(OceanModifier, wave_scale_min)
	FLOAT_PROPERTY(OceanModifier, wave_alignment)
	FLOAT_PROPERTY(OceanModifier, wave_direction)
	FLOAT_PROPERTY(OceanModifier, wave_scale)
	FLOAT_PROPERTY(OceanModifier, depth)
	FLOAT_PROPERTY(OceanModifier, foam_coverage)
	FLOAT_PROPERTY(OceanModifier, bake_foam_fade)
	STRING_PROPERTY(OceanModifier, foam_layer_name)
	FLOAT_PROPERTY(OceanModifier, choppiness)
	FLOAT_PROPERTY(OceanModifier, time)
	ENUM_PROPERTY(spectrum_enum, OceanModifier, spectrum)
	FLOAT_PROPERTY(OceanModifier, fetch_jonswap)
	FLOAT_PROPERTY(OceanModifier, sharpen_peak_jonswap)
	INT_PROPERTY(OceanModifier, random_seed)
	INT_PROPERTY(OceanModifier, frame_start)
	INT_PROPERTY(OceanModifier, frame_end)
	BOOLEAN_PROPERTY(OceanModifier, is_cached)
	STRING_PROPERTY(OceanModifier, filepath)


	ENUM_PROPERTY(mode_enum, RemeshModifier, mode)
	FLOAT_PROPERTY(RemeshModifier, scale)
	FLOAT_PROPERTY(RemeshModifier, threshold)
	INT_PROPERTY(RemeshModifier, octree_depth)
	FLOAT_PROPERTY(RemeshModifier, sharpness)
	FLOAT_PROPERTY(RemeshModifier, voxel_size)
	FLOAT_PROPERTY(RemeshModifier, adaptivity)
	BOOLEAN_PROPERTY(RemeshModifier, use_remove_disconnected)
	BOOLEAN_PROPERTY(RemeshModifier, use_smooth_shade)


	FLOAT_PROPERTY(SkinModifier, branch_smoothing)
	BOOLEAN_PROPERTY(SkinModifier, use_smooth_shade)
	BOOLEAN_PROPERTY(SkinModifier, use_x_symmetry)
	BOOLEAN_PROPERTY(SkinModifier, use_y_symmetry)
	BOOLEAN_PROPERTY(SkinModifier, use_z_symmetry)


	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_x)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_y)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_z)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_volume_preserve)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, use_normalized)
	FLOAT_PROPERTY(LaplacianSmoothModifier, lambda_factor)
	FLOAT_PROPERTY(LaplacianSmoothModifier, lambda_border)
	INT_PROPERTY(LaplacianSmoothModifier, iterations)
	STRING_PROPERTY(LaplacianSmoothModifier, vertex_group)
	BOOLEAN_PROPERTY(LaplacianSmoothModifier, invert_vertex_group)


	ENUM_PROPERTY(quad_method_enum, TriangulateModifier, quad_method)
	ENUM_PROPERTY(ngon_method_enum, TriangulateModifier, ngon_method)
	INT_PROPERTY(TriangulateModifier, min_vertices)
	BOOLEAN_PROPERTY(TriangulateModifier, keep_custom_normals)


	ENUM_PROPERTY(cache_format_enum, MeshCacheModifier, cache_format)
	ENUM_PROPERTY(interpolation_enum, MeshCacheModifier, interpolation)
	ENUM_PROPERTY(time_mode_enum, MeshCacheModifier, time_mode)
	ENUM_PROPERTY(play_mode_enum, MeshCacheModifier, play_mode)
	ENUM_PROPERTY(deform_mode_enum, MeshCacheModifier, deform_mode)
	STRING_PROPERTY(MeshCacheModifier, filepath)
	FLOAT_PROPERTY(MeshCacheModifier, factor)
	STRING_PROPERTY(MeshCacheModifier, vertex_group)
	BOOLEAN_PROPERTY(MeshCacheModifier, invert_vertex_group)
	ENUM_PROPERTY(forward_axis_enum, MeshCacheModifier, forward_axis)
	ENUM_PROPERTY(up_axis_enum, MeshCacheModifier, up_axis)
	ENUM_PROPERTY(flip_axis_enum, MeshCacheModifier, flip_axis)
	FLOAT_PROPERTY(MeshCacheModifier, frame_start)
	FLOAT_PROPERTY(MeshCacheModifier, frame_scale)
	FLOAT_PROPERTY(MeshCacheModifier, eval_frame)
	FLOAT_PROPERTY(MeshCacheModifier, eval_time)
	FLOAT_PROPERTY(MeshCacheModifier, eval_factor)


	STRING_PROPERTY(LaplacianDeformModifier, vertex_group)
	INT_PROPERTY(LaplacianDeformModifier, iterations)
	BOOLEAN_PROPERTY(LaplacianDeformModifier, is_bind)
	BOOLEAN_PROPERTY(LaplacianDeformModifier, invert_vertex_group)


	ENUM_PROPERTY(mode_enum, WeldModifier, mode)
	FLOAT_PROPERTY(WeldModifier, merge_threshold)
	STRING_PROPERTY(WeldModifier, vertex_group)
	BOOLEAN_PROPERTY(WeldModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(WeldModifier, loose_edges)


	FLOAT_PROPERTY(WireframeModifier, thickness)
	FLOAT_PROPERTY(WireframeModifier, thickness_vertex_group)
	FLOAT_PROPERTY(WireframeModifier, offset)
	BOOLEAN_PROPERTY(WireframeModifier, use_replace)
	BOOLEAN_PROPERTY(WireframeModifier, use_boundary)
	BOOLEAN_PROPERTY(WireframeModifier, use_even_offset)
	BOOLEAN_PROPERTY(WireframeModifier, use_relative_offset)
	BOOLEAN_PROPERTY(WireframeModifier, use_crease)
	FLOAT_PROPERTY(WireframeModifier, crease_weight)
	INT_PROPERTY(WireframeModifier, material_offset)
	STRING_PROPERTY(WireframeModifier, vertex_group)
	BOOLEAN_PROPERTY(WireframeModifier, invert_vertex_group)


	POINTER_PROPERTY(Object, DataTransferModifier, object)
	BOOLEAN_PROPERTY(DataTransferModifier, use_object_transform)
	BOOLEAN_PROPERTY(DataTransferModifier, use_vert_data)
	BOOLEAN_PROPERTY(DataTransferModifier, use_edge_data)
	BOOLEAN_PROPERTY(DataTransferModifier, use_loop_data)
	BOOLEAN_PROPERTY(DataTransferModifier, use_poly_data)
	ENUM_PROPERTY(data_types_verts_enum, DataTransferModifier, data_types_verts)
	ENUM_PROPERTY(data_types_edges_enum, DataTransferModifier, data_types_edges)
	ENUM_PROPERTY(data_types_loops_enum, DataTransferModifier, data_types_loops)
	ENUM_PROPERTY(data_types_polys_enum, DataTransferModifier, data_types_polys)
	ENUM_PROPERTY(vert_mapping_enum, DataTransferModifier, vert_mapping)
	ENUM_PROPERTY(edge_mapping_enum, DataTransferModifier, edge_mapping)
	ENUM_PROPERTY(loop_mapping_enum, DataTransferModifier, loop_mapping)
	ENUM_PROPERTY(poly_mapping_enum, DataTransferModifier, poly_mapping)
	BOOLEAN_PROPERTY(DataTransferModifier, use_max_distance)
	FLOAT_PROPERTY(DataTransferModifier, max_distance)
	FLOAT_PROPERTY(DataTransferModifier, ray_radius)
	FLOAT_PROPERTY(DataTransferModifier, islands_precision)
	ENUM_PROPERTY(layers_vgroup_select_src_enum, DataTransferModifier, layers_vgroup_select_src)
	ENUM_PROPERTY(layers_vcol_vert_select_src_enum, DataTransferModifier, layers_vcol_vert_select_src)
	ENUM_PROPERTY(layers_vcol_loop_select_src_enum, DataTransferModifier, layers_vcol_loop_select_src)
	ENUM_PROPERTY(layers_uv_select_src_enum, DataTransferModifier, layers_uv_select_src)
	ENUM_PROPERTY(layers_vgroup_select_dst_enum, DataTransferModifier, layers_vgroup_select_dst)
	ENUM_PROPERTY(layers_vcol_vert_select_dst_enum, DataTransferModifier, layers_vcol_vert_select_dst)
	ENUM_PROPERTY(layers_vcol_loop_select_dst_enum, DataTransferModifier, layers_vcol_loop_select_dst)
	ENUM_PROPERTY(layers_uv_select_dst_enum, DataTransferModifier, layers_uv_select_dst)
	ENUM_PROPERTY(mix_mode_enum, DataTransferModifier, mix_mode)
	FLOAT_PROPERTY(DataTransferModifier, mix_factor)
	STRING_PROPERTY(DataTransferModifier, vertex_group)
	BOOLEAN_PROPERTY(DataTransferModifier, invert_vertex_group)


	ENUM_PROPERTY(mode_enum, NormalEditModifier, mode)
	FLOAT_ARRAY_PROPERTY(NormalEditModifier, 3, offset)
	ENUM_PROPERTY(mix_mode_enum, NormalEditModifier, mix_mode)
	FLOAT_PROPERTY(NormalEditModifier, mix_factor)
	FLOAT_PROPERTY(NormalEditModifier, mix_limit)
	BOOLEAN_PROPERTY(NormalEditModifier, no_polynors_fix)
	STRING_PROPERTY(NormalEditModifier, vertex_group)
	BOOLEAN_PROPERTY(NormalEditModifier, invert_vertex_group)
	POINTER_PROPERTY(Object, NormalEditModifier, target)
	BOOLEAN_PROPERTY(NormalEditModifier, use_direction_parallel)


	POINTER_PROPERTY(CacheFile, MeshSequenceCacheModifier, cache_file)
	STRING_PROPERTY(MeshSequenceCacheModifier, object_path)
	ENUM_PROPERTY(read_data_enum, MeshSequenceCacheModifier, read_data)
	BOOLEAN_PROPERTY(MeshSequenceCacheModifier, use_vertex_interpolation)
	FLOAT_PROPERTY(MeshSequenceCacheModifier, velocity_scale)


	POINTER_PROPERTY(Object, SurfaceDeformModifier, target)
	FLOAT_PROPERTY(SurfaceDeformModifier, falloff)
	BOOLEAN_PROPERTY(SurfaceDeformModifier, is_bound)
	STRING_PROPERTY(SurfaceDeformModifier, vertex_group)
	BOOLEAN_PROPERTY(SurfaceDeformModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(SurfaceDeformModifier, use_sparse_bind)
	FLOAT_PROPERTY(SurfaceDeformModifier, strength)


	INT_PROPERTY(WeightedNormalModifier, weight)
	ENUM_PROPERTY(mode_enum, WeightedNormalModifier, mode)
	FLOAT_PROPERTY(WeightedNormalModifier, thresh)
	BOOLEAN_PROPERTY(WeightedNormalModifier, keep_sharp)
	STRING_PROPERTY(WeightedNormalModifier, vertex_group)
	BOOLEAN_PROPERTY(WeightedNormalModifier, invert_vertex_group)
	BOOLEAN_PROPERTY(WeightedNormalModifier, use_face_influence)


	POINTER_PROPERTY(Struct, NodesModifierBake, rna_type)
	STRING_PROPERTY(NodesModifierBake, directory)
	INT_PROPERTY(NodesModifierBake, frame_start)
	INT_PROPERTY(NodesModifierBake, frame_end)
	BOOLEAN_PROPERTY(NodesModifierBake, use_custom_simulation_frame_range)
	BOOLEAN_PROPERTY(NodesModifierBake, use_custom_path)


	POINTER_PROPERTY(Struct, NodesModifierBakes, rna_type)


	POINTER_PROPERTY(NodeTree, NodesModifier, node_group)
	STRING_PROPERTY(NodesModifier, simulation_bake_directory)

	BOOLEAN_PROPERTY(NodesModifier, show_group_selector)


	POINTER_PROPERTY(Object, MeshToVolumeModifier, object)
	ENUM_PROPERTY(resolution_mode_enum, MeshToVolumeModifier, resolution_mode)
	FLOAT_PROPERTY(MeshToVolumeModifier, voxel_size)
	INT_PROPERTY(MeshToVolumeModifier, voxel_amount)
	FLOAT_PROPERTY(MeshToVolumeModifier, interior_band_width)
	FLOAT_PROPERTY(MeshToVolumeModifier, density)


	FLOAT_PROPERTY(VolumeDisplaceModifier, strength)
	POINTER_PROPERTY(Texture, VolumeDisplaceModifier, texture)
	ENUM_PROPERTY(texture_map_mode_enum, VolumeDisplaceModifier, texture_map_mode)
	POINTER_PROPERTY(Object, VolumeDisplaceModifier, texture_map_object)
	FLOAT_ARRAY_PROPERTY(VolumeDisplaceModifier, 3, texture_mid_level)
	FLOAT_PROPERTY(VolumeDisplaceModifier, texture_sample_radius)


	POINTER_PROPERTY(Object, VolumeToMeshModifier, object)
	FLOAT_PROPERTY(VolumeToMeshModifier, threshold)
	FLOAT_PROPERTY(VolumeToMeshModifier, adaptivity)
	BOOLEAN_PROPERTY(VolumeToMeshModifier, use_smooth_shade)
	STRING_PROPERTY(VolumeToMeshModifier, grid_name)
	ENUM_PROPERTY(resolution_mode_enum, VolumeToMeshModifier, resolution_mode)
	FLOAT_PROPERTY(VolumeToMeshModifier, voxel_size)
	INT_PROPERTY(VolumeToMeshModifier, voxel_amount)


	POINTER_PROPERTY(Struct, GpencilModifier, rna_type)
	STRING_PROPERTY(GpencilModifier, name)
	ENUM_PROPERTY(type_enum, GpencilModifier, type)
	BOOLEAN_PROPERTY(GpencilModifier, show_viewport)
	BOOLEAN_PROPERTY(GpencilModifier, show_render)
	BOOLEAN_PROPERTY(GpencilModifier, show_in_editmode)
	BOOLEAN_PROPERTY(GpencilModifier, show_expanded)
	BOOLEAN_PROPERTY(GpencilModifier, is_override_data)


	STRING_PROPERTY(NoiseGpencilModifier, layer)
	POINTER_PROPERTY(Material, NoiseGpencilModifier, material)
	STRING_PROPERTY(NoiseGpencilModifier, vertex_group)
	FLOAT_PROPERTY(NoiseGpencilModifier, factor)
	FLOAT_PROPERTY(NoiseGpencilModifier, factor_strength)
	FLOAT_PROPERTY(NoiseGpencilModifier, factor_thickness)
	FLOAT_PROPERTY(NoiseGpencilModifier, factor_uvs)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, use_random)
	INT_PROPERTY(NoiseGpencilModifier, seed)
	FLOAT_PROPERTY(NoiseGpencilModifier, noise_scale)
	FLOAT_PROPERTY(NoiseGpencilModifier, noise_offset)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, use_custom_curve)
	POINTER_PROPERTY(CurveMapping, NoiseGpencilModifier, curve)
	INT_PROPERTY(NoiseGpencilModifier, pass_index)
	INT_PROPERTY(NoiseGpencilModifier, step)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_vertex)
	INT_PROPERTY(NoiseGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(NoiseGpencilModifier, invert_layer_pass)
	ENUM_PROPERTY(random_mode_enum, NoiseGpencilModifier, random_mode)


	STRING_PROPERTY(SmoothGpencilModifier, layer)
	POINTER_PROPERTY(Material, SmoothGpencilModifier, material)
	STRING_PROPERTY(SmoothGpencilModifier, vertex_group)
	FLOAT_PROPERTY(SmoothGpencilModifier, factor)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_position)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_strength)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_thickness)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_edit_uv)
	INT_PROPERTY(SmoothGpencilModifier, pass_index)
	INT_PROPERTY(SmoothGpencilModifier, step)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_keep_shape)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_vertex)
	INT_PROPERTY(SmoothGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(SmoothGpencilModifier, use_custom_curve)
	POINTER_PROPERTY(CurveMapping, SmoothGpencilModifier, curve)


	STRING_PROPERTY(SubdivGpencilModifier, layer)
	POINTER_PROPERTY(Material, SubdivGpencilModifier, material)
	INT_PROPERTY(SubdivGpencilModifier, level)
	ENUM_PROPERTY(subdivision_type_enum, SubdivGpencilModifier, subdivision_type)
	INT_PROPERTY(SubdivGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, invert_material_pass)
	INT_PROPERTY(SubdivGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(SubdivGpencilModifier, invert_layer_pass)


	STRING_PROPERTY(SimplifyGpencilModifier, layer)
	POINTER_PROPERTY(Material, SimplifyGpencilModifier, material)
	FLOAT_PROPERTY(SimplifyGpencilModifier, factor)
	INT_PROPERTY(SimplifyGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(SimplifyGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(SimplifyGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(SimplifyGpencilModifier, invert_material_pass)
	INT_PROPERTY(SimplifyGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(SimplifyGpencilModifier, invert_layer_pass)
	ENUM_PROPERTY(mode_enum, SimplifyGpencilModifier, mode)
	INT_PROPERTY(SimplifyGpencilModifier, step)
	FLOAT_PROPERTY(SimplifyGpencilModifier, length)
	FLOAT_PROPERTY(SimplifyGpencilModifier, sharp_threshold)
	FLOAT_PROPERTY(SimplifyGpencilModifier, distance)


	STRING_PROPERTY(ThickGpencilModifier, layer)
	POINTER_PROPERTY(Material, ThickGpencilModifier, material)
	STRING_PROPERTY(ThickGpencilModifier, vertex_group)
	INT_PROPERTY(ThickGpencilModifier, thickness)
	FLOAT_PROPERTY(ThickGpencilModifier, thickness_factor)
	BOOLEAN_PROPERTY(ThickGpencilModifier, use_weight_factor)
	INT_PROPERTY(ThickGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_vertex)
	INT_PROPERTY(ThickGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(ThickGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(ThickGpencilModifier, use_custom_curve)
	BOOLEAN_PROPERTY(ThickGpencilModifier, use_normalized_thickness)
	POINTER_PROPERTY(CurveMapping, ThickGpencilModifier, curve)


	ENUM_PROPERTY(mode_enum, OffsetGpencilModifier, mode)
	STRING_PROPERTY(OffsetGpencilModifier, layer)
	POINTER_PROPERTY(Material, OffsetGpencilModifier, material)
	STRING_PROPERTY(OffsetGpencilModifier, vertex_group)
	INT_PROPERTY(OffsetGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_vertex)
	INT_PROPERTY(OffsetGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, invert_layer_pass)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, location)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, rotation)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, scale)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, random_offset)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, random_rotation)
	FLOAT_ARRAY_PROPERTY(OffsetGpencilModifier, 3, random_scale)
	INT_PROPERTY(OffsetGpencilModifier, seed)
	INT_PROPERTY(OffsetGpencilModifier, stroke_step)
	INT_PROPERTY(OffsetGpencilModifier, stroke_start_offset)
	BOOLEAN_PROPERTY(OffsetGpencilModifier, use_uniform_random_scale)


	POINTER_PROPERTY(Object, TintGpencilModifier, object)
	STRING_PROPERTY(TintGpencilModifier, layer)
	POINTER_PROPERTY(Material, TintGpencilModifier, material)
	STRING_PROPERTY(TintGpencilModifier, vertex_group)
	INT_PROPERTY(TintGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_vertex)
	INT_PROPERTY(TintGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(TintGpencilModifier, invert_layer_pass)
	FLOAT_PROPERTY(TintGpencilModifier, factor)
	BOOLEAN_PROPERTY(TintGpencilModifier, use_weight_factor)
	FLOAT_PROPERTY(TintGpencilModifier, radius)
	ENUM_PROPERTY(vertex_mode_enum, TintGpencilModifier, vertex_mode)
	ENUM_PROPERTY(tint_type_enum, TintGpencilModifier, tint_type)
	FLOAT_ARRAY_PROPERTY(TintGpencilModifier, 3, color)
	POINTER_PROPERTY(ColorRamp, TintGpencilModifier, colors)
	BOOLEAN_PROPERTY(TintGpencilModifier, use_custom_curve)
	POINTER_PROPERTY(CurveMapping, TintGpencilModifier, curve)


	POINTER_PROPERTY(Struct, TimeGpencilModifierSegment, rna_type)
	STRING_PROPERTY(TimeGpencilModifierSegment, name)
	INT_PROPERTY(TimeGpencilModifierSegment, seg_start)
	INT_PROPERTY(TimeGpencilModifierSegment, seg_end)
	INT_PROPERTY(TimeGpencilModifierSegment, seg_repeat)
	ENUM_PROPERTY(seg_mode_enum, TimeGpencilModifierSegment, seg_mode)



	INT_PROPERTY(TimeGpencilModifier, segment_active_index)
	ENUM_PROPERTY(mode_enum, TimeGpencilModifier, mode)
	STRING_PROPERTY(TimeGpencilModifier, layer)
	BOOLEAN_PROPERTY(TimeGpencilModifier, invert_layers)
	INT_PROPERTY(TimeGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(TimeGpencilModifier, invert_layer_pass)
	INT_PROPERTY(TimeGpencilModifier, offset)
	FLOAT_PROPERTY(TimeGpencilModifier, frame_scale)
	INT_PROPERTY(TimeGpencilModifier, frame_start)
	INT_PROPERTY(TimeGpencilModifier, frame_end)
	BOOLEAN_PROPERTY(TimeGpencilModifier, use_keep_loop)
	BOOLEAN_PROPERTY(TimeGpencilModifier, use_custom_frame_range)


	ENUM_PROPERTY(modify_color_enum, ColorGpencilModifier, modify_color)
	STRING_PROPERTY(ColorGpencilModifier, layer)
	POINTER_PROPERTY(Material, ColorGpencilModifier, material)
	FLOAT_PROPERTY(ColorGpencilModifier, hue)
	FLOAT_PROPERTY(ColorGpencilModifier, saturation)
	FLOAT_PROPERTY(ColorGpencilModifier, value)
	INT_PROPERTY(ColorGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(ColorGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(ColorGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(ColorGpencilModifier, invert_material_pass)
	INT_PROPERTY(ColorGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(ColorGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(ColorGpencilModifier, use_custom_curve)
	POINTER_PROPERTY(CurveMapping, ColorGpencilModifier, curve)


	STRING_PROPERTY(ArrayGpencilModifier, layer)
	POINTER_PROPERTY(Material, ArrayGpencilModifier, material)
	INT_PROPERTY(ArrayGpencilModifier, pass_index)
	INT_PROPERTY(ArrayGpencilModifier, count)
	POINTER_PROPERTY(Object, ArrayGpencilModifier, offset_object)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, constant_offset)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, relative_offset)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, random_offset)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, random_rotation)
	FLOAT_ARRAY_PROPERTY(ArrayGpencilModifier, 3, random_scale)
	INT_PROPERTY(ArrayGpencilModifier, seed)
	INT_PROPERTY(ArrayGpencilModifier, replace_material)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, invert_material_pass)
	INT_PROPERTY(ArrayGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, use_constant_offset)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, use_object_offset)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, use_relative_offset)
	BOOLEAN_PROPERTY(ArrayGpencilModifier, use_uniform_random_scale)


	ENUM_PROPERTY(mode_enum, BuildGpencilModifier, mode)
	ENUM_PROPERTY(transition_enum, BuildGpencilModifier, transition)
	FLOAT_PROPERTY(BuildGpencilModifier, start_delay)
	FLOAT_PROPERTY(BuildGpencilModifier, length)
	ENUM_PROPERTY(concurrent_time_alignment_enum, BuildGpencilModifier, concurrent_time_alignment)
	ENUM_PROPERTY(time_mode_enum, BuildGpencilModifier, time_mode)
	FLOAT_PROPERTY(BuildGpencilModifier, speed_factor)
	FLOAT_PROPERTY(BuildGpencilModifier, speed_maxgap)
	BOOLEAN_PROPERTY(BuildGpencilModifier, use_restrict_frame_range)
	BOOLEAN_PROPERTY(BuildGpencilModifier, use_percentage)
	FLOAT_PROPERTY(BuildGpencilModifier, percentage_factor)
	FLOAT_PROPERTY(BuildGpencilModifier, frame_start)
	FLOAT_PROPERTY(BuildGpencilModifier, frame_end)
	BOOLEAN_PROPERTY(BuildGpencilModifier, use_fading)
	FLOAT_PROPERTY(BuildGpencilModifier, fade_factor)
	STRING_PROPERTY(BuildGpencilModifier, target_vertex_group)
	FLOAT_PROPERTY(BuildGpencilModifier, fade_opacity_strength)
	FLOAT_PROPERTY(BuildGpencilModifier, fade_thickness_strength)
	POINTER_PROPERTY(Object, BuildGpencilModifier, object)
	STRING_PROPERTY(BuildGpencilModifier, layer)
	BOOLEAN_PROPERTY(BuildGpencilModifier, invert_layers)
	INT_PROPERTY(BuildGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(BuildGpencilModifier, invert_layer_pass)


	ENUM_PROPERTY(modify_color_enum, OpacityGpencilModifier, modify_color)
	STRING_PROPERTY(OpacityGpencilModifier, layer)
	POINTER_PROPERTY(Material, OpacityGpencilModifier, material)
	STRING_PROPERTY(OpacityGpencilModifier, vertex_group)
	FLOAT_PROPERTY(OpacityGpencilModifier, factor)
	FLOAT_PROPERTY(OpacityGpencilModifier, hardness)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, use_weight_factor)
	INT_PROPERTY(OpacityGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_vertex)
	INT_PROPERTY(OpacityGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, use_normalized_opacity)
	BOOLEAN_PROPERTY(OpacityGpencilModifier, use_custom_curve)
	POINTER_PROPERTY(CurveMapping, OpacityGpencilModifier, curve)


	STRING_PROPERTY(OutlineGpencilModifier, layer)
	POINTER_PROPERTY(Material, OutlineGpencilModifier, material)
	INT_PROPERTY(OutlineGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(OutlineGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(OutlineGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(OutlineGpencilModifier, invert_material_pass)
	INT_PROPERTY(OutlineGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(OutlineGpencilModifier, invert_layer_pass)
	INT_PROPERTY(OutlineGpencilModifier, thickness)
	FLOAT_PROPERTY(OutlineGpencilModifier, sample_length)
	INT_PROPERTY(OutlineGpencilModifier, subdivision)
	BOOLEAN_PROPERTY(OutlineGpencilModifier, use_keep_shape)
	POINTER_PROPERTY(Material, OutlineGpencilModifier, outline_material)
	POINTER_PROPERTY(Object, OutlineGpencilModifier, object)


	STRING_PROPERTY(LatticeGpencilModifier, layer)
	POINTER_PROPERTY(Material, LatticeGpencilModifier, material)
	STRING_PROPERTY(LatticeGpencilModifier, vertex_group)
	INT_PROPERTY(LatticeGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_vertex)
	INT_PROPERTY(LatticeGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(LatticeGpencilModifier, invert_layer_pass)
	POINTER_PROPERTY(Object, LatticeGpencilModifier, object)
	FLOAT_PROPERTY(LatticeGpencilModifier, strength)


	STRING_PROPERTY(MirrorGpencilModifier, layer)
	POINTER_PROPERTY(Material, MirrorGpencilModifier, material)
	INT_PROPERTY(MirrorGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, invert_material_pass)
	INT_PROPERTY(MirrorGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, invert_layer_pass)
	POINTER_PROPERTY(Object, MirrorGpencilModifier, object)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, use_clip)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, use_axis_x)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, use_axis_y)
	BOOLEAN_PROPERTY(MirrorGpencilModifier, use_axis_z)


	POINTER_PROPERTY(Object, HookGpencilModifier, object)
	STRING_PROPERTY(HookGpencilModifier, subtarget)
	STRING_PROPERTY(HookGpencilModifier, layer)
	POINTER_PROPERTY(Material, HookGpencilModifier, material)
	STRING_PROPERTY(HookGpencilModifier, vertex_group)
	INT_PROPERTY(HookGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_vertex)
	INT_PROPERTY(HookGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(HookGpencilModifier, invert_layer_pass)
	FLOAT_PROPERTY(HookGpencilModifier, strength)
	ENUM_PROPERTY(falloff_type_enum, HookGpencilModifier, falloff_type)
	FLOAT_PROPERTY(HookGpencilModifier, falloff_radius)
	POINTER_PROPERTY(CurveMapping, HookGpencilModifier, falloff_curve)
	FLOAT_ARRAY_PROPERTY(HookGpencilModifier, 3, center)
	FLOAT_ARRAY_PROPERTY(HookGpencilModifier, 16, matrix_inverse)
	BOOLEAN_PROPERTY(HookGpencilModifier, use_falloff_uniform)


	POINTER_PROPERTY(Object, ArmatureGpencilModifier, object)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, use_bone_envelopes)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, use_vertex_groups)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, use_deform_preserve_volume)
	STRING_PROPERTY(ArmatureGpencilModifier, vertex_group)
	BOOLEAN_PROPERTY(ArmatureGpencilModifier, invert_vertex_group)


	STRING_PROPERTY(MultiplyGpencilModifier, layer)
	POINTER_PROPERTY(Material, MultiplyGpencilModifier, material)
	INT_PROPERTY(MultiplyGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(MultiplyGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(MultiplyGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(MultiplyGpencilModifier, invert_material_pass)
	INT_PROPERTY(MultiplyGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(MultiplyGpencilModifier, invert_layer_pass)
	BOOLEAN_PROPERTY(MultiplyGpencilModifier, use_fade)
	INT_PROPERTY(MultiplyGpencilModifier, duplicates)
	FLOAT_PROPERTY(MultiplyGpencilModifier, distance)
	FLOAT_PROPERTY(MultiplyGpencilModifier, offset)
	FLOAT_PROPERTY(MultiplyGpencilModifier, fading_thickness)
	FLOAT_PROPERTY(MultiplyGpencilModifier, fading_opacity)
	FLOAT_PROPERTY(MultiplyGpencilModifier, fading_center)


	STRING_PROPERTY(TextureGpencilModifier, layer)
	BOOLEAN_PROPERTY(TextureGpencilModifier, invert_layers)
	POINTER_PROPERTY(Material, TextureGpencilModifier, material)
	BOOLEAN_PROPERTY(TextureGpencilModifier, invert_materials)
	STRING_PROPERTY(TextureGpencilModifier, vertex_group)
	BOOLEAN_PROPERTY(TextureGpencilModifier, invert_vertex)
	INT_PROPERTY(TextureGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(TextureGpencilModifier, invert_material_pass)
	INT_PROPERTY(TextureGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(TextureGpencilModifier, invert_layer_pass)
	FLOAT_PROPERTY(TextureGpencilModifier, uv_offset)
	FLOAT_PROPERTY(TextureGpencilModifier, uv_scale)
	FLOAT_PROPERTY(TextureGpencilModifier, alignment_rotation)
	FLOAT_PROPERTY(TextureGpencilModifier, fill_rotation)
	FLOAT_ARRAY_PROPERTY(TextureGpencilModifier, 2, fill_offset)
	FLOAT_PROPERTY(TextureGpencilModifier, fill_scale)
	ENUM_PROPERTY(fit_method_enum, TextureGpencilModifier, fit_method)
	ENUM_PROPERTY(mode_enum, TextureGpencilModifier, mode)


	STRING_PROPERTY(WeightAngleGpencilModifier, target_vertex_group)
	BOOLEAN_PROPERTY(WeightAngleGpencilModifier, use_multiply)
	BOOLEAN_PROPERTY(WeightAngleGpencilModifier, use_invert_output)
	FLOAT_PROPERTY(WeightAngleGpencilModifier, angle)
	ENUM_PROPERTY(axis_enum, WeightAngleGpencilModifier, axis)
	ENUM_PROPERTY(space_enum, WeightAngleGpencilModifier, space)
	STRING_PROPERTY(WeightAngleGpencilModifier, layer)
	POINTER_PROPERTY(Material, WeightAngleGpencilModifier, material)
	STRING_PROPERTY(WeightAngleGpencilModifier, vertex_group)
	FLOAT_PROPERTY(WeightAngleGpencilModifier, minimum_weight)
	INT_PROPERTY(WeightAngleGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(WeightAngleGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(WeightAngleGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(WeightAngleGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(WeightAngleGpencilModifier, invert_vertex)
	INT_PROPERTY(WeightAngleGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(WeightAngleGpencilModifier, invert_layer_pass)


	STRING_PROPERTY(WeightProxGpencilModifier, target_vertex_group)
	BOOLEAN_PROPERTY(WeightProxGpencilModifier, use_multiply)
	BOOLEAN_PROPERTY(WeightProxGpencilModifier, use_invert_output)
	STRING_PROPERTY(WeightProxGpencilModifier, layer)
	POINTER_PROPERTY(Material, WeightProxGpencilModifier, material)
	STRING_PROPERTY(WeightProxGpencilModifier, vertex_group)
	POINTER_PROPERTY(Object, WeightProxGpencilModifier, object)
	FLOAT_PROPERTY(WeightProxGpencilModifier, distance_start)
	FLOAT_PROPERTY(WeightProxGpencilModifier, minimum_weight)
	FLOAT_PROPERTY(WeightProxGpencilModifier, distance_end)
	INT_PROPERTY(WeightProxGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(WeightProxGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(WeightProxGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(WeightProxGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(WeightProxGpencilModifier, invert_vertex)
	INT_PROPERTY(WeightProxGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(WeightProxGpencilModifier, invert_layer_pass)


	BOOLEAN_PROPERTY(LineartGpencilModifier, use_custom_camera)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_fuzzy_intersections)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_fuzzy_all)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_object_instances)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_edge_overlap)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_clip_plane_boundaries)
	FLOAT_PROPERTY(LineartGpencilModifier, crease_threshold)
	FLOAT_PROPERTY(LineartGpencilModifier, split_angle)
	FLOAT_PROPERTY(LineartGpencilModifier, smooth_tolerance)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_loose_as_contour)
	BOOLEAN_PROPERTY(LineartGpencilModifier, invert_source_vertex_group)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_output_vertex_group_match_by_name)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_face_mark)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_face_mark_invert)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_face_mark_boundaries)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_face_mark_keep_contour)
	FLOAT_PROPERTY(LineartGpencilModifier, chaining_image_threshold)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_loose_edge_chain)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_geometry_space_chain)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_detail_preserve)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_overlap_edge_type_support)
	FLOAT_PROPERTY(LineartGpencilModifier, stroke_depth_offset)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_offset_towards_custom_camera)
	POINTER_PROPERTY(Object, LineartGpencilModifier, source_camera)
	POINTER_PROPERTY(Object, LineartGpencilModifier, light_contour_object)
	ENUM_PROPERTY(source_type_enum, LineartGpencilModifier, source_type)
	POINTER_PROPERTY(Object, LineartGpencilModifier, source_object)
	POINTER_PROPERTY(Collection, LineartGpencilModifier, source_collection)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_contour)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_loose)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_crease)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_material)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_edge_mark)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_intersection)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_light_contour)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_shadow)
	ENUM_PROPERTY(shadow_region_filtering_enum, LineartGpencilModifier, shadow_region_filtering)
	ENUM_PROPERTY(silhouette_filtering_enum, LineartGpencilModifier, silhouette_filtering)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_multiple_levels)
	INT_PROPERTY(LineartGpencilModifier, level_start)
	INT_PROPERTY(LineartGpencilModifier, level_end)
	POINTER_PROPERTY(Material, LineartGpencilModifier, target_material)
	STRING_PROPERTY(LineartGpencilModifier, target_layer)
	STRING_PROPERTY(LineartGpencilModifier, source_vertex_group)
	STRING_PROPERTY(LineartGpencilModifier, vertex_group)
	BOOLEAN_PROPERTY(LineartGpencilModifier, is_baked)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_cache)
	FLOAT_PROPERTY(LineartGpencilModifier, overscan)
	INT_PROPERTY(LineartGpencilModifier, thickness)
	FLOAT_PROPERTY(LineartGpencilModifier, opacity)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_material_mask)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_material_mask_match)
	BOOLEAN_ARRAY_PROPERTY(LineartGpencilModifier, 8, use_material_mask_bits)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_intersection_match)
	BOOLEAN_ARRAY_PROPERTY(LineartGpencilModifier, 8, use_intersection_mask)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_crease_on_smooth)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_crease_on_sharp)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_image_boundary_trimming)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_back_face_culling)
	FLOAT_PROPERTY(LineartGpencilModifier, shadow_camera_near)
	FLOAT_PROPERTY(LineartGpencilModifier, shadow_camera_far)
	FLOAT_PROPERTY(LineartGpencilModifier, shadow_camera_size)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_invert_collection)
	BOOLEAN_PROPERTY(LineartGpencilModifier, use_invert_silhouette)


	FLOAT_PROPERTY(LengthGpencilModifier, start_factor)
	FLOAT_PROPERTY(LengthGpencilModifier, end_factor)
	FLOAT_PROPERTY(LengthGpencilModifier, start_length)
	FLOAT_PROPERTY(LengthGpencilModifier, end_length)
	FLOAT_PROPERTY(LengthGpencilModifier, random_start_factor)
	FLOAT_PROPERTY(LengthGpencilModifier, random_end_factor)
	FLOAT_PROPERTY(LengthGpencilModifier, random_offset)
	BOOLEAN_PROPERTY(LengthGpencilModifier, use_random)
	INT_PROPERTY(LengthGpencilModifier, seed)
	INT_PROPERTY(LengthGpencilModifier, step)
	FLOAT_PROPERTY(LengthGpencilModifier, overshoot_factor)
	ENUM_PROPERTY(mode_enum, LengthGpencilModifier, mode)
	BOOLEAN_PROPERTY(LengthGpencilModifier, use_curvature)
	BOOLEAN_PROPERTY(LengthGpencilModifier, invert_curvature)
	FLOAT_PROPERTY(LengthGpencilModifier, point_density)
	FLOAT_PROPERTY(LengthGpencilModifier, segment_influence)
	FLOAT_PROPERTY(LengthGpencilModifier, max_angle)
	STRING_PROPERTY(LengthGpencilModifier, layer)
	POINTER_PROPERTY(Material, LengthGpencilModifier, material)
	INT_PROPERTY(LengthGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(LengthGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(LengthGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(LengthGpencilModifier, invert_material_pass)
	INT_PROPERTY(LengthGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(LengthGpencilModifier, invert_layer_pass)


	POINTER_PROPERTY(Struct, DashGpencilModifierSegment, rna_type)
	STRING_PROPERTY(DashGpencilModifierSegment, name)
	INT_PROPERTY(DashGpencilModifierSegment, dash)
	INT_PROPERTY(DashGpencilModifierSegment, gap)
	FLOAT_PROPERTY(DashGpencilModifierSegment, radius)
	FLOAT_PROPERTY(DashGpencilModifierSegment, opacity)
	INT_PROPERTY(DashGpencilModifierSegment, material_index)
	BOOLEAN_PROPERTY(DashGpencilModifierSegment, use_cyclic)



	INT_PROPERTY(DashGpencilModifierData, segment_active_index)
	INT_PROPERTY(DashGpencilModifierData, dash_offset)
	STRING_PROPERTY(DashGpencilModifierData, layer)
	POINTER_PROPERTY(Material, DashGpencilModifierData, material)
	INT_PROPERTY(DashGpencilModifierData, pass_index)
	BOOLEAN_PROPERTY(DashGpencilModifierData, invert_layers)
	BOOLEAN_PROPERTY(DashGpencilModifierData, invert_materials)
	BOOLEAN_PROPERTY(DashGpencilModifierData, invert_material_pass)
	INT_PROPERTY(DashGpencilModifierData, layer_pass)
	BOOLEAN_PROPERTY(DashGpencilModifierData, invert_layer_pass)


	ENUM_PROPERTY(wrap_method_enum, ShrinkwrapGpencilModifier, wrap_method)
	ENUM_PROPERTY(wrap_mode_enum, ShrinkwrapGpencilModifier, wrap_mode)
	ENUM_PROPERTY(cull_face_enum, ShrinkwrapGpencilModifier, cull_face)
	POINTER_PROPERTY(Object, ShrinkwrapGpencilModifier, target)
	POINTER_PROPERTY(Object, ShrinkwrapGpencilModifier, auxiliary_target)
	FLOAT_PROPERTY(ShrinkwrapGpencilModifier, offset)
	FLOAT_PROPERTY(ShrinkwrapGpencilModifier, project_limit)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, use_project_x)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, use_project_y)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, use_project_z)
	INT_PROPERTY(ShrinkwrapGpencilModifier, subsurf_levels)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, use_negative_direction)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, use_positive_direction)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, use_invert_cull)
	STRING_PROPERTY(ShrinkwrapGpencilModifier, layer)
	POINTER_PROPERTY(Material, ShrinkwrapGpencilModifier, material)
	STRING_PROPERTY(ShrinkwrapGpencilModifier, vertex_group)
	INT_PROPERTY(ShrinkwrapGpencilModifier, pass_index)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, invert_vertex)
	INT_PROPERTY(ShrinkwrapGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(ShrinkwrapGpencilModifier, invert_layer_pass)
	FLOAT_PROPERTY(ShrinkwrapGpencilModifier, smooth_factor)
	INT_PROPERTY(ShrinkwrapGpencilModifier, smooth_step)


	STRING_PROPERTY(EnvelopeGpencilModifier, layer)
	POINTER_PROPERTY(Material, EnvelopeGpencilModifier, material)
	STRING_PROPERTY(EnvelopeGpencilModifier, vertex_group)
	INT_PROPERTY(EnvelopeGpencilModifier, pass_index)
	INT_PROPERTY(EnvelopeGpencilModifier, spread)
	ENUM_PROPERTY(mode_enum, EnvelopeGpencilModifier, mode)
	INT_PROPERTY(EnvelopeGpencilModifier, mat_nr)
	FLOAT_PROPERTY(EnvelopeGpencilModifier, thickness)
	FLOAT_PROPERTY(EnvelopeGpencilModifier, strength)
	INT_PROPERTY(EnvelopeGpencilModifier, skip)
	BOOLEAN_PROPERTY(EnvelopeGpencilModifier, invert_layers)
	BOOLEAN_PROPERTY(EnvelopeGpencilModifier, invert_materials)
	BOOLEAN_PROPERTY(EnvelopeGpencilModifier, invert_material_pass)
	BOOLEAN_PROPERTY(EnvelopeGpencilModifier, invert_vertex)
	INT_PROPERTY(EnvelopeGpencilModifier, layer_pass)
	BOOLEAN_PROPERTY(EnvelopeGpencilModifier, invert_layer_pass)


	POINTER_PROPERTY(Struct, ShaderFx, rna_type)
	STRING_PROPERTY(ShaderFx, name)
	ENUM_PROPERTY(type_enum, ShaderFx, type)
	BOOLEAN_PROPERTY(ShaderFx, show_viewport)
	BOOLEAN_PROPERTY(ShaderFx, show_render)
	BOOLEAN_PROPERTY(ShaderFx, show_in_editmode)
	BOOLEAN_PROPERTY(ShaderFx, show_expanded)


	FLOAT_ARRAY_PROPERTY(ShaderFxBlur, 2, size)
	INT_PROPERTY(ShaderFxBlur, samples)
	FLOAT_PROPERTY(ShaderFxBlur, rotation)
	BOOLEAN_PROPERTY(ShaderFxBlur, use_dof_mode)


	FLOAT_PROPERTY(ShaderFxColorize, factor)
	FLOAT_ARRAY_PROPERTY(ShaderFxColorize, 4, low_color)
	FLOAT_ARRAY_PROPERTY(ShaderFxColorize, 4, high_color)
	ENUM_PROPERTY(mode_enum, ShaderFxColorize, mode)


	ENUM_PROPERTY(orientation_enum, ShaderFxWave, orientation)
	FLOAT_PROPERTY(ShaderFxWave, amplitude)
	FLOAT_PROPERTY(ShaderFxWave, period)
	FLOAT_PROPERTY(ShaderFxWave, phase)


	INT_ARRAY_PROPERTY(ShaderFxPixel, 2, size)
	BOOLEAN_PROPERTY(ShaderFxPixel, use_antialiasing)


	INT_ARRAY_PROPERTY(ShaderFxRim, 2, offset)
	FLOAT_ARRAY_PROPERTY(ShaderFxRim, 3, rim_color)
	FLOAT_ARRAY_PROPERTY(ShaderFxRim, 3, mask_color)
	ENUM_PROPERTY(mode_enum, ShaderFxRim, mode)
	INT_ARRAY_PROPERTY(ShaderFxRim, 2, blur)
	INT_PROPERTY(ShaderFxRim, samples)


	POINTER_PROPERTY(Object, ShaderFxShadow, object)
	INT_ARRAY_PROPERTY(ShaderFxShadow, 2, offset)
	FLOAT_ARRAY_PROPERTY(ShaderFxShadow, 2, scale)
	FLOAT_ARRAY_PROPERTY(ShaderFxShadow, 4, shadow_color)
	ENUM_PROPERTY(orientation_enum, ShaderFxShadow, orientation)
	FLOAT_PROPERTY(ShaderFxShadow, amplitude)
	FLOAT_PROPERTY(ShaderFxShadow, period)
	FLOAT_PROPERTY(ShaderFxShadow, phase)
	FLOAT_PROPERTY(ShaderFxShadow, rotation)
	INT_ARRAY_PROPERTY(ShaderFxShadow, 2, blur)
	INT_PROPERTY(ShaderFxShadow, samples)
	BOOLEAN_PROPERTY(ShaderFxShadow, use_object)
	BOOLEAN_PROPERTY(ShaderFxShadow, use_wave)


	FLOAT_ARRAY_PROPERTY(ShaderFxGlow, 3, glow_color)
	FLOAT_PROPERTY(ShaderFxGlow, opacity)
	FLOAT_ARRAY_PROPERTY(ShaderFxGlow, 3, select_color)
	ENUM_PROPERTY(mode_enum, ShaderFxGlow, mode)
	FLOAT_PROPERTY(ShaderFxGlow, threshold)
	FLOAT_ARRAY_PROPERTY(ShaderFxGlow, 2, size)
	INT_PROPERTY(ShaderFxGlow, samples)
	BOOLEAN_PROPERTY(ShaderFxGlow, use_glow_under)
	FLOAT_PROPERTY(ShaderFxGlow, rotation)
	ENUM_PROPERTY(blend_mode_enum, ShaderFxGlow, blend_mode)


	INT_PROPERTY(ShaderFxSwirl, radius)
	FLOAT_PROPERTY(ShaderFxSwirl, angle)
	BOOLEAN_PROPERTY(ShaderFxSwirl, use_transparent)
	POINTER_PROPERTY(Object, ShaderFxSwirl, object)


	BOOLEAN_PROPERTY(ShaderFxFlip, use_flip_x)
	BOOLEAN_PROPERTY(ShaderFxFlip, use_flip_y)


	POINTER_PROPERTY(Struct, NlaTrack, rna_type)

	BOOLEAN_PROPERTY(NlaTrack, is_override_data)
	STRING_PROPERTY(NlaTrack, name)
	BOOLEAN_PROPERTY(NlaTrack, active)
	BOOLEAN_PROPERTY(NlaTrack, is_solo)
	BOOLEAN_PROPERTY(NlaTrack, select)
	BOOLEAN_PROPERTY(NlaTrack, mute)
	BOOLEAN_PROPERTY(NlaTrack, lock)


	POINTER_PROPERTY(Struct, NlaStrips, rna_type)

	inline NlaStrip NlaStrips::create(void *main, Context C, const char * name, int start, Action& action) {
		PointerRNA result;
		::NlaStrip *retdata = NlaStrips_new_func((::ID *) ptr.owner_id, (::NlaTrack *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, nullptr, name, start, (::bAction *) action.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NlaStrip, retdata);
		return NlaStrip(result);
	}

	inline void NlaStrips::remove(void *main, Context C, NlaStrip& strip) {
		NlaStrips_remove_func((::ID *) ptr.owner_id, (::NlaTrack *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &strip.ptr);
	}


	POINTER_PROPERTY(Struct, NlaStrip, rna_type)
	STRING_PROPERTY(NlaStrip, name)
	ENUM_PROPERTY(type_enum, NlaStrip, type)
	ENUM_PROPERTY(extrapolation_enum, NlaStrip, extrapolation)
	ENUM_PROPERTY(blend_type_enum, NlaStrip, blend_type)
	FLOAT_PROPERTY(NlaStrip, frame_start)
	FLOAT_PROPERTY(NlaStrip, frame_end)
	FLOAT_PROPERTY(NlaStrip, frame_start_raw)
	FLOAT_PROPERTY(NlaStrip, frame_end_raw)
	FLOAT_PROPERTY(NlaStrip, frame_start_ui)
	FLOAT_PROPERTY(NlaStrip, frame_end_ui)
	FLOAT_PROPERTY(NlaStrip, blend_in)
	FLOAT_PROPERTY(NlaStrip, blend_out)
	BOOLEAN_PROPERTY(NlaStrip, use_auto_blend)
	POINTER_PROPERTY(Action, NlaStrip, action)
	FLOAT_PROPERTY(NlaStrip, action_frame_start)
	FLOAT_PROPERTY(NlaStrip, action_frame_end)
	FLOAT_PROPERTY(NlaStrip, repeat)
	FLOAT_PROPERTY(NlaStrip, scale)



	FLOAT_PROPERTY(NlaStrip, influence)
	FLOAT_PROPERTY(NlaStrip, strip_time)
	BOOLEAN_PROPERTY(NlaStrip, use_animated_influence)
	BOOLEAN_PROPERTY(NlaStrip, use_animated_time)
	BOOLEAN_PROPERTY(NlaStrip, use_animated_time_cyclic)
	BOOLEAN_PROPERTY(NlaStrip, active)
	BOOLEAN_PROPERTY(NlaStrip, select)
	BOOLEAN_PROPERTY(NlaStrip, mute)
	BOOLEAN_PROPERTY(NlaStrip, use_reverse)
	BOOLEAN_PROPERTY(NlaStrip, use_sync_length)


	POINTER_PROPERTY(Struct, NlaStripFCurves, rna_type)

	inline FCurve NlaStripFCurves::find(const char * data_path, int index) {
		PointerRNA result;
		::FCurve *retdata = NlaStripFCurves_find_func((::NlaStrip *) this->ptr.data, nullptr, data_path, index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_FCurve, retdata);
		return FCurve(result);
	}


	POINTER_PROPERTY(Struct, Node, rna_type)
	ENUM_PROPERTY(type_enum, Node, type)
	FLOAT_ARRAY_PROPERTY(Node, 2, location)
	FLOAT_PROPERTY(Node, width)
	FLOAT_PROPERTY(Node, height)
	FLOAT_ARRAY_PROPERTY(Node, 2, dimensions)
	STRING_PROPERTY(Node, name)
	STRING_PROPERTY(Node, label)



	POINTER_PROPERTY(Node, Node, parent)
	BOOLEAN_PROPERTY(Node, use_custom_color)
	FLOAT_ARRAY_PROPERTY(Node, 3, color)
	BOOLEAN_PROPERTY(Node, select)
	BOOLEAN_PROPERTY(Node, show_options)
	BOOLEAN_PROPERTY(Node, show_preview)
	BOOLEAN_PROPERTY(Node, hide)
	BOOLEAN_PROPERTY(Node, mute)
	BOOLEAN_PROPERTY(Node, show_texture)
	STRING_PROPERTY(Node, bl_idname)
	STRING_PROPERTY(Node, bl_label)
	STRING_PROPERTY(Node, bl_description)
	ENUM_PROPERTY(bl_icon_enum, Node, bl_icon)
	ENUM_PROPERTY(bl_static_type_enum, Node, bl_static_type)
	FLOAT_PROPERTY(Node, bl_width_default)
	FLOAT_PROPERTY(Node, bl_width_min)
	FLOAT_PROPERTY(Node, bl_width_max)
	FLOAT_PROPERTY(Node, bl_height_default)
	FLOAT_PROPERTY(Node, bl_height_min)
	FLOAT_PROPERTY(Node, bl_height_max)

	inline void Node::socket_value_update(Context& context) {
		Node_socket_value_update_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::bContext *) context.ptr.data);
	}

	inline bool Node::is_registered_node_type() {
		return Node_is_registered_node_type_func(this->ptr.type);
	}


	POINTER_PROPERTY(Struct, NodeInputs, rna_type)

	inline NodeSocket NodeInputs::create(void *main, const char * type, const char * name, const char * identifier) {
		PointerRNA result;
		::bNodeSocket *retdata = NodeInputs_new_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, type, name, identifier);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeSocket, retdata);
		return NodeSocket(result);
	}

	inline void NodeInputs::remove(void *main, NodeSocket& socket) {
		NodeInputs_remove_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, (::bNodeSocket *) socket.ptr.data);
	}

	inline void NodeInputs::clear(void *main) {
		NodeInputs_clear_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline void NodeInputs::move(void *main, int from_index, int to_index) {
		NodeInputs_move_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, NodeOutputs, rna_type)

	inline NodeSocket NodeOutputs::create(void *main, const char * type, const char * name, const char * identifier) {
		PointerRNA result;
		::bNodeSocket *retdata = NodeOutputs_new_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, type, name, identifier);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeSocket, retdata);
		return NodeSocket(result);
	}

	inline void NodeOutputs::remove(void *main, NodeSocket& socket) {
		NodeOutputs_remove_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, (::bNodeSocket *) socket.ptr.data);
	}

	inline void NodeOutputs::clear(void *main) {
		NodeOutputs_clear_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline void NodeOutputs::move(void *main, int from_index, int to_index) {
		NodeOutputs_move_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, NodeLink, rna_type)
	BOOLEAN_PROPERTY(NodeLink, is_valid)
	BOOLEAN_PROPERTY(NodeLink, is_muted)
	POINTER_PROPERTY(Node, NodeLink, from_node)
	POINTER_PROPERTY(Node, NodeLink, to_node)
	POINTER_PROPERTY(NodeSocket, NodeLink, from_socket)
	POINTER_PROPERTY(NodeSocket, NodeLink, to_socket)
	BOOLEAN_PROPERTY(NodeLink, is_hidden)


	POINTER_PROPERTY(Struct, NodeInternalSocketTemplate, rna_type)
	STRING_PROPERTY(NodeInternalSocketTemplate, name)
	STRING_PROPERTY(NodeInternalSocketTemplate, identifier)
	ENUM_PROPERTY(type_enum, NodeInternalSocketTemplate, type)



	inline bool NodeInternal::poll(NodeTree& node_tree) {
		return NodeInternal_poll_func(this->ptr.type, (::bNodeTree *) node_tree.ptr.data);
	}

	inline bool NodeInternal::poll_instance(NodeTree& node_tree) {
		return NodeInternal_poll_instance_func((::bNode *) this->ptr.data, (::bNodeTree *) node_tree.ptr.data);
	}

	inline void NodeInternal::update(void *main) {
		NodeInternal_update_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main);
	}

	inline void NodeInternal::draw_buttons(Context& context, UILayout& layout) {
		NodeInternal_draw_buttons_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeInternal::draw_buttons_ext(Context& context, UILayout& layout) {
		NodeInternal_draw_buttons_ext_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}





	inline void CompositorNode::tag_need_exec() {
		CompositorNode_tag_need_exec_func((::bNode *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, CryptomatteEntry, rna_type)
	FLOAT_PROPERTY(CryptomatteEntry, encoded_hash)
	STRING_PROPERTY(CryptomatteEntry, name)








	FLOAT_ARRAY_PROPERTY(NodeTree, 2, view_center)
	POINTER_PROPERTY(AnimData, NodeTree, animation_data)


	POINTER_PROPERTY(GreasePencil, NodeTree, grease_pencil)
	ENUM_PROPERTY(type_enum, NodeTree, type)
	POINTER_PROPERTY(NodeTreeInterface, NodeTree, interface)
	STRING_PROPERTY(NodeTree, bl_idname)
	STRING_PROPERTY(NodeTree, bl_label)
	STRING_PROPERTY(NodeTree, bl_description)
	ENUM_PROPERTY(bl_icon_enum, NodeTree, bl_icon)

	inline void NodeTree::interface_update(Context& context) {
		NodeTree_interface_update_func((::bNodeTree *) this->ptr.data, (::bContext *) context.ptr.data);
	}

	inline bool NodeTree::contains_tree(NodeTree& sub_tree) {
		return NodeTree_contains_tree_func((::bNodeTree *) this->ptr.data, (::bNodeTree *) sub_tree.ptr.data);
	}


	POINTER_PROPERTY(Struct, Nodes, rna_type)
	POINTER_PROPERTY(Node, Nodes, active)

	inline Node Nodes::create(Context C, const char * type) {
		PointerRNA result;
		::bNode *retdata = Nodes_new_func((::bNodeTree *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Node, retdata);
		return Node(result);
	}

	inline void Nodes::remove(void *main, Node& node) {
		Nodes_remove_func((::bNodeTree *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &node.ptr);
	}

	inline void Nodes::clear(void *main) {
		Nodes_clear_func((::bNodeTree *) this->ptr.data, (::Main *) main, nullptr);
	}


	POINTER_PROPERTY(Struct, NodeLinks, rna_type)

	inline NodeLink NodeLinks::create(void *main, NodeSocket& input, NodeSocket& output, bool verify_limits) {
		PointerRNA result;
		::bNodeLink *retdata = NodeLinks_new_func((::bNodeTree *) this->ptr.data, (::Main *) main, nullptr, (::bNodeSocket *) input.ptr.data, (::bNodeSocket *) output.ptr.data, verify_limits);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeLink, retdata);
		return NodeLink(result);
	}

	inline void NodeLinks::remove(void *main, NodeLink& link) {
		NodeLinks_remove_func((::bNodeTree *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &link.ptr);
	}

	inline void NodeLinks::clear(void *main) {
		NodeLinks_clear_func((::bNodeTree *) this->ptr.data, (::Main *) main, nullptr);
	}


	ENUM_PROPERTY(precision_enum, CompositorNodeTree, precision)
	ENUM_PROPERTY(execution_mode_enum, CompositorNodeTree, execution_mode)
	ENUM_PROPERTY(render_quality_enum, CompositorNodeTree, render_quality)
	ENUM_PROPERTY(edit_quality_enum, CompositorNodeTree, edit_quality)
	ENUM_PROPERTY(chunk_size_enum, CompositorNodeTree, chunk_size)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_opencl)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_groupnode_buffer)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_two_pass)
	BOOLEAN_PROPERTY(CompositorNodeTree, use_viewer_border)



	inline ShaderNode ShaderNodeTree::get_output_node(int target) {
		PointerRNA result;
		::bNode *retdata = ShaderNodeTree_get_output_node_func((::bNodeTree *) this->ptr.data, target);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ShaderNode, retdata);
		return ShaderNode(result);
	}




	BOOLEAN_PROPERTY(GeometryNodeTree, is_tool)
	BOOLEAN_PROPERTY(GeometryNodeTree, is_modifier)
	BOOLEAN_PROPERTY(GeometryNodeTree, is_mode_object)
	BOOLEAN_PROPERTY(GeometryNodeTree, is_mode_edit)
	BOOLEAN_PROPERTY(GeometryNodeTree, is_mode_sculpt)
	BOOLEAN_PROPERTY(GeometryNodeTree, is_type_mesh)
	BOOLEAN_PROPERTY(GeometryNodeTree, is_type_curve)
	BOOLEAN_PROPERTY(GeometryNodeTree, is_type_point_cloud)


	POINTER_PROPERTY(Struct, SimulationStateItem, rna_type)
	STRING_PROPERTY(SimulationStateItem, name)
	ENUM_PROPERTY(socket_type_enum, SimulationStateItem, socket_type)
	FLOAT_ARRAY_PROPERTY(SimulationStateItem, 4, color)
	ENUM_PROPERTY(attribute_domain_enum, SimulationStateItem, attribute_domain)


	POINTER_PROPERTY(Struct, RepeatItem, rna_type)
	STRING_PROPERTY(RepeatItem, name)
	ENUM_PROPERTY(socket_type_enum, RepeatItem, socket_type)
	FLOAT_ARRAY_PROPERTY(RepeatItem, 4, color)


	POINTER_PROPERTY(Text, NodeFrame, text)
	BOOLEAN_PROPERTY(NodeFrame, shrink)
	INT_PROPERTY(NodeFrame, label_size)

	inline bool NodeFrame::is_registered_node_type() {
		return NodeFrame_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeFrame::input_template(int index) {
		PointerRNA result;
		result = NodeFrame_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeFrame::output_template(int index) {
		PointerRNA result;
		result = NodeFrame_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, NodeGroup, node_tree)

	inline bool NodeGroup::is_registered_node_type() {
		return NodeGroup_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeGroup::input_template(int index) {
		PointerRNA result;
		result = NodeGroup_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeGroup::output_template(int index) {
		PointerRNA result;
		result = NodeGroup_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool NodeGroupInput::is_registered_node_type() {
		return NodeGroupInput_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeGroupInput::input_template(int index) {
		PointerRNA result;
		result = NodeGroupInput_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeGroupInput::output_template(int index) {
		PointerRNA result;
		result = NodeGroupInput_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(NodeGroupOutput, is_active_output)

	inline bool NodeGroupOutput::is_registered_node_type() {
		return NodeGroupOutput_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeGroupOutput::input_template(int index) {
		PointerRNA result;
		result = NodeGroupOutput_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeGroupOutput::output_template(int index) {
		PointerRNA result;
		result = NodeGroupOutput_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool NodeReroute::is_registered_node_type() {
		return NodeReroute_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate NodeReroute::input_template(int index) {
		PointerRNA result;
		result = NodeReroute_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate NodeReroute::output_template(int index) {
		PointerRNA result;
		result = NodeReroute_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeRGB::is_registered_node_type() {
		return ShaderNodeRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeValue::is_registered_node_type() {
		return ShaderNodeValue_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeValue::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeValue_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeValue::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeValue_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(blend_type_enum, ShaderNodeMixRGB, blend_type)
	BOOLEAN_PROPERTY(ShaderNodeMixRGB, use_alpha)
	BOOLEAN_PROPERTY(ShaderNodeMixRGB, use_clamp)

	inline bool ShaderNodeMixRGB::is_registered_node_type() {
		return ShaderNodeMixRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(ColorRamp, ShaderNodeValToRGB, color_ramp)

	inline bool ShaderNodeValToRGB::is_registered_node_type() {
		return ShaderNodeValToRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeValToRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeValToRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeValToRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeValToRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeRGBToBW::is_registered_node_type() {
		return ShaderNodeRGBToBW_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBToBW::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBToBW_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBToBW::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBToBW_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeShaderToRGB::is_registered_node_type() {
		return ShaderNodeShaderToRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeShaderToRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeShaderToRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeShaderToRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeShaderToRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeNormal::is_registered_node_type() {
		return ShaderNodeNormal_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormal::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormal_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormal::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormal_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeGamma::is_registered_node_type() {
		return ShaderNodeGamma_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeGamma::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeGamma_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeGamma::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeGamma_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBrightContrast::is_registered_node_type() {
		return ShaderNodeBrightContrast_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBrightContrast::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBrightContrast_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBrightContrast::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBrightContrast_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(vector_type_enum, ShaderNodeMapping, vector_type)

	inline bool ShaderNodeMapping::is_registered_node_type() {
		return ShaderNodeMapping_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMapping::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMapping_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMapping::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMapping_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, ShaderNodeVectorCurve, mapping)

	inline bool ShaderNodeVectorCurve::is_registered_node_type() {
		return ShaderNodeVectorCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorCurve::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorCurve::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, ShaderNodeRGBCurve, mapping)

	inline bool ShaderNodeRGBCurve::is_registered_node_type() {
		return ShaderNodeRGBCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBCurve::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeRGBCurve::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeRGBCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCameraData::is_registered_node_type() {
		return ShaderNodeCameraData_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCameraData::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCameraData_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCameraData::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCameraData_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeMapRange, clamp)
	ENUM_PROPERTY(interpolation_type_enum, ShaderNodeMapRange, interpolation_type)
	ENUM_PROPERTY(data_type_enum, ShaderNodeMapRange, data_type)

	inline bool ShaderNodeMapRange::is_registered_node_type() {
		return ShaderNodeMapRange_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMapRange::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMapRange_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMapRange::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMapRange_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(clamp_type_enum, ShaderNodeClamp, clamp_type)

	inline bool ShaderNodeClamp::is_registered_node_type() {
		return ShaderNodeClamp_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeClamp::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeClamp_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeClamp::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeClamp_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, ShaderNodeMath, operation)
	BOOLEAN_PROPERTY(ShaderNodeMath, use_clamp)

	inline bool ShaderNodeMath::is_registered_node_type() {
		return ShaderNodeMath_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMath::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMath_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMath::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMath_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, ShaderNodeVectorMath, operation)

	inline bool ShaderNodeVectorMath::is_registered_node_type() {
		return ShaderNodeVectorMath_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorMath::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorMath_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorMath::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorMath_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSqueeze::is_registered_node_type() {
		return ShaderNodeSqueeze_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSqueeze::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSqueeze_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSqueeze::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSqueeze_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeInvert::is_registered_node_type() {
		return ShaderNodeInvert_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeInvert::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeInvert_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeInvert::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeInvert_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSeparateRGB::is_registered_node_type() {
		return ShaderNodeSeparateRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCombineRGB::is_registered_node_type() {
		return ShaderNodeCombineRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineRGB::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineRGB::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeHueSaturation::is_registered_node_type() {
		return ShaderNodeHueSaturation_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeHueSaturation::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeHueSaturation_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeHueSaturation::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeHueSaturation_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputMaterial, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputMaterial, target)

	inline bool ShaderNodeOutputMaterial::is_registered_node_type() {
		return ShaderNodeOutputMaterial_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputMaterial::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputMaterial_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputMaterial::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputMaterial_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeEeveeSpecular::is_registered_node_type() {
		return ShaderNodeEeveeSpecular_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeEeveeSpecular::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeEeveeSpecular_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeEeveeSpecular::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeEeveeSpecular_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputLight, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputLight, target)

	inline bool ShaderNodeOutputLight::is_registered_node_type() {
		return ShaderNodeOutputLight_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLight::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLight_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLight::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLight_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputWorld, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputWorld, target)

	inline bool ShaderNodeOutputWorld::is_registered_node_type() {
		return ShaderNodeOutputWorld_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputWorld::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputWorld_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputWorld::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputWorld_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeOutputLineStyle, is_active_output)
	ENUM_PROPERTY(target_enum, ShaderNodeOutputLineStyle, target)
	ENUM_PROPERTY(blend_type_enum, ShaderNodeOutputLineStyle, blend_type)
	BOOLEAN_PROPERTY(ShaderNodeOutputLineStyle, use_alpha)
	BOOLEAN_PROPERTY(ShaderNodeOutputLineStyle, use_clamp)

	inline bool ShaderNodeOutputLineStyle::is_registered_node_type() {
		return ShaderNodeOutputLineStyle_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLineStyle::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLineStyle_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputLineStyle::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputLineStyle_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeFresnel::is_registered_node_type() {
		return ShaderNodeFresnel_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeFresnel::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeFresnel_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeFresnel::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeFresnel_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeLayerWeight::is_registered_node_type() {
		return ShaderNodeLayerWeight_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeLayerWeight::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeLayerWeight_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeLayerWeight::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeLayerWeight_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeMixShader::is_registered_node_type() {
		return ShaderNodeMixShader_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixShader::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixShader_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMixShader::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMixShader_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeAddShader::is_registered_node_type() {
		return ShaderNodeAddShader_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeAddShader::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeAddShader_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeAddShader::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeAddShader_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(attribute_type_enum, ShaderNodeAttribute, attribute_type)
	STRING_PROPERTY(ShaderNodeAttribute, attribute_name)

	inline bool ShaderNodeAttribute::is_registered_node_type() {
		return ShaderNodeAttribute_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeAttribute::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeAttribute_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeAttribute::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeAttribute_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(ShaderNodeAmbientOcclusion, samples)
	BOOLEAN_PROPERTY(ShaderNodeAmbientOcclusion, inside)
	BOOLEAN_PROPERTY(ShaderNodeAmbientOcclusion, only_local)

	inline bool ShaderNodeAmbientOcclusion::is_registered_node_type() {
		return ShaderNodeAmbientOcclusion_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeAmbientOcclusion::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeAmbientOcclusion_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeAmbientOcclusion::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeAmbientOcclusion_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBackground::is_registered_node_type() {
		return ShaderNodeBackground_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBackground::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBackground_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBackground::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBackground_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeHoldout::is_registered_node_type() {
		return ShaderNodeHoldout_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeHoldout::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeHoldout_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeHoldout::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeHoldout_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBsdfDiffuse::is_registered_node_type() {
		return ShaderNodeBsdfDiffuse_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfDiffuse::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfDiffuse_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfDiffuse::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfDiffuse_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfPrincipled, distribution)
	ENUM_PROPERTY(subsurface_method_enum, ShaderNodeBsdfPrincipled, subsurface_method)

	inline bool ShaderNodeBsdfPrincipled::is_registered_node_type() {
		return ShaderNodeBsdfPrincipled_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfPrincipled::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfPrincipled_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfPrincipled::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfPrincipled_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfAnisotropic, distribution)

	inline bool ShaderNodeBsdfAnisotropic::is_registered_node_type() {
		return ShaderNodeBsdfAnisotropic_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfAnisotropic::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfAnisotropic_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfAnisotropic::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfAnisotropic_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfGlass, distribution)

	inline bool ShaderNodeBsdfGlass::is_registered_node_type() {
		return ShaderNodeBsdfGlass_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfGlass::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfGlass_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfGlass::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfGlass_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfRefraction, distribution)

	inline bool ShaderNodeBsdfRefraction::is_registered_node_type() {
		return ShaderNodeBsdfRefraction_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfRefraction::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfRefraction_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfRefraction::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfRefraction_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBsdfTranslucent::is_registered_node_type() {
		return ShaderNodeBsdfTranslucent_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTranslucent::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTranslucent_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTranslucent::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTranslucent_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBsdfTransparent::is_registered_node_type() {
		return ShaderNodeBsdfTransparent_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTransparent::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTransparent_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfTransparent::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfTransparent_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribution_enum, ShaderNodeBsdfSheen, distribution)

	inline bool ShaderNodeBsdfSheen::is_registered_node_type() {
		return ShaderNodeBsdfSheen_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfSheen::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfSheen_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfSheen::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfSheen_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(component_enum, ShaderNodeBsdfToon, component)

	inline bool ShaderNodeBsdfToon::is_registered_node_type() {
		return ShaderNodeBsdfToon_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfToon::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfToon_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfToon::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfToon_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(component_enum, ShaderNodeBsdfHair, component)

	inline bool ShaderNodeBsdfHair::is_registered_node_type() {
		return ShaderNodeBsdfHair_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHair::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHair_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHair::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHair_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(model_enum, ShaderNodeBsdfHairPrincipled, model)
	ENUM_PROPERTY(parametrization_enum, ShaderNodeBsdfHairPrincipled, parametrization)

	inline bool ShaderNodeBsdfHairPrincipled::is_registered_node_type() {
		return ShaderNodeBsdfHairPrincipled_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHairPrincipled::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHairPrincipled_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBsdfHairPrincipled::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBsdfHairPrincipled_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(falloff_enum, ShaderNodeSubsurfaceScattering, falloff)

	inline bool ShaderNodeSubsurfaceScattering::is_registered_node_type() {
		return ShaderNodeSubsurfaceScattering_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSubsurfaceScattering::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSubsurfaceScattering_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSubsurfaceScattering::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSubsurfaceScattering_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeVolumeAbsorption::is_registered_node_type() {
		return ShaderNodeVolumeAbsorption_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeAbsorption::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeAbsorption_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeAbsorption::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeAbsorption_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeVolumeScatter::is_registered_node_type() {
		return ShaderNodeVolumeScatter_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeScatter::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeScatter_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeScatter::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeScatter_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeVolumePrincipled::is_registered_node_type() {
		return ShaderNodeVolumePrincipled_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumePrincipled::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumePrincipled_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumePrincipled::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumePrincipled_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeEmission::is_registered_node_type() {
		return ShaderNodeEmission_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeEmission::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeEmission_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeEmission::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeEmission_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeNewGeometry::is_registered_node_type() {
		return ShaderNodeNewGeometry_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeNewGeometry::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeNewGeometry_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeNewGeometry::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeNewGeometry_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeLightPath::is_registered_node_type() {
		return ShaderNodeLightPath_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightPath::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightPath_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightPath::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightPath_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeLightFalloff::is_registered_node_type() {
		return ShaderNodeLightFalloff_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightFalloff::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightFalloff_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeLightFalloff::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeLightFalloff_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeObjectInfo::is_registered_node_type() {
		return ShaderNodeObjectInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeObjectInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeObjectInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeObjectInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeObjectInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeParticleInfo::is_registered_node_type() {
		return ShaderNodeParticleInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeParticleInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeParticleInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeParticleInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeParticleInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeHairInfo::is_registered_node_type() {
		return ShaderNodeHairInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeHairInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeHairInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeHairInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeHairInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodePointInfo::is_registered_node_type() {
		return ShaderNodePointInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodePointInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodePointInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodePointInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodePointInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeVolumeInfo::is_registered_node_type() {
		return ShaderNodeVolumeInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeInfo::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVolumeInfo::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVolumeInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeWireframe, use_pixel_size)

	inline bool ShaderNodeWireframe::is_registered_node_type() {
		return ShaderNodeWireframe_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeWireframe::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeWireframe_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeWireframe::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeWireframe_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeWavelength::is_registered_node_type() {
		return ShaderNodeWavelength_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeWavelength::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeWavelength_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeWavelength::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeWavelength_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeBlackbody::is_registered_node_type() {
		return ShaderNodeBlackbody_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBlackbody::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBlackbody_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBlackbody::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBlackbody_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeBump, invert)

	inline bool ShaderNodeBump::is_registered_node_type() {
		return ShaderNodeBump_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBump::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBump_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBump::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBump_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, ShaderNodeNormalMap, space)
	STRING_PROPERTY(ShaderNodeNormalMap, uv_map)

	inline bool ShaderNodeNormalMap::is_registered_node_type() {
		return ShaderNodeNormalMap_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormalMap::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormalMap_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeNormalMap::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeNormalMap_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(direction_type_enum, ShaderNodeTangent, direction_type)
	ENUM_PROPERTY(axis_enum, ShaderNodeTangent, axis)
	STRING_PROPERTY(ShaderNodeTangent, uv_map)

	inline bool ShaderNodeTangent::is_registered_node_type() {
		return ShaderNodeTangent_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTangent::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTangent_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTangent::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTangent_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Text, ShaderNodeScript, script)
	STRING_PROPERTY(ShaderNodeScript, filepath)
	ENUM_PROPERTY(mode_enum, ShaderNodeScript, mode)
	BOOLEAN_PROPERTY(ShaderNodeScript, use_auto_update)
	STRING_PROPERTY(ShaderNodeScript, bytecode)
	STRING_PROPERTY(ShaderNodeScript, bytecode_hash)

	inline bool ShaderNodeScript::is_registered_node_type() {
		return ShaderNodeScript_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeScript::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeScript_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeScript::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeScript_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, ShaderNodeTexImage, image)
	POINTER_PROPERTY(TexMapping, ShaderNodeTexImage, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexImage, color_mapping)
	ENUM_PROPERTY(projection_enum, ShaderNodeTexImage, projection)
	ENUM_PROPERTY(interpolation_enum, ShaderNodeTexImage, interpolation)
	FLOAT_PROPERTY(ShaderNodeTexImage, projection_blend)
	ENUM_PROPERTY(extension_enum, ShaderNodeTexImage, extension)
	POINTER_PROPERTY(ImageUser, ShaderNodeTexImage, image_user)

	inline bool ShaderNodeTexImage::is_registered_node_type() {
		return ShaderNodeTexImage_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexImage::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexImage_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexImage::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexImage_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, ShaderNodeTexEnvironment, image)
	POINTER_PROPERTY(TexMapping, ShaderNodeTexEnvironment, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexEnvironment, color_mapping)
	ENUM_PROPERTY(projection_enum, ShaderNodeTexEnvironment, projection)
	ENUM_PROPERTY(interpolation_enum, ShaderNodeTexEnvironment, interpolation)
	POINTER_PROPERTY(ImageUser, ShaderNodeTexEnvironment, image_user)

	inline bool ShaderNodeTexEnvironment::is_registered_node_type() {
		return ShaderNodeTexEnvironment_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexEnvironment::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexEnvironment_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexEnvironment::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexEnvironment_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexSky, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexSky, color_mapping)
	ENUM_PROPERTY(sky_type_enum, ShaderNodeTexSky, sky_type)
	FLOAT_ARRAY_PROPERTY(ShaderNodeTexSky, 3, sun_direction)
	FLOAT_PROPERTY(ShaderNodeTexSky, turbidity)
	FLOAT_PROPERTY(ShaderNodeTexSky, ground_albedo)
	BOOLEAN_PROPERTY(ShaderNodeTexSky, sun_disc)
	FLOAT_PROPERTY(ShaderNodeTexSky, sun_size)
	FLOAT_PROPERTY(ShaderNodeTexSky, sun_intensity)
	FLOAT_PROPERTY(ShaderNodeTexSky, sun_elevation)
	FLOAT_PROPERTY(ShaderNodeTexSky, sun_rotation)
	FLOAT_PROPERTY(ShaderNodeTexSky, altitude)
	FLOAT_PROPERTY(ShaderNodeTexSky, air_density)
	FLOAT_PROPERTY(ShaderNodeTexSky, dust_density)
	FLOAT_PROPERTY(ShaderNodeTexSky, ozone_density)

	inline bool ShaderNodeTexSky::is_registered_node_type() {
		return ShaderNodeTexSky_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexSky::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexSky_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexSky::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexSky_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexGradient, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexGradient, color_mapping)
	ENUM_PROPERTY(gradient_type_enum, ShaderNodeTexGradient, gradient_type)

	inline bool ShaderNodeTexGradient::is_registered_node_type() {
		return ShaderNodeTexGradient_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexGradient::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexGradient_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexGradient::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexGradient_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexNoise, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexNoise, color_mapping)
	ENUM_PROPERTY(noise_dimensions_enum, ShaderNodeTexNoise, noise_dimensions)
	BOOLEAN_PROPERTY(ShaderNodeTexNoise, normalize)

	inline bool ShaderNodeTexNoise::is_registered_node_type() {
		return ShaderNodeTexNoise_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexNoise::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexNoise_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexNoise::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexNoise_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexMagic, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexMagic, color_mapping)
	INT_PROPERTY(ShaderNodeTexMagic, turbulence_depth)

	inline bool ShaderNodeTexMagic::is_registered_node_type() {
		return ShaderNodeTexMagic_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMagic::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMagic_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMagic::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMagic_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexWave, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexWave, color_mapping)
	ENUM_PROPERTY(wave_type_enum, ShaderNodeTexWave, wave_type)
	ENUM_PROPERTY(bands_direction_enum, ShaderNodeTexWave, bands_direction)
	ENUM_PROPERTY(rings_direction_enum, ShaderNodeTexWave, rings_direction)
	ENUM_PROPERTY(wave_profile_enum, ShaderNodeTexWave, wave_profile)

	inline bool ShaderNodeTexWave::is_registered_node_type() {
		return ShaderNodeTexWave_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexWave::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexWave_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexWave::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexWave_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexMusgrave, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexMusgrave, color_mapping)
	ENUM_PROPERTY(musgrave_dimensions_enum, ShaderNodeTexMusgrave, musgrave_dimensions)
	ENUM_PROPERTY(musgrave_type_enum, ShaderNodeTexMusgrave, musgrave_type)

	inline bool ShaderNodeTexMusgrave::is_registered_node_type() {
		return ShaderNodeTexMusgrave_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMusgrave::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMusgrave_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexMusgrave::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexMusgrave_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexVoronoi, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexVoronoi, color_mapping)
	ENUM_PROPERTY(voronoi_dimensions_enum, ShaderNodeTexVoronoi, voronoi_dimensions)
	ENUM_PROPERTY(distance_enum, ShaderNodeTexVoronoi, distance)
	ENUM_PROPERTY(feature_enum, ShaderNodeTexVoronoi, feature)
	BOOLEAN_PROPERTY(ShaderNodeTexVoronoi, normalize)

	inline bool ShaderNodeTexVoronoi::is_registered_node_type() {
		return ShaderNodeTexVoronoi_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexVoronoi::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexVoronoi_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexVoronoi::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexVoronoi_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexChecker, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexChecker, color_mapping)

	inline bool ShaderNodeTexChecker::is_registered_node_type() {
		return ShaderNodeTexChecker_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexChecker::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexChecker_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexChecker::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexChecker_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(TexMapping, ShaderNodeTexBrick, texture_mapping)
	POINTER_PROPERTY(ColorMapping, ShaderNodeTexBrick, color_mapping)
	INT_PROPERTY(ShaderNodeTexBrick, offset_frequency)
	INT_PROPERTY(ShaderNodeTexBrick, squash_frequency)
	FLOAT_PROPERTY(ShaderNodeTexBrick, offset)
	FLOAT_PROPERTY(ShaderNodeTexBrick, squash)

	inline bool ShaderNodeTexBrick::is_registered_node_type() {
		return ShaderNodeTexBrick_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexBrick::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexBrick_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexBrick::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexBrick_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Object, ShaderNodeTexPointDensity, object)
	ENUM_PROPERTY(point_source_enum, ShaderNodeTexPointDensity, point_source)
	POINTER_PROPERTY(ParticleSystem, ShaderNodeTexPointDensity, particle_system)
	INT_PROPERTY(ShaderNodeTexPointDensity, resolution)
	FLOAT_PROPERTY(ShaderNodeTexPointDensity, radius)
	ENUM_PROPERTY(space_enum, ShaderNodeTexPointDensity, space)
	ENUM_PROPERTY(interpolation_enum, ShaderNodeTexPointDensity, interpolation)
	ENUM_PROPERTY(particle_color_source_enum, ShaderNodeTexPointDensity, particle_color_source)
	ENUM_PROPERTY(vertex_color_source_enum, ShaderNodeTexPointDensity, vertex_color_source)
	STRING_PROPERTY(ShaderNodeTexPointDensity, vertex_attribute_name)

	inline bool ShaderNodeTexPointDensity::is_registered_node_type() {
		return ShaderNodeTexPointDensity_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexPointDensity::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexPointDensity_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexPointDensity::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexPointDensity_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline void ShaderNodeTexPointDensity::cache_point_density(Depsgraph& depsgraph) {
		ShaderNodeTexPointDensity_cache_point_density_func((::bNode *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data);
	}

	inline void ShaderNodeTexPointDensity::calc_point_density(Depsgraph& depsgraph, int *rgba_values_len, float **rgba_values) {
		ShaderNodeTexPointDensity_calc_point_density_func((::bNode *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, rgba_values_len, rgba_values);
	}

	inline void ShaderNodeTexPointDensity::calc_point_density_minmax(Depsgraph& depsgraph, float min[3], float max[3]) {
		ShaderNodeTexPointDensity_calc_point_density_minmax_func((::bNode *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, min, max);
	}


	POINTER_PROPERTY(Object, ShaderNodeTexCoord, object)
	BOOLEAN_PROPERTY(ShaderNodeTexCoord, from_instancer)

	inline bool ShaderNodeTexCoord::is_registered_node_type() {
		return ShaderNodeTexCoord_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexCoord::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexCoord_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexCoord::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexCoord_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(rotation_type_enum, ShaderNodeVectorRotate, rotation_type)
	BOOLEAN_PROPERTY(ShaderNodeVectorRotate, invert)

	inline bool ShaderNodeVectorRotate::is_registered_node_type() {
		return ShaderNodeVectorRotate_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorRotate::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorRotate_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorRotate::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorRotate_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(vector_type_enum, ShaderNodeVectorTransform, vector_type)
	ENUM_PROPERTY(convert_from_enum, ShaderNodeVectorTransform, convert_from)
	ENUM_PROPERTY(convert_to_enum, ShaderNodeVectorTransform, convert_to)

	inline bool ShaderNodeVectorTransform::is_registered_node_type() {
		return ShaderNodeVectorTransform_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorTransform::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorTransform_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorTransform::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorTransform_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSeparateHSV::is_registered_node_type() {
		return ShaderNodeSeparateHSV_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateHSV::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateHSV_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateHSV::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateHSV_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCombineHSV::is_registered_node_type() {
		return ShaderNodeCombineHSV_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineHSV::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineHSV_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineHSV::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineHSV_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeUVMap, from_instancer)
	STRING_PROPERTY(ShaderNodeUVMap, uv_map)

	inline bool ShaderNodeUVMap::is_registered_node_type() {
		return ShaderNodeUVMap_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVMap::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVMap_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVMap::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVMap_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(ShaderNodeVertexColor, layer_name)

	inline bool ShaderNodeVertexColor::is_registered_node_type() {
		return ShaderNodeVertexColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVertexColor::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVertexColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVertexColor::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVertexColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(ShaderNodeUVAlongStroke, use_tips)

	inline bool ShaderNodeUVAlongStroke::is_registered_node_type() {
		return ShaderNodeUVAlongStroke_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVAlongStroke::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVAlongStroke_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeUVAlongStroke::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeUVAlongStroke_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeSeparateXYZ::is_registered_node_type() {
		return ShaderNodeSeparateXYZ_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateXYZ::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateXYZ_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateXYZ::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateXYZ_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool ShaderNodeCombineXYZ::is_registered_node_type() {
		return ShaderNodeCombineXYZ_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineXYZ::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineXYZ_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineXYZ::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineXYZ_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(ShaderNodeBevel, samples)

	inline bool ShaderNodeBevel::is_registered_node_type() {
		return ShaderNodeBevel_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeBevel::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeBevel_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeBevel::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeBevel_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, ShaderNodeDisplacement, space)

	inline bool ShaderNodeDisplacement::is_registered_node_type() {
		return ShaderNodeDisplacement_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeDisplacement::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeDisplacement_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeDisplacement::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeDisplacement_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, ShaderNodeVectorDisplacement, space)

	inline bool ShaderNodeVectorDisplacement::is_registered_node_type() {
		return ShaderNodeVectorDisplacement_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorDisplacement::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorDisplacement_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeVectorDisplacement::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeVectorDisplacement_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Text, ShaderNodeTexIES, ies)
	STRING_PROPERTY(ShaderNodeTexIES, filepath)
	ENUM_PROPERTY(mode_enum, ShaderNodeTexIES, mode)

	inline bool ShaderNodeTexIES::is_registered_node_type() {
		return ShaderNodeTexIES_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexIES::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexIES_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexIES::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexIES_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(noise_dimensions_enum, ShaderNodeTexWhiteNoise, noise_dimensions)

	inline bool ShaderNodeTexWhiteNoise::is_registered_node_type() {
		return ShaderNodeTexWhiteNoise_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexWhiteNoise::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexWhiteNoise_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeTexWhiteNoise::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeTexWhiteNoise_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(ShaderNodeOutputAOV, name)

	inline bool ShaderNodeOutputAOV::is_registered_node_type() {
		return ShaderNodeOutputAOV_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputAOV::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputAOV_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeOutputAOV::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeOutputAOV_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, ShaderNodeFloatCurve, mapping)

	inline bool ShaderNodeFloatCurve::is_registered_node_type() {
		return ShaderNodeFloatCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeFloatCurve::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeFloatCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeFloatCurve::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeFloatCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, ShaderNodeCombineColor, mode)

	inline bool ShaderNodeCombineColor::is_registered_node_type() {
		return ShaderNodeCombineColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineColor::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeCombineColor::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeCombineColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, ShaderNodeSeparateColor, mode)

	inline bool ShaderNodeSeparateColor::is_registered_node_type() {
		return ShaderNodeSeparateColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateColor::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeSeparateColor::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeSeparateColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(data_type_enum, ShaderNodeMix, data_type)
	ENUM_PROPERTY(factor_mode_enum, ShaderNodeMix, factor_mode)
	ENUM_PROPERTY(blend_type_enum, ShaderNodeMix, blend_type)
	BOOLEAN_PROPERTY(ShaderNodeMix, clamp_factor)
	BOOLEAN_PROPERTY(ShaderNodeMix, clamp_result)

	inline bool ShaderNodeMix::is_registered_node_type() {
		return ShaderNodeMix_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeMix::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeMix_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeMix::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeMix_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(tile_order_enum, CompositorNodeViewer, tile_order)
	FLOAT_PROPERTY(CompositorNodeViewer, center_x)
	FLOAT_PROPERTY(CompositorNodeViewer, center_y)
	BOOLEAN_PROPERTY(CompositorNodeViewer, use_alpha)

	inline bool CompositorNodeViewer::is_registered_node_type() {
		return CompositorNodeViewer_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeViewer::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeViewer_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeViewer::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeViewer_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeRGB::is_registered_node_type() {
		return CompositorNodeRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeValue::is_registered_node_type() {
		return CompositorNodeValue_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeValue::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeValue_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeValue::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeValue_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(blend_type_enum, CompositorNodeMixRGB, blend_type)
	BOOLEAN_PROPERTY(CompositorNodeMixRGB, use_alpha)
	BOOLEAN_PROPERTY(CompositorNodeMixRGB, use_clamp)

	inline bool CompositorNodeMixRGB::is_registered_node_type() {
		return CompositorNodeMixRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMixRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMixRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMixRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMixRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(ColorRamp, CompositorNodeValToRGB, color_ramp)

	inline bool CompositorNodeValToRGB::is_registered_node_type() {
		return CompositorNodeValToRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeValToRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeValToRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeValToRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeValToRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeRGBToBW::is_registered_node_type() {
		return CompositorNodeRGBToBW_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGBToBW::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGBToBW_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRGBToBW::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRGBToBW_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeNormal::is_registered_node_type() {
		return CompositorNodeNormal_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormal::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormal_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormal::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormal_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeCurveVec, mapping)

	inline bool CompositorNodeCurveVec::is_registered_node_type() {
		return CompositorNodeCurveVec_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveVec::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveVec_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveVec::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveVec_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeCurveRGB, mapping)

	inline bool CompositorNodeCurveRGB::is_registered_node_type() {
		return CompositorNodeCurveRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveRGB::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCurveRGB::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCurveRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeAlphaOver, use_premultiply)
	FLOAT_PROPERTY(CompositorNodeAlphaOver, premul)

	inline bool CompositorNodeAlphaOver::is_registered_node_type() {
		return CompositorNodeAlphaOver_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeAlphaOver::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeAlphaOver_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeAlphaOver::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeAlphaOver_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeBlur, use_variable_size)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_extended_bounds)
	INT_PROPERTY(CompositorNodeBlur, size_x)
	INT_PROPERTY(CompositorNodeBlur, size_y)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_relative)
	ENUM_PROPERTY(aspect_correction_enum, CompositorNodeBlur, aspect_correction)
	FLOAT_PROPERTY(CompositorNodeBlur, factor)
	FLOAT_PROPERTY(CompositorNodeBlur, factor_x)
	FLOAT_PROPERTY(CompositorNodeBlur, factor_y)
	ENUM_PROPERTY(filter_type_enum, CompositorNodeBlur, filter_type)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_bokeh)
	BOOLEAN_PROPERTY(CompositorNodeBlur, use_gamma_correction)

	inline bool CompositorNodeBlur::is_registered_node_type() {
		return CompositorNodeBlur_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBlur_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBlur_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(filter_type_enum, CompositorNodeFilter, filter_type)

	inline bool CompositorNodeFilter::is_registered_node_type() {
		return CompositorNodeFilter_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeFilter::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeFilter_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeFilter::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeFilter_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, offset)
	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, size)
	BOOLEAN_PROPERTY(CompositorNodeMapValue, use_min)
	BOOLEAN_PROPERTY(CompositorNodeMapValue, use_max)
	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, min)
	FLOAT_ARRAY_PROPERTY(CompositorNodeMapValue, 1, max)

	inline bool CompositorNodeMapValue::is_registered_node_type() {
		return CompositorNodeMapValue_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapValue::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapValue_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapValue::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapValue_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeMapRange, use_clamp)

	inline bool CompositorNodeMapRange::is_registered_node_type() {
		return CompositorNodeMapRange_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapRange::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapRange_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapRange::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapRange_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeTime, curve)
	INT_PROPERTY(CompositorNodeTime, frame_start)
	INT_PROPERTY(CompositorNodeTime, frame_end)

	inline bool CompositorNodeTime::is_registered_node_type() {
		return CompositorNodeTime_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTime::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTime_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTime::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTime_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeVecBlur, samples)
	INT_PROPERTY(CompositorNodeVecBlur, speed_min)
	INT_PROPERTY(CompositorNodeVecBlur, speed_max)
	FLOAT_PROPERTY(CompositorNodeVecBlur, factor)
	BOOLEAN_PROPERTY(CompositorNodeVecBlur, use_curved)

	inline bool CompositorNodeVecBlur::is_registered_node_type() {
		return CompositorNodeVecBlur_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeVecBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeVecBlur_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeVecBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeVecBlur_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSepRGBA::is_registered_node_type() {
		return CompositorNodeSepRGBA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepRGBA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepRGBA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepRGBA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepRGBA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSepHSVA::is_registered_node_type() {
		return CompositorNodeSepHSVA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepHSVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepHSVA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepHSVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepHSVA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeSetAlpha, mode)

	inline bool CompositorNodeSetAlpha::is_registered_node_type() {
		return CompositorNodeSetAlpha_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSetAlpha::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSetAlpha_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSetAlpha::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSetAlpha_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeHueSat::is_registered_node_type() {
		return CompositorNodeHueSat_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueSat::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueSat_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueSat::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueSat_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, CompositorNodeImage, image)
	BOOLEAN_PROPERTY(CompositorNodeImage, use_straight_alpha_output)
	INT_PROPERTY(CompositorNodeImage, frame_duration)
	INT_PROPERTY(CompositorNodeImage, frame_start)
	INT_PROPERTY(CompositorNodeImage, frame_offset)
	BOOLEAN_PROPERTY(CompositorNodeImage, use_cyclic)
	BOOLEAN_PROPERTY(CompositorNodeImage, use_auto_refresh)
	ENUM_PROPERTY(layer_enum, CompositorNodeImage, layer)
	BOOLEAN_PROPERTY(CompositorNodeImage, has_layers)
	ENUM_PROPERTY(view_enum, CompositorNodeImage, view)
	BOOLEAN_PROPERTY(CompositorNodeImage, has_views)

	inline bool CompositorNodeImage::is_registered_node_type() {
		return CompositorNodeImage_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeImage::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeImage_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeImage::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeImage_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Scene, CompositorNodeRLayers, scene)
	ENUM_PROPERTY(layer_enum, CompositorNodeRLayers, layer)

	inline bool CompositorNodeRLayers::is_registered_node_type() {
		return CompositorNodeRLayers_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRLayers::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRLayers_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRLayers::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRLayers_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeComposite, use_alpha)

	inline bool CompositorNodeComposite::is_registered_node_type() {
		return CompositorNodeComposite_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeComposite::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeComposite_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeComposite::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeComposite_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(CompositorNodeOutputFile, base_path)
	INT_PROPERTY(CompositorNodeOutputFile, active_input_index)
	POINTER_PROPERTY(ImageFormatSettings, CompositorNodeOutputFile, format)



	inline bool CompositorNodeOutputFile::is_registered_node_type() {
		return CompositorNodeOutputFile_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeOutputFile::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeOutputFile_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeOutputFile::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeOutputFile_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Struct, CompositorNodeOutputFileFileSlots, rna_type)

	inline NodeSocket CompositorNodeOutputFileFileSlots::create(Context C, const char * name) {
		PointerRNA result;
		::bNodeSocket *retdata = CompositorNodeOutputFileFileSlots_new_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeSocket, retdata);
		return NodeSocket(result);
	}

	inline void CompositorNodeOutputFileFileSlots::remove(void *main, NodeSocket& socket) {
		CompositorNodeOutputFileFileSlots_remove_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, (::bNodeSocket *) socket.ptr.data);
	}

	inline void CompositorNodeOutputFileFileSlots::clear(void *main) {
		CompositorNodeOutputFileFileSlots_clear_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline void CompositorNodeOutputFileFileSlots::move(void *main, int from_index, int to_index) {
		CompositorNodeOutputFileFileSlots_move_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, CompositorNodeOutputFileLayerSlots, rna_type)

	inline NodeSocket CompositorNodeOutputFileLayerSlots::create(Context C, const char * name) {
		PointerRNA result;
		::bNodeSocket *retdata = CompositorNodeOutputFileLayerSlots_new_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeSocket, retdata);
		return NodeSocket(result);
	}

	inline void CompositorNodeOutputFileLayerSlots::remove(void *main, NodeSocket& socket) {
		CompositorNodeOutputFileLayerSlots_remove_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, (::bNodeSocket *) socket.ptr.data);
	}

	inline void CompositorNodeOutputFileLayerSlots::clear(void *main) {
		CompositorNodeOutputFileLayerSlots_clear_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline void CompositorNodeOutputFileLayerSlots::move(void *main, int from_index, int to_index) {
		CompositorNodeOutputFileLayerSlots_move_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, from_index, to_index);
	}


	POINTER_PROPERTY(Texture, CompositorNodeTexture, texture)
	INT_PROPERTY(CompositorNodeTexture, node_output)

	inline bool CompositorNodeTexture::is_registered_node_type() {
		return CompositorNodeTexture_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTexture::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTexture_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTexture::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTexture_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeTranslate, use_relative)
	ENUM_PROPERTY(wrap_axis_enum, CompositorNodeTranslate, wrap_axis)

	inline bool CompositorNodeTranslate::is_registered_node_type() {
		return CompositorNodeTranslate_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTranslate::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTranslate_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTranslate::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTranslate_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeZcombine, use_alpha)
	BOOLEAN_PROPERTY(CompositorNodeZcombine, use_antialias_z)

	inline bool CompositorNodeZcombine::is_registered_node_type() {
		return CompositorNodeZcombine_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeZcombine::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeZcombine_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeZcombine::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeZcombine_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCombRGBA::is_registered_node_type() {
		return CompositorNodeCombRGBA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombRGBA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombRGBA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombRGBA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombRGBA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeDilateErode, mode)
	INT_PROPERTY(CompositorNodeDilateErode, distance)
	FLOAT_PROPERTY(CompositorNodeDilateErode, edge)
	ENUM_PROPERTY(falloff_enum, CompositorNodeDilateErode, falloff)

	inline bool CompositorNodeDilateErode::is_registered_node_type() {
		return CompositorNodeDilateErode_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDilateErode::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDilateErode_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDilateErode::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDilateErode_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeInpaint, distance)

	inline bool CompositorNodeInpaint::is_registered_node_type() {
		return CompositorNodeInpaint_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeInpaint::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeInpaint_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeInpaint::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeInpaint_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeDespeckle, threshold)
	FLOAT_PROPERTY(CompositorNodeDespeckle, threshold_neighbor)

	inline bool CompositorNodeDespeckle::is_registered_node_type() {
		return CompositorNodeDespeckle_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDespeckle::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDespeckle_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDespeckle::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDespeckle_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(filter_type_enum, CompositorNodeRotate, filter_type)

	inline bool CompositorNodeRotate::is_registered_node_type() {
		return CompositorNodeRotate_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeRotate::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeRotate_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeRotate::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeRotate_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(space_enum, CompositorNodeScale, space)
	ENUM_PROPERTY(frame_method_enum, CompositorNodeScale, frame_method)
	FLOAT_PROPERTY(CompositorNodeScale, offset_x)
	FLOAT_PROPERTY(CompositorNodeScale, offset_y)

	inline bool CompositorNodeScale::is_registered_node_type() {
		return CompositorNodeScale_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeScale::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeScale_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeScale::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeScale_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeSepYCCA, mode)

	inline bool CompositorNodeSepYCCA::is_registered_node_type() {
		return CompositorNodeSepYCCA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYCCA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYCCA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYCCA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYCCA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeCombYCCA, mode)

	inline bool CompositorNodeCombYCCA::is_registered_node_type() {
		return CompositorNodeCombYCCA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYCCA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYCCA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYCCA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYCCA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSepYUVA::is_registered_node_type() {
		return CompositorNodeSepYUVA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYUVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYUVA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSepYUVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSepYUVA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCombYUVA::is_registered_node_type() {
		return CompositorNodeCombYUVA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYUVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYUVA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombYUVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombYUVA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeDiffMatte, tolerance)
	FLOAT_PROPERTY(CompositorNodeDiffMatte, falloff)

	inline bool CompositorNodeDiffMatte::is_registered_node_type() {
		return CompositorNodeDiffMatte_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDiffMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDiffMatte_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDiffMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDiffMatte_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(channel_enum, CompositorNodeColorSpill, channel)
	ENUM_PROPERTY(limit_method_enum, CompositorNodeColorSpill, limit_method)
	ENUM_PROPERTY(limit_channel_enum, CompositorNodeColorSpill, limit_channel)
	FLOAT_PROPERTY(CompositorNodeColorSpill, ratio)
	BOOLEAN_PROPERTY(CompositorNodeColorSpill, use_unspill)
	FLOAT_PROPERTY(CompositorNodeColorSpill, unspill_red)
	FLOAT_PROPERTY(CompositorNodeColorSpill, unspill_green)
	FLOAT_PROPERTY(CompositorNodeColorSpill, unspill_blue)

	inline bool CompositorNodeColorSpill::is_registered_node_type() {
		return CompositorNodeColorSpill_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorSpill::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorSpill_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorSpill::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorSpill_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeChromaMatte, tolerance)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, threshold)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, lift)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, gain)
	FLOAT_PROPERTY(CompositorNodeChromaMatte, shadow_adjust)

	inline bool CompositorNodeChromaMatte::is_registered_node_type() {
		return CompositorNodeChromaMatte_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeChromaMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeChromaMatte_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeChromaMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeChromaMatte_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(color_space_enum, CompositorNodeChannelMatte, color_space)
	ENUM_PROPERTY(matte_channel_enum, CompositorNodeChannelMatte, matte_channel)
	ENUM_PROPERTY(limit_method_enum, CompositorNodeChannelMatte, limit_method)
	ENUM_PROPERTY(limit_channel_enum, CompositorNodeChannelMatte, limit_channel)
	FLOAT_PROPERTY(CompositorNodeChannelMatte, limit_max)
	FLOAT_PROPERTY(CompositorNodeChannelMatte, limit_min)

	inline bool CompositorNodeChannelMatte::is_registered_node_type() {
		return CompositorNodeChannelMatte_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeChannelMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeChannelMatte_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeChannelMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeChannelMatte_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(axis_enum, CompositorNodeFlip, axis)

	inline bool CompositorNodeFlip::is_registered_node_type() {
		return CompositorNodeFlip_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeFlip::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeFlip_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeFlip::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeFlip_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(axis_enum, CompositorNodeSplitViewer, axis)
	INT_PROPERTY(CompositorNodeSplitViewer, factor)

	inline bool CompositorNodeSplitViewer::is_registered_node_type() {
		return CompositorNodeSplitViewer_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSplitViewer::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSplitViewer_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSplitViewer::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSplitViewer_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeMapUV, alpha)

	inline bool CompositorNodeMapUV::is_registered_node_type() {
		return CompositorNodeMapUV_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapUV::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapUV_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMapUV::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMapUV_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeIDMask, index)
	BOOLEAN_PROPERTY(CompositorNodeIDMask, use_antialiasing)

	inline bool CompositorNodeIDMask::is_registered_node_type() {
		return CompositorNodeIDMask_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeIDMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeIDMask_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeIDMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeIDMask_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(inner_mode_enum, CompositorNodeDoubleEdgeMask, inner_mode)
	ENUM_PROPERTY(edge_mode_enum, CompositorNodeDoubleEdgeMask, edge_mode)

	inline bool CompositorNodeDoubleEdgeMask::is_registered_node_type() {
		return CompositorNodeDoubleEdgeMask_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDoubleEdgeMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDoubleEdgeMask_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDoubleEdgeMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDoubleEdgeMask_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Scene, CompositorNodeDefocus, scene)
	ENUM_PROPERTY(bokeh_enum, CompositorNodeDefocus, bokeh)
	FLOAT_PROPERTY(CompositorNodeDefocus, angle)
	BOOLEAN_PROPERTY(CompositorNodeDefocus, use_gamma_correction)
	FLOAT_PROPERTY(CompositorNodeDefocus, f_stop)
	FLOAT_PROPERTY(CompositorNodeDefocus, blur_max)
	FLOAT_PROPERTY(CompositorNodeDefocus, threshold)
	BOOLEAN_PROPERTY(CompositorNodeDefocus, use_preview)
	BOOLEAN_PROPERTY(CompositorNodeDefocus, use_zbuffer)
	FLOAT_PROPERTY(CompositorNodeDefocus, z_scale)

	inline bool CompositorNodeDefocus::is_registered_node_type() {
		return CompositorNodeDefocus_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDefocus::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDefocus_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDefocus::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDefocus_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeDisplace::is_registered_node_type() {
		return CompositorNodeDisplace_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDisplace::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDisplace_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDisplace::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDisplace_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCombHSVA::is_registered_node_type() {
		return CompositorNodeCombHSVA_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombHSVA::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombHSVA_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombHSVA::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombHSVA_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, CompositorNodeMath, operation)
	BOOLEAN_PROPERTY(CompositorNodeMath, use_clamp)

	inline bool CompositorNodeMath::is_registered_node_type() {
		return CompositorNodeMath_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMath::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMath_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMath::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMath_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeLumaMatte, limit_max)
	FLOAT_PROPERTY(CompositorNodeLumaMatte, limit_min)

	inline bool CompositorNodeLumaMatte::is_registered_node_type() {
		return CompositorNodeLumaMatte_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeLumaMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeLumaMatte_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeLumaMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeLumaMatte_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeBrightContrast, use_premultiply)

	inline bool CompositorNodeBrightContrast::is_registered_node_type() {
		return CompositorNodeBrightContrast_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBrightContrast::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBrightContrast_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBrightContrast::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBrightContrast_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeGamma::is_registered_node_type() {
		return CompositorNodeGamma_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeGamma::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeGamma_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeGamma::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeGamma_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeInvert, invert_rgb)
	BOOLEAN_PROPERTY(CompositorNodeInvert, invert_alpha)

	inline bool CompositorNodeInvert::is_registered_node_type() {
		return CompositorNodeInvert_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeInvert::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeInvert_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeInvert::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeInvert_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeNormalize::is_registered_node_type() {
		return CompositorNodeNormalize_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormalize::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormalize_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeNormalize::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeNormalize_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeCrop, use_crop_size)
	BOOLEAN_PROPERTY(CompositorNodeCrop, relative)
	INT_PROPERTY(CompositorNodeCrop, min_x)
	INT_PROPERTY(CompositorNodeCrop, max_x)
	INT_PROPERTY(CompositorNodeCrop, min_y)
	INT_PROPERTY(CompositorNodeCrop, max_y)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_min_x)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_max_x)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_min_y)
	FLOAT_PROPERTY(CompositorNodeCrop, rel_max_y)

	inline bool CompositorNodeCrop::is_registered_node_type() {
		return CompositorNodeCrop_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCrop::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCrop_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCrop::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCrop_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeDBlur, iterations)
	FLOAT_PROPERTY(CompositorNodeDBlur, center_x)
	FLOAT_PROPERTY(CompositorNodeDBlur, center_y)
	FLOAT_PROPERTY(CompositorNodeDBlur, distance)
	FLOAT_PROPERTY(CompositorNodeDBlur, angle)
	FLOAT_PROPERTY(CompositorNodeDBlur, spin)
	FLOAT_PROPERTY(CompositorNodeDBlur, zoom)

	inline bool CompositorNodeDBlur::is_registered_node_type() {
		return CompositorNodeDBlur_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDBlur_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDBlur_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(CompositorNodeBilateralblur, iterations)
	FLOAT_PROPERTY(CompositorNodeBilateralblur, sigma_color)
	FLOAT_PROPERTY(CompositorNodeBilateralblur, sigma_space)

	inline bool CompositorNodeBilateralblur::is_registered_node_type() {
		return CompositorNodeBilateralblur_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBilateralblur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBilateralblur_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBilateralblur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBilateralblur_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mapping_enum, CompositorNodePremulKey, mapping)

	inline bool CompositorNodePremulKey::is_registered_node_type() {
		return CompositorNodePremulKey_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodePremulKey::input_template(int index) {
		PointerRNA result;
		result = CompositorNodePremulKey_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodePremulKey::output_template(int index) {
		PointerRNA result;
		result = CompositorNodePremulKey_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(glare_type_enum, CompositorNodeGlare, glare_type)
	ENUM_PROPERTY(quality_enum, CompositorNodeGlare, quality)
	INT_PROPERTY(CompositorNodeGlare, iterations)
	FLOAT_PROPERTY(CompositorNodeGlare, color_modulation)
	FLOAT_PROPERTY(CompositorNodeGlare, mix)
	FLOAT_PROPERTY(CompositorNodeGlare, threshold)
	INT_PROPERTY(CompositorNodeGlare, streaks)
	FLOAT_PROPERTY(CompositorNodeGlare, angle_offset)
	FLOAT_PROPERTY(CompositorNodeGlare, fade)
	BOOLEAN_PROPERTY(CompositorNodeGlare, use_rotate_45)
	INT_PROPERTY(CompositorNodeGlare, size)

	inline bool CompositorNodeGlare::is_registered_node_type() {
		return CompositorNodeGlare_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeGlare::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeGlare_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeGlare::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeGlare_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(tonemap_type_enum, CompositorNodeTonemap, tonemap_type)
	FLOAT_PROPERTY(CompositorNodeTonemap, key)
	FLOAT_PROPERTY(CompositorNodeTonemap, offset)
	FLOAT_PROPERTY(CompositorNodeTonemap, gamma)
	FLOAT_PROPERTY(CompositorNodeTonemap, intensity)
	FLOAT_PROPERTY(CompositorNodeTonemap, contrast)
	FLOAT_PROPERTY(CompositorNodeTonemap, adaptation)
	FLOAT_PROPERTY(CompositorNodeTonemap, correction)

	inline bool CompositorNodeTonemap::is_registered_node_type() {
		return CompositorNodeTonemap_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTonemap::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTonemap_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTonemap::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTonemap_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeLensdist, use_projector)
	BOOLEAN_PROPERTY(CompositorNodeLensdist, use_jitter)
	BOOLEAN_PROPERTY(CompositorNodeLensdist, use_fit)

	inline bool CompositorNodeLensdist::is_registered_node_type() {
		return CompositorNodeLensdist_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeLensdist::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeLensdist_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeLensdist::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeLensdist_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(channel_enum, CompositorNodeLevels, channel)

	inline bool CompositorNodeLevels::is_registered_node_type() {
		return CompositorNodeLevels_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeLevels::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeLevels_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeLevels::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeLevels_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeColorMatte, color_hue)
	FLOAT_PROPERTY(CompositorNodeColorMatte, color_saturation)
	FLOAT_PROPERTY(CompositorNodeColorMatte, color_value)

	inline bool CompositorNodeColorMatte::is_registered_node_type() {
		return CompositorNodeColorMatte_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorMatte_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorMatte_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(channel_enum, CompositorNodeDistanceMatte, channel)
	FLOAT_PROPERTY(CompositorNodeDistanceMatte, tolerance)
	FLOAT_PROPERTY(CompositorNodeDistanceMatte, falloff)

	inline bool CompositorNodeDistanceMatte::is_registered_node_type() {
		return CompositorNodeDistanceMatte_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDistanceMatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDistanceMatte_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDistanceMatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDistanceMatte_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(correction_method_enum, CompositorNodeColorBalance, correction_method)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, lift)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, gamma)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, gain)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, offset)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, power)
	FLOAT_ARRAY_PROPERTY(CompositorNodeColorBalance, 3, slope)
	FLOAT_PROPERTY(CompositorNodeColorBalance, offset_basis)

	inline bool CompositorNodeColorBalance::is_registered_node_type() {
		return CompositorNodeColorBalance_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorBalance::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorBalance_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorBalance::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorBalance_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, CompositorNodeHueCorrect, mapping)

	inline bool CompositorNodeHueCorrect::is_registered_node_type() {
		return CompositorNodeHueCorrect_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueCorrect::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueCorrect_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeHueCorrect::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeHueCorrect_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeMovieClip, clip)

	inline bool CompositorNodeMovieClip::is_registered_node_type() {
		return CompositorNodeMovieClip_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieClip::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieClip_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieClip::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieClip_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(filter_type_enum, CompositorNodeTransform, filter_type)

	inline bool CompositorNodeTransform::is_registered_node_type() {
		return CompositorNodeTransform_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTransform::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTransform_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTransform::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTransform_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeStabilize, clip)
	ENUM_PROPERTY(filter_type_enum, CompositorNodeStabilize, filter_type)
	BOOLEAN_PROPERTY(CompositorNodeStabilize, invert)

	inline bool CompositorNodeStabilize::is_registered_node_type() {
		return CompositorNodeStabilize_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeStabilize::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeStabilize_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeStabilize::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeStabilize_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeMovieDistortion, clip)
	ENUM_PROPERTY(distortion_type_enum, CompositorNodeMovieDistortion, distortion_type)

	inline bool CompositorNodeMovieDistortion::is_registered_node_type() {
		return CompositorNodeMovieDistortion_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieDistortion::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieDistortion_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMovieDistortion::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMovieDistortion_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mask_type_enum, CompositorNodeBoxMask, mask_type)
	FLOAT_PROPERTY(CompositorNodeBoxMask, x)
	FLOAT_PROPERTY(CompositorNodeBoxMask, y)
	FLOAT_PROPERTY(CompositorNodeBoxMask, width)
	FLOAT_PROPERTY(CompositorNodeBoxMask, height)
	FLOAT_PROPERTY(CompositorNodeBoxMask, rotation)

	inline bool CompositorNodeBoxMask::is_registered_node_type() {
		return CompositorNodeBoxMask_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBoxMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBoxMask_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBoxMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBoxMask_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mask_type_enum, CompositorNodeEllipseMask, mask_type)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, x)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, y)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, width)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, height)
	FLOAT_PROPERTY(CompositorNodeEllipseMask, rotation)

	inline bool CompositorNodeEllipseMask::is_registered_node_type() {
		return CompositorNodeEllipseMask_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeEllipseMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeEllipseMask_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeEllipseMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeEllipseMask_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeBokehImage, angle)
	INT_PROPERTY(CompositorNodeBokehImage, flaps)
	FLOAT_PROPERTY(CompositorNodeBokehImage, rounding)
	FLOAT_PROPERTY(CompositorNodeBokehImage, catadioptric)
	FLOAT_PROPERTY(CompositorNodeBokehImage, shift)

	inline bool CompositorNodeBokehImage::is_registered_node_type() {
		return CompositorNodeBokehImage_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehImage::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehImage_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehImage::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehImage_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeBokehBlur, use_variable_size)
	BOOLEAN_PROPERTY(CompositorNodeBokehBlur, use_extended_bounds)
	FLOAT_PROPERTY(CompositorNodeBokehBlur, blur_max)

	inline bool CompositorNodeBokehBlur::is_registered_node_type() {
		return CompositorNodeBokehBlur_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehBlur::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehBlur_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeBokehBlur::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeBokehBlur_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeSwitch, check)

	inline bool CompositorNodeSwitch::is_registered_node_type() {
		return CompositorNodeSwitch_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitch::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitch_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitch::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitch_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSwitchView::is_registered_node_type() {
		return CompositorNodeSwitchView_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitchView::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitchView_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSwitchView::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSwitchView_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeColorCorrection, red)
	BOOLEAN_PROPERTY(CompositorNodeColorCorrection, green)
	BOOLEAN_PROPERTY(CompositorNodeColorCorrection, blue)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_start)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_end)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, master_lift)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, shadows_lift)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, midtones_lift)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_saturation)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_contrast)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_gamma)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_gain)
	FLOAT_PROPERTY(CompositorNodeColorCorrection, highlights_lift)

	inline bool CompositorNodeColorCorrection::is_registered_node_type() {
		return CompositorNodeColorCorrection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorCorrection::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorCorrection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeColorCorrection::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeColorCorrection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Mask, CompositorNodeMask, mask)
	BOOLEAN_PROPERTY(CompositorNodeMask, use_feather)
	BOOLEAN_PROPERTY(CompositorNodeMask, use_motion_blur)
	INT_PROPERTY(CompositorNodeMask, motion_blur_samples)
	FLOAT_PROPERTY(CompositorNodeMask, motion_blur_shutter)
	ENUM_PROPERTY(size_source_enum, CompositorNodeMask, size_source)
	INT_PROPERTY(CompositorNodeMask, size_x)
	INT_PROPERTY(CompositorNodeMask, size_y)

	inline bool CompositorNodeMask::is_registered_node_type() {
		return CompositorNodeMask_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeMask::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeMask_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeMask::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeMask_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeKeyingScreen, clip)
	STRING_PROPERTY(CompositorNodeKeyingScreen, tracking_object)
	FLOAT_PROPERTY(CompositorNodeKeyingScreen, smoothness)

	inline bool CompositorNodeKeyingScreen::is_registered_node_type() {
		return CompositorNodeKeyingScreen_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeyingScreen::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeyingScreen_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeyingScreen::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeyingScreen_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeKeying, screen_balance)
	FLOAT_PROPERTY(CompositorNodeKeying, despill_factor)
	FLOAT_PROPERTY(CompositorNodeKeying, despill_balance)
	FLOAT_PROPERTY(CompositorNodeKeying, clip_black)
	FLOAT_PROPERTY(CompositorNodeKeying, clip_white)
	INT_PROPERTY(CompositorNodeKeying, blur_pre)
	INT_PROPERTY(CompositorNodeKeying, blur_post)
	INT_PROPERTY(CompositorNodeKeying, dilate_distance)
	INT_PROPERTY(CompositorNodeKeying, edge_kernel_radius)
	FLOAT_PROPERTY(CompositorNodeKeying, edge_kernel_tolerance)
	ENUM_PROPERTY(feather_falloff_enum, CompositorNodeKeying, feather_falloff)
	INT_PROPERTY(CompositorNodeKeying, feather_distance)

	inline bool CompositorNodeKeying::is_registered_node_type() {
		return CompositorNodeKeying_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeying::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeying_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeKeying::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeKeying_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodeTrackPos, clip)
	ENUM_PROPERTY(position_enum, CompositorNodeTrackPos, position)
	INT_PROPERTY(CompositorNodeTrackPos, frame_relative)
	STRING_PROPERTY(CompositorNodeTrackPos, tracking_object)
	STRING_PROPERTY(CompositorNodeTrackPos, track_name)

	inline bool CompositorNodeTrackPos::is_registered_node_type() {
		return CompositorNodeTrackPos_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeTrackPos::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeTrackPos_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeTrackPos::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeTrackPos_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodePixelate::is_registered_node_type() {
		return CompositorNodePixelate_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodePixelate::input_template(int index) {
		PointerRNA result;
		result = CompositorNodePixelate_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodePixelate::output_template(int index) {
		PointerRNA result;
		result = CompositorNodePixelate_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(MovieClip, CompositorNodePlaneTrackDeform, clip)
	STRING_PROPERTY(CompositorNodePlaneTrackDeform, tracking_object)
	STRING_PROPERTY(CompositorNodePlaneTrackDeform, plane_track_name)
	BOOLEAN_PROPERTY(CompositorNodePlaneTrackDeform, use_motion_blur)
	INT_PROPERTY(CompositorNodePlaneTrackDeform, motion_blur_samples)
	FLOAT_PROPERTY(CompositorNodePlaneTrackDeform, motion_blur_shutter)

	inline bool CompositorNodePlaneTrackDeform::is_registered_node_type() {
		return CompositorNodePlaneTrackDeform_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodePlaneTrackDeform::input_template(int index) {
		PointerRNA result;
		result = CompositorNodePlaneTrackDeform_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodePlaneTrackDeform::output_template(int index) {
		PointerRNA result;
		result = CompositorNodePlaneTrackDeform_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCornerPin::is_registered_node_type() {
		return CompositorNodeCornerPin_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCornerPin::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCornerPin_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCornerPin::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCornerPin_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_ARRAY_PROPERTY(CompositorNodeSunBeams, 2, source)
	FLOAT_PROPERTY(CompositorNodeSunBeams, ray_length)

	inline bool CompositorNodeSunBeams::is_registered_node_type() {
		return CompositorNodeSunBeams_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSunBeams::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSunBeams_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSunBeams::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSunBeams_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(source_enum, CompositorNodeCryptomatteV2, source)
	POINTER_PROPERTY(Scene, CompositorNodeCryptomatteV2, scene)
	POINTER_PROPERTY(Image, CompositorNodeCryptomatteV2, image)
	STRING_PROPERTY(CompositorNodeCryptomatteV2, matte_id)
	FLOAT_ARRAY_PROPERTY(CompositorNodeCryptomatteV2, 3, add)
	FLOAT_ARRAY_PROPERTY(CompositorNodeCryptomatteV2, 3, remove)
	ENUM_PROPERTY(layer_name_enum, CompositorNodeCryptomatteV2, layer_name)

	INT_PROPERTY(CompositorNodeCryptomatteV2, frame_duration)
	INT_PROPERTY(CompositorNodeCryptomatteV2, frame_start)
	INT_PROPERTY(CompositorNodeCryptomatteV2, frame_offset)
	BOOLEAN_PROPERTY(CompositorNodeCryptomatteV2, use_cyclic)
	BOOLEAN_PROPERTY(CompositorNodeCryptomatteV2, use_auto_refresh)
	ENUM_PROPERTY(layer_enum, CompositorNodeCryptomatteV2, layer)
	BOOLEAN_PROPERTY(CompositorNodeCryptomatteV2, has_layers)
	ENUM_PROPERTY(view_enum, CompositorNodeCryptomatteV2, view)
	BOOLEAN_PROPERTY(CompositorNodeCryptomatteV2, has_views)

	inline bool CompositorNodeCryptomatteV2::is_registered_node_type() {
		return CompositorNodeCryptomatteV2_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCryptomatteV2::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCryptomatteV2_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCryptomatteV2::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCryptomatteV2_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(CompositorNodeCryptomatte, matte_id)
	FLOAT_ARRAY_PROPERTY(CompositorNodeCryptomatte, 3, add)
	FLOAT_ARRAY_PROPERTY(CompositorNodeCryptomatte, 3, remove)

	inline bool CompositorNodeCryptomatte::is_registered_node_type() {
		return CompositorNodeCryptomatte_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCryptomatte::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCryptomatte_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCryptomatte::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCryptomatte_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(CompositorNodeDenoise, use_hdr)
	ENUM_PROPERTY(prefilter_enum, CompositorNodeDenoise, prefilter)

	inline bool CompositorNodeDenoise::is_registered_node_type() {
		return CompositorNodeDenoise_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeDenoise::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeDenoise_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeDenoise::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeDenoise_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeExposure::is_registered_node_type() {
		return CompositorNodeExposure_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeExposure::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeExposure_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeExposure::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeExposure_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(CompositorNodeAntiAliasing, threshold)
	FLOAT_PROPERTY(CompositorNodeAntiAliasing, contrast_limit)
	FLOAT_PROPERTY(CompositorNodeAntiAliasing, corner_rounding)

	inline bool CompositorNodeAntiAliasing::is_registered_node_type() {
		return CompositorNodeAntiAliasing_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeAntiAliasing::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeAntiAliasing_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeAntiAliasing::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeAntiAliasing_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodePosterize::is_registered_node_type() {
		return CompositorNodePosterize_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodePosterize::input_template(int index) {
		PointerRNA result;
		result = CompositorNodePosterize_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodePosterize::output_template(int index) {
		PointerRNA result;
		result = CompositorNodePosterize_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(from_color_space_enum, CompositorNodeConvertColorSpace, from_color_space)
	ENUM_PROPERTY(to_color_space_enum, CompositorNodeConvertColorSpace, to_color_space)

	inline bool CompositorNodeConvertColorSpace::is_registered_node_type() {
		return CompositorNodeConvertColorSpace_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeConvertColorSpace::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeConvertColorSpace_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeConvertColorSpace::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeConvertColorSpace_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSceneTime::is_registered_node_type() {
		return CompositorNodeSceneTime_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSceneTime::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSceneTime_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSceneTime::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSceneTime_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeCombineXYZ::is_registered_node_type() {
		return CompositorNodeCombineXYZ_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombineXYZ::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombineXYZ_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombineXYZ::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombineXYZ_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool CompositorNodeSeparateXYZ::is_registered_node_type() {
		return CompositorNodeSeparateXYZ_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSeparateXYZ::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSeparateXYZ_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSeparateXYZ::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSeparateXYZ_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeSeparateColor, mode)
	ENUM_PROPERTY(ycc_mode_enum, CompositorNodeSeparateColor, ycc_mode)

	inline bool CompositorNodeSeparateColor::is_registered_node_type() {
		return CompositorNodeSeparateColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeSeparateColor::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeSeparateColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeSeparateColor::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeSeparateColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, CompositorNodeCombineColor, mode)
	ENUM_PROPERTY(ycc_mode_enum, CompositorNodeCombineColor, ycc_mode)

	inline bool CompositorNodeCombineColor::is_registered_node_type() {
		return CompositorNodeCombineColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombineColor::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombineColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeCombineColor::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeCombineColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(variation_enum, CompositorNodeKuwahara, variation)
	INT_PROPERTY(CompositorNodeKuwahara, uniformity)
	FLOAT_PROPERTY(CompositorNodeKuwahara, sharpness)
	FLOAT_PROPERTY(CompositorNodeKuwahara, eccentricity)

	inline bool CompositorNodeKuwahara::is_registered_node_type() {
		return CompositorNodeKuwahara_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeKuwahara::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeKuwahara_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeKuwahara::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeKuwahara_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(TextureNodeOutput, filepath)

	inline bool TextureNodeOutput::is_registered_node_type() {
		return TextureNodeOutput_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeOutput::input_template(int index) {
		PointerRNA result;
		result = TextureNodeOutput_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeOutput::output_template(int index) {
		PointerRNA result;
		result = TextureNodeOutput_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeChecker::is_registered_node_type() {
		return TextureNodeChecker_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeChecker::input_template(int index) {
		PointerRNA result;
		result = TextureNodeChecker_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeChecker::output_template(int index) {
		PointerRNA result;
		result = TextureNodeChecker_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Texture, TextureNodeTexture, texture)
	INT_PROPERTY(TextureNodeTexture, node_output)

	inline bool TextureNodeTexture::is_registered_node_type() {
		return TextureNodeTexture_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexture::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexture_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexture::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexture_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_PROPERTY(TextureNodeBricks, offset)
	INT_PROPERTY(TextureNodeBricks, offset_frequency)
	FLOAT_PROPERTY(TextureNodeBricks, squash)
	INT_PROPERTY(TextureNodeBricks, squash_frequency)

	inline bool TextureNodeBricks::is_registered_node_type() {
		return TextureNodeBricks_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeBricks::input_template(int index) {
		PointerRNA result;
		result = TextureNodeBricks_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeBricks::output_template(int index) {
		PointerRNA result;
		result = TextureNodeBricks_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(operation_enum, TextureNodeMath, operation)
	BOOLEAN_PROPERTY(TextureNodeMath, use_clamp)

	inline bool TextureNodeMath::is_registered_node_type() {
		return TextureNodeMath_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeMath::input_template(int index) {
		PointerRNA result;
		result = TextureNodeMath_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeMath::output_template(int index) {
		PointerRNA result;
		result = TextureNodeMath_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(blend_type_enum, TextureNodeMixRGB, blend_type)
	BOOLEAN_PROPERTY(TextureNodeMixRGB, use_alpha)
	BOOLEAN_PROPERTY(TextureNodeMixRGB, use_clamp)

	inline bool TextureNodeMixRGB::is_registered_node_type() {
		return TextureNodeMixRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeMixRGB::input_template(int index) {
		PointerRNA result;
		result = TextureNodeMixRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeMixRGB::output_template(int index) {
		PointerRNA result;
		result = TextureNodeMixRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeRGBToBW::is_registered_node_type() {
		return TextureNodeRGBToBW_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeRGBToBW::input_template(int index) {
		PointerRNA result;
		result = TextureNodeRGBToBW_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeRGBToBW::output_template(int index) {
		PointerRNA result;
		result = TextureNodeRGBToBW_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(ColorRamp, TextureNodeValToRGB, color_ramp)

	inline bool TextureNodeValToRGB::is_registered_node_type() {
		return TextureNodeValToRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeValToRGB::input_template(int index) {
		PointerRNA result;
		result = TextureNodeValToRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeValToRGB::output_template(int index) {
		PointerRNA result;
		result = TextureNodeValToRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, TextureNodeImage, image)
	POINTER_PROPERTY(ImageUser, TextureNodeImage, image_user)

	inline bool TextureNodeImage::is_registered_node_type() {
		return TextureNodeImage_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeImage::input_template(int index) {
		PointerRNA result;
		result = TextureNodeImage_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeImage::output_template(int index) {
		PointerRNA result;
		result = TextureNodeImage_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, TextureNodeCurveRGB, mapping)

	inline bool TextureNodeCurveRGB::is_registered_node_type() {
		return TextureNodeCurveRGB_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveRGB::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveRGB_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveRGB::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveRGB_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeInvert::is_registered_node_type() {
		return TextureNodeInvert_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeInvert::input_template(int index) {
		PointerRNA result;
		result = TextureNodeInvert_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeInvert::output_template(int index) {
		PointerRNA result;
		result = TextureNodeInvert_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeHueSaturation::is_registered_node_type() {
		return TextureNodeHueSaturation_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeHueSaturation::input_template(int index) {
		PointerRNA result;
		result = TextureNodeHueSaturation_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeHueSaturation::output_template(int index) {
		PointerRNA result;
		result = TextureNodeHueSaturation_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(CurveMapping, TextureNodeCurveTime, curve)
	INT_PROPERTY(TextureNodeCurveTime, frame_start)
	INT_PROPERTY(TextureNodeCurveTime, frame_end)

	inline bool TextureNodeCurveTime::is_registered_node_type() {
		return TextureNodeCurveTime_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveTime::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveTime_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCurveTime::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCurveTime_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeRotate::is_registered_node_type() {
		return TextureNodeRotate_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeRotate::input_template(int index) {
		PointerRNA result;
		result = TextureNodeRotate_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeRotate::output_template(int index) {
		PointerRNA result;
		result = TextureNodeRotate_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeViewer::is_registered_node_type() {
		return TextureNodeViewer_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeViewer::input_template(int index) {
		PointerRNA result;
		result = TextureNodeViewer_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeViewer::output_template(int index) {
		PointerRNA result;
		result = TextureNodeViewer_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTranslate::is_registered_node_type() {
		return TextureNodeTranslate_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTranslate::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTranslate_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTranslate::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTranslate_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeCoordinates::is_registered_node_type() {
		return TextureNodeCoordinates_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCoordinates::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCoordinates_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCoordinates::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCoordinates_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeDistance::is_registered_node_type() {
		return TextureNodeDistance_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeDistance::input_template(int index) {
		PointerRNA result;
		result = TextureNodeDistance_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeDistance::output_template(int index) {
		PointerRNA result;
		result = TextureNodeDistance_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeCompose::is_registered_node_type() {
		return TextureNodeCompose_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCompose::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCompose_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCompose::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCompose_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeDecompose::is_registered_node_type() {
		return TextureNodeDecompose_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeDecompose::input_template(int index) {
		PointerRNA result;
		result = TextureNodeDecompose_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeDecompose::output_template(int index) {
		PointerRNA result;
		result = TextureNodeDecompose_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeValToNor::is_registered_node_type() {
		return TextureNodeValToNor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeValToNor::input_template(int index) {
		PointerRNA result;
		result = TextureNodeValToNor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeValToNor::output_template(int index) {
		PointerRNA result;
		result = TextureNodeValToNor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeScale::is_registered_node_type() {
		return TextureNodeScale_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeScale::input_template(int index) {
		PointerRNA result;
		result = TextureNodeScale_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeScale::output_template(int index) {
		PointerRNA result;
		result = TextureNodeScale_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeAt::is_registered_node_type() {
		return TextureNodeAt_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeAt::input_template(int index) {
		PointerRNA result;
		result = TextureNodeAt_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeAt::output_template(int index) {
		PointerRNA result;
		result = TextureNodeAt_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, TextureNodeCombineColor, mode)

	inline bool TextureNodeCombineColor::is_registered_node_type() {
		return TextureNodeCombineColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeCombineColor::input_template(int index) {
		PointerRNA result;
		result = TextureNodeCombineColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeCombineColor::output_template(int index) {
		PointerRNA result;
		result = TextureNodeCombineColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, TextureNodeSeparateColor, mode)

	inline bool TextureNodeSeparateColor::is_registered_node_type() {
		return TextureNodeSeparateColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeSeparateColor::input_template(int index) {
		PointerRNA result;
		result = TextureNodeSeparateColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeSeparateColor::output_template(int index) {
		PointerRNA result;
		result = TextureNodeSeparateColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexVoronoi::is_registered_node_type() {
		return TextureNodeTexVoronoi_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexVoronoi::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexVoronoi_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexVoronoi::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexVoronoi_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexBlend::is_registered_node_type() {
		return TextureNodeTexBlend_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexBlend::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexBlend_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexBlend::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexBlend_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexMagic::is_registered_node_type() {
		return TextureNodeTexMagic_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMagic::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMagic_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMagic::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMagic_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexMarble::is_registered_node_type() {
		return TextureNodeTexMarble_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMarble::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMarble_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMarble::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMarble_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexClouds::is_registered_node_type() {
		return TextureNodeTexClouds_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexClouds::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexClouds_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexClouds::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexClouds_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexWood::is_registered_node_type() {
		return TextureNodeTexWood_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexWood::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexWood_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexWood::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexWood_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexMusgrave::is_registered_node_type() {
		return TextureNodeTexMusgrave_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMusgrave::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMusgrave_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexMusgrave::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexMusgrave_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexNoise::is_registered_node_type() {
		return TextureNodeTexNoise_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexNoise::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexNoise_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexNoise::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexNoise_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexStucci::is_registered_node_type() {
		return TextureNodeTexStucci_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexStucci::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexStucci_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexStucci::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexStucci_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool TextureNodeTexDistNoise::is_registered_node_type() {
		return TextureNodeTexDistNoise_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeTexDistNoise::input_template(int index) {
		PointerRNA result;
		result = TextureNodeTexDistNoise_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeTexDistNoise::output_template(int index) {
		PointerRNA result;
		result = TextureNodeTexDistNoise_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeAlignEulerToVector::is_registered_node_type() {
		return FunctionNodeAlignEulerToVector_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeAlignEulerToVector::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeAlignEulerToVector_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeAlignEulerToVector::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeAlignEulerToVector_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeAxisAngleToRotation::is_registered_node_type() {
		return FunctionNodeAxisAngleToRotation_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeAxisAngleToRotation::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeAxisAngleToRotation_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeAxisAngleToRotation::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeAxisAngleToRotation_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeBooleanMath::is_registered_node_type() {
		return FunctionNodeBooleanMath_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeBooleanMath::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeBooleanMath_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeBooleanMath::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeBooleanMath_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeCombineColor::is_registered_node_type() {
		return FunctionNodeCombineColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeCombineColor::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeCombineColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeCombineColor::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeCombineColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeQuaternionToRotation::is_registered_node_type() {
		return FunctionNodeQuaternionToRotation_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeQuaternionToRotation::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeQuaternionToRotation_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeQuaternionToRotation::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeQuaternionToRotation_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeCompare::is_registered_node_type() {
		return FunctionNodeCompare_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeCompare::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeCompare_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeCompare::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeCompare_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeEulerToRotation::is_registered_node_type() {
		return FunctionNodeEulerToRotation_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeEulerToRotation::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeEulerToRotation_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeEulerToRotation::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeEulerToRotation_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(rounding_mode_enum, FunctionNodeFloatToInt, rounding_mode)

	inline bool FunctionNodeFloatToInt::is_registered_node_type() {
		return FunctionNodeFloatToInt_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeFloatToInt::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeFloatToInt_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeFloatToInt::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeFloatToInt_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	BOOLEAN_PROPERTY(FunctionNodeInputBool, boolean)

	inline bool FunctionNodeInputBool::is_registered_node_type() {
		return FunctionNodeInputBool_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputBool::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputBool_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputBool::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputBool_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_ARRAY_PROPERTY(FunctionNodeInputColor, 4, color)

	inline bool FunctionNodeInputColor::is_registered_node_type() {
		return FunctionNodeInputColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputColor::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputColor::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	INT_PROPERTY(FunctionNodeInputInt, integer)

	inline bool FunctionNodeInputInt::is_registered_node_type() {
		return FunctionNodeInputInt_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputInt::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputInt_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputInt::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputInt_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeInputSpecialCharacters::is_registered_node_type() {
		return FunctionNodeInputSpecialCharacters_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputSpecialCharacters::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputSpecialCharacters_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputSpecialCharacters::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputSpecialCharacters_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	STRING_PROPERTY(FunctionNodeInputString, string)

	inline bool FunctionNodeInputString::is_registered_node_type() {
		return FunctionNodeInputString_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputString::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputString_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputString::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputString_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	FLOAT_ARRAY_PROPERTY(FunctionNodeInputVector, 3, vector)

	inline bool FunctionNodeInputVector::is_registered_node_type() {
		return FunctionNodeInputVector_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputVector::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputVector_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeInputVector::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeInputVector_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeInvertRotation::is_registered_node_type() {
		return FunctionNodeInvertRotation_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeInvertRotation::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeInvertRotation_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeInvertRotation::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeInvertRotation_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(data_type_enum, FunctionNodeRandomValue, data_type)

	inline bool FunctionNodeRandomValue::is_registered_node_type() {
		return FunctionNodeRandomValue_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeRandomValue::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeRandomValue_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeRandomValue::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeRandomValue_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeReplaceString::is_registered_node_type() {
		return FunctionNodeReplaceString_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeReplaceString::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeReplaceString_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeReplaceString::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeReplaceString_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(type_enum, FunctionNodeRotateEuler, type)
	ENUM_PROPERTY(space_enum, FunctionNodeRotateEuler, space)

	inline bool FunctionNodeRotateEuler::is_registered_node_type() {
		return FunctionNodeRotateEuler_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotateEuler::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotateEuler_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotateEuler::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotateEuler_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeRotateVector::is_registered_node_type() {
		return FunctionNodeRotateVector_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotateVector::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotateVector_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotateVector::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotateVector_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeRotationToAxisAngle::is_registered_node_type() {
		return FunctionNodeRotationToAxisAngle_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotationToAxisAngle::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotationToAxisAngle_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotationToAxisAngle::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotationToAxisAngle_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeRotationToEuler::is_registered_node_type() {
		return FunctionNodeRotationToEuler_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotationToEuler::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotationToEuler_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotationToEuler::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotationToEuler_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeSeparateColor::is_registered_node_type() {
		return FunctionNodeSeparateColor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeSeparateColor::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeSeparateColor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeSeparateColor::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeSeparateColor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeRotationToQuaternion::is_registered_node_type() {
		return FunctionNodeRotationToQuaternion_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotationToQuaternion::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotationToQuaternion_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeRotationToQuaternion::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeRotationToQuaternion_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeSliceString::is_registered_node_type() {
		return FunctionNodeSliceString_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeSliceString::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeSliceString_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeSliceString::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeSliceString_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeStringLength::is_registered_node_type() {
		return FunctionNodeStringLength_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeStringLength::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeStringLength_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeStringLength::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeStringLength_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool FunctionNodeValueToString::is_registered_node_type() {
		return FunctionNodeValueToString_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate FunctionNodeValueToString::input_template(int index) {
		PointerRNA result;
		result = FunctionNodeValueToString_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate FunctionNodeValueToString::output_template(int index) {
		PointerRNA result;
		result = FunctionNodeValueToString_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeAccumulateField::is_registered_node_type() {
		return GeometryNodeAccumulateField_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeAccumulateField::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeAccumulateField_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeAccumulateField::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeAccumulateField_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeAttributeDomainSize::is_registered_node_type() {
		return GeometryNodeAttributeDomainSize_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeAttributeDomainSize::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeAttributeDomainSize_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeAttributeDomainSize::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeAttributeDomainSize_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeAttributeStatistic::is_registered_node_type() {
		return GeometryNodeAttributeStatistic_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeAttributeStatistic::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeAttributeStatistic_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeAttributeStatistic::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeAttributeStatistic_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeBlurAttribute::is_registered_node_type() {
		return GeometryNodeBlurAttribute_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeBlurAttribute::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeBlurAttribute_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeBlurAttribute::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeBlurAttribute_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeBoundBox::is_registered_node_type() {
		return GeometryNodeBoundBox_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeBoundBox::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeBoundBox_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeBoundBox::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeBoundBox_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCaptureAttribute::is_registered_node_type() {
		return GeometryNodeCaptureAttribute_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCaptureAttribute::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCaptureAttribute_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCaptureAttribute::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCaptureAttribute_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCollectionInfo::is_registered_node_type() {
		return GeometryNodeCollectionInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCollectionInfo::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCollectionInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCollectionInfo::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCollectionInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeConvexHull::is_registered_node_type() {
		return GeometryNodeConvexHull_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeConvexHull::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeConvexHull_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeConvexHull::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeConvexHull_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveEndpointSelection::is_registered_node_type() {
		return GeometryNodeCurveEndpointSelection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveEndpointSelection::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveEndpointSelection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveEndpointSelection::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveEndpointSelection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(handle_type_enum, GeometryNodeCurveHandleTypeSelection, handle_type)
	ENUM_PROPERTY(mode_enum, GeometryNodeCurveHandleTypeSelection, mode)

	inline bool GeometryNodeCurveHandleTypeSelection::is_registered_node_type() {
		return GeometryNodeCurveHandleTypeSelection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveHandleTypeSelection::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveHandleTypeSelection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveHandleTypeSelection::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveHandleTypeSelection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveLength::is_registered_node_type() {
		return GeometryNodeCurveLength_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveLength::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveLength_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveLength::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveLength_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveArc::is_registered_node_type() {
		return GeometryNodeCurveArc_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveArc::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveArc_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveArc::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveArc_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurvePrimitiveBezierSegment::is_registered_node_type() {
		return GeometryNodeCurvePrimitiveBezierSegment_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveBezierSegment::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveBezierSegment_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveBezierSegment::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveBezierSegment_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurvePrimitiveCircle::is_registered_node_type() {
		return GeometryNodeCurvePrimitiveCircle_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveCircle::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveCircle_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveCircle::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveCircle_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurvePrimitiveLine::is_registered_node_type() {
		return GeometryNodeCurvePrimitiveLine_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveLine::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveLine_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveLine::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveLine_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveQuadraticBezier::is_registered_node_type() {
		return GeometryNodeCurveQuadraticBezier_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveQuadraticBezier::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveQuadraticBezier_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveQuadraticBezier::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveQuadraticBezier_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurvePrimitiveQuadrilateral::is_registered_node_type() {
		return GeometryNodeCurvePrimitiveQuadrilateral_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveQuadrilateral::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveQuadrilateral_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurvePrimitiveQuadrilateral::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurvePrimitiveQuadrilateral_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveSpiral::is_registered_node_type() {
		return GeometryNodeCurveSpiral_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveSpiral::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveSpiral_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveSpiral::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveSpiral_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveStar::is_registered_node_type() {
		return GeometryNodeCurveStar_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveStar::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveStar_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveStar::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveStar_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(handle_type_enum, GeometryNodeCurveSetHandles, handle_type)
	ENUM_PROPERTY(mode_enum, GeometryNodeCurveSetHandles, mode)

	inline bool GeometryNodeCurveSetHandles::is_registered_node_type() {
		return GeometryNodeCurveSetHandles_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveSetHandles::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveSetHandles_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveSetHandles::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveSetHandles_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSplineParameter::is_registered_node_type() {
		return GeometryNodeSplineParameter_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplineParameter::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplineParameter_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplineParameter::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplineParameter_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveSplineType::is_registered_node_type() {
		return GeometryNodeCurveSplineType_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveSplineType::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveSplineType_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveSplineType::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveSplineType_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveToMesh::is_registered_node_type() {
		return GeometryNodeCurveToMesh_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveToMesh::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveToMesh_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveToMesh::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveToMesh_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveToPoints::is_registered_node_type() {
		return GeometryNodeCurveToPoints_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveToPoints::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveToPoints_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveToPoints::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveToPoints_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCurveOfPoint::is_registered_node_type() {
		return GeometryNodeCurveOfPoint_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveOfPoint::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveOfPoint_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCurveOfPoint::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCurveOfPoint_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodePointsOfCurve::is_registered_node_type() {
		return GeometryNodePointsOfCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsOfCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsOfCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsOfCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsOfCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeDeformCurvesOnSurface::is_registered_node_type() {
		return GeometryNodeDeformCurvesOnSurface_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeDeformCurvesOnSurface::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeDeformCurvesOnSurface_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeDeformCurvesOnSurface::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeDeformCurvesOnSurface_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeDeleteGeometry::is_registered_node_type() {
		return GeometryNodeDeleteGeometry_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeDeleteGeometry::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeDeleteGeometry_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeDeleteGeometry::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeDeleteGeometry_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeDistributePointsInVolume::is_registered_node_type() {
		return GeometryNodeDistributePointsInVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeDistributePointsInVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeDistributePointsInVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeDistributePointsInVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeDistributePointsInVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(distribute_method_enum, GeometryNodeDistributePointsOnFaces, distribute_method)
	BOOLEAN_PROPERTY(GeometryNodeDistributePointsOnFaces, use_legacy_normal)

	inline bool GeometryNodeDistributePointsOnFaces::is_registered_node_type() {
		return GeometryNodeDistributePointsOnFaces_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeDistributePointsOnFaces::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeDistributePointsOnFaces_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeDistributePointsOnFaces::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeDistributePointsOnFaces_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeDualMesh::is_registered_node_type() {
		return GeometryNodeDualMesh_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeDualMesh::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeDualMesh_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeDualMesh::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeDualMesh_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeDuplicateElements::is_registered_node_type() {
		return GeometryNodeDuplicateElements_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeDuplicateElements::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeDuplicateElements_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeDuplicateElements::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeDuplicateElements_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeEdgePathsToCurves::is_registered_node_type() {
		return GeometryNodeEdgePathsToCurves_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgePathsToCurves::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgePathsToCurves_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgePathsToCurves::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgePathsToCurves_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeEdgePathsToSelection::is_registered_node_type() {
		return GeometryNodeEdgePathsToSelection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgePathsToSelection::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgePathsToSelection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgePathsToSelection::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgePathsToSelection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeEdgesToFaceGroups::is_registered_node_type() {
		return GeometryNodeEdgesToFaceGroups_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgesToFaceGroups::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgesToFaceGroups_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgesToFaceGroups::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgesToFaceGroups_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeFieldAtIndex::is_registered_node_type() {
		return GeometryNodeFieldAtIndex_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeFieldAtIndex::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeFieldAtIndex_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeFieldAtIndex::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeFieldAtIndex_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeFieldOnDomain::is_registered_node_type() {
		return GeometryNodeFieldOnDomain_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeFieldOnDomain::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeFieldOnDomain_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeFieldOnDomain::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeFieldOnDomain_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeExtrudeMesh::is_registered_node_type() {
		return GeometryNodeExtrudeMesh_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeExtrudeMesh::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeExtrudeMesh_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeExtrudeMesh::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeExtrudeMesh_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeFillCurve::is_registered_node_type() {
		return GeometryNodeFillCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeFillCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeFillCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeFillCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeFillCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeFilletCurve::is_registered_node_type() {
		return GeometryNodeFilletCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeFilletCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeFilletCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeFilletCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeFilletCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeFlipFaces::is_registered_node_type() {
		return GeometryNodeFlipFaces_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeFlipFaces::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeFlipFaces_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeFlipFaces::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeFlipFaces_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeGeometryToInstance::is_registered_node_type() {
		return GeometryNodeGeometryToInstance_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeGeometryToInstance::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeGeometryToInstance_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeGeometryToInstance::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeGeometryToInstance_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeImageInfo::is_registered_node_type() {
		return GeometryNodeImageInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeImageInfo::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeImageInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeImageInfo::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeImageInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(interpolation_enum, GeometryNodeImageTexture, interpolation)
	ENUM_PROPERTY(extension_enum, GeometryNodeImageTexture, extension)

	inline bool GeometryNodeImageTexture::is_registered_node_type() {
		return GeometryNodeImageTexture_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeImageTexture::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeImageTexture_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeImageTexture::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeImageTexture_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeIndexOfNearest::is_registered_node_type() {
		return GeometryNodeIndexOfNearest_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeIndexOfNearest::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeIndexOfNearest_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeIndexOfNearest::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeIndexOfNearest_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Image, GeometryNodeInputImage, image)

	inline bool GeometryNodeInputImage::is_registered_node_type() {
		return GeometryNodeInputImage_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputImage::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputImage_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputImage::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputImage_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputCurveHandlePositions::is_registered_node_type() {
		return GeometryNodeInputCurveHandlePositions_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputCurveHandlePositions::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputCurveHandlePositions_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputCurveHandlePositions::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputCurveHandlePositions_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputCurveTilt::is_registered_node_type() {
		return GeometryNodeInputCurveTilt_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputCurveTilt::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputCurveTilt_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputCurveTilt::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputCurveTilt_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputID::is_registered_node_type() {
		return GeometryNodeInputID_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputID::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputID_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputID::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputID_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputIndex::is_registered_node_type() {
		return GeometryNodeInputIndex_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputIndex::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputIndex_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputIndex::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputIndex_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputInstanceRotation::is_registered_node_type() {
		return GeometryNodeInputInstanceRotation_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputInstanceRotation::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputInstanceRotation_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputInstanceRotation::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputInstanceRotation_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputInstanceScale::is_registered_node_type() {
		return GeometryNodeInputInstanceScale_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputInstanceScale::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputInstanceScale_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputInstanceScale::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputInstanceScale_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMaterialIndex::is_registered_node_type() {
		return GeometryNodeInputMaterialIndex_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMaterialIndex::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMaterialIndex_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMaterialIndex::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMaterialIndex_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Material, GeometryNodeInputMaterial, material)

	inline bool GeometryNodeInputMaterial::is_registered_node_type() {
		return GeometryNodeInputMaterial_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMaterial::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMaterial_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMaterial::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMaterial_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshEdgeAngle::is_registered_node_type() {
		return GeometryNodeInputMeshEdgeAngle_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshEdgeAngle::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshEdgeAngle_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshEdgeAngle::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshEdgeAngle_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshEdgeNeighbors::is_registered_node_type() {
		return GeometryNodeInputMeshEdgeNeighbors_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshEdgeNeighbors::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshEdgeNeighbors_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshEdgeNeighbors::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshEdgeNeighbors_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshEdgeVertices::is_registered_node_type() {
		return GeometryNodeInputMeshEdgeVertices_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshEdgeVertices::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshEdgeVertices_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshEdgeVertices::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshEdgeVertices_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshFaceArea::is_registered_node_type() {
		return GeometryNodeInputMeshFaceArea_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshFaceArea::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshFaceArea_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshFaceArea::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshFaceArea_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshFaceIsPlanar::is_registered_node_type() {
		return GeometryNodeInputMeshFaceIsPlanar_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshFaceIsPlanar::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshFaceIsPlanar_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshFaceIsPlanar::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshFaceIsPlanar_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshFaceNeighbors::is_registered_node_type() {
		return GeometryNodeInputMeshFaceNeighbors_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshFaceNeighbors::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshFaceNeighbors_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshFaceNeighbors::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshFaceNeighbors_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshIsland::is_registered_node_type() {
		return GeometryNodeInputMeshIsland_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshIsland::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshIsland_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshIsland::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshIsland_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputMeshVertexNeighbors::is_registered_node_type() {
		return GeometryNodeInputMeshVertexNeighbors_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshVertexNeighbors::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshVertexNeighbors_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputMeshVertexNeighbors::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputMeshVertexNeighbors_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputNamedAttribute::is_registered_node_type() {
		return GeometryNodeInputNamedAttribute_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputNamedAttribute::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputNamedAttribute_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputNamedAttribute::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputNamedAttribute_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputNamedLayerSelection::is_registered_node_type() {
		return GeometryNodeInputNamedLayerSelection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputNamedLayerSelection::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputNamedLayerSelection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputNamedLayerSelection::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputNamedLayerSelection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputNormal::is_registered_node_type() {
		return GeometryNodeInputNormal_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputNormal::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputNormal_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputNormal::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputNormal_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputPosition::is_registered_node_type() {
		return GeometryNodeInputPosition_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputPosition::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputPosition_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputPosition::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputPosition_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputRadius::is_registered_node_type() {
		return GeometryNodeInputRadius_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputRadius::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputRadius_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputRadius::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputRadius_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputSceneTime::is_registered_node_type() {
		return GeometryNodeInputSceneTime_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSceneTime::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSceneTime_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSceneTime::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSceneTime_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputShadeSmooth::is_registered_node_type() {
		return GeometryNodeInputShadeSmooth_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputShadeSmooth::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputShadeSmooth_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputShadeSmooth::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputShadeSmooth_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputShortestEdgePaths::is_registered_node_type() {
		return GeometryNodeInputShortestEdgePaths_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputShortestEdgePaths::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputShortestEdgePaths_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputShortestEdgePaths::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputShortestEdgePaths_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputSignedDistance::is_registered_node_type() {
		return GeometryNodeInputSignedDistance_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSignedDistance::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSignedDistance_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSignedDistance::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSignedDistance_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputSplineCyclic::is_registered_node_type() {
		return GeometryNodeInputSplineCyclic_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSplineCyclic::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSplineCyclic_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSplineCyclic::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSplineCyclic_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSplineLength::is_registered_node_type() {
		return GeometryNodeSplineLength_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplineLength::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplineLength_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplineLength::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplineLength_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputSplineResolution::is_registered_node_type() {
		return GeometryNodeInputSplineResolution_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSplineResolution::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSplineResolution_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputSplineResolution::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputSplineResolution_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputTangent::is_registered_node_type() {
		return GeometryNodeInputTangent_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputTangent::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputTangent_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputTangent::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputTangent_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInstanceOnPoints::is_registered_node_type() {
		return GeometryNodeInstanceOnPoints_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInstanceOnPoints::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInstanceOnPoints_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInstanceOnPoints::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInstanceOnPoints_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInstancesToPoints::is_registered_node_type() {
		return GeometryNodeInstancesToPoints_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInstancesToPoints::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInstancesToPoints_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInstancesToPoints::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInstancesToPoints_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeIsViewport::is_registered_node_type() {
		return GeometryNodeIsViewport_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeIsViewport::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeIsViewport_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeIsViewport::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeIsViewport_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeJoinGeometry::is_registered_node_type() {
		return GeometryNodeJoinGeometry_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeJoinGeometry::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeJoinGeometry_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeJoinGeometry::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeJoinGeometry_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMaterialSelection::is_registered_node_type() {
		return GeometryNodeMaterialSelection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMaterialSelection::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMaterialSelection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMaterialSelection::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMaterialSelection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeanFilterSDFVolume::is_registered_node_type() {
		return GeometryNodeMeanFilterSDFVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeanFilterSDFVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeanFilterSDFVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeanFilterSDFVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeanFilterSDFVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMergeByDistance::is_registered_node_type() {
		return GeometryNodeMergeByDistance_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMergeByDistance::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMergeByDistance_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMergeByDistance::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMergeByDistance_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshBoolean::is_registered_node_type() {
		return GeometryNodeMeshBoolean_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshBoolean::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshBoolean_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshBoolean::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshBoolean_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshFaceSetBoundaries::is_registered_node_type() {
		return GeometryNodeMeshFaceSetBoundaries_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshFaceSetBoundaries::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshFaceSetBoundaries_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshFaceSetBoundaries::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshFaceSetBoundaries_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshCircle::is_registered_node_type() {
		return GeometryNodeMeshCircle_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCircle::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCircle_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCircle::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCircle_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshCone::is_registered_node_type() {
		return GeometryNodeMeshCone_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCone::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCone_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCone::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCone_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshCube::is_registered_node_type() {
		return GeometryNodeMeshCube_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCube::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCube_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCube::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCube_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshCylinder::is_registered_node_type() {
		return GeometryNodeMeshCylinder_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCylinder::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCylinder_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshCylinder::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshCylinder_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshGrid::is_registered_node_type() {
		return GeometryNodeMeshGrid_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshGrid::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshGrid_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshGrid::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshGrid_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshIcoSphere::is_registered_node_type() {
		return GeometryNodeMeshIcoSphere_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshIcoSphere::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshIcoSphere_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshIcoSphere::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshIcoSphere_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshLine::is_registered_node_type() {
		return GeometryNodeMeshLine_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshLine::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshLine_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshLine::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshLine_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshUVSphere::is_registered_node_type() {
		return GeometryNodeMeshUVSphere_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshUVSphere::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshUVSphere_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshUVSphere::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshUVSphere_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshToCurve::is_registered_node_type() {
		return GeometryNodeMeshToCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshToPoints::is_registered_node_type() {
		return GeometryNodeMeshToPoints_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToPoints::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToPoints_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToPoints::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToPoints_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshToSDFVolume::is_registered_node_type() {
		return GeometryNodeMeshToSDFVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToSDFVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToSDFVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToSDFVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToSDFVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeMeshToVolume::is_registered_node_type() {
		return GeometryNodeMeshToVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeMeshToVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeMeshToVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCornersOfEdge::is_registered_node_type() {
		return GeometryNodeCornersOfEdge_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCornersOfEdge::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCornersOfEdge_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCornersOfEdge::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCornersOfEdge_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCornersOfFace::is_registered_node_type() {
		return GeometryNodeCornersOfFace_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCornersOfFace::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCornersOfFace_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCornersOfFace::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCornersOfFace_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeCornersOfVertex::is_registered_node_type() {
		return GeometryNodeCornersOfVertex_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeCornersOfVertex::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeCornersOfVertex_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeCornersOfVertex::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeCornersOfVertex_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeEdgesOfCorner::is_registered_node_type() {
		return GeometryNodeEdgesOfCorner_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgesOfCorner::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgesOfCorner_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgesOfCorner::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgesOfCorner_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeEdgesOfVertex::is_registered_node_type() {
		return GeometryNodeEdgesOfVertex_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgesOfVertex::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgesOfVertex_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeEdgesOfVertex::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeEdgesOfVertex_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeFaceOfCorner::is_registered_node_type() {
		return GeometryNodeFaceOfCorner_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeFaceOfCorner::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeFaceOfCorner_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeFaceOfCorner::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeFaceOfCorner_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeOffsetCornerInFace::is_registered_node_type() {
		return GeometryNodeOffsetCornerInFace_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeOffsetCornerInFace::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeOffsetCornerInFace_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeOffsetCornerInFace::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeOffsetCornerInFace_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeVertexOfCorner::is_registered_node_type() {
		return GeometryNodeVertexOfCorner_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeVertexOfCorner::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeVertexOfCorner_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeVertexOfCorner::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeVertexOfCorner_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeObjectInfo::is_registered_node_type() {
		return GeometryNodeObjectInfo_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeObjectInfo::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeObjectInfo_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeObjectInfo::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeObjectInfo_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeOffsetPointInCurve::is_registered_node_type() {
		return GeometryNodeOffsetPointInCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeOffsetPointInCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeOffsetPointInCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeOffsetPointInCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeOffsetPointInCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeOffsetSDFVolume::is_registered_node_type() {
		return GeometryNodeOffsetSDFVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeOffsetSDFVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeOffsetSDFVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeOffsetSDFVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeOffsetSDFVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeToolFaceSet::is_registered_node_type() {
		return GeometryNodeToolFaceSet_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolFaceSet::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolFaceSet_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolFaceSet::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolFaceSet_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeTool3DCursor::is_registered_node_type() {
		return GeometryNodeTool3DCursor_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeTool3DCursor::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeTool3DCursor_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeTool3DCursor::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeTool3DCursor_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeToolSelection::is_registered_node_type() {
		return GeometryNodeToolSelection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolSelection::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolSelection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolSelection::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolSelection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeToolSetSelection::is_registered_node_type() {
		return GeometryNodeToolSetSelection_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolSetSelection::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolSetSelection_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolSetSelection::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolSetSelection_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeToolSetFaceSet::is_registered_node_type() {
		return GeometryNodeToolSetFaceSet_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolSetFaceSet::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolSetFaceSet_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeToolSetFaceSet::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeToolSetFaceSet_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodePointsToSDFVolume::is_registered_node_type() {
		return GeometryNodePointsToSDFVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToSDFVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToSDFVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToSDFVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToSDFVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodePointsToVertices::is_registered_node_type() {
		return GeometryNodePointsToVertices_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToVertices::input_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToVertices_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToVertices::output_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToVertices_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodePointsToVolume::is_registered_node_type() {
		return GeometryNodePointsToVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodePoints::is_registered_node_type() {
		return GeometryNodePoints_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodePoints::input_template(int index) {
		PointerRNA result;
		result = GeometryNodePoints_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodePoints::output_template(int index) {
		PointerRNA result;
		result = GeometryNodePoints_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeProximity::is_registered_node_type() {
		return GeometryNodeProximity_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeProximity::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeProximity_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeProximity::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeProximity_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeRaycast::is_registered_node_type() {
		return GeometryNodeRaycast_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeRaycast::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeRaycast_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeRaycast::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeRaycast_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeRealizeInstances::is_registered_node_type() {
		return GeometryNodeRealizeInstances_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeRealizeInstances::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeRealizeInstances_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeRealizeInstances::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeRealizeInstances_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeRemoveAttribute::is_registered_node_type() {
		return GeometryNodeRemoveAttribute_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeRemoveAttribute::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeRemoveAttribute_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeRemoveAttribute::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeRemoveAttribute_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Node, GeometryNodeRepeatInput, paired_output)

	inline bool GeometryNodeRepeatInput::is_registered_node_type() {
		return GeometryNodeRepeatInput_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeRepeatInput::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeRepeatInput_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeRepeatInput::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeRepeatInput_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline bool GeometryNodeRepeatInput::pair_with_output(Context C, GeometryNode& output_node) {
		return GeometryNodeRepeatInput_pair_with_output_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::bNode *) output_node.ptr.data);
	}



	INT_PROPERTY(GeometryNodeRepeatOutput, active_index)
	POINTER_PROPERTY(RepeatItem, GeometryNodeRepeatOutput, active_item)
	INT_PROPERTY(GeometryNodeRepeatOutput, inspection_index)

	inline bool GeometryNodeRepeatOutput::is_registered_node_type() {
		return GeometryNodeRepeatOutput_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeRepeatOutput::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeRepeatOutput_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeRepeatOutput::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeRepeatOutput_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeReplaceMaterial::is_registered_node_type() {
		return GeometryNodeReplaceMaterial_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeReplaceMaterial::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeReplaceMaterial_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeReplaceMaterial::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeReplaceMaterial_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeResampleCurve::is_registered_node_type() {
		return GeometryNodeResampleCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeResampleCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeResampleCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeResampleCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeResampleCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeReverseCurve::is_registered_node_type() {
		return GeometryNodeReverseCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeReverseCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeReverseCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeReverseCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeReverseCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeRotateInstances::is_registered_node_type() {
		return GeometryNodeRotateInstances_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeRotateInstances::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeRotateInstances_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeRotateInstances::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeRotateInstances_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(mode_enum, GeometryNodeSampleCurve, mode)
	BOOLEAN_PROPERTY(GeometryNodeSampleCurve, use_all_curves)
	ENUM_PROPERTY(data_type_enum, GeometryNodeSampleCurve, data_type)

	inline bool GeometryNodeSampleCurve::is_registered_node_type() {
		return GeometryNodeSampleCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	ENUM_PROPERTY(data_type_enum, GeometryNodeSampleIndex, data_type)
	ENUM_PROPERTY(domain_enum, GeometryNodeSampleIndex, domain)
	BOOLEAN_PROPERTY(GeometryNodeSampleIndex, clamp)

	inline bool GeometryNodeSampleIndex::is_registered_node_type() {
		return GeometryNodeSampleIndex_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleIndex::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleIndex_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleIndex::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleIndex_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSampleNearestSurface::is_registered_node_type() {
		return GeometryNodeSampleNearestSurface_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleNearestSurface::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleNearestSurface_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleNearestSurface::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleNearestSurface_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSampleNearest::is_registered_node_type() {
		return GeometryNodeSampleNearest_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleNearest::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleNearest_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleNearest::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleNearest_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSampleUVSurface::is_registered_node_type() {
		return GeometryNodeSampleUVSurface_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleUVSurface::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleUVSurface_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleUVSurface::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleUVSurface_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSampleVolume::is_registered_node_type() {
		return GeometryNodeSampleVolume_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleVolume::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleVolume_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSampleVolume::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSampleVolume_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeScaleElements::is_registered_node_type() {
		return GeometryNodeScaleElements_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeScaleElements::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeScaleElements_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeScaleElements::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeScaleElements_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeScaleInstances::is_registered_node_type() {
		return GeometryNodeScaleInstances_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeScaleInstances::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeScaleInstances_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeScaleInstances::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeScaleInstances_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSDFVolumeSphere::is_registered_node_type() {
		return GeometryNodeSDFVolumeSphere_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSDFVolumeSphere::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSDFVolumeSphere_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSDFVolumeSphere::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSDFVolumeSphere_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSelfObject::is_registered_node_type() {
		return GeometryNodeSelfObject_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSelfObject::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSelfObject_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSelfObject::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSelfObject_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSeparateComponents::is_registered_node_type() {
		return GeometryNodeSeparateComponents_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSeparateComponents::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSeparateComponents_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSeparateComponents::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSeparateComponents_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSeparateGeometry::is_registered_node_type() {
		return GeometryNodeSeparateGeometry_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSeparateGeometry::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSeparateGeometry_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSeparateGeometry::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSeparateGeometry_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetCurveHandlePositions::is_registered_node_type() {
		return GeometryNodeSetCurveHandlePositions_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveHandlePositions::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveHandlePositions_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveHandlePositions::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveHandlePositions_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetCurveNormal::is_registered_node_type() {
		return GeometryNodeSetCurveNormal_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveNormal::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveNormal_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveNormal::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveNormal_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetCurveRadius::is_registered_node_type() {
		return GeometryNodeSetCurveRadius_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveRadius::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveRadius_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveRadius::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveRadius_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetCurveTilt::is_registered_node_type() {
		return GeometryNodeSetCurveTilt_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveTilt::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveTilt_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetCurveTilt::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetCurveTilt_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetID::is_registered_node_type() {
		return GeometryNodeSetID_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetID::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetID_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetID::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetID_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetMaterialIndex::is_registered_node_type() {
		return GeometryNodeSetMaterialIndex_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetMaterialIndex::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetMaterialIndex_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetMaterialIndex::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetMaterialIndex_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetMaterial::is_registered_node_type() {
		return GeometryNodeSetMaterial_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetMaterial::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetMaterial_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetMaterial::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetMaterial_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetPointRadius::is_registered_node_type() {
		return GeometryNodeSetPointRadius_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetPointRadius::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetPointRadius_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetPointRadius::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetPointRadius_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetPosition::is_registered_node_type() {
		return GeometryNodeSetPosition_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetPosition::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetPosition_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetPosition::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetPosition_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetShadeSmooth::is_registered_node_type() {
		return GeometryNodeSetShadeSmooth_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetShadeSmooth::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetShadeSmooth_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetShadeSmooth::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetShadeSmooth_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetSplineCyclic::is_registered_node_type() {
		return GeometryNodeSetSplineCyclic_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetSplineCyclic::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetSplineCyclic_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetSplineCyclic::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetSplineCyclic_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSetSplineResolution::is_registered_node_type() {
		return GeometryNodeSetSplineResolution_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetSplineResolution::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetSplineResolution_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSetSplineResolution::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSetSplineResolution_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(Node, GeometryNodeSimulationInput, paired_output)

	inline bool GeometryNodeSimulationInput::is_registered_node_type() {
		return GeometryNodeSimulationInput_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSimulationInput::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSimulationInput_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSimulationInput::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSimulationInput_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline bool GeometryNodeSimulationInput::pair_with_output(Context C, GeometryNode& output_node) {
		return GeometryNodeSimulationInput_pair_with_output_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::bNode *) output_node.ptr.data);
	}



	INT_PROPERTY(GeometryNodeSimulationOutput, active_index)
	POINTER_PROPERTY(SimulationStateItem, GeometryNodeSimulationOutput, active_item)

	inline bool GeometryNodeSimulationOutput::is_registered_node_type() {
		return GeometryNodeSimulationOutput_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSimulationOutput::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSimulationOutput_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSimulationOutput::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSimulationOutput_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSplitToInstances::is_registered_node_type() {
		return GeometryNodeSplitToInstances_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplitToInstances::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplitToInstances_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplitToInstances::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplitToInstances_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSplitEdges::is_registered_node_type() {
		return GeometryNodeSplitEdges_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplitEdges::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplitEdges_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSplitEdges::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSplitEdges_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeStoreNamedAttribute::is_registered_node_type() {
		return GeometryNodeStoreNamedAttribute_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeStoreNamedAttribute::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeStoreNamedAttribute_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeStoreNamedAttribute::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeStoreNamedAttribute_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeStringJoin::is_registered_node_type() {
		return GeometryNodeStringJoin_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeStringJoin::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeStringJoin_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeStringJoin::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeStringJoin_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(VectorFont, GeometryNodeStringToCurves, font)
	ENUM_PROPERTY(overflow_enum, GeometryNodeStringToCurves, overflow)
	ENUM_PROPERTY(align_x_enum, GeometryNodeStringToCurves, align_x)
	ENUM_PROPERTY(align_y_enum, GeometryNodeStringToCurves, align_y)
	ENUM_PROPERTY(pivot_mode_enum, GeometryNodeStringToCurves, pivot_mode)

	inline bool GeometryNodeStringToCurves::is_registered_node_type() {
		return GeometryNodeStringToCurves_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeStringToCurves::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeStringToCurves_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeStringToCurves::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeStringToCurves_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSubdivideCurve::is_registered_node_type() {
		return GeometryNodeSubdivideCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSubdivideCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSubdivideCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSubdivideCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSubdivideCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSubdivideMesh::is_registered_node_type() {
		return GeometryNodeSubdivideMesh_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSubdivideMesh::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSubdivideMesh_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSubdivideMesh::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSubdivideMesh_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSubdivisionSurface::is_registered_node_type() {
		return GeometryNodeSubdivisionSurface_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSubdivisionSurface::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSubdivisionSurface_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSubdivisionSurface::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSubdivisionSurface_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeSwitch::is_registered_node_type() {
		return GeometryNodeSwitch_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeSwitch::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeSwitch_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeSwitch::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeSwitch_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeTransform::is_registered_node_type() {
		return GeometryNodeTransform_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeTransform::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeTransform_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeTransform::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeTransform_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeTranslateInstances::is_registered_node_type() {
		return GeometryNodeTranslateInstances_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeTranslateInstances::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeTranslateInstances_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeTranslateInstances::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeTranslateInstances_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeTriangulate::is_registered_node_type() {
		return GeometryNodeTriangulate_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeTriangulate::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeTriangulate_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeTriangulate::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeTriangulate_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeTrimCurve::is_registered_node_type() {
		return GeometryNodeTrimCurve_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeTrimCurve::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeTrimCurve_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeTrimCurve::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeTrimCurve_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeUVPackIslands::is_registered_node_type() {
		return GeometryNodeUVPackIslands_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeUVPackIslands::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeUVPackIslands_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeUVPackIslands::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeUVPackIslands_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeUVUnwrap::is_registered_node_type() {
		return GeometryNodeUVUnwrap_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeUVUnwrap::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeUVUnwrap_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeUVUnwrap::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeUVUnwrap_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeViewer::is_registered_node_type() {
		return GeometryNodeViewer_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeViewer::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeViewer_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeViewer::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeViewer_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeVolumeCube::is_registered_node_type() {
		return GeometryNodeVolumeCube_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeVolumeCube::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeVolumeCube_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeVolumeCube::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeVolumeCube_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeVolumeToMesh::is_registered_node_type() {
		return GeometryNodeVolumeToMesh_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeVolumeToMesh::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeVolumeToMesh_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeVolumeToMesh::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeVolumeToMesh_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInterpolateCurves::is_registered_node_type() {
		return GeometryNodeInterpolateCurves_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInterpolateCurves::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInterpolateCurves_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInterpolateCurves::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInterpolateCurves_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodePointsToCurves::is_registered_node_type() {
		return GeometryNodePointsToCurves_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToCurves::input_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToCurves_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodePointsToCurves::output_template(int index) {
		PointerRNA result;
		result = GeometryNodePointsToCurves_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}



	inline bool GeometryNodeInputEdgeSmooth::is_registered_node_type() {
		return GeometryNodeInputEdgeSmooth_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputEdgeSmooth::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputEdgeSmooth_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeInputEdgeSmooth::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeInputEdgeSmooth_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, ShaderNodeGroup, node_tree)

	inline bool ShaderNodeGroup::is_registered_node_type() {
		return ShaderNodeGroup_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate ShaderNodeGroup::input_template(int index) {
		PointerRNA result;
		result = ShaderNodeGroup_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate ShaderNodeGroup::output_template(int index) {
		PointerRNA result;
		result = ShaderNodeGroup_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, CompositorNodeGroup, node_tree)

	inline bool CompositorNodeGroup::is_registered_node_type() {
		return CompositorNodeGroup_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate CompositorNodeGroup::input_template(int index) {
		PointerRNA result;
		result = CompositorNodeGroup_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate CompositorNodeGroup::output_template(int index) {
		PointerRNA result;
		result = CompositorNodeGroup_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, TextureNodeGroup, node_tree)

	inline bool TextureNodeGroup::is_registered_node_type() {
		return TextureNodeGroup_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate TextureNodeGroup::input_template(int index) {
		PointerRNA result;
		result = TextureNodeGroup_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate TextureNodeGroup::output_template(int index) {
		PointerRNA result;
		result = TextureNodeGroup_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, GeometryNodeGroup, node_tree)

	inline bool GeometryNodeGroup::is_registered_node_type() {
		return GeometryNodeGroup_is_registered_node_type_func(this->ptr.type);
	}

	inline NodeInternalSocketTemplate GeometryNodeGroup::input_template(int index) {
		PointerRNA result;
		result = GeometryNodeGroup_input_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}

	inline NodeInternalSocketTemplate GeometryNodeGroup::output_template(int index) {
		PointerRNA result;
		result = GeometryNodeGroup_output_template_func(this->ptr.type, index);
		return NodeInternalSocketTemplate(result);
	}


	POINTER_PROPERTY(NodeTree, ShaderNodeCustomGroup, node_tree)


	POINTER_PROPERTY(NodeTree, CompositorNodeCustomGroup, node_tree)


	POINTER_PROPERTY(NodeTree, NodeCustomGroup, node_tree)


	POINTER_PROPERTY(NodeTree, GeometryNodeCustomGroup, node_tree)


	POINTER_PROPERTY(Struct, NodeOutputFileSlotFile, rna_type)
	BOOLEAN_PROPERTY(NodeOutputFileSlotFile, use_node_format)
	BOOLEAN_PROPERTY(NodeOutputFileSlotFile, save_as_render)
	POINTER_PROPERTY(ImageFormatSettings, NodeOutputFileSlotFile, format)
	STRING_PROPERTY(NodeOutputFileSlotFile, path)


	POINTER_PROPERTY(Struct, NodeOutputFileSlotLayer, rna_type)
	STRING_PROPERTY(NodeOutputFileSlotLayer, name)


	POINTER_PROPERTY(Struct, NodeGeometrySimulationOutputItems, rna_type)

	inline SimulationStateItem NodeGeometrySimulationOutputItems::create(void *main, int socket_type, const char * name) {
		PointerRNA result;
		::NodeSimulationItem *retdata = NodeGeometrySimulationOutputItems_new_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, socket_type, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_SimulationStateItem, retdata);
		return SimulationStateItem(result);
	}

	inline void NodeGeometrySimulationOutputItems::remove(void *main, SimulationStateItem& item) {
		NodeGeometrySimulationOutputItems_remove_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, (::NodeSimulationItem *) item.ptr.data);
	}

	inline void NodeGeometrySimulationOutputItems::clear(void *main) {
		NodeGeometrySimulationOutputItems_clear_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main);
	}

	inline void NodeGeometrySimulationOutputItems::move(void *main, int from_index, int to_index) {
		NodeGeometrySimulationOutputItems_move_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, NodeGeometryRepeatOutputItems, rna_type)

	inline RepeatItem NodeGeometryRepeatOutputItems::create(void *main, int socket_type, const char * name) {
		PointerRNA result;
		::NodeRepeatItem *retdata = NodeGeometryRepeatOutputItems_new_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, socket_type, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RepeatItem, retdata);
		return RepeatItem(result);
	}

	inline void NodeGeometryRepeatOutputItems::remove(void *main, RepeatItem& item) {
		NodeGeometryRepeatOutputItems_remove_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, nullptr, (::NodeRepeatItem *) item.ptr.data);
	}

	inline void NodeGeometryRepeatOutputItems::clear(void *main) {
		NodeGeometryRepeatOutputItems_clear_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main);
	}

	inline void NodeGeometryRepeatOutputItems::move(void *main, int from_index, int to_index) {
		NodeGeometryRepeatOutputItems_move_func((::ID *) ptr.owner_id, (::bNode *) this->ptr.data, (::Main *) main, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, NodeInstanceHash, rna_type)


	POINTER_PROPERTY(Struct, NodeSocket, rna_type)
	STRING_PROPERTY(NodeSocket, name)
	STRING_PROPERTY(NodeSocket, label)
	STRING_PROPERTY(NodeSocket, identifier)
	STRING_PROPERTY(NodeSocket, description)
	BOOLEAN_PROPERTY(NodeSocket, is_output)
	BOOLEAN_PROPERTY(NodeSocket, hide)
	BOOLEAN_PROPERTY(NodeSocket, enabled)
	INT_PROPERTY(NodeSocket, link_limit)
	BOOLEAN_PROPERTY(NodeSocket, is_linked)
	BOOLEAN_PROPERTY(NodeSocket, is_unavailable)
	BOOLEAN_PROPERTY(NodeSocket, is_multi_input)
	BOOLEAN_PROPERTY(NodeSocket, show_expanded)
	BOOLEAN_PROPERTY(NodeSocket, hide_value)
	POINTER_PROPERTY(Node, NodeSocket, node)
	ENUM_PROPERTY(type_enum, NodeSocket, type)
	ENUM_PROPERTY(display_shape_enum, NodeSocket, display_shape)
	STRING_PROPERTY(NodeSocket, bl_idname)
	STRING_PROPERTY(NodeSocket, bl_label)
	STRING_PROPERTY(NodeSocket, bl_subtype_label)



	inline void NodeSocketStandard::draw(Context& context, UILayout& layout, Node& node, const char * text) {
		NodeSocketStandard_draw_func((::ID *) ptr.owner_id, (::bNodeSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data, (::PointerRNA *) &node, text);
	}

	inline void NodeSocketStandard::draw_color(Context& context, Node& node, float color[4]) {
		NodeSocketStandard_draw_color_func((::ID *) ptr.owner_id, (::bNodeSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::PointerRNA *) &node, color);
	}

	inline void NodeSocketStandard::draw_color_simple(float color[4]) {
		NodeSocketStandard_draw_color_simple_func(this->ptr.type, color);
	}


	FLOAT_PROPERTY(NodeSocketFloat, default_value)


	FLOAT_PROPERTY(NodeSocketFloatUnsigned, default_value)


	FLOAT_PROPERTY(NodeSocketFloatPercentage, default_value)


	FLOAT_PROPERTY(NodeSocketFloatFactor, default_value)


	FLOAT_PROPERTY(NodeSocketFloatAngle, default_value)


	FLOAT_PROPERTY(NodeSocketFloatTime, default_value)


	FLOAT_PROPERTY(NodeSocketFloatTimeAbsolute, default_value)


	FLOAT_PROPERTY(NodeSocketFloatDistance, default_value)


	INT_PROPERTY(NodeSocketInt, default_value)


	INT_PROPERTY(NodeSocketIntUnsigned, default_value)


	INT_PROPERTY(NodeSocketIntPercentage, default_value)


	INT_PROPERTY(NodeSocketIntFactor, default_value)


	BOOLEAN_PROPERTY(NodeSocketBool, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketRotation, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVector, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorTranslation, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorDirection, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorVelocity, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorAcceleration, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorEuler, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketVectorXYZ, 3, default_value)


	FLOAT_ARRAY_PROPERTY(NodeSocketColor, 4, default_value)


	STRING_PROPERTY(NodeSocketString, default_value)




	POINTER_PROPERTY(Object, NodeSocketObject, default_value)


	POINTER_PROPERTY(Image, NodeSocketImage, default_value)




	POINTER_PROPERTY(Collection, NodeSocketCollection, default_value)


	POINTER_PROPERTY(Texture, NodeSocketTexture, default_value)


	POINTER_PROPERTY(Material, NodeSocketMaterial, default_value)




	POINTER_PROPERTY(Struct, NodeTreeInterfaceItem, rna_type)
	ENUM_PROPERTY(item_type_enum, NodeTreeInterfaceItem, item_type)
	POINTER_PROPERTY(NodeTreeInterfacePanel, NodeTreeInterfaceItem, parent)
	INT_PROPERTY(NodeTreeInterfaceItem, position)
	INT_PROPERTY(NodeTreeInterfaceItem, index)


	STRING_PROPERTY(NodeTreeInterfaceSocket, name)
	STRING_PROPERTY(NodeTreeInterfaceSocket, identifier)
	STRING_PROPERTY(NodeTreeInterfaceSocket, description)
	ENUM_PROPERTY(socket_type_enum, NodeTreeInterfaceSocket, socket_type)
	ENUM_PROPERTY(in_out_enum, NodeTreeInterfaceSocket, in_out)
	BOOLEAN_PROPERTY(NodeTreeInterfaceSocket, hide_value)
	BOOLEAN_PROPERTY(NodeTreeInterfaceSocket, hide_in_modifier)
	BOOLEAN_PROPERTY(NodeTreeInterfaceSocket, force_non_field)
	BOOLEAN_PROPERTY(NodeTreeInterfaceSocket, layer_selection_field)
	ENUM_PROPERTY(attribute_domain_enum, NodeTreeInterfaceSocket, attribute_domain)
	STRING_PROPERTY(NodeTreeInterfaceSocket, default_attribute_name)
	ENUM_PROPERTY(default_input_enum, NodeTreeInterfaceSocket, default_input)
	STRING_PROPERTY(NodeTreeInterfaceSocket, bl_socket_idname)


	STRING_PROPERTY(NodeTreeInterfacePanel, name)
	STRING_PROPERTY(NodeTreeInterfacePanel, description)
	BOOLEAN_PROPERTY(NodeTreeInterfacePanel, default_closed)



	POINTER_PROPERTY(Struct, NodeTreeInterface, rna_type)

	INT_PROPERTY(NodeTreeInterface, active_index)
	POINTER_PROPERTY(NodeTreeInterfaceItem, NodeTreeInterface, active)

	inline NodeTreeInterfaceSocket NodeTreeInterface::new_socket(void *main, const char * name, const char * description, int in_out, int socket_type, NodeTreeInterfacePanel& parent) {
		PointerRNA result;
		::bNodeTreeInterfaceSocket *retdata = NodeTreeInterface_new_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterface *) this->ptr.data, (::Main *) main, nullptr, name, description, in_out, socket_type, (::bNodeTreeInterfacePanel *) parent.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeTreeInterfaceSocket, retdata);
		return NodeTreeInterfaceSocket(result);
	}

	inline NodeTreeInterfacePanel NodeTreeInterface::new_panel(void *main, const char * name, const char * description, bool default_closed, NodeTreeInterfacePanel& parent) {
		PointerRNA result;
		::bNodeTreeInterfacePanel *retdata = NodeTreeInterface_new_panel_func((::ID *) ptr.owner_id, (::bNodeTreeInterface *) this->ptr.data, (::Main *) main, nullptr, name, description, default_closed, (::bNodeTreeInterfacePanel *) parent.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeTreeInterfacePanel, retdata);
		return NodeTreeInterfacePanel(result);
	}

	inline NodeTreeInterfaceItem NodeTreeInterface::copy(void *main, NodeTreeInterfaceItem& item) {
		PointerRNA result;
		::bNodeTreeInterfaceItem *retdata = NodeTreeInterface_copy_func((::ID *) ptr.owner_id, (::bNodeTreeInterface *) this->ptr.data, (::Main *) main, nullptr, (::bNodeTreeInterfaceItem *) item.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_NodeTreeInterfaceItem, retdata);
		return NodeTreeInterfaceItem(result);
	}

	inline void NodeTreeInterface::remove(void *main, NodeTreeInterfaceItem& item, bool move_content_to_parent) {
		NodeTreeInterface_remove_func((::ID *) ptr.owner_id, (::bNodeTreeInterface *) this->ptr.data, (::Main *) main, (::bNodeTreeInterfaceItem *) item.ptr.data, move_content_to_parent);
	}

	inline void NodeTreeInterface::clear(void *main) {
		NodeTreeInterface_clear_func((::ID *) ptr.owner_id, (::bNodeTreeInterface *) this->ptr.data, (::Main *) main);
	}

	inline void NodeTreeInterface::move(void *main, NodeTreeInterfaceItem& item, int to_position) {
		NodeTreeInterface_move_func((::ID *) ptr.owner_id, (::bNodeTreeInterface *) this->ptr.data, (::Main *) main, (::bNodeTreeInterfaceItem *) item.ptr.data, to_position);
	}

	inline void NodeTreeInterface::move_to_parent(void *main, NodeTreeInterfaceItem& item, NodeTreeInterfacePanel& parent, int to_position) {
		NodeTreeInterface_move_to_parent_func((::ID *) ptr.owner_id, (::bNodeTreeInterface *) this->ptr.data, (::Main *) main, nullptr, (::bNodeTreeInterfaceItem *) item.ptr.data, (::bNodeTreeInterfacePanel *) parent.ptr.data, to_position);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloat, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloat, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloat, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloat, max_value)

	inline void NodeTreeInterfaceSocketFloat::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloat_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloat::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloat_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloat::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloat_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloatUnsigned, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatUnsigned, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatUnsigned, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatUnsigned, max_value)

	inline void NodeTreeInterfaceSocketFloatUnsigned::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloatUnsigned_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloatUnsigned::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloatUnsigned_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloatUnsigned::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloatUnsigned_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloatPercentage, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatPercentage, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatPercentage, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatPercentage, max_value)

	inline void NodeTreeInterfaceSocketFloatPercentage::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloatPercentage_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloatPercentage::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloatPercentage_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloatPercentage::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloatPercentage_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloatFactor, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatFactor, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatFactor, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatFactor, max_value)

	inline void NodeTreeInterfaceSocketFloatFactor::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloatFactor_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloatFactor::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloatFactor_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloatFactor::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloatFactor_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloatAngle, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatAngle, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatAngle, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatAngle, max_value)

	inline void NodeTreeInterfaceSocketFloatAngle::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloatAngle_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloatAngle::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloatAngle_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloatAngle::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloatAngle_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloatTime, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatTime, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatTime, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatTime, max_value)

	inline void NodeTreeInterfaceSocketFloatTime::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloatTime_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloatTime::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloatTime_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloatTime::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloatTime_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloatTimeAbsolute, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatTimeAbsolute, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatTimeAbsolute, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatTimeAbsolute, max_value)

	inline void NodeTreeInterfaceSocketFloatTimeAbsolute::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloatTimeAbsolute_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloatTimeAbsolute::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloatTimeAbsolute_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloatTimeAbsolute::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloatTimeAbsolute_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketFloatDistance, subtype)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatDistance, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatDistance, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketFloatDistance, max_value)

	inline void NodeTreeInterfaceSocketFloatDistance::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketFloatDistance_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketFloatDistance::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketFloatDistance_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketFloatDistance::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketFloatDistance_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketInt, subtype)
	INT_PROPERTY(NodeTreeInterfaceSocketInt, default_value)
	INT_PROPERTY(NodeTreeInterfaceSocketInt, min_value)
	INT_PROPERTY(NodeTreeInterfaceSocketInt, max_value)

	inline void NodeTreeInterfaceSocketInt::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketInt_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketInt::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketInt_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketInt::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketInt_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketIntUnsigned, subtype)
	INT_PROPERTY(NodeTreeInterfaceSocketIntUnsigned, default_value)
	INT_PROPERTY(NodeTreeInterfaceSocketIntUnsigned, min_value)
	INT_PROPERTY(NodeTreeInterfaceSocketIntUnsigned, max_value)

	inline void NodeTreeInterfaceSocketIntUnsigned::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketIntUnsigned_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketIntUnsigned::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketIntUnsigned_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketIntUnsigned::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketIntUnsigned_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketIntPercentage, subtype)
	INT_PROPERTY(NodeTreeInterfaceSocketIntPercentage, default_value)
	INT_PROPERTY(NodeTreeInterfaceSocketIntPercentage, min_value)
	INT_PROPERTY(NodeTreeInterfaceSocketIntPercentage, max_value)

	inline void NodeTreeInterfaceSocketIntPercentage::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketIntPercentage_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketIntPercentage::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketIntPercentage_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketIntPercentage::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketIntPercentage_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketIntFactor, subtype)
	INT_PROPERTY(NodeTreeInterfaceSocketIntFactor, default_value)
	INT_PROPERTY(NodeTreeInterfaceSocketIntFactor, min_value)
	INT_PROPERTY(NodeTreeInterfaceSocketIntFactor, max_value)

	inline void NodeTreeInterfaceSocketIntFactor::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketIntFactor_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketIntFactor::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketIntFactor_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketIntFactor::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketIntFactor_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	BOOLEAN_PROPERTY(NodeTreeInterfaceSocketBool, default_value)

	inline void NodeTreeInterfaceSocketBool::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketBool_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketBool::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketBool_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketBool::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketBool_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketRotation, 3, default_value)

	inline void NodeTreeInterfaceSocketRotation::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketRotation_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketRotation::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketRotation_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketRotation::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketRotation_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketVector, subtype)
	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketVector, 3, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVector, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVector, max_value)

	inline void NodeTreeInterfaceSocketVector::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketVector_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketVector::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketVector_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketVector::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketVector_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketVectorTranslation, subtype)
	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketVectorTranslation, 3, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorTranslation, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorTranslation, max_value)

	inline void NodeTreeInterfaceSocketVectorTranslation::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketVectorTranslation_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketVectorTranslation::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketVectorTranslation_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketVectorTranslation::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketVectorTranslation_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketVectorDirection, subtype)
	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketVectorDirection, 3, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorDirection, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorDirection, max_value)

	inline void NodeTreeInterfaceSocketVectorDirection::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketVectorDirection_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketVectorDirection::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketVectorDirection_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketVectorDirection::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketVectorDirection_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketVectorVelocity, subtype)
	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketVectorVelocity, 3, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorVelocity, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorVelocity, max_value)

	inline void NodeTreeInterfaceSocketVectorVelocity::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketVectorVelocity_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketVectorVelocity::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketVectorVelocity_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketVectorVelocity::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketVectorVelocity_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketVectorAcceleration, subtype)
	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketVectorAcceleration, 3, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorAcceleration, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorAcceleration, max_value)

	inline void NodeTreeInterfaceSocketVectorAcceleration::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketVectorAcceleration_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketVectorAcceleration::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketVectorAcceleration_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketVectorAcceleration::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketVectorAcceleration_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketVectorEuler, subtype)
	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketVectorEuler, 3, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorEuler, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorEuler, max_value)

	inline void NodeTreeInterfaceSocketVectorEuler::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketVectorEuler_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketVectorEuler::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketVectorEuler_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketVectorEuler::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketVectorEuler_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	ENUM_PROPERTY(subtype_enum, NodeTreeInterfaceSocketVectorXYZ, subtype)
	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketVectorXYZ, 3, default_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorXYZ, min_value)
	FLOAT_PROPERTY(NodeTreeInterfaceSocketVectorXYZ, max_value)

	inline void NodeTreeInterfaceSocketVectorXYZ::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketVectorXYZ_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketVectorXYZ::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketVectorXYZ_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketVectorXYZ::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketVectorXYZ_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	FLOAT_ARRAY_PROPERTY(NodeTreeInterfaceSocketColor, 4, default_value)

	inline void NodeTreeInterfaceSocketColor::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketColor_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketColor::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketColor_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketColor::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketColor_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	STRING_PROPERTY(NodeTreeInterfaceSocketString, default_value)

	inline void NodeTreeInterfaceSocketString::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketString_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketString::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketString_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketString::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketString_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}



	inline void NodeTreeInterfaceSocketShader::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketShader_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketShader::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketShader_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketShader::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketShader_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	POINTER_PROPERTY(Object, NodeTreeInterfaceSocketObject, default_value)

	inline void NodeTreeInterfaceSocketObject::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketObject_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketObject::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketObject_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketObject::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketObject_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	POINTER_PROPERTY(Image, NodeTreeInterfaceSocketImage, default_value)

	inline void NodeTreeInterfaceSocketImage::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketImage_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketImage::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketImage_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketImage::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketImage_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}



	inline void NodeTreeInterfaceSocketGeometry::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketGeometry_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketGeometry::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketGeometry_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketGeometry::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketGeometry_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	POINTER_PROPERTY(Collection, NodeTreeInterfaceSocketCollection, default_value)

	inline void NodeTreeInterfaceSocketCollection::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketCollection_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketCollection::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketCollection_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketCollection::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketCollection_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	POINTER_PROPERTY(Texture, NodeTreeInterfaceSocketTexture, default_value)

	inline void NodeTreeInterfaceSocketTexture::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketTexture_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketTexture::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketTexture_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketTexture::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketTexture_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	POINTER_PROPERTY(Material, NodeTreeInterfaceSocketMaterial, default_value)

	inline void NodeTreeInterfaceSocketMaterial::draw(Context& context, UILayout& layout) {
		NodeTreeInterfaceSocketMaterial_draw_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bContext *) context.ptr.data, (::uiLayout *) layout.ptr.data);
	}

	inline void NodeTreeInterfaceSocketMaterial::init_socket(Node& node, NodeSocket& socket, const char * data_path) {
		NodeTreeInterfaceSocketMaterial_init_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data, data_path);
	}

	inline void NodeTreeInterfaceSocketMaterial::from_socket(Node& node, NodeSocket& socket) {
		NodeTreeInterfaceSocketMaterial_from_socket_func((::ID *) ptr.owner_id, (::bNodeTreeInterfaceSocket *) this->ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}


	POINTER_PROPERTY(ID, Object, data)
	ENUM_PROPERTY(type_enum, Object, type)
	ENUM_PROPERTY(mode_enum, Object, mode)
	FLOAT_ARRAY_PROPERTY(Object, 24, bound_box)
	POINTER_PROPERTY(Object, Object, parent)
	ENUM_PROPERTY(parent_type_enum, Object, parent_type)
	INT_ARRAY_PROPERTY(Object, 3, parent_vertices)
	STRING_PROPERTY(Object, parent_bone)
	BOOLEAN_PROPERTY(Object, use_camera_lock_parent)
	ENUM_PROPERTY(track_axis_enum, Object, track_axis)
	ENUM_PROPERTY(up_axis_enum, Object, up_axis)

	POINTER_PROPERTY(Material, Object, active_material)
	INT_PROPERTY(Object, active_material_index)
	FLOAT_ARRAY_PROPERTY(Object, 3, location)
	FLOAT_ARRAY_PROPERTY(Object, 4, rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(Object, 4, rotation_axis_angle)
	FLOAT_ARRAY_PROPERTY(Object, 3, rotation_euler)
	ENUM_PROPERTY(rotation_mode_enum, Object, rotation_mode)
	FLOAT_ARRAY_PROPERTY(Object, 3, scale)
	FLOAT_ARRAY_PROPERTY(Object, 3, dimensions)
	FLOAT_ARRAY_PROPERTY(Object, 3, delta_location)
	FLOAT_ARRAY_PROPERTY(Object, 3, delta_rotation_euler)
	FLOAT_ARRAY_PROPERTY(Object, 4, delta_rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(Object, 3, delta_scale)
	BOOLEAN_ARRAY_PROPERTY(Object, 3, lock_location)
	BOOLEAN_ARRAY_PROPERTY(Object, 3, lock_rotation)
	BOOLEAN_PROPERTY(Object, lock_rotation_w)
	BOOLEAN_PROPERTY(Object, lock_rotations_4d)
	BOOLEAN_ARRAY_PROPERTY(Object, 3, lock_scale)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_world)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_local)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_basis)
	FLOAT_ARRAY_PROPERTY(Object, 16, matrix_parent_inverse)





	ENUM_PROPERTY(empty_display_type_enum, Object, empty_display_type)
	FLOAT_PROPERTY(Object, empty_display_size)
	FLOAT_ARRAY_PROPERTY(Object, 2, empty_image_offset)
	POINTER_PROPERTY(ImageUser, Object, image_user)
	ENUM_PROPERTY(empty_image_depth_enum, Object, empty_image_depth)
	BOOLEAN_PROPERTY(Object, show_empty_image_perspective)
	BOOLEAN_PROPERTY(Object, show_empty_image_orthographic)
	BOOLEAN_PROPERTY(Object, show_empty_image_only_axis_aligned)
	BOOLEAN_PROPERTY(Object, use_empty_image_alpha)
	ENUM_PROPERTY(empty_image_side_enum, Object, empty_image_side)
	BOOLEAN_PROPERTY(Object, add_rest_position_attribute)
	INT_PROPERTY(Object, pass_index)
	FLOAT_ARRAY_PROPERTY(Object, 4, color)
	POINTER_PROPERTY(FieldSettings, Object, field)
	POINTER_PROPERTY(CollisionSettings, Object, collision)
	POINTER_PROPERTY(SoftBodySettings, Object, soft_body)

	POINTER_PROPERTY(RigidBodyObject, Object, rigid_body)
	POINTER_PROPERTY(RigidBodyConstraint, Object, rigid_body_constraint)
	BOOLEAN_PROPERTY(Object, use_simulation_cache)
	BOOLEAN_PROPERTY(Object, hide_viewport)
	BOOLEAN_PROPERTY(Object, hide_select)
	BOOLEAN_PROPERTY(Object, hide_render)
	BOOLEAN_PROPERTY(Object, hide_probe_volume)
	BOOLEAN_PROPERTY(Object, hide_probe_cubemap)
	BOOLEAN_PROPERTY(Object, hide_probe_planar)
	BOOLEAN_PROPERTY(Object, show_instancer_for_render)
	BOOLEAN_PROPERTY(Object, show_instancer_for_viewport)
	BOOLEAN_PROPERTY(Object, visible_camera)
	BOOLEAN_PROPERTY(Object, visible_diffuse)
	BOOLEAN_PROPERTY(Object, visible_glossy)
	BOOLEAN_PROPERTY(Object, visible_transmission)
	BOOLEAN_PROPERTY(Object, visible_volume_scatter)
	BOOLEAN_PROPERTY(Object, visible_shadow)
	BOOLEAN_PROPERTY(Object, is_holdout)
	BOOLEAN_PROPERTY(Object, is_shadow_catcher)
	ENUM_PROPERTY(instance_type_enum, Object, instance_type)
	BOOLEAN_PROPERTY(Object, use_instance_vertices_rotation)
	BOOLEAN_PROPERTY(Object, use_instance_faces_scale)
	FLOAT_PROPERTY(Object, instance_faces_scale)
	POINTER_PROPERTY(Collection, Object, instance_collection)
	BOOLEAN_PROPERTY(Object, is_instancer)
	ENUM_PROPERTY(display_type_enum, Object, display_type)
	BOOLEAN_PROPERTY(Object, show_bounds)
	ENUM_PROPERTY(display_bounds_type_enum, Object, display_bounds_type)
	BOOLEAN_PROPERTY(Object, show_name)
	BOOLEAN_PROPERTY(Object, show_axis)
	BOOLEAN_PROPERTY(Object, show_texture_space)
	BOOLEAN_PROPERTY(Object, show_wire)
	BOOLEAN_PROPERTY(Object, show_all_edges)
	BOOLEAN_PROPERTY(Object, use_grease_pencil_lights)
	BOOLEAN_PROPERTY(Object, show_transparent)
	BOOLEAN_PROPERTY(Object, show_in_front)
	POINTER_PROPERTY(Pose, Object, pose)
	BOOLEAN_PROPERTY(Object, show_only_shape_key)
	BOOLEAN_PROPERTY(Object, use_shape_key_edit_mode)
	POINTER_PROPERTY(ShapeKey, Object, active_shape_key)
	INT_PROPERTY(Object, active_shape_key_index)
	BOOLEAN_PROPERTY(Object, use_dynamic_topology_sculpting)
	BOOLEAN_PROPERTY(Object, is_from_instancer)
	BOOLEAN_PROPERTY(Object, is_from_set)
	POINTER_PROPERTY(ObjectDisplay, Object, display)
	POINTER_PROPERTY(ObjectLineArt, Object, lineart)
	BOOLEAN_PROPERTY(Object, use_mesh_mirror_x)
	BOOLEAN_PROPERTY(Object, use_mesh_mirror_y)
	BOOLEAN_PROPERTY(Object, use_mesh_mirror_z)
	STRING_PROPERTY(Object, lightgroup)
	POINTER_PROPERTY(ObjectLightLinking, Object, light_linking)
	POINTER_PROPERTY(AnimData, Object, animation_data)
	POINTER_PROPERTY(AnimViz, Object, animation_visualization)
	POINTER_PROPERTY(MotionPath, Object, motion_path)

	inline bool Object::select_get(Context C, ViewLayer& view_layer) {
		return Object_select_get_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &view_layer);
	}

	inline void Object::select_set(Context C, bool state, ViewLayer& view_layer) {
		Object_select_set_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, state, (::PointerRNA *) &view_layer);
	}

	inline bool Object::hide_get(Context C, ViewLayer& view_layer) {
		return Object_hide_get_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &view_layer);
	}

	inline void Object::hide_set(Context C, bool state, ViewLayer& view_layer) {
		Object_hide_set_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, state, (::PointerRNA *) &view_layer);
	}

	inline bool Object::visible_get(Context C, ViewLayer& view_layer, SpaceView3D& viewport) {
		return Object_visible_get_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &view_layer, (::View3D *) viewport.ptr.data);
	}

	inline bool Object::holdout_get(Context C, ViewLayer& view_layer) {
		return Object_holdout_get_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &view_layer);
	}

	inline bool Object::indirect_only_get(Context C, ViewLayer& view_layer) {
		return Object_indirect_only_get_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &view_layer);
	}

	inline bool Object::local_view_get(SpaceView3D& viewport) {
		return Object_local_view_get_func((::Object *) this->ptr.data, nullptr, (::View3D *) viewport.ptr.data);
	}

	inline void Object::local_view_set(SpaceView3D& viewport, bool state) {
		Object_local_view_set_func((::Object *) this->ptr.data, nullptr, (::PointerRNA *) &viewport, state);
	}

	inline bool Object::visible_in_viewport_get(SpaceView3D& viewport) {
		return Object_visible_in_viewport_get_func((::Object *) this->ptr.data, (::View3D *) viewport.ptr.data);
	}

	inline void Object::convert_space(PoseBone& pose_bone, float matrix[16], float matrix_return[16], int from_space, int to_space) {
		Object_convert_space_func((::Object *) this->ptr.data, nullptr, (::bPoseChannel *) pose_bone.ptr.data, matrix, matrix_return, from_space, to_space);
	}

	inline void Object::calc_matrix_camera(Depsgraph& depsgraph, float result[16], int x, int y, float scale_x, float scale_y) {
		Object_calc_matrix_camera_func((::Object *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, result, x, y, scale_x, scale_y);
	}

	inline void Object::camera_fit_coords(Depsgraph& depsgraph, int coordinates_len, float *coordinates, float coord_return[3], float *scale_return) {
		Object_camera_fit_coords_func((::Object *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, coordinates_len, coordinates, coord_return, scale_return);
	}

	inline void Object::crazyspace_eval(Depsgraph& depsgraph, Scene& scene) {
		Object_crazyspace_eval_func((::Object *) this->ptr.data, nullptr, (::Depsgraph *) depsgraph.ptr.data, (::Scene *) scene.ptr.data);
	}

	inline void Object::crazyspace_displacement_to_deformed(int vertex_index, float displacement[3], float displacement_deformed[3]) {
		Object_crazyspace_displacement_to_deformed_func((::Object *) this->ptr.data, nullptr, vertex_index, displacement, displacement_deformed);
	}

	inline void Object::crazyspace_displacement_to_original(int vertex_index, float displacement[3], float displacement_original[3]) {
		Object_crazyspace_displacement_to_original_func((::Object *) this->ptr.data, nullptr, vertex_index, displacement, displacement_original);
	}

	inline void Object::crazyspace_eval_clear() {
		Object_crazyspace_eval_clear_func((::Object *) this->ptr.data);
	}

	inline Mesh Object::to_mesh(bool preserve_all_data_layers, Depsgraph& depsgraph) {
		PointerRNA result;
		::Mesh *retdata = Object_to_mesh_func((::Object *) this->ptr.data, nullptr, preserve_all_data_layers, (::Depsgraph *) depsgraph.ptr.data);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Mesh(result);
	}

	inline void Object::to_mesh_clear() {
		Object_to_mesh_clear_func((::Object *) this->ptr.data);
	}

	inline Curve Object::to_curve(Depsgraph& depsgraph, bool apply_modifiers) {
		PointerRNA result;
		::Curve *retdata = Object_to_curve_func((::Object *) this->ptr.data, nullptr, (::Depsgraph *) depsgraph.ptr.data, apply_modifiers);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Curve(result);
	}

	inline void Object::to_curve_clear() {
		Object_to_curve_clear_func((::Object *) this->ptr.data);
	}

	inline Object Object::find_armature() {
		PointerRNA result;
		::Object *retdata = Object_find_armature_func((::Object *) this->ptr.data);
		result = RNA_id_pointer_create((::ID *) retdata);
		return Object(result);
	}

	inline ShapeKey Object::shape_key_add(Context C, const char * name, bool from_mix) {
		PointerRNA result;
		result = Object_shape_key_add_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, name, from_mix);
		return ShapeKey(result);
	}

	inline void Object::shape_key_remove(void *main, ShapeKey& key) {
		Object_shape_key_remove_func((::Object *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &key.ptr);
	}

	inline void Object::shape_key_clear(void *main) {
		Object_shape_key_clear_func((::Object *) this->ptr.data, (::Main *) main);
	}

	inline void Object::ray_cast(Context C, float origin[3], float direction[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index) {
		Object_ray_cast_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, origin, direction, distance, (::PointerRNA *) &depsgraph, result, location, normal, index);
	}

	inline void Object::closest_point_on_mesh(Context C, float origin[3], float distance, Depsgraph& depsgraph, bool *result, float location[3], float normal[3], int *index) {
		Object_closest_point_on_mesh_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, origin, distance, (::PointerRNA *) &depsgraph, result, location, normal, index);
	}

	inline bool Object::is_modified(Scene& scene, int settings) {
		return Object_is_modified_func((::Object *) this->ptr.data, (::Scene *) scene.ptr.data, settings);
	}

	inline bool Object::is_deform_modified(Scene& scene, int settings) {
		return Object_is_deform_modified_func((::Object *) this->ptr.data, (::Scene *) scene.ptr.data, settings);
	}

	inline void Object::dm_info(Context C, int type, Depsgraph& depsgraph, char * result) {
		Object_dm_info_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, type, (::PointerRNA *) &depsgraph, result);
	}

	inline bool Object::update_from_editmode(void *main) {
		return Object_update_from_editmode_func((::Object *) this->ptr.data, (::Main *) main);
	}

	inline void Object::cache_release() {
		Object_cache_release_func((::Object *) this->ptr.data);
	}

	inline bool Object::generate_gpencil_strokes(Context C, Object& grease_pencil_object, bool use_collections, float scale_thickness, float sample) {
		return Object_generate_gpencil_strokes_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::Object *) grease_pencil_object.ptr.data, use_collections, scale_thickness, sample);
	}


	POINTER_PROPERTY(Struct, ObjectModifiers, rna_type)
	POINTER_PROPERTY(Modifier, ObjectModifiers, active)

	inline Modifier ObjectModifiers::create(Context C, const char * name, int type) {
		PointerRNA result;
		::ModifierData *retdata = ObjectModifiers_new_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Modifier, retdata);
		return Modifier(result);
	}

	inline void ObjectModifiers::remove(Context C, Modifier& modifier) {
		ObjectModifiers_remove_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &modifier.ptr);
	}

	inline void ObjectModifiers::clear(Context C) {
		ObjectModifiers_clear_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void ObjectModifiers::move(int from_index, int to_index) {
		ObjectModifiers_move_func((::Object *) this->ptr.data, nullptr, from_index, to_index);
	}


	POINTER_PROPERTY(Struct, ObjectGpencilModifiers, rna_type)

	inline GpencilModifier ObjectGpencilModifiers::create(Context C, const char * name, int type) {
		PointerRNA result;
		::GpencilModifierData *retdata = ObjectGpencilModifiers_new_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_GpencilModifier, retdata);
		return GpencilModifier(result);
	}

	inline void ObjectGpencilModifiers::remove(Context C, GpencilModifier& greasepencil_modifier) {
		ObjectGpencilModifiers_remove_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &greasepencil_modifier.ptr);
	}

	inline void ObjectGpencilModifiers::clear(Context C) {
		ObjectGpencilModifiers_clear_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectShaderFx, rna_type)

	inline ShaderFx ObjectShaderFx::create(Context C, const char * name, int type) {
		PointerRNA result;
		::ShaderFxData *retdata = ObjectShaderFx_new_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ShaderFx, retdata);
		return ShaderFx(result);
	}

	inline void ObjectShaderFx::remove(Context C, ShaderFx& shader_fx) {
		ObjectShaderFx_remove_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &shader_fx.ptr);
	}

	inline void ObjectShaderFx::clear(Context C) {
		ObjectShaderFx_clear_func((::Object *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, ObjectConstraints, rna_type)
	POINTER_PROPERTY(Constraint, ObjectConstraints, active)

	inline Constraint ObjectConstraints::create(void *main, int type) {
		PointerRNA result;
		::bConstraint *retdata = ObjectConstraints_new_func((::Object *) this->ptr.data, (::Main *) main, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Constraint, retdata);
		return Constraint(result);
	}

	inline void ObjectConstraints::remove(void *main, Constraint& constraint) {
		ObjectConstraints_remove_func((::Object *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &constraint.ptr);
	}

	inline void ObjectConstraints::clear(void *main) {
		ObjectConstraints_clear_func((::Object *) this->ptr.data, (::Main *) main);
	}

	inline void ObjectConstraints::move(void *main, int from_index, int to_index) {
		ObjectConstraints_move_func((::Object *) this->ptr.data, (::Main *) main, nullptr, from_index, to_index);
	}

	inline Constraint ObjectConstraints::copy(void *main, Constraint& constraint) {
		PointerRNA result;
		::bConstraint *retdata = ObjectConstraints_copy_func((::Object *) this->ptr.data, (::Main *) main, (::PointerRNA *) &constraint.ptr);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Constraint, retdata);
		return Constraint(result);
	}


	POINTER_PROPERTY(Struct, VertexGroups, rna_type)
	POINTER_PROPERTY(VertexGroup, VertexGroups, active)
	INT_PROPERTY(VertexGroups, active_index)

	inline VertexGroup VertexGroups::create(void *main, const char * name) {
		PointerRNA result;
		::bDeformGroup *retdata = VertexGroups_new_func((::Object *) this->ptr.data, (::Main *) main, nullptr, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_VertexGroup, retdata);
		return VertexGroup(result);
	}

	inline void VertexGroups::remove(void *main, VertexGroup& group) {
		VertexGroups_remove_func((::Object *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &group.ptr);
	}

	inline void VertexGroups::clear(void *main) {
		VertexGroups_clear_func((::Object *) this->ptr.data, (::Main *) main, nullptr);
	}


	POINTER_PROPERTY(Struct, ParticleSystems, rna_type)
	POINTER_PROPERTY(ParticleSystem, ParticleSystems, active)
	INT_PROPERTY(ParticleSystems, active_index)


	POINTER_PROPERTY(Struct, VertexGroup, rna_type)
	STRING_PROPERTY(VertexGroup, name)
	BOOLEAN_PROPERTY(VertexGroup, lock_weight)
	INT_PROPERTY(VertexGroup, index)

	inline void VertexGroup::add(int index_len, int *index, float weight, int type) {
		VertexGroup_add_func((::ID *) ptr.owner_id, (::bDeformGroup *) this->ptr.data, nullptr, index_len, index, weight, type);
	}

	inline void VertexGroup::remove(int index_len, int *index) {
		VertexGroup_remove_func((::ID *) ptr.owner_id, (::bDeformGroup *) this->ptr.data, nullptr, index_len, index);
	}

	inline float VertexGroup::weight(int index) {
		return VertexGroup_weight_func((::ID *) ptr.owner_id, (::bDeformGroup *) this->ptr.data, nullptr, index);
	}


	POINTER_PROPERTY(Struct, MaterialSlot, rna_type)
	ENUM_PROPERTY(link_enum, MaterialSlot, link)
	POINTER_PROPERTY(Material, MaterialSlot, material)
	INT_PROPERTY(MaterialSlot, slot_index)
	STRING_PROPERTY(MaterialSlot, name)


	POINTER_PROPERTY(Struct, ObjectDisplay, rna_type)
	BOOLEAN_PROPERTY(ObjectDisplay, show_shadows)


	POINTER_PROPERTY(Struct, ObjectLineArt, rna_type)
	ENUM_PROPERTY(usage_enum, ObjectLineArt, usage)
	BOOLEAN_PROPERTY(ObjectLineArt, use_crease_override)
	FLOAT_PROPERTY(ObjectLineArt, crease_threshold)
	BOOLEAN_PROPERTY(ObjectLineArt, use_intersection_priority_override)
	INT_PROPERTY(ObjectLineArt, intersection_priority)


	POINTER_PROPERTY(Struct, ObjectLightLinking, rna_type)
	POINTER_PROPERTY(Collection, ObjectLightLinking, receiver_collection)
	POINTER_PROPERTY(Collection, ObjectLightLinking, blocker_collection)


	POINTER_PROPERTY(Struct, PointCache, rna_type)
	INT_PROPERTY(PointCache, frame_start)
	INT_PROPERTY(PointCache, frame_end)
	INT_PROPERTY(PointCache, frame_step)
	INT_PROPERTY(PointCache, index)
	ENUM_PROPERTY(compression_enum, PointCache, compression)
	BOOLEAN_PROPERTY(PointCache, is_baked)
	BOOLEAN_PROPERTY(PointCache, is_baking)
	BOOLEAN_PROPERTY(PointCache, use_disk_cache)
	BOOLEAN_PROPERTY(PointCache, is_outdated)
	BOOLEAN_PROPERTY(PointCache, is_frame_skip)
	STRING_PROPERTY(PointCache, name)
	STRING_PROPERTY(PointCache, filepath)
	STRING_PROPERTY(PointCache, info)
	BOOLEAN_PROPERTY(PointCache, use_external)
	BOOLEAN_PROPERTY(PointCache, use_library_path)



	POINTER_PROPERTY(Struct, PointCaches, rna_type)
	INT_PROPERTY(PointCaches, active_index)


	POINTER_PROPERTY(Struct, PointCacheItem, rna_type)
	INT_PROPERTY(PointCacheItem, frame_start)
	INT_PROPERTY(PointCacheItem, frame_end)
	INT_PROPERTY(PointCacheItem, frame_step)
	INT_PROPERTY(PointCacheItem, index)
	ENUM_PROPERTY(compression_enum, PointCacheItem, compression)
	BOOLEAN_PROPERTY(PointCacheItem, is_baked)
	BOOLEAN_PROPERTY(PointCacheItem, is_baking)
	BOOLEAN_PROPERTY(PointCacheItem, use_disk_cache)
	BOOLEAN_PROPERTY(PointCacheItem, is_outdated)
	BOOLEAN_PROPERTY(PointCacheItem, is_frame_skip)
	STRING_PROPERTY(PointCacheItem, name)
	STRING_PROPERTY(PointCacheItem, filepath)
	STRING_PROPERTY(PointCacheItem, info)
	BOOLEAN_PROPERTY(PointCacheItem, use_external)
	BOOLEAN_PROPERTY(PointCacheItem, use_library_path)


	POINTER_PROPERTY(Struct, CollisionSettings, rna_type)
	BOOLEAN_PROPERTY(CollisionSettings, use)
	FLOAT_PROPERTY(CollisionSettings, damping_factor)
	FLOAT_PROPERTY(CollisionSettings, damping_random)
	FLOAT_PROPERTY(CollisionSettings, friction_factor)
	FLOAT_PROPERTY(CollisionSettings, friction_random)
	FLOAT_PROPERTY(CollisionSettings, permeability)
	BOOLEAN_PROPERTY(CollisionSettings, use_particle_kill)
	FLOAT_PROPERTY(CollisionSettings, stickiness)
	FLOAT_PROPERTY(CollisionSettings, thickness_inner)
	FLOAT_PROPERTY(CollisionSettings, thickness_outer)
	FLOAT_PROPERTY(CollisionSettings, damping)
	FLOAT_PROPERTY(CollisionSettings, absorption)
	FLOAT_PROPERTY(CollisionSettings, cloth_friction)
	BOOLEAN_PROPERTY(CollisionSettings, use_culling)
	BOOLEAN_PROPERTY(CollisionSettings, use_normal)


	POINTER_PROPERTY(Struct, EffectorWeights, rna_type)
	BOOLEAN_PROPERTY(EffectorWeights, apply_to_hair_growing)
	POINTER_PROPERTY(Collection, EffectorWeights, collection)
	FLOAT_PROPERTY(EffectorWeights, gravity)
	FLOAT_PROPERTY(EffectorWeights, all)
	FLOAT_PROPERTY(EffectorWeights, force)
	FLOAT_PROPERTY(EffectorWeights, vortex)
	FLOAT_PROPERTY(EffectorWeights, magnetic)
	FLOAT_PROPERTY(EffectorWeights, wind)
	FLOAT_PROPERTY(EffectorWeights, curve_guide)
	FLOAT_PROPERTY(EffectorWeights, texture)
	FLOAT_PROPERTY(EffectorWeights, harmonic)
	FLOAT_PROPERTY(EffectorWeights, charge)
	FLOAT_PROPERTY(EffectorWeights, lennardjones)
	FLOAT_PROPERTY(EffectorWeights, boid)
	FLOAT_PROPERTY(EffectorWeights, turbulence)
	FLOAT_PROPERTY(EffectorWeights, drag)
	FLOAT_PROPERTY(EffectorWeights, smokeflow)


	POINTER_PROPERTY(Struct, FieldSettings, rna_type)
	ENUM_PROPERTY(type_enum, FieldSettings, type)
	ENUM_PROPERTY(shape_enum, FieldSettings, shape)
	ENUM_PROPERTY(falloff_type_enum, FieldSettings, falloff_type)
	ENUM_PROPERTY(texture_mode_enum, FieldSettings, texture_mode)
	ENUM_PROPERTY(z_direction_enum, FieldSettings, z_direction)
	FLOAT_PROPERTY(FieldSettings, strength)
	FLOAT_PROPERTY(FieldSettings, linear_drag)
	FLOAT_PROPERTY(FieldSettings, harmonic_damping)
	FLOAT_PROPERTY(FieldSettings, quadratic_drag)
	FLOAT_PROPERTY(FieldSettings, flow)
	FLOAT_PROPERTY(FieldSettings, wind_factor)
	FLOAT_PROPERTY(FieldSettings, inflow)
	FLOAT_PROPERTY(FieldSettings, size)
	FLOAT_PROPERTY(FieldSettings, rest_length)
	FLOAT_PROPERTY(FieldSettings, falloff_power)
	FLOAT_PROPERTY(FieldSettings, distance_min)
	FLOAT_PROPERTY(FieldSettings, distance_max)
	FLOAT_PROPERTY(FieldSettings, radial_min)
	FLOAT_PROPERTY(FieldSettings, radial_max)
	FLOAT_PROPERTY(FieldSettings, radial_falloff)
	FLOAT_PROPERTY(FieldSettings, texture_nabla)
	FLOAT_PROPERTY(FieldSettings, noise)
	INT_PROPERTY(FieldSettings, seed)
	BOOLEAN_PROPERTY(FieldSettings, use_min_distance)
	BOOLEAN_PROPERTY(FieldSettings, use_max_distance)
	BOOLEAN_PROPERTY(FieldSettings, use_radial_min)
	BOOLEAN_PROPERTY(FieldSettings, use_radial_max)
	BOOLEAN_PROPERTY(FieldSettings, use_object_coords)
	BOOLEAN_PROPERTY(FieldSettings, use_global_coords)
	BOOLEAN_PROPERTY(FieldSettings, use_2d_force)
	BOOLEAN_PROPERTY(FieldSettings, use_root_coords)
	BOOLEAN_PROPERTY(FieldSettings, apply_to_location)
	BOOLEAN_PROPERTY(FieldSettings, apply_to_rotation)
	BOOLEAN_PROPERTY(FieldSettings, use_absorption)
	BOOLEAN_PROPERTY(FieldSettings, use_multiple_springs)
	BOOLEAN_PROPERTY(FieldSettings, use_smoke_density)
	BOOLEAN_PROPERTY(FieldSettings, use_gravity_falloff)
	POINTER_PROPERTY(Texture, FieldSettings, texture)
	POINTER_PROPERTY(Object, FieldSettings, source_object)
	FLOAT_PROPERTY(FieldSettings, guide_minimum)
	FLOAT_PROPERTY(FieldSettings, guide_free)
	BOOLEAN_PROPERTY(FieldSettings, use_guide_path_add)
	BOOLEAN_PROPERTY(FieldSettings, use_guide_path_weight)
	FLOAT_PROPERTY(FieldSettings, guide_clump_amount)
	FLOAT_PROPERTY(FieldSettings, guide_clump_shape)
	ENUM_PROPERTY(guide_kink_type_enum, FieldSettings, guide_kink_type)
	ENUM_PROPERTY(guide_kink_axis_enum, FieldSettings, guide_kink_axis)
	FLOAT_PROPERTY(FieldSettings, guide_kink_frequency)
	FLOAT_PROPERTY(FieldSettings, guide_kink_shape)
	FLOAT_PROPERTY(FieldSettings, guide_kink_amplitude)


	POINTER_PROPERTY(Struct, SoftBodySettings, rna_type)
	FLOAT_PROPERTY(SoftBodySettings, friction)
	FLOAT_PROPERTY(SoftBodySettings, mass)
	STRING_PROPERTY(SoftBodySettings, vertex_group_mass)
	FLOAT_PROPERTY(SoftBodySettings, gravity)
	FLOAT_PROPERTY(SoftBodySettings, speed)
	STRING_PROPERTY(SoftBodySettings, vertex_group_goal)
	FLOAT_PROPERTY(SoftBodySettings, goal_min)
	FLOAT_PROPERTY(SoftBodySettings, goal_max)
	FLOAT_PROPERTY(SoftBodySettings, goal_default)
	FLOAT_PROPERTY(SoftBodySettings, goal_spring)
	FLOAT_PROPERTY(SoftBodySettings, goal_friction)
	FLOAT_PROPERTY(SoftBodySettings, pull)
	FLOAT_PROPERTY(SoftBodySettings, push)
	FLOAT_PROPERTY(SoftBodySettings, damping)
	INT_PROPERTY(SoftBodySettings, spring_length)
	INT_PROPERTY(SoftBodySettings, aero)
	INT_PROPERTY(SoftBodySettings, plastic)
	FLOAT_PROPERTY(SoftBodySettings, bend)
	FLOAT_PROPERTY(SoftBodySettings, shear)
	STRING_PROPERTY(SoftBodySettings, vertex_group_spring)
	ENUM_PROPERTY(collision_type_enum, SoftBodySettings, collision_type)
	FLOAT_PROPERTY(SoftBodySettings, ball_size)
	FLOAT_PROPERTY(SoftBodySettings, ball_stiff)
	FLOAT_PROPERTY(SoftBodySettings, ball_damp)
	FLOAT_PROPERTY(SoftBodySettings, error_threshold)
	INT_PROPERTY(SoftBodySettings, step_min)
	INT_PROPERTY(SoftBodySettings, step_max)
	INT_PROPERTY(SoftBodySettings, choke)
	INT_PROPERTY(SoftBodySettings, fuzzy)
	BOOLEAN_PROPERTY(SoftBodySettings, use_auto_step)
	BOOLEAN_PROPERTY(SoftBodySettings, use_diagnose)
	BOOLEAN_PROPERTY(SoftBodySettings, use_estimate_matrix)
	FLOAT_ARRAY_PROPERTY(SoftBodySettings, 3, location_mass_center)
	FLOAT_ARRAY_PROPERTY(SoftBodySettings, 9, rotation_estimate)
	FLOAT_ARRAY_PROPERTY(SoftBodySettings, 9, scale_estimate)
	BOOLEAN_PROPERTY(SoftBodySettings, use_goal)
	BOOLEAN_PROPERTY(SoftBodySettings, use_edges)
	BOOLEAN_PROPERTY(SoftBodySettings, use_stiff_quads)
	BOOLEAN_PROPERTY(SoftBodySettings, use_edge_collision)
	BOOLEAN_PROPERTY(SoftBodySettings, use_face_collision)
	ENUM_PROPERTY(aerodynamics_type_enum, SoftBodySettings, aerodynamics_type)
	BOOLEAN_PROPERTY(SoftBodySettings, use_self_collision)
	POINTER_PROPERTY(Collection, SoftBodySettings, collision_collection)
	POINTER_PROPERTY(EffectorWeights, SoftBodySettings, effector_weights)


	POINTER_PROPERTY(Struct, DepsgraphObjectInstance, rna_type)
	POINTER_PROPERTY(Object, DepsgraphObjectInstance, object)
	BOOLEAN_PROPERTY(DepsgraphObjectInstance, show_self)
	BOOLEAN_PROPERTY(DepsgraphObjectInstance, show_particles)
	BOOLEAN_PROPERTY(DepsgraphObjectInstance, is_instance)
	POINTER_PROPERTY(Object, DepsgraphObjectInstance, instance_object)
	POINTER_PROPERTY(Object, DepsgraphObjectInstance, parent)
	POINTER_PROPERTY(ParticleSystem, DepsgraphObjectInstance, particle_system)
	INT_ARRAY_PROPERTY(DepsgraphObjectInstance, 8, persistent_id)
	INT_PROPERTY(DepsgraphObjectInstance, random_id)
	FLOAT_ARRAY_PROPERTY(DepsgraphObjectInstance, 16, matrix_world)
	FLOAT_ARRAY_PROPERTY(DepsgraphObjectInstance, 3, orco)
	FLOAT_ARRAY_PROPERTY(DepsgraphObjectInstance, 2, uv)


	POINTER_PROPERTY(Struct, DepsgraphUpdate, rna_type)
	POINTER_PROPERTY(ID, DepsgraphUpdate, id)
	BOOLEAN_PROPERTY(DepsgraphUpdate, is_updated_transform)
	BOOLEAN_PROPERTY(DepsgraphUpdate, is_updated_geometry)
	BOOLEAN_PROPERTY(DepsgraphUpdate, is_updated_shading)


	POINTER_PROPERTY(Struct, Depsgraph, rna_type)
	ENUM_PROPERTY(mode_enum, Depsgraph, mode)
	POINTER_PROPERTY(Scene, Depsgraph, scene)
	POINTER_PROPERTY(ViewLayer, Depsgraph, view_layer)
	POINTER_PROPERTY(Scene, Depsgraph, scene_eval)
	POINTER_PROPERTY(ViewLayer, Depsgraph, view_layer_eval)





	inline void Depsgraph::debug_relations_graphviz(const char * filepath) {
		Depsgraph_debug_relations_graphviz_func((::Depsgraph *) this->ptr.data, filepath);
	}

	inline void Depsgraph::debug_stats_gnuplot(const char * filepath, const char * output_filepath) {
		Depsgraph_debug_stats_gnuplot_func((::Depsgraph *) this->ptr.data, filepath, output_filepath);
	}

	inline void Depsgraph::debug_tag_update() {
		Depsgraph_debug_tag_update_func((::Depsgraph *) this->ptr.data);
	}

	inline void Depsgraph::debug_stats(char * result) {
		Depsgraph_debug_stats_func((::Depsgraph *) this->ptr.data, result);
	}

	inline void Depsgraph::update(void *main) {
		Depsgraph_update_func((::Depsgraph *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline ID Depsgraph::id_eval_get(ID& id) {
		PointerRNA result;
		::ID *retdata = Depsgraph_id_eval_get_func((::Depsgraph *) this->ptr.data, (::ID *) id.ptr.data);
		result = RNA_id_pointer_create((::ID *) retdata);
		return ID(result);
	}

	inline bool Depsgraph::id_type_updated(int id_type) {
		return Depsgraph_id_type_updated_func((::Depsgraph *) this->ptr.data, id_type);
	}


	POINTER_PROPERTY(Struct, PackedFile, rna_type)
	INT_PROPERTY(PackedFile, size)
	STRING_PROPERTY(PackedFile, data)


	POINTER_PROPERTY(Struct, PaletteColor, rna_type)
	FLOAT_ARRAY_PROPERTY(PaletteColor, 3, color)
	FLOAT_PROPERTY(PaletteColor, strength)
	FLOAT_PROPERTY(PaletteColor, weight)





	POINTER_PROPERTY(Struct, PaletteColors, rna_type)
	POINTER_PROPERTY(PaletteColor, PaletteColors, active)

	inline PaletteColor PaletteColors::create() {
		PointerRNA result;
		::PaletteColor *retdata = PaletteColors_new_func((::Palette *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_PaletteColor, retdata);
		return PaletteColor(result);
	}

	inline void PaletteColors::remove(PaletteColor& color) {
		PaletteColors_remove_func((::Palette *) this->ptr.data, nullptr, (::PointerRNA *) &color.ptr);
	}

	inline void PaletteColors::clear() {
		PaletteColors_clear_func((::Palette *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ParticleTarget, rna_type)
	STRING_PROPERTY(ParticleTarget, name)
	POINTER_PROPERTY(Object, ParticleTarget, object)
	INT_PROPERTY(ParticleTarget, system)
	FLOAT_PROPERTY(ParticleTarget, time)
	FLOAT_PROPERTY(ParticleTarget, duration)
	BOOLEAN_PROPERTY(ParticleTarget, is_valid)
	ENUM_PROPERTY(alliance_enum, ParticleTarget, alliance)


	POINTER_PROPERTY(Struct, SPHFluidSettings, rna_type)
	ENUM_PROPERTY(solver_enum, SPHFluidSettings, solver)
	FLOAT_PROPERTY(SPHFluidSettings, spring_force)
	FLOAT_PROPERTY(SPHFluidSettings, fluid_radius)
	FLOAT_PROPERTY(SPHFluidSettings, rest_length)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_viscoelastic_springs)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_initial_rest_length)
	FLOAT_PROPERTY(SPHFluidSettings, plasticity)
	FLOAT_PROPERTY(SPHFluidSettings, yield_ratio)
	INT_PROPERTY(SPHFluidSettings, spring_frames)
	FLOAT_PROPERTY(SPHFluidSettings, linear_viscosity)
	FLOAT_PROPERTY(SPHFluidSettings, stiff_viscosity)
	FLOAT_PROPERTY(SPHFluidSettings, stiffness)
	FLOAT_PROPERTY(SPHFluidSettings, repulsion)
	FLOAT_PROPERTY(SPHFluidSettings, rest_density)
	FLOAT_PROPERTY(SPHFluidSettings, buoyancy)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_repulsion)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_density)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_radius)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_stiff_viscosity)
	BOOLEAN_PROPERTY(SPHFluidSettings, use_factor_rest_length)


	POINTER_PROPERTY(Struct, ParticleHairKey, rna_type)
	FLOAT_PROPERTY(ParticleHairKey, time)
	FLOAT_PROPERTY(ParticleHairKey, weight)
	FLOAT_ARRAY_PROPERTY(ParticleHairKey, 3, co)
	FLOAT_ARRAY_PROPERTY(ParticleHairKey, 3, co_local)

	inline void ParticleHairKey::co_object(Object& object, ParticleSystemModifier& modifier, Particle& particle, float co[3]) {
		ParticleHairKey_co_object_func((::HairKey *) this->ptr.data, (::Object *) object.ptr.data, (::ParticleSystemModifierData *) modifier.ptr.data, (::ParticleData *) particle.ptr.data, co);
	}

	inline void ParticleHairKey::co_object_set(Object& object, ParticleSystemModifier& modifier, Particle& particle, float co[3]) {
		ParticleHairKey_co_object_set_func((::ID *) ptr.owner_id, (::HairKey *) this->ptr.data, (::Object *) object.ptr.data, (::ParticleSystemModifierData *) modifier.ptr.data, (::ParticleData *) particle.ptr.data, co);
	}


	POINTER_PROPERTY(Struct, ParticleKey, rna_type)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 3, location)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 3, velocity)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 4, rotation)
	FLOAT_ARRAY_PROPERTY(ParticleKey, 3, angular_velocity)
	FLOAT_PROPERTY(ParticleKey, time)


	POINTER_PROPERTY(Struct, ChildParticle, rna_type)


	POINTER_PROPERTY(Struct, Particle, rna_type)
	FLOAT_ARRAY_PROPERTY(Particle, 3, location)
	FLOAT_ARRAY_PROPERTY(Particle, 3, velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 3, angular_velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 4, rotation)
	FLOAT_ARRAY_PROPERTY(Particle, 3, prev_location)
	FLOAT_ARRAY_PROPERTY(Particle, 3, prev_velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 3, prev_angular_velocity)
	FLOAT_ARRAY_PROPERTY(Particle, 4, prev_rotation)


	FLOAT_PROPERTY(Particle, birth_time)
	FLOAT_PROPERTY(Particle, lifetime)
	FLOAT_PROPERTY(Particle, die_time)
	FLOAT_PROPERTY(Particle, size)
	BOOLEAN_PROPERTY(Particle, is_exist)
	BOOLEAN_PROPERTY(Particle, is_visible)
	ENUM_PROPERTY(alive_state_enum, Particle, alive_state)

	inline void Particle::uv_on_emitter(ParticleSystemModifier& modifier, float uv[2]) {
		Particle_uv_on_emitter_func((::ParticleData *) this->ptr.data, nullptr, (::ParticleSystemModifierData *) modifier.ptr.data, uv);
	}


	POINTER_PROPERTY(Struct, ParticleDupliWeight, rna_type)
	STRING_PROPERTY(ParticleDupliWeight, name)
	INT_PROPERTY(ParticleDupliWeight, count)


	POINTER_PROPERTY(Struct, ParticleSystem, rna_type)
	STRING_PROPERTY(ParticleSystem, name)
	POINTER_PROPERTY(ParticleSettings, ParticleSystem, settings)


	INT_PROPERTY(ParticleSystem, seed)
	INT_PROPERTY(ParticleSystem, child_seed)
	BOOLEAN_PROPERTY(ParticleSystem, is_global_hair)
	BOOLEAN_PROPERTY(ParticleSystem, use_hair_dynamics)
	POINTER_PROPERTY(ClothModifier, ParticleSystem, cloth)
	POINTER_PROPERTY(Object, ParticleSystem, reactor_target_object)
	INT_PROPERTY(ParticleSystem, reactor_target_particle_system)
	BOOLEAN_PROPERTY(ParticleSystem, use_keyed_timing)

	POINTER_PROPERTY(ParticleTarget, ParticleSystem, active_particle_target)
	INT_PROPERTY(ParticleSystem, active_particle_target_index)
	STRING_PROPERTY(ParticleSystem, vertex_group_density)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_density)
	STRING_PROPERTY(ParticleSystem, vertex_group_velocity)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_velocity)
	STRING_PROPERTY(ParticleSystem, vertex_group_length)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_length)
	STRING_PROPERTY(ParticleSystem, vertex_group_clump)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_clump)
	STRING_PROPERTY(ParticleSystem, vertex_group_kink)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_kink)
	STRING_PROPERTY(ParticleSystem, vertex_group_roughness_1)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_roughness_1)
	STRING_PROPERTY(ParticleSystem, vertex_group_roughness_2)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_roughness_2)
	STRING_PROPERTY(ParticleSystem, vertex_group_roughness_end)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_roughness_end)
	STRING_PROPERTY(ParticleSystem, vertex_group_size)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_size)
	STRING_PROPERTY(ParticleSystem, vertex_group_tangent)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_tangent)
	STRING_PROPERTY(ParticleSystem, vertex_group_rotation)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_rotation)
	STRING_PROPERTY(ParticleSystem, vertex_group_field)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_field)
	STRING_PROPERTY(ParticleSystem, vertex_group_twist)
	BOOLEAN_PROPERTY(ParticleSystem, invert_vertex_group_twist)
	POINTER_PROPERTY(PointCache, ParticleSystem, point_cache)
	BOOLEAN_PROPERTY(ParticleSystem, has_multiple_caches)
	POINTER_PROPERTY(Object, ParticleSystem, parent)
	BOOLEAN_PROPERTY(ParticleSystem, is_editable)
	BOOLEAN_PROPERTY(ParticleSystem, is_edited)
	FLOAT_PROPERTY(ParticleSystem, dt_frac)

	inline void ParticleSystem::co_hair(Object& object, int particle_no, int step, float co[3]) {
		ParticleSystem_co_hair_func((::ParticleSystem *) this->ptr.data, (::Object *) object.ptr.data, particle_no, step, co);
	}

	inline void ParticleSystem::uv_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int uv_no, float uv[2]) {
		ParticleSystem_uv_on_emitter_func((::ParticleSystem *) this->ptr.data, nullptr, (::ParticleSystemModifierData *) modifier.ptr.data, (::ParticleData *) particle.ptr.data, particle_no, uv_no, uv);
	}

	inline void ParticleSystem::mcol_on_emitter(ParticleSystemModifier& modifier, Particle& particle, int particle_no, int vcol_no, float mcol[3]) {
		ParticleSystem_mcol_on_emitter_func((::ParticleSystem *) this->ptr.data, nullptr, (::ParticleSystemModifierData *) modifier.ptr.data, (::ParticleData *) particle.ptr.data, particle_no, vcol_no, mcol);
	}


	ENUM_PROPERTY(texture_coords_enum, ParticleSettingsTextureSlot, texture_coords)
	POINTER_PROPERTY(Object, ParticleSettingsTextureSlot, object)
	STRING_PROPERTY(ParticleSettingsTextureSlot, uv_layer)
	ENUM_PROPERTY(mapping_x_enum, ParticleSettingsTextureSlot, mapping_x)
	ENUM_PROPERTY(mapping_y_enum, ParticleSettingsTextureSlot, mapping_y)
	ENUM_PROPERTY(mapping_z_enum, ParticleSettingsTextureSlot, mapping_z)
	ENUM_PROPERTY(mapping_enum, ParticleSettingsTextureSlot, mapping)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_time)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_life)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_density)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_size)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_velocity)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_field)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_gravity)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_damp)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_clump)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_kink_amp)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_kink_freq)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_rough)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_length)
	BOOLEAN_PROPERTY(ParticleSettingsTextureSlot, use_map_twist)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, time_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, life_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, density_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, size_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, velocity_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, field_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, gravity_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, damp_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, length_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, clump_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, kink_amp_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, kink_freq_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, rough_factor)
	FLOAT_PROPERTY(ParticleSettingsTextureSlot, twist_factor)



	POINTER_PROPERTY(Texture, ParticleSettings, active_texture)
	INT_PROPERTY(ParticleSettings, active_texture_index)
	BOOLEAN_PROPERTY(ParticleSettings, is_fluid)
	BOOLEAN_PROPERTY(ParticleSettings, use_react_start_end)
	BOOLEAN_PROPERTY(ParticleSettings, use_react_multiple)
	BOOLEAN_PROPERTY(ParticleSettings, use_regrow_hair)
	BOOLEAN_PROPERTY(ParticleSettings, show_unborn)
	BOOLEAN_PROPERTY(ParticleSettings, use_dead)
	BOOLEAN_PROPERTY(ParticleSettings, use_emit_random)
	BOOLEAN_PROPERTY(ParticleSettings, use_even_distribution)
	BOOLEAN_PROPERTY(ParticleSettings, use_die_on_collision)
	BOOLEAN_PROPERTY(ParticleSettings, use_size_deflect)
	BOOLEAN_PROPERTY(ParticleSettings, use_rotations)
	BOOLEAN_PROPERTY(ParticleSettings, use_dynamic_rotation)
	BOOLEAN_PROPERTY(ParticleSettings, use_multiply_size_mass)
	BOOLEAN_PROPERTY(ParticleSettings, use_advanced_hair)
	BOOLEAN_PROPERTY(ParticleSettings, lock_boids_to_surface)
	BOOLEAN_PROPERTY(ParticleSettings, use_hair_bspline)
	BOOLEAN_PROPERTY(ParticleSettings, invert_grid)
	BOOLEAN_PROPERTY(ParticleSettings, hexagonal_grid)
	BOOLEAN_PROPERTY(ParticleSettings, apply_effector_to_children)
	BOOLEAN_PROPERTY(ParticleSettings, create_long_hair_children)
	BOOLEAN_PROPERTY(ParticleSettings, apply_guide_to_children)
	BOOLEAN_PROPERTY(ParticleSettings, use_self_effect)
	ENUM_PROPERTY(type_enum, ParticleSettings, type)
	ENUM_PROPERTY(emit_from_enum, ParticleSettings, emit_from)
	ENUM_PROPERTY(distribution_enum, ParticleSettings, distribution)
	ENUM_PROPERTY(physics_type_enum, ParticleSettings, physics_type)
	ENUM_PROPERTY(rotation_mode_enum, ParticleSettings, rotation_mode)
	ENUM_PROPERTY(angular_velocity_mode_enum, ParticleSettings, angular_velocity_mode)
	ENUM_PROPERTY(react_event_enum, ParticleSettings, react_event)
	BOOLEAN_PROPERTY(ParticleSettings, show_guide_hairs)
	BOOLEAN_PROPERTY(ParticleSettings, show_hair_grid)
	BOOLEAN_PROPERTY(ParticleSettings, show_velocity)
	BOOLEAN_PROPERTY(ParticleSettings, show_size)
	BOOLEAN_PROPERTY(ParticleSettings, show_health)
	BOOLEAN_PROPERTY(ParticleSettings, use_absolute_path_time)
	BOOLEAN_PROPERTY(ParticleSettings, use_parent_particles)
	BOOLEAN_PROPERTY(ParticleSettings, show_number)
	BOOLEAN_PROPERTY(ParticleSettings, use_collection_pick_random)
	BOOLEAN_PROPERTY(ParticleSettings, use_collection_count)
	BOOLEAN_PROPERTY(ParticleSettings, use_global_instance)
	BOOLEAN_PROPERTY(ParticleSettings, use_rotation_instance)
	BOOLEAN_PROPERTY(ParticleSettings, use_scale_instance)
	BOOLEAN_PROPERTY(ParticleSettings, use_render_adaptive)
	BOOLEAN_PROPERTY(ParticleSettings, use_velocity_length)
	BOOLEAN_PROPERTY(ParticleSettings, use_whole_collection)
	BOOLEAN_PROPERTY(ParticleSettings, use_strand_primitive)
	ENUM_PROPERTY(display_method_enum, ParticleSettings, display_method)
	ENUM_PROPERTY(render_type_enum, ParticleSettings, render_type)
	ENUM_PROPERTY(display_color_enum, ParticleSettings, display_color)
	FLOAT_PROPERTY(ParticleSettings, display_size)
	ENUM_PROPERTY(child_type_enum, ParticleSettings, child_type)
	INT_PROPERTY(ParticleSettings, display_step)
	INT_PROPERTY(ParticleSettings, render_step)
	INT_PROPERTY(ParticleSettings, hair_step)
	FLOAT_PROPERTY(ParticleSettings, bending_random)
	INT_PROPERTY(ParticleSettings, keys_step)
	INT_PROPERTY(ParticleSettings, adaptive_angle)
	INT_PROPERTY(ParticleSettings, adaptive_pixel)
	INT_PROPERTY(ParticleSettings, display_percentage)
	INT_PROPERTY(ParticleSettings, material)
	ENUM_PROPERTY(material_slot_enum, ParticleSettings, material_slot)
	ENUM_PROPERTY(integrator_enum, ParticleSettings, integrator)
	ENUM_PROPERTY(kink_enum, ParticleSettings, kink)
	ENUM_PROPERTY(kink_axis_enum, ParticleSettings, kink_axis)
	FLOAT_PROPERTY(ParticleSettings, color_maximum)
	FLOAT_PROPERTY(ParticleSettings, frame_start)
	FLOAT_PROPERTY(ParticleSettings, frame_end)
	FLOAT_PROPERTY(ParticleSettings, lifetime)
	FLOAT_PROPERTY(ParticleSettings, lifetime_random)
	FLOAT_PROPERTY(ParticleSettings, time_tweak)
	FLOAT_PROPERTY(ParticleSettings, timestep)
	BOOLEAN_PROPERTY(ParticleSettings, use_adaptive_subframes)
	INT_PROPERTY(ParticleSettings, subframes)
	FLOAT_PROPERTY(ParticleSettings, courant_target)
	FLOAT_PROPERTY(ParticleSettings, jitter_factor)
	FLOAT_PROPERTY(ParticleSettings, effect_hair)
	INT_PROPERTY(ParticleSettings, count)
	INT_PROPERTY(ParticleSettings, userjit)
	INT_PROPERTY(ParticleSettings, grid_resolution)
	FLOAT_PROPERTY(ParticleSettings, grid_random)
	INT_PROPERTY(ParticleSettings, effector_amount)
	FLOAT_PROPERTY(ParticleSettings, normal_factor)
	FLOAT_PROPERTY(ParticleSettings, object_factor)
	FLOAT_PROPERTY(ParticleSettings, factor_random)
	FLOAT_PROPERTY(ParticleSettings, particle_factor)
	FLOAT_PROPERTY(ParticleSettings, tangent_factor)
	FLOAT_PROPERTY(ParticleSettings, tangent_phase)
	FLOAT_PROPERTY(ParticleSettings, reactor_factor)
	FLOAT_ARRAY_PROPERTY(ParticleSettings, 3, object_align_factor)
	FLOAT_PROPERTY(ParticleSettings, angular_velocity_factor)
	FLOAT_PROPERTY(ParticleSettings, phase_factor)
	FLOAT_PROPERTY(ParticleSettings, rotation_factor_random)
	FLOAT_PROPERTY(ParticleSettings, phase_factor_random)
	FLOAT_PROPERTY(ParticleSettings, hair_length)
	FLOAT_PROPERTY(ParticleSettings, mass)
	FLOAT_PROPERTY(ParticleSettings, particle_size)
	FLOAT_PROPERTY(ParticleSettings, size_random)
	POINTER_PROPERTY(Collection, ParticleSettings, collision_collection)
	FLOAT_PROPERTY(ParticleSettings, drag_factor)
	FLOAT_PROPERTY(ParticleSettings, brownian_factor)
	FLOAT_PROPERTY(ParticleSettings, damping)
	FLOAT_PROPERTY(ParticleSettings, length_random)
	INT_PROPERTY(ParticleSettings, child_percent)
	INT_PROPERTY(ParticleSettings, rendered_child_count)
	FLOAT_PROPERTY(ParticleSettings, virtual_parents)
	FLOAT_PROPERTY(ParticleSettings, child_size)
	FLOAT_PROPERTY(ParticleSettings, child_size_random)
	FLOAT_PROPERTY(ParticleSettings, child_radius)
	FLOAT_PROPERTY(ParticleSettings, child_roundness)
	FLOAT_PROPERTY(ParticleSettings, clump_factor)
	FLOAT_PROPERTY(ParticleSettings, clump_shape)
	BOOLEAN_PROPERTY(ParticleSettings, use_clump_curve)
	POINTER_PROPERTY(CurveMapping, ParticleSettings, clump_curve)
	BOOLEAN_PROPERTY(ParticleSettings, use_clump_noise)
	FLOAT_PROPERTY(ParticleSettings, clump_noise_size)
	FLOAT_PROPERTY(ParticleSettings, kink_amplitude)
	FLOAT_PROPERTY(ParticleSettings, kink_amplitude_clump)
	FLOAT_PROPERTY(ParticleSettings, kink_amplitude_random)
	FLOAT_PROPERTY(ParticleSettings, kink_frequency)
	FLOAT_PROPERTY(ParticleSettings, kink_shape)
	FLOAT_PROPERTY(ParticleSettings, kink_flat)
	INT_PROPERTY(ParticleSettings, kink_extra_steps)
	FLOAT_PROPERTY(ParticleSettings, kink_axis_random)
	FLOAT_PROPERTY(ParticleSettings, roughness_1)
	FLOAT_PROPERTY(ParticleSettings, roughness_1_size)
	FLOAT_PROPERTY(ParticleSettings, roughness_2)
	FLOAT_PROPERTY(ParticleSettings, roughness_2_size)
	FLOAT_PROPERTY(ParticleSettings, roughness_2_threshold)
	FLOAT_PROPERTY(ParticleSettings, roughness_endpoint)
	FLOAT_PROPERTY(ParticleSettings, roughness_end_shape)
	BOOLEAN_PROPERTY(ParticleSettings, use_roughness_curve)
	POINTER_PROPERTY(CurveMapping, ParticleSettings, roughness_curve)
	FLOAT_PROPERTY(ParticleSettings, child_length)
	FLOAT_PROPERTY(ParticleSettings, child_length_threshold)
	FLOAT_PROPERTY(ParticleSettings, child_parting_factor)
	FLOAT_PROPERTY(ParticleSettings, child_parting_min)
	FLOAT_PROPERTY(ParticleSettings, child_parting_max)
	FLOAT_PROPERTY(ParticleSettings, branch_threshold)
	FLOAT_PROPERTY(ParticleSettings, line_length_tail)
	FLOAT_PROPERTY(ParticleSettings, line_length_head)
	FLOAT_PROPERTY(ParticleSettings, path_start)
	FLOAT_PROPERTY(ParticleSettings, path_end)
	INT_PROPERTY(ParticleSettings, trail_count)
	INT_PROPERTY(ParticleSettings, keyed_loops)
	BOOLEAN_PROPERTY(ParticleSettings, use_modifier_stack)
	POINTER_PROPERTY(Collection, ParticleSettings, instance_collection)

	POINTER_PROPERTY(ParticleDupliWeight, ParticleSettings, active_instanceweight)
	INT_PROPERTY(ParticleSettings, active_instanceweight_index)
	POINTER_PROPERTY(Object, ParticleSettings, instance_object)
	POINTER_PROPERTY(BoidSettings, ParticleSettings, boids)
	POINTER_PROPERTY(SPHFluidSettings, ParticleSettings, fluid)
	POINTER_PROPERTY(EffectorWeights, ParticleSettings, effector_weights)
	POINTER_PROPERTY(AnimData, ParticleSettings, animation_data)
	POINTER_PROPERTY(FieldSettings, ParticleSettings, force_field_1)
	POINTER_PROPERTY(FieldSettings, ParticleSettings, force_field_2)
	FLOAT_PROPERTY(ParticleSettings, twist)
	BOOLEAN_PROPERTY(ParticleSettings, use_twist_curve)
	POINTER_PROPERTY(CurveMapping, ParticleSettings, twist_curve)
	BOOLEAN_PROPERTY(ParticleSettings, use_close_tip)
	FLOAT_PROPERTY(ParticleSettings, shape)
	FLOAT_PROPERTY(ParticleSettings, root_radius)
	FLOAT_PROPERTY(ParticleSettings, tip_radius)
	FLOAT_PROPERTY(ParticleSettings, radius_scale)


	POINTER_PROPERTY(Struct, ParticleSettingsTextureSlots, rna_type)

	inline ParticleSettingsTextureSlot ParticleSettingsTextureSlots::add(Context C) {
		PointerRNA result;
		::MTex *retdata = ParticleSettingsTextureSlots_add_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, nullptr);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ParticleSettingsTextureSlot, retdata);
		return ParticleSettingsTextureSlot(result);
	}

	inline ParticleSettingsTextureSlot ParticleSettingsTextureSlots::create(Context C, int index) {
		PointerRNA result;
		::MTex *retdata = ParticleSettingsTextureSlots_create_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, nullptr, index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ParticleSettingsTextureSlot, retdata);
		return ParticleSettingsTextureSlot(result);
	}

	inline void ParticleSettingsTextureSlots::clear(Context C, int index) {
		ParticleSettingsTextureSlots_clear_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, nullptr, index);
	}


	POINTER_PROPERTY(Struct, Point, rna_type)
	FLOAT_ARRAY_PROPERTY(Point, 3, co)
	FLOAT_PROPERTY(Point, radius)
	INT_PROPERTY(Point, index)






	POINTER_PROPERTY(AnimData, PointCloud, animation_data)


	POINTER_PROPERTY(Struct, Pose, rna_type)

	ENUM_PROPERTY(ik_solver_enum, Pose, ik_solver)
	POINTER_PROPERTY(IKParam, Pose, ik_param)
	BOOLEAN_PROPERTY(Pose, use_mirror_x)
	BOOLEAN_PROPERTY(Pose, use_mirror_relative)
	BOOLEAN_PROPERTY(Pose, use_auto_ik)
	POINTER_PROPERTY(AnimViz, Pose, animation_visualization)

	inline void Pose::apply_pose_from_action(Context C, Action& action, float evaluation_time) {
		Pose_apply_pose_from_action_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, (::bAction *) action.ptr.data, evaluation_time);
	}

	inline void Pose::blend_pose_from_action(Context C, Action& action, float blend_factor, float evaluation_time) {
		Pose_blend_pose_from_action_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data, (::bAction *) action.ptr.data, blend_factor, evaluation_time);
	}

	inline void Pose::backup_create(Action& action) {
		Pose_backup_create_func((::ID *) ptr.owner_id, (::bAction *) action.ptr.data);
	}

	inline bool Pose::backup_restore(Context C) {
		return Pose_backup_restore_func((::ID *) ptr.owner_id, (::bContext *) C.ptr.data);
	}

	inline void Pose::backup_clear() {
		Pose_backup_clear_func((::ID *) ptr.owner_id);
	}


	POINTER_PROPERTY(Struct, PoseBone, rna_type)

	STRING_PROPERTY(PoseBone, name)
	POINTER_PROPERTY(MotionPath, PoseBone, motion_path)
	POINTER_PROPERTY(Bone, PoseBone, bone)
	POINTER_PROPERTY(PoseBone, PoseBone, parent)
	POINTER_PROPERTY(PoseBone, PoseBone, child)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, location)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, scale)
	FLOAT_ARRAY_PROPERTY(PoseBone, 4, rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(PoseBone, 4, rotation_axis_angle)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, rotation_euler)
	ENUM_PROPERTY(rotation_mode_enum, PoseBone, rotation_mode)
	FLOAT_PROPERTY(PoseBone, bbone_rollin)
	FLOAT_PROPERTY(PoseBone, bbone_rollout)
	FLOAT_PROPERTY(PoseBone, bbone_curveinx)
	FLOAT_PROPERTY(PoseBone, bbone_curveinz)
	FLOAT_PROPERTY(PoseBone, bbone_curveoutx)
	FLOAT_PROPERTY(PoseBone, bbone_curveoutz)
	FLOAT_PROPERTY(PoseBone, bbone_easein)
	FLOAT_PROPERTY(PoseBone, bbone_easeout)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, bbone_scalein)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, bbone_scaleout)
	POINTER_PROPERTY(PoseBone, PoseBone, bbone_custom_handle_start)
	POINTER_PROPERTY(PoseBone, PoseBone, bbone_custom_handle_end)
	FLOAT_ARRAY_PROPERTY(PoseBone, 16, matrix_channel)
	FLOAT_ARRAY_PROPERTY(PoseBone, 16, matrix_basis)
	FLOAT_ARRAY_PROPERTY(PoseBone, 16, matrix)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, head)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, tail)
	FLOAT_PROPERTY(PoseBone, length)
	BOOLEAN_PROPERTY(PoseBone, is_in_ik_chain)
	BOOLEAN_PROPERTY(PoseBone, lock_ik_x)
	BOOLEAN_PROPERTY(PoseBone, lock_ik_y)
	BOOLEAN_PROPERTY(PoseBone, lock_ik_z)
	BOOLEAN_PROPERTY(PoseBone, use_ik_limit_x)
	BOOLEAN_PROPERTY(PoseBone, use_ik_limit_y)
	BOOLEAN_PROPERTY(PoseBone, use_ik_limit_z)
	BOOLEAN_PROPERTY(PoseBone, use_ik_rotation_control)
	BOOLEAN_PROPERTY(PoseBone, use_ik_linear_control)
	FLOAT_PROPERTY(PoseBone, ik_min_x)
	FLOAT_PROPERTY(PoseBone, ik_max_x)
	FLOAT_PROPERTY(PoseBone, ik_min_y)
	FLOAT_PROPERTY(PoseBone, ik_max_y)
	FLOAT_PROPERTY(PoseBone, ik_min_z)
	FLOAT_PROPERTY(PoseBone, ik_max_z)
	FLOAT_PROPERTY(PoseBone, ik_stiffness_x)
	FLOAT_PROPERTY(PoseBone, ik_stiffness_y)
	FLOAT_PROPERTY(PoseBone, ik_stiffness_z)
	FLOAT_PROPERTY(PoseBone, ik_stretch)
	FLOAT_PROPERTY(PoseBone, ik_rotation_weight)
	FLOAT_PROPERTY(PoseBone, ik_linear_weight)
	POINTER_PROPERTY(Object, PoseBone, custom_shape)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, custom_shape_scale_xyz)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, custom_shape_translation)
	FLOAT_ARRAY_PROPERTY(PoseBone, 3, custom_shape_rotation_euler)
	BOOLEAN_PROPERTY(PoseBone, use_custom_shape_bone_size)
	POINTER_PROPERTY(PoseBone, PoseBone, custom_shape_transform)
	POINTER_PROPERTY(BoneColor, PoseBone, color)
	BOOLEAN_ARRAY_PROPERTY(PoseBone, 3, lock_location)
	BOOLEAN_ARRAY_PROPERTY(PoseBone, 3, lock_rotation)
	BOOLEAN_PROPERTY(PoseBone, lock_rotation_w)
	BOOLEAN_PROPERTY(PoseBone, lock_rotations_4d)
	BOOLEAN_ARRAY_PROPERTY(PoseBone, 3, lock_scale)

	inline float PoseBone::evaluate_envelope(float point[3]) {
		return PoseBone_evaluate_envelope_func((::bPoseChannel *) this->ptr.data, point);
	}

	inline void PoseBone::bbone_segment_index(float point[3], int *index, float *blend_next) {
		PoseBone_bbone_segment_index_func((::bPoseChannel *) this->ptr.data, nullptr, point, index, blend_next);
	}

	inline void PoseBone::bbone_segment_matrix(float matrix_return[16], int index, bool rest) {
		PoseBone_bbone_segment_matrix_func((::bPoseChannel *) this->ptr.data, nullptr, matrix_return, index, rest);
	}

	inline void PoseBone::compute_bbone_handles(float handle1[3], float *roll1, float handle2[3], float *roll2, bool rest, bool ease, bool offsets) {
		PoseBone_compute_bbone_handles_func((::bPoseChannel *) this->ptr.data, nullptr, handle1, roll1, handle2, roll2, rest, ease, offsets);
	}


	POINTER_PROPERTY(Struct, PoseBoneConstraints, rna_type)
	POINTER_PROPERTY(Constraint, PoseBoneConstraints, active)

	inline Constraint PoseBoneConstraints::create(void *main, int type) {
		PointerRNA result;
		::bConstraint *retdata = PoseBoneConstraints_new_func((::ID *) ptr.owner_id, (::bPoseChannel *) this->ptr.data, (::Main *) main, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Constraint, retdata);
		return Constraint(result);
	}

	inline void PoseBoneConstraints::remove(void *main, Constraint& constraint) {
		PoseBoneConstraints_remove_func((::ID *) ptr.owner_id, (::bPoseChannel *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &constraint.ptr);
	}

	inline void PoseBoneConstraints::move(void *main, int from_index, int to_index) {
		PoseBoneConstraints_move_func((::ID *) ptr.owner_id, (::bPoseChannel *) this->ptr.data, (::Main *) main, nullptr, from_index, to_index);
	}

	inline Constraint PoseBoneConstraints::copy(void *main, Constraint& constraint) {
		PointerRNA result;
		::bConstraint *retdata = PoseBoneConstraints_copy_func((::ID *) ptr.owner_id, (::bPoseChannel *) this->ptr.data, (::Main *) main, (::PointerRNA *) &constraint.ptr);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Constraint, retdata);
		return Constraint(result);
	}


	POINTER_PROPERTY(Struct, IKParam, rna_type)
	ENUM_PROPERTY(ik_solver_enum, IKParam, ik_solver)


	FLOAT_PROPERTY(Itasc, precision)
	INT_PROPERTY(Itasc, iterations)
	INT_PROPERTY(Itasc, step_count)
	BOOLEAN_PROPERTY(Itasc, translate_root_bones)
	ENUM_PROPERTY(mode_enum, Itasc, mode)
	ENUM_PROPERTY(reiteration_method_enum, Itasc, reiteration_method)
	BOOLEAN_PROPERTY(Itasc, use_auto_step)
	FLOAT_PROPERTY(Itasc, step_min)
	FLOAT_PROPERTY(Itasc, step_max)
	FLOAT_PROPERTY(Itasc, feedback)
	FLOAT_PROPERTY(Itasc, velocity_max)
	ENUM_PROPERTY(solver_enum, Itasc, solver)
	FLOAT_PROPERTY(Itasc, damping_max)
	FLOAT_PROPERTY(Itasc, damping_epsilon)


	POINTER_PROPERTY(Struct, CurveProfilePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(CurveProfilePoint, 2, location)
	ENUM_PROPERTY(handle_type_1_enum, CurveProfilePoint, handle_type_1)
	ENUM_PROPERTY(handle_type_2_enum, CurveProfilePoint, handle_type_2)
	BOOLEAN_PROPERTY(CurveProfilePoint, select)


	POINTER_PROPERTY(Struct, CurveProfile, rna_type)
	ENUM_PROPERTY(preset_enum, CurveProfile, preset)
	BOOLEAN_PROPERTY(CurveProfile, use_clip)
	BOOLEAN_PROPERTY(CurveProfile, use_sample_straight_edges)
	BOOLEAN_PROPERTY(CurveProfile, use_sample_even_lengths)



	inline void CurveProfile::update() {
		CurveProfile_update_func((::CurveProfile *) this->ptr.data);
	}

	inline void CurveProfile::reset_view() {
		CurveProfile_reset_view_func((::CurveProfile *) this->ptr.data);
	}

	inline void CurveProfile::initialize(int totsegments) {
		CurveProfile_initialize_func((::CurveProfile *) this->ptr.data, totsegments);
	}

	inline void CurveProfile::evaluate(float length_portion, float location[2]) {
		CurveProfile_evaluate_func((::CurveProfile *) this->ptr.data, nullptr, length_portion, location);
	}


	POINTER_PROPERTY(Struct, CurveProfilePoints, rna_type)

	inline CurveProfilePoint CurveProfilePoints::add(float x, float y) {
		PointerRNA result;
		::CurveProfilePoint *retdata = CurveProfilePoints_add_func((::CurveProfile *) this->ptr.data, x, y);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_CurveProfilePoint, retdata);
		return CurveProfilePoint(result);
	}

	inline void CurveProfilePoints::remove(CurveProfilePoint& point) {
		CurveProfilePoints_remove_func((::CurveProfile *) this->ptr.data, nullptr, (::PointerRNA *) &point.ptr);
	}


	ENUM_PROPERTY(type_enum, LightProbe, type)
	FLOAT_PROPERTY(LightProbe, clip_start)
	FLOAT_PROPERTY(LightProbe, clip_end)
	BOOLEAN_PROPERTY(LightProbe, show_clip)
	ENUM_PROPERTY(influence_type_enum, LightProbe, influence_type)
	BOOLEAN_PROPERTY(LightProbe, show_influence)
	FLOAT_PROPERTY(LightProbe, influence_distance)
	FLOAT_PROPERTY(LightProbe, falloff)
	BOOLEAN_PROPERTY(LightProbe, use_custom_parallax)
	BOOLEAN_PROPERTY(LightProbe, show_parallax)
	ENUM_PROPERTY(parallax_type_enum, LightProbe, parallax_type)
	FLOAT_PROPERTY(LightProbe, parallax_distance)
	INT_PROPERTY(LightProbe, grid_resolution_x)
	INT_PROPERTY(LightProbe, grid_resolution_y)
	INT_PROPERTY(LightProbe, grid_resolution_z)
	FLOAT_PROPERTY(LightProbe, grid_normal_bias)
	FLOAT_PROPERTY(LightProbe, grid_view_bias)
	FLOAT_PROPERTY(LightProbe, grid_irradiance_smoothing)
	INT_PROPERTY(LightProbe, grid_bake_samples)
	FLOAT_PROPERTY(LightProbe, grid_surface_bias)
	FLOAT_PROPERTY(LightProbe, grid_escape_bias)
	FLOAT_PROPERTY(LightProbe, surfel_density)
	FLOAT_PROPERTY(LightProbe, grid_validity_threshold)
	FLOAT_PROPERTY(LightProbe, grid_dilation_threshold)
	FLOAT_PROPERTY(LightProbe, grid_dilation_radius)
	BOOLEAN_PROPERTY(LightProbe, grid_capture_world)
	BOOLEAN_PROPERTY(LightProbe, grid_capture_indirect)
	BOOLEAN_PROPERTY(LightProbe, grid_capture_emission)
	FLOAT_PROPERTY(LightProbe, grid_clamp_direct)
	FLOAT_PROPERTY(LightProbe, grid_clamp_indirect)
	FLOAT_PROPERTY(LightProbe, visibility_buffer_bias)
	FLOAT_PROPERTY(LightProbe, visibility_bleed_bias)
	FLOAT_PROPERTY(LightProbe, visibility_blur)
	FLOAT_PROPERTY(LightProbe, intensity)
	POINTER_PROPERTY(Collection, LightProbe, visibility_collection)
	BOOLEAN_PROPERTY(LightProbe, invert_visibility_collection)
	BOOLEAN_PROPERTY(LightProbe, show_data)
	BOOLEAN_PROPERTY(LightProbe, use_data_display)
	FLOAT_PROPERTY(LightProbe, data_display_size)
	POINTER_PROPERTY(AnimData, LightProbe, animation_data)


	POINTER_PROPERTY(Struct, RenderEngine, rna_type)
	BOOLEAN_PROPERTY(RenderEngine, is_animation)
	BOOLEAN_PROPERTY(RenderEngine, is_preview)
	POINTER_PROPERTY(Object, RenderEngine, camera_override)
	BOOLEAN_ARRAY_PROPERTY(RenderEngine, 20, layer_override)
	INT_PROPERTY(RenderEngine, resolution_x)
	INT_PROPERTY(RenderEngine, resolution_y)
	STRING_PROPERTY(RenderEngine, temporary_directory)
	POINTER_PROPERTY(RenderSettings, RenderEngine, render)
	BOOLEAN_PROPERTY(RenderEngine, use_highlight_tiles)
	STRING_PROPERTY(RenderEngine, bl_idname)
	STRING_PROPERTY(RenderEngine, bl_label)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_preview)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_postprocess)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_eevee_viewport)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_custom_freestyle)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_image_save)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_gpu_context)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_shading_nodes_custom)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_spherical_stereo)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_stereo_viewport)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_alembic_procedural)
	BOOLEAN_PROPERTY(RenderEngine, bl_use_materialx)

	inline void RenderEngine::tag_redraw() {
		RenderEngine_tag_redraw_func((::RenderEngine *) this->ptr.data);
	}

	inline void RenderEngine::tag_update() {
		RenderEngine_tag_update_func((::RenderEngine *) this->ptr.data);
	}

	inline RenderResult RenderEngine::begin_result(int x, int y, int w, int h, const char * layer, const char * view) {
		PointerRNA result;
		::RenderResult *retdata = RenderEngine_begin_result_func((::RenderEngine *) this->ptr.data, x, y, w, h, layer, view);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RenderResult, retdata);
		return RenderResult(result);
	}

	inline void RenderEngine::update_result(RenderResult& result) {
		RenderEngine_update_result_func((::RenderEngine *) this->ptr.data, (::RenderResult *) result.ptr.data);
	}

	inline void RenderEngine::end_result(RenderResult& result, bool cancel, bool highlight, bool do_merge_results) {
		RenderEngine_end_result_func((::RenderEngine *) this->ptr.data, (::RenderResult *) result.ptr.data, cancel, highlight, do_merge_results);
	}

	inline void RenderEngine::add_pass(const char * name, int channels, const char * chan_id, const char * layer) {
		RenderEngine_add_pass_func((::RenderEngine *) this->ptr.data, name, channels, chan_id, layer);
	}

	inline RenderResult RenderEngine::get_result() {
		PointerRNA result;
		::RenderResult *retdata = RenderEngine_get_result_func((::RenderEngine *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RenderResult, retdata);
		return RenderResult(result);
	}

	inline bool RenderEngine::test_break() {
		return RenderEngine_test_break_func((::RenderEngine *) this->ptr.data);
	}

	inline RenderPass RenderEngine::pass_by_index_get(const char * layer, int index) {
		PointerRNA result;
		::RenderPass *retdata = RenderEngine_pass_by_index_get_func((::RenderEngine *) this->ptr.data, layer, index);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RenderPass, retdata);
		return RenderPass(result);
	}

	inline const char * RenderEngine::active_view_get() {
		return RenderEngine_active_view_get_func((::RenderEngine *) this->ptr.data);
	}

	inline void RenderEngine::active_view_set(const char * view) {
		RenderEngine_active_view_set_func((::RenderEngine *) this->ptr.data, view);
	}

	inline float RenderEngine::camera_shift_x(Object& camera, bool use_spherical_stereo) {
		return RenderEngine_camera_shift_x_func((::RenderEngine *) this->ptr.data, (::Object *) camera.ptr.data, use_spherical_stereo);
	}

	inline void RenderEngine::camera_model_matrix(Object& camera, bool use_spherical_stereo, float r_model_matrix[16]) {
		RenderEngine_camera_model_matrix_func((::RenderEngine *) this->ptr.data, (::Object *) camera.ptr.data, use_spherical_stereo, r_model_matrix);
	}

	inline bool RenderEngine::use_spherical_stereo(Object& camera) {
		return RenderEngine_use_spherical_stereo_func((::RenderEngine *) this->ptr.data, (::Object *) camera.ptr.data);
	}

	inline void RenderEngine::update_stats(const char * stats, const char * info) {
		RenderEngine_update_stats_func((::RenderEngine *) this->ptr.data, stats, info);
	}

	inline void RenderEngine::frame_set(int frame, float subframe) {
		RenderEngine_frame_set_func((::RenderEngine *) this->ptr.data, frame, subframe);
	}

	inline void RenderEngine::update_progress(float progress) {
		RenderEngine_update_progress_func((::RenderEngine *) this->ptr.data, progress);
	}

	inline void RenderEngine::update_memory_stats(float memory_used, float memory_peak) {
		RenderEngine_update_memory_stats_func((::RenderEngine *) this->ptr.data, memory_used, memory_peak);
	}

	inline void RenderEngine::report(int type, const char * message) {
		RenderEngine_report_func((::RenderEngine *) this->ptr.data, type, message);
	}

	inline void RenderEngine::error_set(const char * message) {
		RenderEngine_error_set_func((::RenderEngine *) this->ptr.data, message);
	}

	inline void RenderEngine::bind_display_space_shader(Scene& scene) {
		RenderEngine_bind_display_space_shader_func((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data);
	}

	inline void RenderEngine::unbind_display_space_shader() {
		RenderEngine_unbind_display_space_shader_func((::RenderEngine *) this->ptr.data);
	}

	inline bool RenderEngine::support_display_space_shader(Scene& scene) {
		return RenderEngine_support_display_space_shader_func((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data);
	}

	inline int RenderEngine::get_preview_pixel_size(Scene& scene) {
		return RenderEngine_get_preview_pixel_size_func((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data);
	}

	inline void RenderEngine::free_blender_memory() {
		RenderEngine_free_blender_memory_func((::RenderEngine *) this->ptr.data);
	}

	inline void RenderEngine::tile_highlight_set(int x, int y, int width, int height, bool highlight) {
		RenderEngine_tile_highlight_set_func((::RenderEngine *) this->ptr.data, x, y, width, height, highlight);
	}

	inline void RenderEngine::tile_highlight_clear_all() {
		RenderEngine_tile_highlight_clear_all_func((::RenderEngine *) this->ptr.data);
	}

	inline void RenderEngine::register_pass(Scene& scene, ViewLayer& view_layer, const char * name, int channels, const char * chanid, eNodeSocketDatatype type) {
		RenderEngine_register_pass_func((::RenderEngine *) this->ptr.data, (::Scene *) scene.ptr.data, (::ViewLayer *) view_layer.ptr.data, name, channels, chanid, type);
	}




	POINTER_PROPERTY(Struct, RenderResult, rna_type)
	INT_PROPERTY(RenderResult, resolution_x)
	INT_PROPERTY(RenderResult, resolution_y)



	inline void RenderResult::load_from_file(const char * filepath) {
		RenderResult_load_from_file_func((::RenderResult *) this->ptr.data, nullptr, filepath);
	}

	inline void RenderResult::stamp_data_add_field(const char * field, const char * value) {
		RenderResult_stamp_data_add_field_func((::RenderResult *) this->ptr.data, field, value);
	}


	POINTER_PROPERTY(Struct, RenderView, rna_type)
	STRING_PROPERTY(RenderView, name)


	POINTER_PROPERTY(Struct, RenderLayer, rna_type)
	STRING_PROPERTY(RenderLayer, name)
	BOOLEAN_PROPERTY(RenderLayer, use_solid)
	BOOLEAN_PROPERTY(RenderLayer, use_sky)
	BOOLEAN_PROPERTY(RenderLayer, use_ao)
	BOOLEAN_PROPERTY(RenderLayer, use_strand)
	BOOLEAN_PROPERTY(RenderLayer, use_volumes)
	BOOLEAN_PROPERTY(RenderLayer, use_motion_blur)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_combined)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_z)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_vector)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_position)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_normal)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_uv)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_mist)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_object_index)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_material_index)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_shadow)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_ambient_occlusion)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_emit)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_environment)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_diffuse_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_diffuse_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_diffuse_color)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_glossy_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_glossy_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_glossy_color)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_transmission_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_transmission_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_transmission_color)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_subsurface_direct)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_subsurface_indirect)
	BOOLEAN_PROPERTY(RenderLayer, use_pass_subsurface_color)


	inline void RenderLayer::load_from_file(const char * filepath, int x, int y) {
		RenderLayer_load_from_file_func((::RenderLayer *) this->ptr.data, nullptr, filepath, x, y);
	}


	POINTER_PROPERTY(Struct, RenderPasses, rna_type)

	inline RenderPass RenderPasses::find_by_type(int pass_type, const char * view) {
		PointerRNA result;
		::RenderPass *retdata = RenderPasses_find_by_type_func((::RenderLayer *) this->ptr.data, pass_type, view);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RenderPass, retdata);
		return RenderPass(result);
	}

	inline RenderPass RenderPasses::find_by_name(const char * name, const char * view) {
		PointerRNA result;
		::RenderPass *retdata = RenderPasses_find_by_name_func((::RenderLayer *) this->ptr.data, name, view);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RenderPass, retdata);
		return RenderPass(result);
	}


	POINTER_PROPERTY(Struct, RenderPass, rna_type)
	STRING_PROPERTY(RenderPass, fullname)
	STRING_PROPERTY(RenderPass, name)
	STRING_PROPERTY(RenderPass, channel_id)
	INT_PROPERTY(RenderPass, channels)
	FLOAT_DYNAMIC_ARRAY_PROPERTY(RenderPass, rect)
	INT_PROPERTY(RenderPass, view_id)


	POINTER_PROPERTY(Struct, RigidBodyWorld, rna_type)
	POINTER_PROPERTY(Collection, RigidBodyWorld, collection)
	POINTER_PROPERTY(Collection, RigidBodyWorld, constraints)
	BOOLEAN_PROPERTY(RigidBodyWorld, enabled)
	FLOAT_PROPERTY(RigidBodyWorld, time_scale)
	INT_PROPERTY(RigidBodyWorld, substeps_per_frame)
	INT_PROPERTY(RigidBodyWorld, solver_iterations)
	BOOLEAN_PROPERTY(RigidBodyWorld, use_split_impulse)
	POINTER_PROPERTY(PointCache, RigidBodyWorld, point_cache)
	POINTER_PROPERTY(EffectorWeights, RigidBodyWorld, effector_weights)

	inline void RigidBodyWorld::convex_sweep_test(Object& object, float start[3], float end[3], float object_location[3], float hitpoint[3], float normal[3], int *has_hit) {
		RigidBodyWorld_convex_sweep_test_func((::RigidBodyWorld *) this->ptr.data, nullptr, (::Object *) object.ptr.data, start, end, object_location, hitpoint, normal, has_hit);
	}


	POINTER_PROPERTY(Struct, RigidBodyObject, rna_type)
	ENUM_PROPERTY(type_enum, RigidBodyObject, type)
	ENUM_PROPERTY(mesh_source_enum, RigidBodyObject, mesh_source)
	BOOLEAN_PROPERTY(RigidBodyObject, enabled)
	ENUM_PROPERTY(collision_shape_enum, RigidBodyObject, collision_shape)
	BOOLEAN_PROPERTY(RigidBodyObject, kinematic)
	BOOLEAN_PROPERTY(RigidBodyObject, use_deform)
	FLOAT_PROPERTY(RigidBodyObject, mass)
	BOOLEAN_PROPERTY(RigidBodyObject, use_deactivation)
	BOOLEAN_PROPERTY(RigidBodyObject, use_start_deactivated)
	FLOAT_PROPERTY(RigidBodyObject, deactivate_linear_velocity)
	FLOAT_PROPERTY(RigidBodyObject, deactivate_angular_velocity)
	FLOAT_PROPERTY(RigidBodyObject, linear_damping)
	FLOAT_PROPERTY(RigidBodyObject, angular_damping)
	FLOAT_PROPERTY(RigidBodyObject, friction)
	FLOAT_PROPERTY(RigidBodyObject, restitution)
	BOOLEAN_PROPERTY(RigidBodyObject, use_margin)
	FLOAT_PROPERTY(RigidBodyObject, collision_margin)
	BOOLEAN_ARRAY_PROPERTY(RigidBodyObject, 20, collision_collections)


	POINTER_PROPERTY(Struct, RigidBodyConstraint, rna_type)
	ENUM_PROPERTY(type_enum, RigidBodyConstraint, type)
	ENUM_PROPERTY(spring_type_enum, RigidBodyConstraint, spring_type)
	BOOLEAN_PROPERTY(RigidBodyConstraint, enabled)
	BOOLEAN_PROPERTY(RigidBodyConstraint, disable_collisions)
	POINTER_PROPERTY(Object, RigidBodyConstraint, object1)
	POINTER_PROPERTY(Object, RigidBodyConstraint, object2)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_breaking)
	FLOAT_PROPERTY(RigidBodyConstraint, breaking_threshold)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_override_solver_iterations)
	INT_PROPERTY(RigidBodyConstraint, solver_iterations)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_lin_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_lin_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_lin_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_ang_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_ang_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_limit_ang_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_ang_x)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_ang_y)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_spring_ang_z)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_motor_lin)
	BOOLEAN_PROPERTY(RigidBodyConstraint, use_motor_ang)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_x_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_x_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_y_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_y_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_z_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_lin_z_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_x_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_x_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_y_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_y_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_z_lower)
	FLOAT_PROPERTY(RigidBodyConstraint, limit_ang_z_upper)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_z)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_ang_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_ang_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_stiffness_ang_z)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_z)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_ang_x)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_ang_y)
	FLOAT_PROPERTY(RigidBodyConstraint, spring_damping_ang_z)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_lin_target_velocity)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_lin_max_impulse)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_ang_target_velocity)
	FLOAT_PROPERTY(RigidBodyConstraint, motor_ang_max_impulse)


	POINTER_PROPERTY(Object, Scene, camera)
	POINTER_PROPERTY(Scene, Scene, background_set)
	POINTER_PROPERTY(World, Scene, world)

	INT_PROPERTY(Scene, frame_current)
	FLOAT_PROPERTY(Scene, frame_subframe)
	FLOAT_PROPERTY(Scene, frame_float)
	INT_PROPERTY(Scene, frame_start)
	INT_PROPERTY(Scene, frame_end)
	INT_PROPERTY(Scene, frame_step)
	FLOAT_PROPERTY(Scene, frame_current_final)
	BOOLEAN_PROPERTY(Scene, lock_frame_selection_to_range)
	BOOLEAN_PROPERTY(Scene, use_preview_range)
	INT_PROPERTY(Scene, frame_preview_start)
	INT_PROPERTY(Scene, frame_preview_end)
	BOOLEAN_PROPERTY(Scene, show_subframe)
	BOOLEAN_PROPERTY(Scene, show_keys_from_selected_only)
	STRING_PROPERTY(Scene, use_stamp_note)
	POINTER_PROPERTY(AnimData, Scene, animation_data)
	BOOLEAN_PROPERTY(Scene, is_nla_tweakmode)
	BOOLEAN_PROPERTY(Scene, use_custom_simulation_range)
	INT_PROPERTY(Scene, simulation_frame_start)
	INT_PROPERTY(Scene, simulation_frame_end)
	ENUM_PROPERTY(sync_mode_enum, Scene, sync_mode)
	POINTER_PROPERTY(NodeTree, Scene, node_tree)
	BOOLEAN_PROPERTY(Scene, use_nodes)
	POINTER_PROPERTY(SequenceEditor, Scene, sequence_editor)


	POINTER_PROPERTY(RigidBodyWorld, Scene, rigidbody_world)
	POINTER_PROPERTY(ToolSettings, Scene, tool_settings)
	POINTER_PROPERTY(UnitSettings, Scene, unit_settings)
	FLOAT_ARRAY_PROPERTY(Scene, 3, gravity)
	BOOLEAN_PROPERTY(Scene, use_gravity)
	POINTER_PROPERTY(RenderSettings, Scene, render)
	POINTER_PROPERTY(DisplaySafeAreas, Scene, safe_areas)


	POINTER_PROPERTY(View3DCursor, Scene, cursor)
	BOOLEAN_PROPERTY(Scene, use_audio)
	BOOLEAN_PROPERTY(Scene, use_audio_scrub)
	FLOAT_PROPERTY(Scene, audio_doppler_speed)
	FLOAT_PROPERTY(Scene, audio_doppler_factor)
	ENUM_PROPERTY(audio_distance_model_enum, Scene, audio_distance_model)
	FLOAT_PROPERTY(Scene, audio_volume)
	POINTER_PROPERTY(GreasePencil, Scene, grease_pencil)
	POINTER_PROPERTY(MovieClip, Scene, active_clip)
	POINTER_PROPERTY(ColorManagedViewSettings, Scene, view_settings)
	POINTER_PROPERTY(ColorManagedDisplaySettings, Scene, display_settings)
	POINTER_PROPERTY(ColorManagedSequencerColorspaceSettings, Scene, sequencer_colorspace_settings)

	POINTER_PROPERTY(Collection, Scene, collection)
	POINTER_PROPERTY(SceneDisplay, Scene, display)
	POINTER_PROPERTY(SceneEEVEE, Scene, eevee)
	POINTER_PROPERTY(SceneGpencil, Scene, grease_pencil_settings)
	POINTER_PROPERTY(SceneHydra, Scene, hydra)

	inline void Scene::update_render_engine(void *main) {
		Scene_update_render_engine_func((::Main *) main);
	}

	inline const char * Scene::statistics(void *main, ViewLayer& view_layer) {
		return Scene_statistics_func((::Scene *) this->ptr.data, (::Main *) main, nullptr, (::ViewLayer *) view_layer.ptr.data);
	}

	inline void Scene::frame_set(void *main, int frame, float subframe) {
		Scene_frame_set_func((::Scene *) this->ptr.data, (::Main *) main, frame, subframe);
	}

	inline void Scene::uvedit_aspect(Object& object, float result[2]) {
		Scene_uvedit_aspect_func((::Scene *) this->ptr.data, (::Object *) object.ptr.data, result);
	}

	inline void Scene::ray_cast(Depsgraph& depsgraph, float origin[3], float direction[3], float distance, bool *result, float location[3], float normal[3], int *index, Object *object, float matrix[16]) {
		Scene_ray_cast_func((::Scene *) this->ptr.data, (::Depsgraph *) depsgraph.ptr.data, origin, direction, distance, result, location, normal, index, (::Object **) &object->ptr.data, matrix);
	}

	inline SequenceEditor Scene::sequence_editor_create() {
		PointerRNA result;
		::Editing *retdata = Scene_sequence_editor_create_func((::Scene *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_SequenceEditor, retdata);
		return SequenceEditor(result);
	}

	inline void Scene::sequence_editor_clear() {
		Scene_sequence_editor_clear_func((::Scene *) this->ptr.data);
	}

	inline void Scene::alembic_export(Context C, const char * filepath, int frame_start, int frame_end, int xform_samples, int geom_samples, float shutter_open, float shutter_close, bool selected_only, bool uvs, bool normals, bool vcolors, bool apply_subdiv, bool flatten, bool visible_objects_only, bool face_sets, bool subdiv_schema, bool export_hair, bool export_particles, bool packuv, float scale, bool triangulate, int quad_method, int ngon_method) {
		Scene_alembic_export_func((::Scene *) this->ptr.data, (::bContext *) C.ptr.data, filepath, frame_start, frame_end, xform_samples, geom_samples, shutter_open, shutter_close, selected_only, uvs, normals, vcolors, apply_subdiv, flatten, visible_objects_only, face_sets, subdiv_schema, export_hair, export_particles, packuv, scale, triangulate, quad_method, ngon_method);
	}


	POINTER_PROPERTY(Struct, SceneObjects, rna_type)


	POINTER_PROPERTY(Struct, KeyingSets, rna_type)
	POINTER_PROPERTY(KeyingSet, KeyingSets, active)
	INT_PROPERTY(KeyingSets, active_index)

	inline KeyingSet KeyingSets::create(const char * idname, const char * name) {
		PointerRNA result;
		::KeyingSet *retdata = KeyingSets_new_func((::Scene *) this->ptr.data, nullptr, idname, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyingSet, retdata);
		return KeyingSet(result);
	}


	POINTER_PROPERTY(Struct, KeyingSetsAll, rna_type)
	POINTER_PROPERTY(KeyingSet, KeyingSetsAll, active)
	INT_PROPERTY(KeyingSetsAll, active_index)


	POINTER_PROPERTY(Struct, TimelineMarkers, rna_type)

	inline TimelineMarker TimelineMarkers::create(const char * name, int frame) {
		PointerRNA result;
		::TimeMarker *retdata = TimelineMarkers_new_func((::Scene *) this->ptr.data, name, frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_TimelineMarker, retdata);
		return TimelineMarker(result);
	}

	inline void TimelineMarkers::remove(TimelineMarker& marker) {
		TimelineMarkers_remove_func((::Scene *) this->ptr.data, nullptr, (::PointerRNA *) &marker.ptr);
	}

	inline void TimelineMarkers::clear() {
		TimelineMarkers_clear_func((::Scene *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ViewLayers, rna_type)

	inline ViewLayer ViewLayers::create(void *main, const char * name) {
		PointerRNA result;
		::ViewLayer *retdata = ViewLayers_new_func((::ID *) ptr.owner_id, (::Scene *) this->ptr.data, (::Main *) main, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ViewLayer, retdata);
		return ViewLayer(result);
	}

	inline void ViewLayers::remove(void *main, ViewLayer& layer) {
		ViewLayers_remove_func((::ID *) ptr.owner_id, (::Scene *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &layer.ptr);
	}


	POINTER_PROPERTY(Struct, ToolSettings, rna_type)
	POINTER_PROPERTY(Sculpt, ToolSettings, sculpt)
	POINTER_PROPERTY(CurvesSculpt, ToolSettings, curves_sculpt)
	BOOLEAN_PROPERTY(ToolSettings, use_auto_normalize)
	BOOLEAN_PROPERTY(ToolSettings, use_lock_relative)
	BOOLEAN_PROPERTY(ToolSettings, use_multipaint)
	ENUM_PROPERTY(vertex_group_user_enum, ToolSettings, vertex_group_user)
	ENUM_PROPERTY(vertex_group_subset_enum, ToolSettings, vertex_group_subset)
	POINTER_PROPERTY(VertexPaint, ToolSettings, vertex_paint)
	POINTER_PROPERTY(VertexPaint, ToolSettings, weight_paint)
	POINTER_PROPERTY(ImagePaint, ToolSettings, image_paint)
	POINTER_PROPERTY(PaintModeSettings, ToolSettings, paint_mode)
	POINTER_PROPERTY(UvSculpt, ToolSettings, uv_sculpt)
	POINTER_PROPERTY(GpPaint, ToolSettings, gpencil_paint)
	POINTER_PROPERTY(GpVertexPaint, ToolSettings, gpencil_vertex_paint)
	POINTER_PROPERTY(GpSculptPaint, ToolSettings, gpencil_sculpt_paint)
	POINTER_PROPERTY(GpWeightPaint, ToolSettings, gpencil_weight_paint)
	POINTER_PROPERTY(ParticleEdit, ToolSettings, particle_edit)
	BOOLEAN_PROPERTY(ToolSettings, uv_sculpt_lock_borders)
	BOOLEAN_PROPERTY(ToolSettings, uv_sculpt_all_islands)
	ENUM_PROPERTY(uv_relax_method_enum, ToolSettings, uv_relax_method)
	BOOLEAN_PROPERTY(ToolSettings, lock_object_mode)
	ENUM_PROPERTY(workspace_tool_type_enum, ToolSettings, workspace_tool_type)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_edit)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_edit_objects)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_projected)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_connected)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_edit_mask)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_action)
	BOOLEAN_PROPERTY(ToolSettings, use_proportional_fcurve)
	BOOLEAN_PROPERTY(ToolSettings, lock_markers)
	ENUM_PROPERTY(proportional_edit_falloff_enum, ToolSettings, proportional_edit_falloff)
	FLOAT_PROPERTY(ToolSettings, proportional_size)
	FLOAT_PROPERTY(ToolSettings, proportional_distance)
	FLOAT_PROPERTY(ToolSettings, double_threshold)
	ENUM_PROPERTY(transform_pivot_point_enum, ToolSettings, transform_pivot_point)
	BOOLEAN_PROPERTY(ToolSettings, use_transform_pivot_point_align)
	BOOLEAN_PROPERTY(ToolSettings, use_transform_data_origin)
	BOOLEAN_PROPERTY(ToolSettings, use_transform_skip_children)
	BOOLEAN_PROPERTY(ToolSettings, use_transform_correct_face_attributes)
	BOOLEAN_PROPERTY(ToolSettings, use_transform_correct_keep_connected)
	BOOLEAN_PROPERTY(ToolSettings, use_mesh_automerge)
	BOOLEAN_PROPERTY(ToolSettings, use_mesh_automerge_and_split)
	BOOLEAN_PROPERTY(ToolSettings, use_snap)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_node)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_sequencer)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_uv)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_align_rotation)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_grid_absolute)
	ENUM_PROPERTY(snap_elements_enum, ToolSettings, snap_elements)
	ENUM_PROPERTY(snap_elements_base_enum, ToolSettings, snap_elements_base)
	ENUM_PROPERTY(snap_elements_individual_enum, ToolSettings, snap_elements_individual)
	INT_PROPERTY(ToolSettings, snap_face_nearest_steps)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_to_same_target)
	ENUM_PROPERTY(snap_node_element_enum, ToolSettings, snap_node_element)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_anim)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_time_absolute)
	ENUM_PROPERTY(snap_anim_element_enum, ToolSettings, snap_anim_element)
	ENUM_PROPERTY(snap_uv_element_enum, ToolSettings, snap_uv_element)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_uv_grid_absolute)
	ENUM_PROPERTY(snap_target_enum, ToolSettings, snap_target)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_peel_object)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_backface_culling)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_self)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_edit)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_nonedit)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_selectable)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_translate)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_rotate)
	BOOLEAN_PROPERTY(ToolSettings, use_snap_scale)
	ENUM_PROPERTY(plane_axis_enum, ToolSettings, plane_axis)
	BOOLEAN_PROPERTY(ToolSettings, plane_axis_auto)
	ENUM_PROPERTY(plane_depth_enum, ToolSettings, plane_depth)
	ENUM_PROPERTY(plane_orientation_enum, ToolSettings, plane_orientation)
	ENUM_PROPERTY(snap_elements_tool_enum, ToolSettings, snap_elements_tool)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_draw_additive)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_draw_onback)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_thumbnail_list)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_weight_data_add)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_automerge_strokes)
	POINTER_PROPERTY(GPencilSculptSettings, ToolSettings, gpencil_sculpt)
	POINTER_PROPERTY(GPencilInterpolateSettings, ToolSettings, gpencil_interpolate)
	ENUM_PROPERTY(gpencil_stroke_placement_view3d_enum, ToolSettings, gpencil_stroke_placement_view3d)
	ENUM_PROPERTY(gpencil_stroke_snap_mode_enum, ToolSettings, gpencil_stroke_snap_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_stroke_endpoints)
	ENUM_PROPERTY(gpencil_selectmode_edit_enum, ToolSettings, gpencil_selectmode_edit)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_select_mask_point)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_select_mask_stroke)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_select_mask_segment)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_vertex_select_mask_point)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_vertex_select_mask_stroke)
	BOOLEAN_PROPERTY(ToolSettings, use_gpencil_vertex_select_mask_segment)
	BOOLEAN_PROPERTY(ToolSettings, use_grease_pencil_multi_frame_editing)
	ENUM_PROPERTY(annotation_stroke_placement_view2d_enum, ToolSettings, annotation_stroke_placement_view2d)
	ENUM_PROPERTY(annotation_stroke_placement_view3d_enum, ToolSettings, annotation_stroke_placement_view3d)
	INT_PROPERTY(ToolSettings, annotation_thickness)
	BOOLEAN_PROPERTY(ToolSettings, use_keyframe_insert_auto)
	ENUM_PROPERTY(auto_keying_mode_enum, ToolSettings, auto_keying_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_record_with_nla)
	BOOLEAN_PROPERTY(ToolSettings, use_keyframe_insert_keyingset)
	BOOLEAN_PROPERTY(ToolSettings, use_keyframe_cycle_aware)
	ENUM_PROPERTY(keyframe_type_enum, ToolSettings, keyframe_type)
	ENUM_PROPERTY(uv_select_mode_enum, ToolSettings, uv_select_mode)
	ENUM_PROPERTY(uv_sticky_select_mode_enum, ToolSettings, uv_sticky_select_mode)
	BOOLEAN_PROPERTY(ToolSettings, use_uv_select_sync)
	BOOLEAN_PROPERTY(ToolSettings, show_uv_local_view)
	BOOLEAN_ARRAY_PROPERTY(ToolSettings, 3, mesh_select_mode)
	FLOAT_PROPERTY(ToolSettings, vertex_group_weight)
	BOOLEAN_PROPERTY(ToolSettings, use_edge_path_live_unwrap)
	FLOAT_ARRAY_PROPERTY(ToolSettings, 3, normal_vector)
	POINTER_PROPERTY(UnifiedPaintSettings, ToolSettings, unified_paint_settings)
	POINTER_PROPERTY(CurvePaintSettings, ToolSettings, curve_paint_settings)
	POINTER_PROPERTY(MeshStatVis, ToolSettings, statvis)
	POINTER_PROPERTY(CurveProfile, ToolSettings, custom_bevel_profile_preset)
	POINTER_PROPERTY(SequencerToolSettings, ToolSettings, sequencer_tool_settings)


	POINTER_PROPERTY(Struct, GPencilInterpolateSettings, rna_type)
	POINTER_PROPERTY(CurveMapping, GPencilInterpolateSettings, interpolation_curve)


	POINTER_PROPERTY(Struct, UnifiedPaintSettings, rna_type)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_size)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_strength)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_weight)
	BOOLEAN_PROPERTY(UnifiedPaintSettings, use_unified_color)
	INT_PROPERTY(UnifiedPaintSettings, size)
	FLOAT_PROPERTY(UnifiedPaintSettings, unprojected_radius)
	FLOAT_PROPERTY(UnifiedPaintSettings, strength)
	FLOAT_PROPERTY(UnifiedPaintSettings, weight)
	FLOAT_ARRAY_PROPERTY(UnifiedPaintSettings, 3, color)
	FLOAT_ARRAY_PROPERTY(UnifiedPaintSettings, 3, secondary_color)
	ENUM_PROPERTY(use_locked_size_enum, UnifiedPaintSettings, use_locked_size)


	POINTER_PROPERTY(Struct, CurvePaintSettings, rna_type)
	ENUM_PROPERTY(curve_type_enum, CurvePaintSettings, curve_type)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_corners_detect)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_pressure_radius)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_stroke_endpoints)
	BOOLEAN_PROPERTY(CurvePaintSettings, use_offset_absolute)
	INT_PROPERTY(CurvePaintSettings, error_threshold)
	ENUM_PROPERTY(fit_method_enum, CurvePaintSettings, fit_method)
	FLOAT_PROPERTY(CurvePaintSettings, corner_angle)
	FLOAT_PROPERTY(CurvePaintSettings, radius_min)
	FLOAT_PROPERTY(CurvePaintSettings, radius_max)
	FLOAT_PROPERTY(CurvePaintSettings, radius_taper_start)
	FLOAT_PROPERTY(CurvePaintSettings, radius_taper_end)
	FLOAT_PROPERTY(CurvePaintSettings, surface_offset)
	ENUM_PROPERTY(depth_mode_enum, CurvePaintSettings, depth_mode)
	ENUM_PROPERTY(surface_plane_enum, CurvePaintSettings, surface_plane)


	POINTER_PROPERTY(Struct, SequencerToolSettings, rna_type)
	ENUM_PROPERTY(fit_method_enum, SequencerToolSettings, fit_method)
	BOOLEAN_PROPERTY(SequencerToolSettings, snap_to_current_frame)
	BOOLEAN_PROPERTY(SequencerToolSettings, snap_to_hold_offset)
	BOOLEAN_PROPERTY(SequencerToolSettings, snap_ignore_muted)
	BOOLEAN_PROPERTY(SequencerToolSettings, snap_ignore_sound)
	BOOLEAN_PROPERTY(SequencerToolSettings, use_snap_current_frame_to_strips)
	INT_PROPERTY(SequencerToolSettings, snap_distance)
	ENUM_PROPERTY(overlap_mode_enum, SequencerToolSettings, overlap_mode)
	ENUM_PROPERTY(pivot_point_enum, SequencerToolSettings, pivot_point)


	POINTER_PROPERTY(Struct, MeshStatVis, rna_type)
	ENUM_PROPERTY(type_enum, MeshStatVis, type)
	FLOAT_PROPERTY(MeshStatVis, overhang_min)
	FLOAT_PROPERTY(MeshStatVis, overhang_max)
	ENUM_PROPERTY(overhang_axis_enum, MeshStatVis, overhang_axis)
	FLOAT_PROPERTY(MeshStatVis, thickness_min)
	FLOAT_PROPERTY(MeshStatVis, thickness_max)
	INT_PROPERTY(MeshStatVis, thickness_samples)
	FLOAT_PROPERTY(MeshStatVis, distort_min)
	FLOAT_PROPERTY(MeshStatVis, distort_max)
	FLOAT_PROPERTY(MeshStatVis, sharp_min)
	FLOAT_PROPERTY(MeshStatVis, sharp_max)


	POINTER_PROPERTY(Struct, UnitSettings, rna_type)
	ENUM_PROPERTY(system_enum, UnitSettings, system)
	ENUM_PROPERTY(system_rotation_enum, UnitSettings, system_rotation)
	FLOAT_PROPERTY(UnitSettings, scale_length)
	BOOLEAN_PROPERTY(UnitSettings, use_separate)
	ENUM_PROPERTY(length_unit_enum, UnitSettings, length_unit)
	ENUM_PROPERTY(mass_unit_enum, UnitSettings, mass_unit)
	ENUM_PROPERTY(time_unit_enum, UnitSettings, time_unit)
	ENUM_PROPERTY(temperature_unit_enum, UnitSettings, temperature_unit)


	POINTER_PROPERTY(Struct, Stereo3dFormat, rna_type)
	ENUM_PROPERTY(display_mode_enum, Stereo3dFormat, display_mode)
	ENUM_PROPERTY(anaglyph_type_enum, Stereo3dFormat, anaglyph_type)
	ENUM_PROPERTY(interlace_type_enum, Stereo3dFormat, interlace_type)
	BOOLEAN_PROPERTY(Stereo3dFormat, use_interlace_swap)
	BOOLEAN_PROPERTY(Stereo3dFormat, use_sidebyside_crosseyed)
	BOOLEAN_PROPERTY(Stereo3dFormat, use_squeezed_frame)


	POINTER_PROPERTY(Struct, ImageFormatSettings, rna_type)
	ENUM_PROPERTY(file_format_enum, ImageFormatSettings, file_format)
	ENUM_PROPERTY(color_mode_enum, ImageFormatSettings, color_mode)
	ENUM_PROPERTY(color_depth_enum, ImageFormatSettings, color_depth)
	INT_PROPERTY(ImageFormatSettings, quality)
	INT_PROPERTY(ImageFormatSettings, compression)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_preview)
	ENUM_PROPERTY(exr_codec_enum, ImageFormatSettings, exr_codec)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_jpeg2k_ycc)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_jpeg2k_cinema_preset)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_jpeg2k_cinema_48)
	ENUM_PROPERTY(jpeg2k_codec_enum, ImageFormatSettings, jpeg2k_codec)
	ENUM_PROPERTY(tiff_codec_enum, ImageFormatSettings, tiff_codec)
	BOOLEAN_PROPERTY(ImageFormatSettings, use_cineon_log)
	INT_PROPERTY(ImageFormatSettings, cineon_black)
	INT_PROPERTY(ImageFormatSettings, cineon_white)
	FLOAT_PROPERTY(ImageFormatSettings, cineon_gamma)
	ENUM_PROPERTY(views_format_enum, ImageFormatSettings, views_format)
	POINTER_PROPERTY(Stereo3dFormat, ImageFormatSettings, stereo_3d_format)
	ENUM_PROPERTY(color_management_enum, ImageFormatSettings, color_management)
	POINTER_PROPERTY(ColorManagedViewSettings, ImageFormatSettings, view_settings)
	POINTER_PROPERTY(ColorManagedDisplaySettings, ImageFormatSettings, display_settings)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, ImageFormatSettings, linear_colorspace_settings)
	BOOLEAN_PROPERTY(ImageFormatSettings, has_linear_colorspace)


	POINTER_PROPERTY(Struct, TransformOrientation, rna_type)
	FLOAT_ARRAY_PROPERTY(TransformOrientation, 9, matrix)
	STRING_PROPERTY(TransformOrientation, name)


	POINTER_PROPERTY(Struct, TransformOrientationSlot, rna_type)
	ENUM_PROPERTY(type_enum, TransformOrientationSlot, type)
	POINTER_PROPERTY(TransformOrientation, TransformOrientationSlot, custom_orientation)
	BOOLEAN_PROPERTY(TransformOrientationSlot, use)


	POINTER_PROPERTY(Struct, View3DCursor, rna_type)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 3, location)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 4, rotation_quaternion)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 4, rotation_axis_angle)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 3, rotation_euler)
	ENUM_PROPERTY(rotation_mode_enum, View3DCursor, rotation_mode)
	FLOAT_ARRAY_PROPERTY(View3DCursor, 16, matrix)




	POINTER_PROPERTY(Struct, DisplaySafeAreas, rna_type)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, title)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, action)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, title_center)
	FLOAT_ARRAY_PROPERTY(DisplaySafeAreas, 2, action_center)


	POINTER_PROPERTY(Struct, SceneDisplay, rna_type)
	FLOAT_ARRAY_PROPERTY(SceneDisplay, 3, light_direction)
	FLOAT_PROPERTY(SceneDisplay, shadow_shift)
	FLOAT_PROPERTY(SceneDisplay, shadow_focus)
	FLOAT_PROPERTY(SceneDisplay, matcap_ssao_distance)
	FLOAT_PROPERTY(SceneDisplay, matcap_ssao_attenuation)
	INT_PROPERTY(SceneDisplay, matcap_ssao_samples)
	ENUM_PROPERTY(render_aa_enum, SceneDisplay, render_aa)
	ENUM_PROPERTY(viewport_aa_enum, SceneDisplay, viewport_aa)
	POINTER_PROPERTY(View3DShading, SceneDisplay, shading)


	POINTER_PROPERTY(Struct, RaytraceEEVEE, rna_type)
	ENUM_PROPERTY(resolution_scale_enum, RaytraceEEVEE, resolution_scale)
	BOOLEAN_PROPERTY(RaytraceEEVEE, use_denoise)
	BOOLEAN_PROPERTY(RaytraceEEVEE, denoise_spatial)
	BOOLEAN_PROPERTY(RaytraceEEVEE, denoise_temporal)
	BOOLEAN_PROPERTY(RaytraceEEVEE, denoise_bilateral)
	FLOAT_PROPERTY(RaytraceEEVEE, sample_clamp)
	FLOAT_PROPERTY(RaytraceEEVEE, screen_trace_thickness)
	FLOAT_PROPERTY(RaytraceEEVEE, screen_trace_quality)


	POINTER_PROPERTY(Struct, SceneEEVEE, rna_type)
	INT_PROPERTY(SceneEEVEE, gi_diffuse_bounces)
	ENUM_PROPERTY(gi_cubemap_resolution_enum, SceneEEVEE, gi_cubemap_resolution)
	ENUM_PROPERTY(gi_visibility_resolution_enum, SceneEEVEE, gi_visibility_resolution)
	FLOAT_PROPERTY(SceneEEVEE, gi_irradiance_smoothing)
	FLOAT_PROPERTY(SceneEEVEE, gi_glossy_clamp)
	FLOAT_PROPERTY(SceneEEVEE, gi_filter_quality)
	BOOLEAN_PROPERTY(SceneEEVEE, gi_show_irradiance)
	BOOLEAN_PROPERTY(SceneEEVEE, gi_show_cubemaps)
	FLOAT_PROPERTY(SceneEEVEE, gi_irradiance_display_size)
	FLOAT_PROPERTY(SceneEEVEE, gi_cubemap_display_size)
	BOOLEAN_PROPERTY(SceneEEVEE, gi_auto_bake)
	STRING_PROPERTY(SceneEEVEE, gi_cache_info)
	ENUM_PROPERTY(gi_irradiance_pool_size_enum, SceneEEVEE, gi_irradiance_pool_size)
	INT_PROPERTY(SceneEEVEE, taa_samples)
	INT_PROPERTY(SceneEEVEE, taa_render_samples)
	BOOLEAN_PROPERTY(SceneEEVEE, use_taa_reprojection)
	INT_PROPERTY(SceneEEVEE, sss_samples)
	FLOAT_PROPERTY(SceneEEVEE, sss_jitter_threshold)
	BOOLEAN_PROPERTY(SceneEEVEE, use_ssr)
	BOOLEAN_PROPERTY(SceneEEVEE, use_ssr_refraction)
	BOOLEAN_PROPERTY(SceneEEVEE, use_ssr_halfres)
	FLOAT_PROPERTY(SceneEEVEE, ssr_quality)
	FLOAT_PROPERTY(SceneEEVEE, ssr_max_roughness)
	FLOAT_PROPERTY(SceneEEVEE, ssr_thickness)
	FLOAT_PROPERTY(SceneEEVEE, ssr_border_fade)
	FLOAT_PROPERTY(SceneEEVEE, ssr_firefly_fac)
	ENUM_PROPERTY(ray_split_settings_enum, SceneEEVEE, ray_split_settings)
	ENUM_PROPERTY(ray_tracing_method_enum, SceneEEVEE, ray_tracing_method)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_start)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_end)
	ENUM_PROPERTY(volumetric_tile_size_enum, SceneEEVEE, volumetric_tile_size)
	INT_PROPERTY(SceneEEVEE, volumetric_samples)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_sample_distribution)
	INT_PROPERTY(SceneEEVEE, volumetric_ray_depth)
	BOOLEAN_PROPERTY(SceneEEVEE, use_volumetric_lights)
	FLOAT_PROPERTY(SceneEEVEE, volumetric_light_clamp)
	BOOLEAN_PROPERTY(SceneEEVEE, use_volumetric_shadows)
	INT_PROPERTY(SceneEEVEE, volumetric_shadow_samples)
	BOOLEAN_PROPERTY(SceneEEVEE, use_gtao)
	BOOLEAN_PROPERTY(SceneEEVEE, use_gtao_bent_normals)
	BOOLEAN_PROPERTY(SceneEEVEE, use_gtao_bounce)
	FLOAT_PROPERTY(SceneEEVEE, gtao_factor)
	FLOAT_PROPERTY(SceneEEVEE, gtao_quality)
	FLOAT_PROPERTY(SceneEEVEE, gtao_distance)
	FLOAT_PROPERTY(SceneEEVEE, horizon_thickness)
	FLOAT_PROPERTY(SceneEEVEE, horizon_quality)
	FLOAT_PROPERTY(SceneEEVEE, horizon_bias)
	FLOAT_PROPERTY(SceneEEVEE, bokeh_max_size)
	FLOAT_PROPERTY(SceneEEVEE, bokeh_threshold)
	FLOAT_PROPERTY(SceneEEVEE, bokeh_neighbor_max)
	FLOAT_PROPERTY(SceneEEVEE, bokeh_denoise_fac)
	BOOLEAN_PROPERTY(SceneEEVEE, use_bokeh_high_quality_slight_defocus)
	BOOLEAN_PROPERTY(SceneEEVEE, use_bokeh_jittered)
	FLOAT_PROPERTY(SceneEEVEE, bokeh_overblur)
	BOOLEAN_PROPERTY(SceneEEVEE, use_bloom)
	FLOAT_PROPERTY(SceneEEVEE, bloom_threshold)
	FLOAT_ARRAY_PROPERTY(SceneEEVEE, 3, bloom_color)
	FLOAT_PROPERTY(SceneEEVEE, bloom_knee)
	FLOAT_PROPERTY(SceneEEVEE, bloom_radius)
	FLOAT_PROPERTY(SceneEEVEE, bloom_clamp)
	FLOAT_PROPERTY(SceneEEVEE, bloom_intensity)
	BOOLEAN_PROPERTY(SceneEEVEE, use_motion_blur)
	FLOAT_PROPERTY(SceneEEVEE, motion_blur_shutter)
	FLOAT_PROPERTY(SceneEEVEE, motion_blur_depth_scale)
	INT_PROPERTY(SceneEEVEE, motion_blur_max)
	INT_PROPERTY(SceneEEVEE, motion_blur_steps)
	ENUM_PROPERTY(motion_blur_position_enum, SceneEEVEE, motion_blur_position)
	BOOLEAN_PROPERTY(SceneEEVEE, use_shadows)
	ENUM_PROPERTY(shadow_cube_size_enum, SceneEEVEE, shadow_cube_size)
	ENUM_PROPERTY(shadow_cascade_size_enum, SceneEEVEE, shadow_cascade_size)
	ENUM_PROPERTY(shadow_pool_size_enum, SceneEEVEE, shadow_pool_size)
	INT_PROPERTY(SceneEEVEE, shadow_ray_count)
	INT_PROPERTY(SceneEEVEE, shadow_step_count)
	FLOAT_PROPERTY(SceneEEVEE, shadow_normal_bias)
	BOOLEAN_PROPERTY(SceneEEVEE, use_shadow_high_bitdepth)
	BOOLEAN_PROPERTY(SceneEEVEE, use_soft_shadows)
	FLOAT_PROPERTY(SceneEEVEE, light_threshold)
	BOOLEAN_PROPERTY(SceneEEVEE, use_overscan)
	FLOAT_PROPERTY(SceneEEVEE, overscan_size)
	POINTER_PROPERTY(RaytraceEEVEE, SceneEEVEE, reflection_options)
	POINTER_PROPERTY(RaytraceEEVEE, SceneEEVEE, refraction_options)
	POINTER_PROPERTY(RaytraceEEVEE, SceneEEVEE, diffuse_options)


	POINTER_PROPERTY(Struct, SceneHydra, rna_type)
	ENUM_PROPERTY(export_method_enum, SceneHydra, export_method)


	POINTER_PROPERTY(Struct, AOV, rna_type)
	STRING_PROPERTY(AOV, name)
	BOOLEAN_PROPERTY(AOV, is_valid)
	ENUM_PROPERTY(type_enum, AOV, type)


	POINTER_PROPERTY(Struct, Lightgroup, rna_type)
	STRING_PROPERTY(Lightgroup, name)


	POINTER_PROPERTY(Struct, ViewLayerEEVEE, rna_type)
	BOOLEAN_PROPERTY(ViewLayerEEVEE, use_pass_volume_direct)
	BOOLEAN_PROPERTY(ViewLayerEEVEE, use_pass_bloom)
	BOOLEAN_PROPERTY(ViewLayerEEVEE, use_pass_transparent)


	POINTER_PROPERTY(Struct, SceneGpencil, rna_type)
	FLOAT_PROPERTY(SceneGpencil, antialias_threshold)


	POINTER_PROPERTY(Struct, FFmpegSettings, rna_type)
	ENUM_PROPERTY(format_enum, FFmpegSettings, format)
	ENUM_PROPERTY(codec_enum, FFmpegSettings, codec)
	INT_PROPERTY(FFmpegSettings, video_bitrate)
	INT_PROPERTY(FFmpegSettings, minrate)
	INT_PROPERTY(FFmpegSettings, maxrate)
	INT_PROPERTY(FFmpegSettings, muxrate)
	INT_PROPERTY(FFmpegSettings, gopsize)
	INT_PROPERTY(FFmpegSettings, max_b_frames)
	BOOLEAN_PROPERTY(FFmpegSettings, use_max_b_frames)
	INT_PROPERTY(FFmpegSettings, buffersize)
	INT_PROPERTY(FFmpegSettings, packetsize)
	ENUM_PROPERTY(constant_rate_factor_enum, FFmpegSettings, constant_rate_factor)
	ENUM_PROPERTY(ffmpeg_preset_enum, FFmpegSettings, ffmpeg_preset)
	BOOLEAN_PROPERTY(FFmpegSettings, use_autosplit)
	BOOLEAN_PROPERTY(FFmpegSettings, use_lossless_output)
	ENUM_PROPERTY(audio_codec_enum, FFmpegSettings, audio_codec)
	INT_PROPERTY(FFmpegSettings, audio_bitrate)
	FLOAT_PROPERTY(FFmpegSettings, audio_volume)
	INT_PROPERTY(FFmpegSettings, audio_mixrate)
	ENUM_PROPERTY(audio_channels_enum, FFmpegSettings, audio_channels)


	POINTER_PROPERTY(Struct, RenderSettings, rna_type)
	POINTER_PROPERTY(ImageFormatSettings, RenderSettings, image_settings)
	INT_PROPERTY(RenderSettings, resolution_x)
	INT_PROPERTY(RenderSettings, resolution_y)
	INT_PROPERTY(RenderSettings, resolution_percentage)
	ENUM_PROPERTY(preview_pixel_size_enum, RenderSettings, preview_pixel_size)
	FLOAT_PROPERTY(RenderSettings, pixel_aspect_x)
	FLOAT_PROPERTY(RenderSettings, pixel_aspect_y)
	POINTER_PROPERTY(FFmpegSettings, RenderSettings, ffmpeg)
	INT_PROPERTY(RenderSettings, fps)
	FLOAT_PROPERTY(RenderSettings, fps_base)
	INT_PROPERTY(RenderSettings, frame_map_old)
	INT_PROPERTY(RenderSettings, frame_map_new)
	FLOAT_PROPERTY(RenderSettings, dither_intensity)
	FLOAT_PROPERTY(RenderSettings, filter_size)
	BOOLEAN_PROPERTY(RenderSettings, film_transparent)
	BOOLEAN_PROPERTY(RenderSettings, use_freestyle)
	INT_PROPERTY(RenderSettings, threads)
	ENUM_PROPERTY(threads_mode_enum, RenderSettings, threads_mode)
	BOOLEAN_PROPERTY(RenderSettings, use_motion_blur)
	FLOAT_PROPERTY(RenderSettings, motion_blur_shutter)
	POINTER_PROPERTY(CurveMapping, RenderSettings, motion_blur_shutter_curve)
	ENUM_PROPERTY(hair_type_enum, RenderSettings, hair_type)
	INT_PROPERTY(RenderSettings, hair_subdiv)
	BOOLEAN_PROPERTY(RenderSettings, use_high_quality_normals)
	BOOLEAN_PROPERTY(RenderSettings, use_border)
	FLOAT_PROPERTY(RenderSettings, border_min_x)
	FLOAT_PROPERTY(RenderSettings, border_min_y)
	FLOAT_PROPERTY(RenderSettings, border_max_x)
	FLOAT_PROPERTY(RenderSettings, border_max_y)
	BOOLEAN_PROPERTY(RenderSettings, use_crop_to_border)
	BOOLEAN_PROPERTY(RenderSettings, use_placeholder)
	BOOLEAN_PROPERTY(RenderSettings, use_overwrite)
	BOOLEAN_PROPERTY(RenderSettings, use_compositing)
	BOOLEAN_PROPERTY(RenderSettings, use_sequencer)
	BOOLEAN_PROPERTY(RenderSettings, use_file_extension)
	STRING_PROPERTY(RenderSettings, file_extension)
	BOOLEAN_PROPERTY(RenderSettings, is_movie_format)
	BOOLEAN_PROPERTY(RenderSettings, use_lock_interface)
	STRING_PROPERTY(RenderSettings, filepath)
	BOOLEAN_PROPERTY(RenderSettings, use_render_cache)
	ENUM_PROPERTY(bake_type_enum, RenderSettings, bake_type)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_selected_to_active)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_clear)
	INT_PROPERTY(RenderSettings, bake_margin)
	ENUM_PROPERTY(bake_margin_type_enum, RenderSettings, bake_margin_type)
	FLOAT_PROPERTY(RenderSettings, bake_bias)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_multires)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_lores_mesh)
	INT_PROPERTY(RenderSettings, bake_samples)
	BOOLEAN_PROPERTY(RenderSettings, use_bake_user_scale)
	FLOAT_PROPERTY(RenderSettings, bake_user_scale)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_time)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_date)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_frame)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_frame_range)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_camera)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_lens)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_scene)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_note)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_marker)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_filename)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_sequencer_strip)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_render_time)
	STRING_PROPERTY(RenderSettings, stamp_note_text)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_labels)
	ENUM_PROPERTY(metadata_input_enum, RenderSettings, metadata_input)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_memory)
	BOOLEAN_PROPERTY(RenderSettings, use_stamp_hostname)
	INT_PROPERTY(RenderSettings, stamp_font_size)
	FLOAT_ARRAY_PROPERTY(RenderSettings, 4, stamp_foreground)
	FLOAT_ARRAY_PROPERTY(RenderSettings, 4, stamp_background)
	ENUM_PROPERTY(sequencer_gl_preview_enum, RenderSettings, sequencer_gl_preview)
	BOOLEAN_PROPERTY(RenderSettings, use_sequencer_override_scene_strip)
	BOOLEAN_PROPERTY(RenderSettings, use_single_layer)


	BOOLEAN_PROPERTY(RenderSettings, use_multiview)
	ENUM_PROPERTY(views_format_enum, RenderSettings, views_format)
	ENUM_PROPERTY(engine_enum, RenderSettings, engine)
	BOOLEAN_PROPERTY(RenderSettings, has_multiple_engines)
	BOOLEAN_PROPERTY(RenderSettings, use_spherical_stereo)
	BOOLEAN_PROPERTY(RenderSettings, use_simplify)
	INT_PROPERTY(RenderSettings, simplify_subdivision)
	FLOAT_PROPERTY(RenderSettings, simplify_child_particles)
	INT_PROPERTY(RenderSettings, simplify_subdivision_render)
	FLOAT_PROPERTY(RenderSettings, simplify_child_particles_render)
	FLOAT_PROPERTY(RenderSettings, simplify_volumes)
	FLOAT_PROPERTY(RenderSettings, simplify_shadows_render)
	FLOAT_PROPERTY(RenderSettings, simplify_shadows)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_onplay)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_antialiasing)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_view_fill)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_modifier)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_shader_fx)
	BOOLEAN_PROPERTY(RenderSettings, simplify_gpencil_tint)
	BOOLEAN_PROPERTY(RenderSettings, use_persistent_data)
	ENUM_PROPERTY(line_thickness_mode_enum, RenderSettings, line_thickness_mode)
	FLOAT_PROPERTY(RenderSettings, line_thickness)
	POINTER_PROPERTY(BakeSettings, RenderSettings, bake)

	inline void RenderSettings::frame_path(void *main, int frame, bool preview, const char * view, char * filepath) {
		RenderSettings_frame_path_func((::RenderData *) this->ptr.data, (::Main *) main, frame, preview, view, filepath);
	}


	POINTER_PROPERTY(Struct, RenderViews, rna_type)
	INT_PROPERTY(RenderViews, active_index)
	POINTER_PROPERTY(SceneRenderView, RenderViews, active)

	inline SceneRenderView RenderViews::create(const char * name) {
		PointerRNA result;
		::SceneRenderView *retdata = RenderViews_new_func((::ID *) ptr.owner_id, (::RenderData *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_SceneRenderView, retdata);
		return SceneRenderView(result);
	}

	inline void RenderViews::remove(void *main, SceneRenderView& view) {
		RenderViews_remove_func((::ID *) ptr.owner_id, (::RenderData *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &view.ptr);
	}


	POINTER_PROPERTY(Struct, BakeSettings, rna_type)
	POINTER_PROPERTY(Object, BakeSettings, cage_object)
	STRING_PROPERTY(BakeSettings, filepath)
	INT_PROPERTY(BakeSettings, width)
	INT_PROPERTY(BakeSettings, height)
	INT_PROPERTY(BakeSettings, margin)
	ENUM_PROPERTY(margin_type_enum, BakeSettings, margin_type)
	FLOAT_PROPERTY(BakeSettings, max_ray_distance)
	FLOAT_PROPERTY(BakeSettings, cage_extrusion)
	ENUM_PROPERTY(normal_space_enum, BakeSettings, normal_space)
	ENUM_PROPERTY(normal_r_enum, BakeSettings, normal_r)
	ENUM_PROPERTY(normal_g_enum, BakeSettings, normal_g)
	ENUM_PROPERTY(normal_b_enum, BakeSettings, normal_b)
	POINTER_PROPERTY(ImageFormatSettings, BakeSettings, image_settings)
	ENUM_PROPERTY(target_enum, BakeSettings, target)
	ENUM_PROPERTY(save_mode_enum, BakeSettings, save_mode)
	ENUM_PROPERTY(view_from_enum, BakeSettings, view_from)
	BOOLEAN_PROPERTY(BakeSettings, use_selected_to_active)
	BOOLEAN_PROPERTY(BakeSettings, use_clear)
	BOOLEAN_PROPERTY(BakeSettings, use_split_materials)
	BOOLEAN_PROPERTY(BakeSettings, use_automatic_name)
	BOOLEAN_PROPERTY(BakeSettings, use_cage)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_emit)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_direct)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_indirect)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_color)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_diffuse)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_glossy)
	BOOLEAN_PROPERTY(BakeSettings, use_pass_transmission)
	ENUM_PROPERTY(pass_filter_enum, BakeSettings, pass_filter)


	POINTER_PROPERTY(Struct, SceneRenderView, rna_type)
	STRING_PROPERTY(SceneRenderView, name)
	STRING_PROPERTY(SceneRenderView, file_suffix)
	STRING_PROPERTY(SceneRenderView, camera_suffix)
	BOOLEAN_PROPERTY(SceneRenderView, use)



	BOOLEAN_PROPERTY(Screen, is_animation_playing)
	BOOLEAN_PROPERTY(Screen, is_scrubbing)
	BOOLEAN_PROPERTY(Screen, is_temporary)
	BOOLEAN_PROPERTY(Screen, show_fullscreen)
	BOOLEAN_PROPERTY(Screen, show_statusbar)
	BOOLEAN_PROPERTY(Screen, use_play_top_left_3d_editor)
	BOOLEAN_PROPERTY(Screen, use_play_3d_editors)
	BOOLEAN_PROPERTY(Screen, use_follow)
	BOOLEAN_PROPERTY(Screen, use_play_animation_editors)
	BOOLEAN_PROPERTY(Screen, use_play_properties_editors)
	BOOLEAN_PROPERTY(Screen, use_play_image_editors)
	BOOLEAN_PROPERTY(Screen, use_play_sequence_editors)
	BOOLEAN_PROPERTY(Screen, use_play_node_editors)
	BOOLEAN_PROPERTY(Screen, use_play_clip_editors)
	BOOLEAN_PROPERTY(Screen, use_play_spreadsheet_editors)

	inline const char * Screen::statusbar_info(void *main, Context C) {
		return Screen_statusbar_info_func((::bScreen *) this->ptr.data, (::Main *) main, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, Area, rna_type)


	BOOLEAN_PROPERTY(Area, show_menus)
	ENUM_PROPERTY(type_enum, Area, type)
	ENUM_PROPERTY(ui_type_enum, Area, ui_type)
	INT_PROPERTY(Area, x)
	INT_PROPERTY(Area, y)
	INT_PROPERTY(Area, width)
	INT_PROPERTY(Area, height)

	inline void Area::tag_redraw() {
		Area_tag_redraw_func((::ScrArea *) this->ptr.data);
	}

	inline void Area::header_text_set(const char * text) {
		Area_header_text_set_func((::ScrArea *) this->ptr.data, text);
	}


	POINTER_PROPERTY(Struct, AreaSpaces, rna_type)
	POINTER_PROPERTY(Space, AreaSpaces, active)


	POINTER_PROPERTY(Struct, Region, rna_type)
	ENUM_PROPERTY(type_enum, Region, type)
	INT_PROPERTY(Region, x)
	INT_PROPERTY(Region, y)
	INT_PROPERTY(Region, width)
	INT_PROPERTY(Region, height)
	POINTER_PROPERTY(View2D, Region, view2d)
	ENUM_PROPERTY(alignment_enum, Region, alignment)
	POINTER_PROPERTY(AnyType, Region, data)
	ENUM_PROPERTY(active_panel_category_enum, Region, active_panel_category)

	inline void Region::tag_redraw() {
		Region_tag_redraw_func((::ARegion *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, View2D, rna_type)

	inline void View2D::region_to_view(float x, float y, float result[2]) {
		View2D_region_to_view_func((::View2D *) this->ptr.data, x, y, result);
	}

	inline void View2D::view_to_region(float x, float y, bool clip, int result[2]) {
		View2D_view_to_region_func((::View2D *) this->ptr.data, x, y, clip, result);
	}




	POINTER_PROPERTY(Struct, PaintToolSlot, rna_type)
	POINTER_PROPERTY(Brush, PaintToolSlot, brush)


	POINTER_PROPERTY(Struct, Paint, rna_type)
	POINTER_PROPERTY(Brush, Paint, brush)

	POINTER_PROPERTY(Palette, Paint, palette)
	BOOLEAN_PROPERTY(Paint, show_brush)
	BOOLEAN_PROPERTY(Paint, show_brush_on_surface)
	BOOLEAN_PROPERTY(Paint, show_low_resolution)
	BOOLEAN_PROPERTY(Paint, use_sculpt_delay_updates)
	INT_PROPERTY(Paint, input_samples)
	BOOLEAN_PROPERTY(Paint, use_symmetry_x)
	BOOLEAN_PROPERTY(Paint, use_symmetry_y)
	BOOLEAN_PROPERTY(Paint, use_symmetry_z)
	BOOLEAN_PROPERTY(Paint, use_symmetry_feather)
	POINTER_PROPERTY(CurveMapping, Paint, cavity_curve)
	BOOLEAN_PROPERTY(Paint, use_cavity)
	FLOAT_ARRAY_PROPERTY(Paint, 3, tile_offset)
	BOOLEAN_PROPERTY(Paint, tile_x)
	BOOLEAN_PROPERTY(Paint, tile_y)
	BOOLEAN_PROPERTY(Paint, tile_z)


	INT_ARRAY_PROPERTY(Sculpt, 3, radial_symmetry)
	BOOLEAN_PROPERTY(Sculpt, lock_x)
	BOOLEAN_PROPERTY(Sculpt, lock_y)
	BOOLEAN_PROPERTY(Sculpt, lock_z)
	BOOLEAN_PROPERTY(Sculpt, use_deform_only)
	FLOAT_PROPERTY(Sculpt, detail_size)
	FLOAT_PROPERTY(Sculpt, detail_percent)
	FLOAT_PROPERTY(Sculpt, constant_detail_resolution)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_topology)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_face_sets)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_boundary_edges)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_boundary_face_sets)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_cavity)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_cavity_inverted)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_custom_cavity_curve)
	FLOAT_PROPERTY(Sculpt, automasking_cavity_factor)
	INT_PROPERTY(Sculpt, automasking_cavity_blur_steps)
	POINTER_PROPERTY(CurveMapping, Sculpt, automasking_cavity_curve)
	POINTER_PROPERTY(CurveMapping, Sculpt, automasking_cavity_curve_op)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_start_normal)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_view_normal)
	BOOLEAN_PROPERTY(Sculpt, use_automasking_view_occlusion)
	FLOAT_PROPERTY(Sculpt, automasking_start_normal_limit)
	FLOAT_PROPERTY(Sculpt, automasking_start_normal_falloff)
	FLOAT_PROPERTY(Sculpt, automasking_view_normal_limit)
	FLOAT_PROPERTY(Sculpt, automasking_view_normal_falloff)
	ENUM_PROPERTY(symmetrize_direction_enum, Sculpt, symmetrize_direction)
	ENUM_PROPERTY(detail_refine_method_enum, Sculpt, detail_refine_method)
	ENUM_PROPERTY(detail_type_method_enum, Sculpt, detail_type_method)
	FLOAT_PROPERTY(Sculpt, gravity)
	ENUM_PROPERTY(transform_mode_enum, Sculpt, transform_mode)
	POINTER_PROPERTY(Object, Sculpt, gravity_object)




	ENUM_PROPERTY(color_mode_enum, GpPaint, color_mode)








	BOOLEAN_PROPERTY(VertexPaint, use_group_restrict)
	INT_ARRAY_PROPERTY(VertexPaint, 3, radial_symmetry)


	POINTER_PROPERTY(Struct, PaintModeSettings, rna_type)
	ENUM_PROPERTY(canvas_source_enum, PaintModeSettings, canvas_source)
	POINTER_PROPERTY(Image, PaintModeSettings, canvas_image)


	BOOLEAN_PROPERTY(ImagePaint, use_occlude)
	BOOLEAN_PROPERTY(ImagePaint, use_backface_culling)
	BOOLEAN_PROPERTY(ImagePaint, use_normal_falloff)
	BOOLEAN_PROPERTY(ImagePaint, use_stencil_layer)
	BOOLEAN_PROPERTY(ImagePaint, invert_stencil)
	POINTER_PROPERTY(Image, ImagePaint, stencil_image)
	POINTER_PROPERTY(Image, ImagePaint, canvas)
	POINTER_PROPERTY(Image, ImagePaint, clone_image)
	FLOAT_ARRAY_PROPERTY(ImagePaint, 3, stencil_color)
	FLOAT_PROPERTY(ImagePaint, dither)
	BOOLEAN_PROPERTY(ImagePaint, use_clone_layer)
	INT_PROPERTY(ImagePaint, seam_bleed)
	INT_PROPERTY(ImagePaint, normal_angle)
	INT_ARRAY_PROPERTY(ImagePaint, 2, screen_grab_size)
	ENUM_PROPERTY(mode_enum, ImagePaint, mode)
	ENUM_PROPERTY(interpolation_enum, ImagePaint, interpolation)
	BOOLEAN_PROPERTY(ImagePaint, missing_uvs)
	BOOLEAN_PROPERTY(ImagePaint, missing_materials)
	BOOLEAN_PROPERTY(ImagePaint, missing_stencil)
	BOOLEAN_PROPERTY(ImagePaint, missing_texture)

	inline bool ImagePaint::detect_data() {
		return ImagePaint_detect_data_func((::ImagePaintSettings *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, ParticleEdit, rna_type)
	ENUM_PROPERTY(tool_enum, ParticleEdit, tool)
	ENUM_PROPERTY(select_mode_enum, ParticleEdit, select_mode)
	BOOLEAN_PROPERTY(ParticleEdit, use_preserve_length)
	BOOLEAN_PROPERTY(ParticleEdit, use_preserve_root)
	BOOLEAN_PROPERTY(ParticleEdit, use_emitter_deflect)
	FLOAT_PROPERTY(ParticleEdit, emitter_distance)
	BOOLEAN_PROPERTY(ParticleEdit, use_fade_time)
	BOOLEAN_PROPERTY(ParticleEdit, use_auto_velocity)
	BOOLEAN_PROPERTY(ParticleEdit, show_particles)
	BOOLEAN_PROPERTY(ParticleEdit, use_default_interpolate)
	INT_PROPERTY(ParticleEdit, default_key_count)
	POINTER_PROPERTY(ParticleBrush, ParticleEdit, brush)
	INT_PROPERTY(ParticleEdit, display_step)
	INT_PROPERTY(ParticleEdit, fade_frames)
	ENUM_PROPERTY(type_enum, ParticleEdit, type)
	BOOLEAN_PROPERTY(ParticleEdit, is_editable)
	BOOLEAN_PROPERTY(ParticleEdit, is_hair)
	POINTER_PROPERTY(Object, ParticleEdit, object)
	POINTER_PROPERTY(Object, ParticleEdit, shape_object)


	POINTER_PROPERTY(Struct, ParticleBrush, rna_type)
	INT_PROPERTY(ParticleBrush, size)
	FLOAT_PROPERTY(ParticleBrush, strength)
	INT_PROPERTY(ParticleBrush, count)
	INT_PROPERTY(ParticleBrush, steps)
	ENUM_PROPERTY(puff_mode_enum, ParticleBrush, puff_mode)
	BOOLEAN_PROPERTY(ParticleBrush, use_puff_volume)
	ENUM_PROPERTY(length_mode_enum, ParticleBrush, length_mode)
	POINTER_PROPERTY(CurveMapping, ParticleBrush, curve)


	POINTER_PROPERTY(Struct, GPencilSculptGuide, rna_type)
	BOOLEAN_PROPERTY(GPencilSculptGuide, use_guide)
	BOOLEAN_PROPERTY(GPencilSculptGuide, use_snapping)
	POINTER_PROPERTY(Object, GPencilSculptGuide, reference_object)
	ENUM_PROPERTY(reference_point_enum, GPencilSculptGuide, reference_point)
	ENUM_PROPERTY(type_enum, GPencilSculptGuide, type)
	FLOAT_PROPERTY(GPencilSculptGuide, angle)
	FLOAT_PROPERTY(GPencilSculptGuide, angle_snap)
	FLOAT_PROPERTY(GPencilSculptGuide, spacing)
	FLOAT_ARRAY_PROPERTY(GPencilSculptGuide, 3, location)


	POINTER_PROPERTY(Struct, GPencilSculptSettings, rna_type)
	POINTER_PROPERTY(GPencilSculptGuide, GPencilSculptSettings, guide)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_multiframe_falloff)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_thickness_curve)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_scale_thickness)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_automasking_stroke)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_automasking_layer_stroke)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_automasking_material_stroke)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_automasking_layer_active)
	BOOLEAN_PROPERTY(GPencilSculptSettings, use_automasking_material_active)
	POINTER_PROPERTY(CurveMapping, GPencilSculptSettings, multiframe_falloff_curve)
	POINTER_PROPERTY(CurveMapping, GPencilSculptSettings, thickness_primitive_curve)
	ENUM_PROPERTY(lock_axis_enum, GPencilSculptSettings, lock_axis)
	FLOAT_PROPERTY(GPencilSculptSettings, intersection_threshold)




	POINTER_PROPERTY(Struct, SequenceColorBalanceData, rna_type)
	ENUM_PROPERTY(correction_method_enum, SequenceColorBalanceData, correction_method)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, lift)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, gamma)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, gain)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, slope)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, offset)
	FLOAT_ARRAY_PROPERTY(SequenceColorBalanceData, 3, power)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_lift)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_gamma)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_gain)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_slope)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_offset)
	BOOLEAN_PROPERTY(SequenceColorBalanceData, invert_power)


	POINTER_PROPERTY(Struct, SequenceElement, rna_type)
	STRING_PROPERTY(SequenceElement, filename)
	INT_PROPERTY(SequenceElement, orig_width)
	INT_PROPERTY(SequenceElement, orig_height)
	FLOAT_PROPERTY(SequenceElement, orig_fps)


	POINTER_PROPERTY(Struct, RetimingKey, rna_type)
	INT_PROPERTY(RetimingKey, timeline_frame)

	inline void RetimingKey::remove() {
		RetimingKey_remove_func((::ID *) ptr.owner_id, (::SeqRetimingKey *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, SequenceProxy, rna_type)
	STRING_PROPERTY(SequenceProxy, directory)
	STRING_PROPERTY(SequenceProxy, filepath)
	BOOLEAN_PROPERTY(SequenceProxy, use_overwrite)
	BOOLEAN_PROPERTY(SequenceProxy, build_25)
	BOOLEAN_PROPERTY(SequenceProxy, build_50)
	BOOLEAN_PROPERTY(SequenceProxy, build_75)
	BOOLEAN_PROPERTY(SequenceProxy, build_100)
	BOOLEAN_PROPERTY(SequenceProxy, build_record_run)
	BOOLEAN_PROPERTY(SequenceProxy, build_free_run)
	BOOLEAN_PROPERTY(SequenceProxy, build_free_run_rec_date)
	INT_PROPERTY(SequenceProxy, quality)
	ENUM_PROPERTY(timecode_enum, SequenceProxy, timecode)
	BOOLEAN_PROPERTY(SequenceProxy, use_proxy_custom_directory)
	BOOLEAN_PROPERTY(SequenceProxy, use_proxy_custom_file)




	POINTER_PROPERTY(Struct, SequenceCrop, rna_type)
	INT_PROPERTY(SequenceCrop, max_y)
	INT_PROPERTY(SequenceCrop, min_y)
	INT_PROPERTY(SequenceCrop, min_x)
	INT_PROPERTY(SequenceCrop, max_x)


	POINTER_PROPERTY(Struct, SequenceTransform, rna_type)
	FLOAT_PROPERTY(SequenceTransform, scale_x)
	FLOAT_PROPERTY(SequenceTransform, scale_y)
	FLOAT_PROPERTY(SequenceTransform, offset_x)
	FLOAT_PROPERTY(SequenceTransform, offset_y)
	FLOAT_PROPERTY(SequenceTransform, rotation)
	FLOAT_ARRAY_PROPERTY(SequenceTransform, 2, origin)
	ENUM_PROPERTY(filter_enum, SequenceTransform, filter)


	POINTER_PROPERTY(Struct, Sequence, rna_type)
	STRING_PROPERTY(Sequence, name)
	ENUM_PROPERTY(type_enum, Sequence, type)
	BOOLEAN_PROPERTY(Sequence, select)
	BOOLEAN_PROPERTY(Sequence, select_left_handle)
	BOOLEAN_PROPERTY(Sequence, select_right_handle)
	BOOLEAN_PROPERTY(Sequence, mute)
	BOOLEAN_PROPERTY(Sequence, lock)
	INT_PROPERTY(Sequence, frame_final_duration)
	INT_PROPERTY(Sequence, frame_duration)
	FLOAT_PROPERTY(Sequence, frame_start)
	INT_PROPERTY(Sequence, frame_final_start)
	INT_PROPERTY(Sequence, frame_final_end)
	FLOAT_PROPERTY(Sequence, frame_offset_start)
	FLOAT_PROPERTY(Sequence, frame_offset_end)
	INT_PROPERTY(Sequence, channel)
	BOOLEAN_PROPERTY(Sequence, use_linear_modifiers)
	ENUM_PROPERTY(blend_type_enum, Sequence, blend_type)
	FLOAT_PROPERTY(Sequence, blend_alpha)
	FLOAT_PROPERTY(Sequence, effect_fader)
	BOOLEAN_PROPERTY(Sequence, use_default_fade)
	ENUM_PROPERTY(color_tag_enum, Sequence, color_tag)

	BOOLEAN_PROPERTY(Sequence, use_cache_raw)
	BOOLEAN_PROPERTY(Sequence, use_cache_preprocessed)
	BOOLEAN_PROPERTY(Sequence, use_cache_composite)
	BOOLEAN_PROPERTY(Sequence, override_cache_settings)
	BOOLEAN_PROPERTY(Sequence, show_retiming_keys)

	inline SequenceElement Sequence::strip_elem_from_frame(int frame) {
		PointerRNA result;
		::StripElem *retdata = Sequence_strip_elem_from_frame_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_SequenceElement, retdata);
		return SequenceElement(result);
	}

	inline void Sequence::swap(Sequence& other) {
		Sequence_swap_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, nullptr, (::Sequence *) other.ptr.data);
	}

	inline void Sequence::move_to_meta(void *main, Sequence& meta_sequence) {
		Sequence_move_to_meta_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, nullptr, (::Sequence *) meta_sequence.ptr.data);
	}

	inline Sequence Sequence::parent_meta() {
		PointerRNA result;
		::Sequence *retdata = Sequence_parent_meta_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline void Sequence::invalidate_cache(int type) {
		Sequence_invalidate_cache_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, type);
	}

	inline Sequence Sequence::split(void *main, int frame, int split_method) {
		PointerRNA result;
		::Sequence *retdata = Sequence_split_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, nullptr, frame, split_method);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}


	POINTER_PROPERTY(Struct, SequenceModifiers, rna_type)

	inline SequenceModifier SequenceModifiers::create(Context C, const char * name, int type) {
		PointerRNA result;
		::SequenceModifierData *retdata = SequenceModifiers_new_func((::Sequence *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, name, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_SequenceModifier, retdata);
		return SequenceModifier(result);
	}

	inline void SequenceModifiers::remove(Context C, SequenceModifier& modifier) {
		SequenceModifiers_remove_func((::Sequence *) this->ptr.data, (::bContext *) C.ptr.data, nullptr, (::PointerRNA *) &modifier.ptr);
	}

	inline void SequenceModifiers::clear(Context C) {
		SequenceModifiers_clear_func((::Sequence *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, SequenceEditor, rna_type)




	POINTER_PROPERTY(Sequence, SequenceEditor, active_strip)
	BOOLEAN_PROPERTY(SequenceEditor, selected_retiming_keys)
	BOOLEAN_PROPERTY(SequenceEditor, show_overlay_frame)
	BOOLEAN_PROPERTY(SequenceEditor, use_overlay_frame_lock)
	INT_PROPERTY(SequenceEditor, overlay_frame)
	ENUM_PROPERTY(proxy_storage_enum, SequenceEditor, proxy_storage)
	STRING_PROPERTY(SequenceEditor, proxy_dir)
	BOOLEAN_PROPERTY(SequenceEditor, show_cache)
	BOOLEAN_PROPERTY(SequenceEditor, show_cache_final_out)
	BOOLEAN_PROPERTY(SequenceEditor, show_cache_raw)
	BOOLEAN_PROPERTY(SequenceEditor, show_cache_preprocessed)
	BOOLEAN_PROPERTY(SequenceEditor, show_cache_composite)
	BOOLEAN_PROPERTY(SequenceEditor, use_cache_raw)
	BOOLEAN_PROPERTY(SequenceEditor, use_cache_preprocessed)
	BOOLEAN_PROPERTY(SequenceEditor, use_cache_composite)
	BOOLEAN_PROPERTY(SequenceEditor, use_cache_final)
	BOOLEAN_PROPERTY(SequenceEditor, use_prefetch)

	inline void SequenceEditor::display_stack(Sequence& meta_sequence) {
		SequenceEditor_display_stack_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, nullptr, (::Sequence *) meta_sequence.ptr.data);
	}


	POINTER_PROPERTY(Struct, SequencesTopLevel, rna_type)

	inline Sequence SequencesTopLevel::new_clip(void *main, const char * name, MovieClip& clip, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_clip_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, (::Main *) main, name, (::MovieClip *) clip.ptr.data, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesTopLevel::new_mask(void *main, const char * name, Mask& mask, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_mask_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, (::Main *) main, name, (::Mask *) mask.ptr.data, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesTopLevel::new_scene(void *main, const char * name, Scene& scene, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_scene_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, (::Main *) main, name, (::Scene *) scene.ptr.data, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesTopLevel::new_image(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_image_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, (::Main *) main, nullptr, name, filepath, channel, frame_start, fit_method);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesTopLevel::new_movie(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_movie_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, (::Main *) main, name, filepath, channel, frame_start, fit_method);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesTopLevel::new_sound(void *main, const char * name, const char * filepath, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_sound_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, (::Main *) main, nullptr, name, filepath, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesTopLevel::new_meta(const char * name, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_meta_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, name, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesTopLevel::new_effect(const char * name, int type, int channel, int frame_start, int frame_end, Sequence& seq1, Sequence& seq2, Sequence& seq3) {
		PointerRNA result;
		::Sequence *retdata = SequencesTopLevel_new_effect_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, nullptr, name, type, channel, frame_start, frame_end, (::Sequence *) seq1.ptr.data, (::Sequence *) seq2.ptr.data, (::Sequence *) seq3.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline void SequencesTopLevel::remove(void *main, Sequence& sequence) {
		SequencesTopLevel_remove_func((::ID *) ptr.owner_id, (::Editing *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &sequence.ptr);
	}


	POINTER_PROPERTY(Struct, SequenceTimelineChannel, rna_type)
	STRING_PROPERTY(SequenceTimelineChannel, name)
	BOOLEAN_PROPERTY(SequenceTimelineChannel, lock)
	BOOLEAN_PROPERTY(SequenceTimelineChannel, mute)


	STRING_PROPERTY(ImageSequence, directory)

	BOOLEAN_PROPERTY(ImageSequence, use_multiview)
	ENUM_PROPERTY(views_format_enum, ImageSequence, views_format)
	POINTER_PROPERTY(Stereo3dFormat, ImageSequence, stereo_3d_format)
	BOOLEAN_PROPERTY(ImageSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, ImageSequence, alpha_mode)
	BOOLEAN_PROPERTY(ImageSequence, use_flip_x)
	BOOLEAN_PROPERTY(ImageSequence, use_flip_y)
	BOOLEAN_PROPERTY(ImageSequence, use_float)
	BOOLEAN_PROPERTY(ImageSequence, use_reverse_frames)
	FLOAT_PROPERTY(ImageSequence, color_multiply)
	BOOLEAN_PROPERTY(ImageSequence, multiply_alpha)
	FLOAT_PROPERTY(ImageSequence, color_saturation)
	FLOAT_PROPERTY(ImageSequence, strobe)
	POINTER_PROPERTY(SequenceTransform, ImageSequence, transform)
	POINTER_PROPERTY(SequenceCrop, ImageSequence, crop)
	BOOLEAN_PROPERTY(ImageSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, ImageSequence, proxy)
	INT_PROPERTY(ImageSequence, animation_offset_start)
	INT_PROPERTY(ImageSequence, animation_offset_end)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, ImageSequence, colorspace_settings)


	POINTER_PROPERTY(Struct, SequenceElements, rna_type)

	inline SequenceElement SequenceElements::append(const char * filename) {
		PointerRNA result;
		::StripElem *retdata = SequenceElements_append_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, filename);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_SequenceElement, retdata);
		return SequenceElement(result);
	}

	inline void SequenceElements::pop(int index) {
		SequenceElements_pop_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, nullptr, index);
	}




	BOOLEAN_PROPERTY(MetaSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MetaSequence, alpha_mode)
	BOOLEAN_PROPERTY(MetaSequence, use_flip_x)
	BOOLEAN_PROPERTY(MetaSequence, use_flip_y)
	BOOLEAN_PROPERTY(MetaSequence, use_float)
	BOOLEAN_PROPERTY(MetaSequence, use_reverse_frames)
	FLOAT_PROPERTY(MetaSequence, color_multiply)
	BOOLEAN_PROPERTY(MetaSequence, multiply_alpha)
	FLOAT_PROPERTY(MetaSequence, color_saturation)
	FLOAT_PROPERTY(MetaSequence, strobe)
	POINTER_PROPERTY(SequenceTransform, MetaSequence, transform)
	POINTER_PROPERTY(SequenceCrop, MetaSequence, crop)
	BOOLEAN_PROPERTY(MetaSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, MetaSequence, proxy)
	INT_PROPERTY(MetaSequence, animation_offset_start)
	INT_PROPERTY(MetaSequence, animation_offset_end)

	inline void MetaSequence::separate(void *main) {
		MetaSequence_separate_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main);
	}


	POINTER_PROPERTY(Struct, SequencesMeta, rna_type)

	inline Sequence SequencesMeta::new_clip(void *main, const char * name, MovieClip& clip, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_clip_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, name, (::MovieClip *) clip.ptr.data, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesMeta::new_mask(void *main, const char * name, Mask& mask, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_mask_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, name, (::Mask *) mask.ptr.data, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesMeta::new_scene(void *main, const char * name, Scene& scene, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_scene_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, name, (::Scene *) scene.ptr.data, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesMeta::new_image(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_image_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, nullptr, name, filepath, channel, frame_start, fit_method);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesMeta::new_movie(void *main, const char * name, const char * filepath, int channel, int frame_start, int fit_method) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_movie_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, name, filepath, channel, frame_start, fit_method);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesMeta::new_sound(void *main, const char * name, const char * filepath, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_sound_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, nullptr, name, filepath, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesMeta::new_meta(const char * name, int channel, int frame_start) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_meta_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, name, channel, frame_start);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline Sequence SequencesMeta::new_effect(const char * name, int type, int channel, int frame_start, int frame_end, Sequence& seq1, Sequence& seq2, Sequence& seq3) {
		PointerRNA result;
		::Sequence *retdata = SequencesMeta_new_effect_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, nullptr, name, type, channel, frame_start, frame_end, (::Sequence *) seq1.ptr.data, (::Sequence *) seq2.ptr.data, (::Sequence *) seq3.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Sequence, retdata);
		return Sequence(result);
	}

	inline void SequencesMeta::remove(void *main, Sequence& sequence) {
		SequencesMeta_remove_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main, nullptr, (::PointerRNA *) &sequence.ptr);
	}


	POINTER_PROPERTY(Scene, SceneSequence, scene)
	POINTER_PROPERTY(Object, SceneSequence, scene_camera)
	ENUM_PROPERTY(scene_input_enum, SceneSequence, scene_input)
	BOOLEAN_PROPERTY(SceneSequence, use_annotations)
	BOOLEAN_PROPERTY(SceneSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, SceneSequence, alpha_mode)
	BOOLEAN_PROPERTY(SceneSequence, use_flip_x)
	BOOLEAN_PROPERTY(SceneSequence, use_flip_y)
	BOOLEAN_PROPERTY(SceneSequence, use_float)
	BOOLEAN_PROPERTY(SceneSequence, use_reverse_frames)
	FLOAT_PROPERTY(SceneSequence, color_multiply)
	BOOLEAN_PROPERTY(SceneSequence, multiply_alpha)
	FLOAT_PROPERTY(SceneSequence, color_saturation)
	FLOAT_PROPERTY(SceneSequence, strobe)
	POINTER_PROPERTY(SequenceTransform, SceneSequence, transform)
	POINTER_PROPERTY(SequenceCrop, SceneSequence, crop)
	BOOLEAN_PROPERTY(SceneSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, SceneSequence, proxy)
	INT_PROPERTY(SceneSequence, animation_offset_start)
	INT_PROPERTY(SceneSequence, animation_offset_end)
	FLOAT_PROPERTY(SceneSequence, fps)


	INT_PROPERTY(MovieSequence, stream_index)


	STRING_PROPERTY(MovieSequence, filepath)
	BOOLEAN_PROPERTY(MovieSequence, use_multiview)
	ENUM_PROPERTY(views_format_enum, MovieSequence, views_format)
	POINTER_PROPERTY(Stereo3dFormat, MovieSequence, stereo_3d_format)
	BOOLEAN_PROPERTY(MovieSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MovieSequence, alpha_mode)
	BOOLEAN_PROPERTY(MovieSequence, use_flip_x)
	BOOLEAN_PROPERTY(MovieSequence, use_flip_y)
	BOOLEAN_PROPERTY(MovieSequence, use_float)
	BOOLEAN_PROPERTY(MovieSequence, use_reverse_frames)
	FLOAT_PROPERTY(MovieSequence, color_multiply)
	BOOLEAN_PROPERTY(MovieSequence, multiply_alpha)
	FLOAT_PROPERTY(MovieSequence, color_saturation)
	FLOAT_PROPERTY(MovieSequence, strobe)
	POINTER_PROPERTY(SequenceTransform, MovieSequence, transform)
	POINTER_PROPERTY(SequenceCrop, MovieSequence, crop)
	BOOLEAN_PROPERTY(MovieSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, MovieSequence, proxy)
	INT_PROPERTY(MovieSequence, animation_offset_start)
	INT_PROPERTY(MovieSequence, animation_offset_end)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, MovieSequence, colorspace_settings)
	FLOAT_PROPERTY(MovieSequence, fps)

	inline bool MovieSequence::reload_if_needed(void *main) {
		return MovieSequence_reload_if_needed_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, (::Main *) main);
	}

	inline IDPropertyWrapPtr MovieSequence::metadata() {
		PointerRNA result;
		result = MovieSequence_metadata_func((::Sequence *) this->ptr.data);
		return IDPropertyWrapPtr(result);
	}


	POINTER_PROPERTY(Struct, RetimingKeys, rna_type)

	inline RetimingKey RetimingKeys::add(int timeline_frame) {
		PointerRNA result;
		::SeqRetimingKey *retdata = RetimingKeys_add_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data, timeline_frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_RetimingKey, retdata);
		return RetimingKey(result);
	}

	inline void RetimingKeys::reset() {
		RetimingKeys_reset_func((::ID *) ptr.owner_id, (::Sequence *) this->ptr.data);
	}


	BOOLEAN_PROPERTY(MovieClipSequence, undistort)
	BOOLEAN_PROPERTY(MovieClipSequence, stabilize2d)
	BOOLEAN_PROPERTY(MovieClipSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MovieClipSequence, alpha_mode)
	BOOLEAN_PROPERTY(MovieClipSequence, use_flip_x)
	BOOLEAN_PROPERTY(MovieClipSequence, use_flip_y)
	BOOLEAN_PROPERTY(MovieClipSequence, use_float)
	BOOLEAN_PROPERTY(MovieClipSequence, use_reverse_frames)
	FLOAT_PROPERTY(MovieClipSequence, color_multiply)
	BOOLEAN_PROPERTY(MovieClipSequence, multiply_alpha)
	FLOAT_PROPERTY(MovieClipSequence, color_saturation)
	FLOAT_PROPERTY(MovieClipSequence, strobe)
	POINTER_PROPERTY(SequenceTransform, MovieClipSequence, transform)
	POINTER_PROPERTY(SequenceCrop, MovieClipSequence, crop)
	INT_PROPERTY(MovieClipSequence, animation_offset_start)
	INT_PROPERTY(MovieClipSequence, animation_offset_end)
	FLOAT_PROPERTY(MovieClipSequence, fps)


	POINTER_PROPERTY(Mask, MaskSequence, mask)
	BOOLEAN_PROPERTY(MaskSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, MaskSequence, alpha_mode)
	BOOLEAN_PROPERTY(MaskSequence, use_flip_x)
	BOOLEAN_PROPERTY(MaskSequence, use_flip_y)
	BOOLEAN_PROPERTY(MaskSequence, use_float)
	BOOLEAN_PROPERTY(MaskSequence, use_reverse_frames)
	FLOAT_PROPERTY(MaskSequence, color_multiply)
	BOOLEAN_PROPERTY(MaskSequence, multiply_alpha)
	FLOAT_PROPERTY(MaskSequence, color_saturation)
	FLOAT_PROPERTY(MaskSequence, strobe)
	POINTER_PROPERTY(SequenceTransform, MaskSequence, transform)
	POINTER_PROPERTY(SequenceCrop, MaskSequence, crop)
	INT_PROPERTY(MaskSequence, animation_offset_start)
	INT_PROPERTY(MaskSequence, animation_offset_end)


	POINTER_PROPERTY(Sound, SoundSequence, sound)
	FLOAT_PROPERTY(SoundSequence, volume)
	FLOAT_PROPERTY(SoundSequence, pan)
	BOOLEAN_PROPERTY(SoundSequence, show_waveform)
	INT_PROPERTY(SoundSequence, animation_offset_start)
	INT_PROPERTY(SoundSequence, animation_offset_end)


	BOOLEAN_PROPERTY(EffectSequence, use_deinterlace)
	ENUM_PROPERTY(alpha_mode_enum, EffectSequence, alpha_mode)
	BOOLEAN_PROPERTY(EffectSequence, use_flip_x)
	BOOLEAN_PROPERTY(EffectSequence, use_flip_y)
	BOOLEAN_PROPERTY(EffectSequence, use_float)
	BOOLEAN_PROPERTY(EffectSequence, use_reverse_frames)
	FLOAT_PROPERTY(EffectSequence, color_multiply)
	BOOLEAN_PROPERTY(EffectSequence, multiply_alpha)
	FLOAT_PROPERTY(EffectSequence, color_saturation)
	FLOAT_PROPERTY(EffectSequence, strobe)
	POINTER_PROPERTY(SequenceTransform, EffectSequence, transform)
	POINTER_PROPERTY(SequenceCrop, EffectSequence, crop)
	BOOLEAN_PROPERTY(EffectSequence, use_proxy)
	POINTER_PROPERTY(SequenceProxy, EffectSequence, proxy)


	INT_PROPERTY(AddSequence, input_count)
	POINTER_PROPERTY(Sequence, AddSequence, input_1)
	POINTER_PROPERTY(Sequence, AddSequence, input_2)


	INT_PROPERTY(AdjustmentSequence, input_count)
	INT_PROPERTY(AdjustmentSequence, animation_offset_start)
	INT_PROPERTY(AdjustmentSequence, animation_offset_end)


	INT_PROPERTY(AlphaOverSequence, input_count)
	POINTER_PROPERTY(Sequence, AlphaOverSequence, input_1)
	POINTER_PROPERTY(Sequence, AlphaOverSequence, input_2)


	INT_PROPERTY(AlphaUnderSequence, input_count)
	POINTER_PROPERTY(Sequence, AlphaUnderSequence, input_1)
	POINTER_PROPERTY(Sequence, AlphaUnderSequence, input_2)


	INT_PROPERTY(ColorSequence, input_count)
	FLOAT_ARRAY_PROPERTY(ColorSequence, 3, color)


	INT_PROPERTY(CrossSequence, input_count)
	POINTER_PROPERTY(Sequence, CrossSequence, input_1)
	POINTER_PROPERTY(Sequence, CrossSequence, input_2)


	INT_PROPERTY(GammaCrossSequence, input_count)
	POINTER_PROPERTY(Sequence, GammaCrossSequence, input_1)
	POINTER_PROPERTY(Sequence, GammaCrossSequence, input_2)


	INT_PROPERTY(GlowSequence, input_count)
	POINTER_PROPERTY(Sequence, GlowSequence, input_1)
	FLOAT_PROPERTY(GlowSequence, threshold)
	FLOAT_PROPERTY(GlowSequence, clamp)
	FLOAT_PROPERTY(GlowSequence, boost_factor)
	FLOAT_PROPERTY(GlowSequence, blur_radius)
	INT_PROPERTY(GlowSequence, quality)
	BOOLEAN_PROPERTY(GlowSequence, use_only_boost)


	INT_PROPERTY(MulticamSequence, input_count)
	INT_PROPERTY(MulticamSequence, multicam_source)
	INT_PROPERTY(MulticamSequence, animation_offset_start)
	INT_PROPERTY(MulticamSequence, animation_offset_end)


	INT_PROPERTY(MultiplySequence, input_count)
	POINTER_PROPERTY(Sequence, MultiplySequence, input_1)
	POINTER_PROPERTY(Sequence, MultiplySequence, input_2)


	INT_PROPERTY(OverDropSequence, input_count)
	POINTER_PROPERTY(Sequence, OverDropSequence, input_1)
	POINTER_PROPERTY(Sequence, OverDropSequence, input_2)


	INT_PROPERTY(SpeedControlSequence, input_count)
	POINTER_PROPERTY(Sequence, SpeedControlSequence, input_1)
	ENUM_PROPERTY(speed_control_enum, SpeedControlSequence, speed_control)
	FLOAT_PROPERTY(SpeedControlSequence, speed_factor)
	FLOAT_PROPERTY(SpeedControlSequence, speed_frame_number)
	FLOAT_PROPERTY(SpeedControlSequence, speed_length)
	BOOLEAN_PROPERTY(SpeedControlSequence, use_frame_interpolate)


	INT_PROPERTY(SubtractSequence, input_count)
	POINTER_PROPERTY(Sequence, SubtractSequence, input_1)
	POINTER_PROPERTY(Sequence, SubtractSequence, input_2)


	INT_PROPERTY(TransformSequence, input_count)
	POINTER_PROPERTY(Sequence, TransformSequence, input_1)
	FLOAT_PROPERTY(TransformSequence, scale_start_x)
	FLOAT_PROPERTY(TransformSequence, scale_start_y)
	BOOLEAN_PROPERTY(TransformSequence, use_uniform_scale)
	FLOAT_PROPERTY(TransformSequence, translate_start_x)
	FLOAT_PROPERTY(TransformSequence, translate_start_y)
	FLOAT_PROPERTY(TransformSequence, rotation_start)
	ENUM_PROPERTY(translation_unit_enum, TransformSequence, translation_unit)
	ENUM_PROPERTY(interpolation_enum, TransformSequence, interpolation)


	INT_PROPERTY(WipeSequence, input_count)
	POINTER_PROPERTY(Sequence, WipeSequence, input_1)
	POINTER_PROPERTY(Sequence, WipeSequence, input_2)
	FLOAT_PROPERTY(WipeSequence, blur_width)
	FLOAT_PROPERTY(WipeSequence, angle)
	ENUM_PROPERTY(direction_enum, WipeSequence, direction)
	ENUM_PROPERTY(transition_type_enum, WipeSequence, transition_type)


	INT_PROPERTY(GaussianBlurSequence, input_count)
	POINTER_PROPERTY(Sequence, GaussianBlurSequence, input_1)
	FLOAT_PROPERTY(GaussianBlurSequence, size_x)
	FLOAT_PROPERTY(GaussianBlurSequence, size_y)


	INT_PROPERTY(TextSequence, input_count)
	POINTER_PROPERTY(VectorFont, TextSequence, font)
	FLOAT_PROPERTY(TextSequence, font_size)
	FLOAT_ARRAY_PROPERTY(TextSequence, 4, color)
	FLOAT_ARRAY_PROPERTY(TextSequence, 4, shadow_color)
	FLOAT_ARRAY_PROPERTY(TextSequence, 4, box_color)
	FLOAT_ARRAY_PROPERTY(TextSequence, 2, location)
	FLOAT_PROPERTY(TextSequence, wrap_width)
	FLOAT_PROPERTY(TextSequence, box_margin)
	ENUM_PROPERTY(align_x_enum, TextSequence, align_x)
	ENUM_PROPERTY(align_y_enum, TextSequence, align_y)
	STRING_PROPERTY(TextSequence, text)
	BOOLEAN_PROPERTY(TextSequence, use_shadow)
	BOOLEAN_PROPERTY(TextSequence, use_box)
	BOOLEAN_PROPERTY(TextSequence, use_bold)
	BOOLEAN_PROPERTY(TextSequence, use_italic)


	INT_PROPERTY(ColorMixSequence, input_count)
	POINTER_PROPERTY(Sequence, ColorMixSequence, input_1)
	POINTER_PROPERTY(Sequence, ColorMixSequence, input_2)
	ENUM_PROPERTY(blend_effect_enum, ColorMixSequence, blend_effect)
	FLOAT_PROPERTY(ColorMixSequence, factor)


	POINTER_PROPERTY(Struct, SequenceModifier, rna_type)
	STRING_PROPERTY(SequenceModifier, name)
	ENUM_PROPERTY(type_enum, SequenceModifier, type)
	BOOLEAN_PROPERTY(SequenceModifier, mute)
	BOOLEAN_PROPERTY(SequenceModifier, show_expanded)
	ENUM_PROPERTY(input_mask_type_enum, SequenceModifier, input_mask_type)
	ENUM_PROPERTY(mask_time_enum, SequenceModifier, mask_time)
	POINTER_PROPERTY(Sequence, SequenceModifier, input_mask_strip)
	POINTER_PROPERTY(Mask, SequenceModifier, input_mask_id)


	POINTER_PROPERTY(SequenceColorBalanceData, ColorBalanceModifier, color_balance)
	FLOAT_PROPERTY(ColorBalanceModifier, color_multiply)


	POINTER_PROPERTY(CurveMapping, CurvesModifier, curve_mapping)


	POINTER_PROPERTY(CurveMapping, HueCorrectModifier, curve_mapping)


	FLOAT_PROPERTY(BrightContrastModifier, bright)
	FLOAT_PROPERTY(BrightContrastModifier, contrast)


	FLOAT_ARRAY_PROPERTY(WhiteBalanceModifier, 3, white_value)


	ENUM_PROPERTY(tonemap_type_enum, SequencerTonemapModifierData, tonemap_type)
	FLOAT_PROPERTY(SequencerTonemapModifierData, key)
	FLOAT_PROPERTY(SequencerTonemapModifierData, offset)
	FLOAT_PROPERTY(SequencerTonemapModifierData, gamma)
	FLOAT_PROPERTY(SequencerTonemapModifierData, intensity)
	FLOAT_PROPERTY(SequencerTonemapModifierData, contrast)
	FLOAT_PROPERTY(SequencerTonemapModifierData, adaptation)
	FLOAT_PROPERTY(SequencerTonemapModifierData, correction)




	inline EQCurveMappingData SoundEqualizerModifier::new_graphic(Context C, float min_freq, float max_freq) {
		PointerRNA result;
		::EQCurveMappingData *retdata = SoundEqualizerModifier_new_graphic_func((::SoundEqualizerModifierData *) this->ptr.data, (::bContext *) C.ptr.data, min_freq, max_freq);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_EQCurveMappingData, retdata);
		return EQCurveMappingData(result);
	}

	inline void SoundEqualizerModifier::clear_soundeqs(Context C) {
		SoundEqualizerModifier_clear_soundeqs_func((::SoundEqualizerModifierData *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, EQCurveMappingData, rna_type)
	POINTER_PROPERTY(CurveMapping, EQCurveMappingData, curve_mapping)


	POINTER_PROPERTY(Struct, Space, rna_type)
	ENUM_PROPERTY(type_enum, Space, type)
	BOOLEAN_PROPERTY(Space, show_locked_time)
	BOOLEAN_PROPERTY(Space, show_region_header)


	POINTER_PROPERTY(Struct, ViewerPathElem, rna_type)
	ENUM_PROPERTY(type_enum, ViewerPathElem, type)
	STRING_PROPERTY(ViewerPathElem, ui_name)


	POINTER_PROPERTY(ID, IDViewerPathElem, id)


	STRING_PROPERTY(ModifierViewerPathElem, modifier_name)


	INT_PROPERTY(GroupNodeViewerPathElem, node_id)


	INT_PROPERTY(SimulationZoneViewerPathElem, sim_output_node_id)


	INT_PROPERTY(RepeatZoneViewerPathElem, repeat_output_node_id)


	INT_PROPERTY(ViewerNodeViewerPathElem, node_id)


	POINTER_PROPERTY(Struct, ViewerPath, rna_type)



	BOOLEAN_PROPERTY(SpaceImageEditor, show_region_tool_header)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_region_toolbar)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_region_ui)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_region_hud)
	POINTER_PROPERTY(Image, SpaceImageEditor, image)
	POINTER_PROPERTY(ImageUser, SpaceImageEditor, image_user)
	POINTER_PROPERTY(Scopes, SpaceImageEditor, scopes)
	BOOLEAN_PROPERTY(SpaceImageEditor, use_image_pin)
	POINTER_PROPERTY(Histogram, SpaceImageEditor, sample_histogram)
	FLOAT_ARRAY_PROPERTY(SpaceImageEditor, 2, zoom)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_repeat)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_annotation)
	ENUM_PROPERTY(display_channels_enum, SpaceImageEditor, display_channels)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_stereo_3d)
	POINTER_PROPERTY(SpaceUVEditor, SpaceImageEditor, uv_editor)
	ENUM_PROPERTY(mode_enum, SpaceImageEditor, mode)
	ENUM_PROPERTY(ui_mode_enum, SpaceImageEditor, ui_mode)
	FLOAT_ARRAY_PROPERTY(SpaceImageEditor, 2, cursor_location)
	ENUM_PROPERTY(pivot_point_enum, SpaceImageEditor, pivot_point)
	POINTER_PROPERTY(GreasePencil, SpaceImageEditor, grease_pencil)
	BOOLEAN_PROPERTY(SpaceImageEditor, use_realtime_update)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_render)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_paint)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_uvedit)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_maskedit)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_gizmo)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_gizmo_navigate)
	POINTER_PROPERTY(SpaceImageOverlay, SpaceImageEditor, overlay)
	POINTER_PROPERTY(Mask, SpaceImageEditor, mask)
	ENUM_PROPERTY(mask_display_type_enum, SpaceImageEditor, mask_display_type)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_mask_spline)
	BOOLEAN_PROPERTY(SpaceImageEditor, show_mask_overlay)
	ENUM_PROPERTY(mask_overlay_mode_enum, SpaceImageEditor, mask_overlay_mode)
	FLOAT_PROPERTY(SpaceImageEditor, blend_factor)


	POINTER_PROPERTY(Struct, SpaceUVEditor, rna_type)
	ENUM_PROPERTY(edge_display_type_enum, SpaceUVEditor, edge_display_type)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_stretch)
	ENUM_PROPERTY(display_stretch_type_enum, SpaceUVEditor, display_stretch_type)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_modified_edges)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_metadata)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_texpaint)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_pixel_coords)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_faces)
	INT_ARRAY_PROPERTY(SpaceUVEditor, 2, tile_grid_shape)
	BOOLEAN_PROPERTY(SpaceUVEditor, show_grid_over_image)
	ENUM_PROPERTY(grid_shape_source_enum, SpaceUVEditor, grid_shape_source)
	INT_ARRAY_PROPERTY(SpaceUVEditor, 2, custom_grid_subdivisions)
	FLOAT_PROPERTY(SpaceUVEditor, uv_opacity)
	ENUM_PROPERTY(pixel_round_mode_enum, SpaceUVEditor, pixel_round_mode)
	BOOLEAN_PROPERTY(SpaceUVEditor, lock_bounds)
	BOOLEAN_PROPERTY(SpaceUVEditor, use_live_unwrap)


	POINTER_PROPERTY(Struct, SpaceImageOverlay, rna_type)
	BOOLEAN_PROPERTY(SpaceImageOverlay, show_overlays)
	BOOLEAN_PROPERTY(SpaceImageOverlay, show_grid_background)


	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_region_tool_header)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_region_toolbar)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_region_channels)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_region_ui)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_region_hud)
	ENUM_PROPERTY(view_type_enum, SpaceSequenceEditor, view_type)
	ENUM_PROPERTY(display_mode_enum, SpaceSequenceEditor, display_mode)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_frames)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, use_marker_sync)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_separate_color)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_seconds)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_markers)
	INT_PROPERTY(SpaceSequenceEditor, display_channel)
	ENUM_PROPERTY(preview_channels_enum, SpaceSequenceEditor, preview_channels)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, use_zoom_to_fit)
	INT_PROPERTY(SpaceSequenceEditor, show_overexposed)
	ENUM_PROPERTY(proxy_render_size_enum, SpaceSequenceEditor, proxy_render_size)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, use_proxies)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, use_clamp_view)
	POINTER_PROPERTY(GreasePencil, SpaceSequenceEditor, grease_pencil)
	ENUM_PROPERTY(overlay_frame_type_enum, SpaceSequenceEditor, overlay_frame_type)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_backdrop)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_transform_preview)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_gizmo)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_gizmo_navigate)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_gizmo_context)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_gizmo_tool)
	BOOLEAN_PROPERTY(SpaceSequenceEditor, show_overlays)
	POINTER_PROPERTY(SequencerPreviewOverlay, SpaceSequenceEditor, preview_overlay)
	POINTER_PROPERTY(SequencerTimelineOverlay, SpaceSequenceEditor, timeline_overlay)
	FLOAT_ARRAY_PROPERTY(SpaceSequenceEditor, 2, cursor_location)


	POINTER_PROPERTY(Struct, SequencerPreviewOverlay, rna_type)
	BOOLEAN_PROPERTY(SequencerPreviewOverlay, show_safe_areas)
	BOOLEAN_PROPERTY(SequencerPreviewOverlay, show_safe_center)
	BOOLEAN_PROPERTY(SequencerPreviewOverlay, show_metadata)
	BOOLEAN_PROPERTY(SequencerPreviewOverlay, show_annotation)
	BOOLEAN_PROPERTY(SequencerPreviewOverlay, show_image_outline)
	BOOLEAN_PROPERTY(SequencerPreviewOverlay, show_cursor)


	POINTER_PROPERTY(Struct, SequencerTimelineOverlay, rna_type)
	ENUM_PROPERTY(waveform_display_type_enum, SequencerTimelineOverlay, waveform_display_type)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_fcurves)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_strip_name)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_strip_source)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_strip_duration)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_grid)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_strip_offset)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_thumbnails)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_strip_tag_color)
	BOOLEAN_PROPERTY(SequencerTimelineOverlay, show_strip_retiming)


	BOOLEAN_PROPERTY(SpaceTextEditor, show_region_footer)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_region_ui)
	POINTER_PROPERTY(Text, SpaceTextEditor, text)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_word_wrap)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_line_numbers)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_syntax_highlight)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_line_highlight)
	INT_PROPERTY(SpaceTextEditor, tab_width)
	INT_PROPERTY(SpaceTextEditor, font_size)
	BOOLEAN_PROPERTY(SpaceTextEditor, show_margin)
	INT_PROPERTY(SpaceTextEditor, margin_column)
	INT_PROPERTY(SpaceTextEditor, top)
	INT_PROPERTY(SpaceTextEditor, visible_lines)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_overwrite)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_live_edit)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_find_all)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_find_wrap)
	BOOLEAN_PROPERTY(SpaceTextEditor, use_match_case)
	STRING_PROPERTY(SpaceTextEditor, find_text)
	STRING_PROPERTY(SpaceTextEditor, replace_text)

	inline bool SpaceTextEditor::is_syntax_highlight_supported() {
		return SpaceTextEditor_is_syntax_highlight_supported_func((::SpaceText *) this->ptr.data);
	}

	inline void SpaceTextEditor::region_location_from_cursor(int line, int column, int result[2]) {
		SpaceTextEditor_region_location_from_cursor_func((::ID *) ptr.owner_id, (::SpaceText *) this->ptr.data, line, column, result);
	}


	POINTER_PROPERTY(Struct, FileSelectEntry, rna_type)
	STRING_PROPERTY(FileSelectEntry, name)
	STRING_PROPERTY(FileSelectEntry, relative_path)
	INT_PROPERTY(FileSelectEntry, preview_icon_id)
	POINTER_PROPERTY(AssetMetaData, FileSelectEntry, asset_data)


	POINTER_PROPERTY(Struct, FileSelectParams, rna_type)
	STRING_PROPERTY(FileSelectParams, title)
	STRING_PROPERTY(FileSelectParams, directory)
	STRING_PROPERTY(FileSelectParams, filename)
	BOOLEAN_PROPERTY(FileSelectParams, use_library_browsing)
	ENUM_PROPERTY(display_type_enum, FileSelectParams, display_type)
	ENUM_PROPERTY(recursion_level_enum, FileSelectParams, recursion_level)
	BOOLEAN_PROPERTY(FileSelectParams, show_details_size)
	BOOLEAN_PROPERTY(FileSelectParams, show_details_datetime)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter)
	BOOLEAN_PROPERTY(FileSelectParams, show_hidden)
	ENUM_PROPERTY(sort_method_enum, FileSelectParams, sort_method)
	BOOLEAN_PROPERTY(FileSelectParams, use_sort_invert)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_image)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_blender)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_backup)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_movie)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_script)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_font)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_sound)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_text)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_volume)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_folder)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_blendid)
	BOOLEAN_PROPERTY(FileSelectParams, use_filter_asset_only)
	POINTER_PROPERTY(FileSelectIDFilter, FileSelectParams, filter_id)
	STRING_PROPERTY(FileSelectParams, filter_glob)
	STRING_PROPERTY(FileSelectParams, filter_search)
	INT_PROPERTY(FileSelectParams, display_size)
	ENUM_PROPERTY(display_size_discrete_enum, FileSelectParams, display_size_discrete)


	ENUM_PROPERTY(asset_library_reference_enum, FileAssetSelectParams, asset_library_reference)
	STRING_PROPERTY(FileAssetSelectParams, catalog_id)
	POINTER_PROPERTY(FileAssetSelectIDFilter, FileAssetSelectParams, filter_asset_id)
	ENUM_PROPERTY(import_method_enum, FileAssetSelectParams, import_method)


	POINTER_PROPERTY(Struct, FileSelectIDFilter, rna_type)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_action)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_armature)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_brush)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_camera)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_cachefile)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_curve)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_grease_pencil)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_group)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_curves)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_image)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_light)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_light_probe)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_linestyle)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_lattice)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_material)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_metaball)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_movie_clip)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_mesh)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_mask)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_node_tree)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_object)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_particle_settings)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_palette)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_paint_curve)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_pointcloud)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_scene)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_speaker)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_sound)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_texture)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_text)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_font)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_volume)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_world)
	BOOLEAN_PROPERTY(FileSelectIDFilter, filter_work_space)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_scene)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_animation)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_object)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_geometry)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_shading)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_image)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_environment)
	BOOLEAN_PROPERTY(FileSelectIDFilter, category_misc)


	POINTER_PROPERTY(Struct, FileAssetSelectIDFilter, rna_type)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, filter_action)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_armature)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_brush)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_camera)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_cachefile)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_curve)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_grease_pencil)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, filter_group)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_curves)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_image)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_light)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_light_probe)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_linestyle)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_lattice)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, filter_material)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_metaball)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_movie_clip)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_mesh)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_mask)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, filter_node_tree)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, filter_object)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_particle_settings)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_palette)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_paint_curve)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_pointcloud)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_scene)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_speaker)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_sound)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_texture)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_text)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_font)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_volume)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, filter_world)
	BOOLEAN_PROPERTY(FileAssetSelectIDFilter, experimental_filter_work_space)


	POINTER_PROPERTY(Struct, FileBrowserFSMenuEntry, rna_type)
	STRING_PROPERTY(FileBrowserFSMenuEntry, path)
	STRING_PROPERTY(FileBrowserFSMenuEntry, name)
	INT_PROPERTY(FileBrowserFSMenuEntry, icon)
	BOOLEAN_PROPERTY(FileBrowserFSMenuEntry, use_save)
	BOOLEAN_PROPERTY(FileBrowserFSMenuEntry, is_valid)


	BOOLEAN_PROPERTY(SpaceFileBrowser, show_region_toolbar)
	BOOLEAN_PROPERTY(SpaceFileBrowser, show_region_tool_props)
	BOOLEAN_PROPERTY(SpaceFileBrowser, show_region_ui)
	ENUM_PROPERTY(browse_mode_enum, SpaceFileBrowser, browse_mode)
	POINTER_PROPERTY(FileSelectParams, SpaceFileBrowser, params)
	POINTER_PROPERTY(Operator, SpaceFileBrowser, active_operator)
	POINTER_PROPERTY(Operator, SpaceFileBrowser, operator_value)

	INT_PROPERTY(SpaceFileBrowser, system_folders_active)

	INT_PROPERTY(SpaceFileBrowser, system_bookmarks_active)

	INT_PROPERTY(SpaceFileBrowser, bookmarks_active)

	INT_PROPERTY(SpaceFileBrowser, recent_folders_active)

	inline void SpaceFileBrowser::activate_asset_by_id(ID& id_to_activate, bool deferred) {
		SpaceFileBrowser_activate_asset_by_id_func((::SpaceFile *) this->ptr.data, (::ID *) id_to_activate.ptr.data, deferred);
	}

	inline void SpaceFileBrowser::activate_file_by_relative_path(const char * relative_path) {
		SpaceFileBrowser_activate_file_by_relative_path_func((::SpaceFile *) this->ptr.data, relative_path);
	}

	inline void SpaceFileBrowser::deselect_all() {
		SpaceFileBrowser_deselect_all_func((::SpaceFile *) this->ptr.data);
	}


	ENUM_PROPERTY(display_mode_enum, SpaceOutliner, display_mode)
	ENUM_PROPERTY(lib_override_view_mode_enum, SpaceOutliner, lib_override_view_mode)
	STRING_PROPERTY(SpaceOutliner, filter_text)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_case_sensitive)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_complete)
	BOOLEAN_PROPERTY(SpaceOutliner, use_sort_alpha)
	BOOLEAN_PROPERTY(SpaceOutliner, use_sync_select)
	BOOLEAN_PROPERTY(SpaceOutliner, show_mode_column)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_column_enable)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_column_select)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_column_hide)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_column_viewport)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_column_render)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_column_holdout)
	BOOLEAN_PROPERTY(SpaceOutliner, show_restrict_column_indirect_only)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_content)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_children)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_collection)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_view_layers)
	ENUM_PROPERTY(filter_state_enum, SpaceOutliner, filter_state)
	BOOLEAN_PROPERTY(SpaceOutliner, filter_invert)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_mesh)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_armature)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_empty)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_light)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_camera)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_grease_pencil)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_object_others)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_id_type)
	ENUM_PROPERTY(filter_id_type_enum, SpaceOutliner, filter_id_type)
	BOOLEAN_PROPERTY(SpaceOutliner, use_filter_lib_override_system)


	BOOLEAN_PROPERTY(SpaceView3D, show_region_tool_header)
	BOOLEAN_PROPERTY(SpaceView3D, show_region_toolbar)
	BOOLEAN_PROPERTY(SpaceView3D, show_region_ui)
	BOOLEAN_PROPERTY(SpaceView3D, show_region_hud)
	BOOLEAN_PROPERTY(SpaceView3D, show_region_asset_shelf)
	POINTER_PROPERTY(Object, SpaceView3D, camera)
	BOOLEAN_PROPERTY(SpaceView3D, use_render_border)
	FLOAT_PROPERTY(SpaceView3D, render_border_min_x)
	FLOAT_PROPERTY(SpaceView3D, render_border_min_y)
	FLOAT_PROPERTY(SpaceView3D, render_border_max_x)
	FLOAT_PROPERTY(SpaceView3D, render_border_max_y)
	POINTER_PROPERTY(Object, SpaceView3D, lock_object)
	STRING_PROPERTY(SpaceView3D, lock_bone)
	BOOLEAN_PROPERTY(SpaceView3D, lock_cursor)
	POINTER_PROPERTY(SpaceView3D, SpaceView3D, local_view)
	FLOAT_PROPERTY(SpaceView3D, lens)
	FLOAT_PROPERTY(SpaceView3D, clip_start)
	FLOAT_PROPERTY(SpaceView3D, clip_end)
	BOOLEAN_PROPERTY(SpaceView3D, lock_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_navigate)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_context)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_tool)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_object_translate)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_object_rotate)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_object_scale)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_empty_image)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_empty_force_field)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_light_size)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_light_look_at)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_camera_lens)
	BOOLEAN_PROPERTY(SpaceView3D, show_gizmo_camera_dof_distance)
	BOOLEAN_PROPERTY(SpaceView3D, use_local_camera)
	POINTER_PROPERTY(RegionView3D, SpaceView3D, region_3d)

	BOOLEAN_PROPERTY(SpaceView3D, show_reconstruction)
	FLOAT_PROPERTY(SpaceView3D, tracks_display_size)
	ENUM_PROPERTY(tracks_display_type_enum, SpaceView3D, tracks_display_type)
	BOOLEAN_PROPERTY(SpaceView3D, show_camera_path)
	BOOLEAN_PROPERTY(SpaceView3D, show_bundle_names)
	BOOLEAN_PROPERTY(SpaceView3D, use_local_collections)
	ENUM_PROPERTY(stereo_3d_eye_enum, SpaceView3D, stereo_3d_eye)
	ENUM_PROPERTY(stereo_3d_camera_enum, SpaceView3D, stereo_3d_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_stereo_3d_cameras)
	BOOLEAN_PROPERTY(SpaceView3D, show_stereo_3d_convergence_plane)
	FLOAT_PROPERTY(SpaceView3D, stereo_3d_convergence_plane_alpha)
	BOOLEAN_PROPERTY(SpaceView3D, show_stereo_3d_volume)
	FLOAT_PROPERTY(SpaceView3D, stereo_3d_volume_alpha)
	BOOLEAN_PROPERTY(SpaceView3D, mirror_xr_session)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_mesh)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_curve)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_surf)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_meta)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_font)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_curves)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_pointcloud)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_volume)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_armature)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_lattice)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_empty)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_grease_pencil)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_light)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_speaker)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_viewport_light_probe)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_mesh)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_curve)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_surf)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_meta)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_font)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_curves)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_pointcloud)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_volume)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_armature)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_lattice)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_empty)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_grease_pencil)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_camera)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_light)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_speaker)
	BOOLEAN_PROPERTY(SpaceView3D, show_object_select_light_probe)
	INT_PROPERTY(SpaceView3D, icon_from_show_object_viewport)
	BOOLEAN_PROPERTY(SpaceView3D, show_viewer)
	POINTER_PROPERTY(View3DShading, SpaceView3D, shading)
	POINTER_PROPERTY(View3DOverlay, SpaceView3D, overlay)


	POINTER_PROPERTY(Struct, View3DShading, rna_type)
	ENUM_PROPERTY(type_enum, View3DShading, type)
	ENUM_PROPERTY(light_enum, View3DShading, light)
	BOOLEAN_PROPERTY(View3DShading, show_object_outline)
	ENUM_PROPERTY(studio_light_enum, View3DShading, studio_light)
	BOOLEAN_PROPERTY(View3DShading, use_world_space_lighting)
	BOOLEAN_PROPERTY(View3DShading, show_backface_culling)
	BOOLEAN_PROPERTY(View3DShading, show_cavity)
	ENUM_PROPERTY(cavity_type_enum, View3DShading, cavity_type)
	FLOAT_PROPERTY(View3DShading, curvature_ridge_factor)
	FLOAT_PROPERTY(View3DShading, curvature_valley_factor)
	FLOAT_PROPERTY(View3DShading, cavity_ridge_factor)
	FLOAT_PROPERTY(View3DShading, cavity_valley_factor)
	POINTER_PROPERTY(StudioLight, View3DShading, selected_studio_light)
	FLOAT_PROPERTY(View3DShading, studiolight_rotate_z)
	FLOAT_PROPERTY(View3DShading, studiolight_intensity)
	FLOAT_PROPERTY(View3DShading, studiolight_background_alpha)
	FLOAT_PROPERTY(View3DShading, studiolight_background_blur)
	BOOLEAN_PROPERTY(View3DShading, use_studiolight_view_rotation)
	ENUM_PROPERTY(color_type_enum, View3DShading, color_type)
	ENUM_PROPERTY(wireframe_color_type_enum, View3DShading, wireframe_color_type)
	FLOAT_ARRAY_PROPERTY(View3DShading, 3, single_color)
	ENUM_PROPERTY(background_type_enum, View3DShading, background_type)
	FLOAT_ARRAY_PROPERTY(View3DShading, 3, background_color)
	BOOLEAN_PROPERTY(View3DShading, show_shadows)
	BOOLEAN_PROPERTY(View3DShading, show_xray)
	BOOLEAN_PROPERTY(View3DShading, show_xray_wireframe)
	FLOAT_PROPERTY(View3DShading, xray_alpha)
	FLOAT_PROPERTY(View3DShading, xray_alpha_wireframe)
	BOOLEAN_PROPERTY(View3DShading, use_dof)
	BOOLEAN_PROPERTY(View3DShading, use_scene_lights)
	BOOLEAN_PROPERTY(View3DShading, use_scene_world)
	BOOLEAN_PROPERTY(View3DShading, use_scene_lights_render)
	BOOLEAN_PROPERTY(View3DShading, use_scene_world_render)
	BOOLEAN_PROPERTY(View3DShading, show_specular_highlight)
	FLOAT_ARRAY_PROPERTY(View3DShading, 3, object_outline_color)
	FLOAT_PROPERTY(View3DShading, shadow_intensity)
	ENUM_PROPERTY(render_pass_enum, View3DShading, render_pass)
	STRING_PROPERTY(View3DShading, aov_name)
	ENUM_PROPERTY(use_compositor_enum, View3DShading, use_compositor)


	POINTER_PROPERTY(Struct, View3DOverlay, rna_type)
	BOOLEAN_PROPERTY(View3DOverlay, show_overlays)
	BOOLEAN_PROPERTY(View3DOverlay, show_ortho_grid)
	BOOLEAN_PROPERTY(View3DOverlay, show_floor)
	BOOLEAN_PROPERTY(View3DOverlay, show_axis_x)
	BOOLEAN_PROPERTY(View3DOverlay, show_axis_y)
	BOOLEAN_PROPERTY(View3DOverlay, show_axis_z)
	FLOAT_PROPERTY(View3DOverlay, grid_scale)
	INT_PROPERTY(View3DOverlay, grid_lines)
	INT_PROPERTY(View3DOverlay, grid_subdivisions)
	FLOAT_PROPERTY(View3DOverlay, grid_scale_unit)
	BOOLEAN_PROPERTY(View3DOverlay, show_outline_selected)
	BOOLEAN_PROPERTY(View3DOverlay, show_object_origins)
	BOOLEAN_PROPERTY(View3DOverlay, show_object_origins_all)
	BOOLEAN_PROPERTY(View3DOverlay, show_relationship_lines)
	BOOLEAN_PROPERTY(View3DOverlay, show_cursor)
	BOOLEAN_PROPERTY(View3DOverlay, show_text)
	BOOLEAN_PROPERTY(View3DOverlay, show_stats)
	BOOLEAN_PROPERTY(View3DOverlay, show_extras)
	BOOLEAN_PROPERTY(View3DOverlay, show_light_colors)
	BOOLEAN_PROPERTY(View3DOverlay, show_bones)
	BOOLEAN_PROPERTY(View3DOverlay, show_face_orientation)
	BOOLEAN_PROPERTY(View3DOverlay, show_fade_inactive)
	FLOAT_PROPERTY(View3DOverlay, fade_inactive_alpha)
	BOOLEAN_PROPERTY(View3DOverlay, show_xray_bone)
	FLOAT_PROPERTY(View3DOverlay, xray_alpha_bone)
	FLOAT_PROPERTY(View3DOverlay, bone_wire_alpha)
	BOOLEAN_PROPERTY(View3DOverlay, show_motion_paths)
	BOOLEAN_PROPERTY(View3DOverlay, show_onion_skins)
	BOOLEAN_PROPERTY(View3DOverlay, show_look_dev)
	BOOLEAN_PROPERTY(View3DOverlay, show_wireframes)
	FLOAT_PROPERTY(View3DOverlay, wireframe_threshold)
	FLOAT_PROPERTY(View3DOverlay, wireframe_opacity)
	BOOLEAN_PROPERTY(View3DOverlay, show_viewer_attribute)
	FLOAT_PROPERTY(View3DOverlay, viewer_attribute_opacity)
	BOOLEAN_PROPERTY(View3DOverlay, show_paint_wire)
	BOOLEAN_PROPERTY(View3DOverlay, show_wpaint_contours)
	BOOLEAN_PROPERTY(View3DOverlay, show_weight)
	BOOLEAN_PROPERTY(View3DOverlay, show_retopology)
	FLOAT_PROPERTY(View3DOverlay, retopology_offset)
	BOOLEAN_PROPERTY(View3DOverlay, show_face_normals)
	BOOLEAN_PROPERTY(View3DOverlay, show_vertex_normals)
	BOOLEAN_PROPERTY(View3DOverlay, show_split_normals)
	BOOLEAN_PROPERTY(View3DOverlay, show_faces)
	BOOLEAN_PROPERTY(View3DOverlay, show_face_center)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_crease)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_bevel_weight)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_seams)
	BOOLEAN_PROPERTY(View3DOverlay, show_edge_sharp)
	BOOLEAN_PROPERTY(View3DOverlay, show_freestyle_edge_marks)
	BOOLEAN_PROPERTY(View3DOverlay, show_freestyle_face_marks)
	BOOLEAN_PROPERTY(View3DOverlay, show_statvis)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_edge_length)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_edge_angle)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_face_angle)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_face_area)
	BOOLEAN_PROPERTY(View3DOverlay, show_extra_indices)
	ENUM_PROPERTY(display_handle_enum, View3DOverlay, display_handle)
	BOOLEAN_PROPERTY(View3DOverlay, show_curve_normals)
	FLOAT_PROPERTY(View3DOverlay, normals_length)
	FLOAT_PROPERTY(View3DOverlay, normals_constant_screen_size)
	BOOLEAN_PROPERTY(View3DOverlay, use_normals_constant_screen_size)
	FLOAT_PROPERTY(View3DOverlay, backwire_opacity)
	FLOAT_PROPERTY(View3DOverlay, texture_paint_mode_opacity)
	FLOAT_PROPERTY(View3DOverlay, vertex_paint_mode_opacity)
	FLOAT_PROPERTY(View3DOverlay, weight_paint_mode_opacity)
	FLOAT_PROPERTY(View3DOverlay, sculpt_mode_mask_opacity)
	BOOLEAN_PROPERTY(View3DOverlay, show_sculpt_curves_cage)
	FLOAT_PROPERTY(View3DOverlay, sculpt_curves_cage_opacity)
	FLOAT_PROPERTY(View3DOverlay, sculpt_mode_face_sets_opacity)
	BOOLEAN_PROPERTY(View3DOverlay, show_sculpt_mask)
	BOOLEAN_PROPERTY(View3DOverlay, show_sculpt_face_sets)
	BOOLEAN_PROPERTY(View3DOverlay, show_annotation)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_fade_objects)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_grid)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_fade_layers)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_fade_gp_objects)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_canvas_xray)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_show_directions)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_show_material_name)
	FLOAT_PROPERTY(View3DOverlay, gpencil_grid_opacity)
	FLOAT_PROPERTY(View3DOverlay, gpencil_fade_objects)
	FLOAT_PROPERTY(View3DOverlay, gpencil_fade_layer)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_edit_lines)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_multiedit_line_only)
	BOOLEAN_PROPERTY(View3DOverlay, use_gpencil_onion_skin)
	FLOAT_PROPERTY(View3DOverlay, vertex_opacity)
	FLOAT_PROPERTY(View3DOverlay, gpencil_vertex_paint_opacity)
	BOOLEAN_PROPERTY(View3DOverlay, use_debug_freeze_view_culling)


	POINTER_PROPERTY(Struct, RegionView3D, rna_type)
	BOOLEAN_PROPERTY(RegionView3D, lock_rotation)
	BOOLEAN_PROPERTY(RegionView3D, show_sync_view)
	BOOLEAN_PROPERTY(RegionView3D, use_box_clip)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 16, perspective_matrix)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 16, window_matrix)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 16, view_matrix)
	ENUM_PROPERTY(view_perspective_enum, RegionView3D, view_perspective)
	BOOLEAN_PROPERTY(RegionView3D, is_perspective)
	BOOLEAN_PROPERTY(RegionView3D, is_orthographic_side_view)
	BOOLEAN_PROPERTY(RegionView3D, use_clip_planes)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 24, clip_planes)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 3, view_location)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 4, view_rotation)
	FLOAT_PROPERTY(RegionView3D, view_distance)
	FLOAT_PROPERTY(RegionView3D, view_camera_zoom)
	FLOAT_ARRAY_PROPERTY(RegionView3D, 2, view_camera_offset)

	inline void RegionView3D::update(Context C) {
		RegionView3D_update_func((::ID *) ptr.owner_id, (::RegionView3D *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	ENUM_PROPERTY(context_enum, SpaceProperties, context)
	POINTER_PROPERTY(ID, SpaceProperties, pin_id)
	BOOLEAN_PROPERTY(SpaceProperties, use_pin_id)
	BOOLEAN_DYNAMIC_ARRAY_PROPERTY(SpaceProperties, tab_search_results)
	STRING_PROPERTY(SpaceProperties, search_filter)
	ENUM_PROPERTY(outliner_sync_enum, SpaceProperties, outliner_sync)


	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_region_channels)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_region_ui)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_region_hud)
	POINTER_PROPERTY(Action, SpaceDopeSheetEditor, action)
	ENUM_PROPERTY(mode_enum, SpaceDopeSheetEditor, mode)
	ENUM_PROPERTY(ui_mode_enum, SpaceDopeSheetEditor, ui_mode)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_seconds)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_sliders)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_pose_markers)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_interpolation)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_extremes)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_markers)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, use_auto_merge_keyframes)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, use_realtime_update)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, use_marker_sync)
	POINTER_PROPERTY(DopeSheet, SpaceDopeSheetEditor, dopesheet)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, show_cache)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_softbody)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_particles)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_cloth)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_smoke)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_simulation_nodes)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_dynamicpaint)
	BOOLEAN_PROPERTY(SpaceDopeSheetEditor, cache_rigidbody)


	BOOLEAN_PROPERTY(SpaceGraphEditor, show_region_channels)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_region_ui)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_region_hud)
	ENUM_PROPERTY(mode_enum, SpaceGraphEditor, mode)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_seconds)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_sliders)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_handles)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_only_selected_keyframe_handles)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_markers)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_extrapolation)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_auto_merge_keyframes)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_realtime_update)
	BOOLEAN_PROPERTY(SpaceGraphEditor, show_cursor)
	FLOAT_PROPERTY(SpaceGraphEditor, cursor_position_x)
	FLOAT_PROPERTY(SpaceGraphEditor, cursor_position_y)
	ENUM_PROPERTY(pivot_point_enum, SpaceGraphEditor, pivot_point)
	POINTER_PROPERTY(DopeSheet, SpaceGraphEditor, dopesheet)
	BOOLEAN_PROPERTY(SpaceGraphEditor, has_ghost_curves)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_normalization)
	BOOLEAN_PROPERTY(SpaceGraphEditor, use_auto_normalization)


	BOOLEAN_PROPERTY(SpaceNLA, show_region_channels)
	BOOLEAN_PROPERTY(SpaceNLA, show_region_ui)
	BOOLEAN_PROPERTY(SpaceNLA, show_region_hud)
	BOOLEAN_PROPERTY(SpaceNLA, show_seconds)
	BOOLEAN_PROPERTY(SpaceNLA, show_strip_curves)
	BOOLEAN_PROPERTY(SpaceNLA, show_local_markers)
	BOOLEAN_PROPERTY(SpaceNLA, show_markers)
	BOOLEAN_PROPERTY(SpaceNLA, use_realtime_update)
	POINTER_PROPERTY(DopeSheet, SpaceNLA, dopesheet)


	INT_PROPERTY(SpaceConsole, font_size)
	INT_PROPERTY(SpaceConsole, select_start)
	INT_PROPERTY(SpaceConsole, select_end)
	STRING_PROPERTY(SpaceConsole, prompt)
	STRING_PROPERTY(SpaceConsole, language)




	POINTER_PROPERTY(Struct, ConsoleLine, rna_type)
	STRING_PROPERTY(ConsoleLine, body)
	INT_PROPERTY(ConsoleLine, current_character)
	ENUM_PROPERTY(type_enum, ConsoleLine, type)


	BOOLEAN_PROPERTY(SpaceInfo, show_report_debug)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_info)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_operator)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_warning)
	BOOLEAN_PROPERTY(SpaceInfo, show_report_error)


	ENUM_PROPERTY(filter_type_enum, SpacePreferences, filter_type)
	STRING_PROPERTY(SpacePreferences, filter_text)


	POINTER_PROPERTY(Struct, NodeTreePath, rna_type)
	POINTER_PROPERTY(NodeTree, NodeTreePath, node_tree)


	BOOLEAN_PROPERTY(SpaceNodeEditor, show_region_toolbar)
	BOOLEAN_PROPERTY(SpaceNodeEditor, show_region_ui)
	ENUM_PROPERTY(tree_type_enum, SpaceNodeEditor, tree_type)
	ENUM_PROPERTY(texture_type_enum, SpaceNodeEditor, texture_type)
	ENUM_PROPERTY(shader_type_enum, SpaceNodeEditor, shader_type)
	ENUM_PROPERTY(geometry_nodes_type_enum, SpaceNodeEditor, geometry_nodes_type)
	POINTER_PROPERTY(ID, SpaceNodeEditor, id)
	POINTER_PROPERTY(ID, SpaceNodeEditor, id_from)

	POINTER_PROPERTY(NodeTree, SpaceNodeEditor, node_tree)
	POINTER_PROPERTY(NodeTree, SpaceNodeEditor, edit_tree)
	BOOLEAN_PROPERTY(SpaceNodeEditor, pin)
	BOOLEAN_PROPERTY(SpaceNodeEditor, show_backdrop)
	POINTER_PROPERTY(NodeTree, SpaceNodeEditor, geometry_nodes_tool_tree)
	BOOLEAN_PROPERTY(SpaceNodeEditor, show_annotation)
	BOOLEAN_PROPERTY(SpaceNodeEditor, use_auto_render)
	FLOAT_PROPERTY(SpaceNodeEditor, backdrop_zoom)
	FLOAT_ARRAY_PROPERTY(SpaceNodeEditor, 2, backdrop_offset)
	ENUM_PROPERTY(backdrop_channels_enum, SpaceNodeEditor, backdrop_channels)
	FLOAT_ARRAY_PROPERTY(SpaceNodeEditor, 2, cursor_location)
	ENUM_PROPERTY(insert_offset_direction_enum, SpaceNodeEditor, insert_offset_direction)
	POINTER_PROPERTY(SpaceNodeOverlay, SpaceNodeEditor, overlay)
	BOOLEAN_PROPERTY(SpaceNodeEditor, supports_previews)

	inline void SpaceNodeEditor::cursor_location_from_region(Context C, int x, int y) {
		SpaceNodeEditor_cursor_location_from_region_func((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data, x, y);
	}


	POINTER_PROPERTY(Struct, SpaceNodeEditorPath, rna_type)
	STRING_PROPERTY(SpaceNodeEditorPath, to_string)

	inline void SpaceNodeEditorPath::clear(Context C) {
		SpaceNodeEditorPath_clear_func((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void SpaceNodeEditorPath::start(Context C, NodeTree& node_tree) {
		SpaceNodeEditorPath_start_func((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &node_tree);
	}

	inline void SpaceNodeEditorPath::append(Context C, NodeTree& node_tree, Node& node) {
		SpaceNodeEditorPath_append_func((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &node_tree, (::PointerRNA *) &node);
	}

	inline void SpaceNodeEditorPath::pop(Context C) {
		SpaceNodeEditorPath_pop_func((::SpaceNode *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, SpaceNodeOverlay, rna_type)
	BOOLEAN_PROPERTY(SpaceNodeOverlay, show_overlays)
	BOOLEAN_PROPERTY(SpaceNodeOverlay, show_wire_color)
	BOOLEAN_PROPERTY(SpaceNodeOverlay, show_timing)
	BOOLEAN_PROPERTY(SpaceNodeOverlay, show_context_path)
	BOOLEAN_PROPERTY(SpaceNodeOverlay, show_named_attributes)
	BOOLEAN_PROPERTY(SpaceNodeOverlay, show_previews)
	ENUM_PROPERTY(preview_shape_enum, SpaceNodeOverlay, preview_shape)


	BOOLEAN_PROPERTY(SpaceClipEditor, show_region_toolbar)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_region_ui)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_region_hud)
	POINTER_PROPERTY(MovieClip, SpaceClipEditor, clip)
	POINTER_PROPERTY(MovieClipUser, SpaceClipEditor, clip_user)
	POINTER_PROPERTY(Mask, SpaceClipEditor, mask)
	ENUM_PROPERTY(mask_display_type_enum, SpaceClipEditor, mask_display_type)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_mask_spline)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_mask_overlay)
	ENUM_PROPERTY(mask_overlay_mode_enum, SpaceClipEditor, mask_overlay_mode)
	FLOAT_PROPERTY(SpaceClipEditor, blend_factor)
	ENUM_PROPERTY(mode_enum, SpaceClipEditor, mode)
	ENUM_PROPERTY(view_enum, SpaceClipEditor, view)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_marker_pattern)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_marker_search)
	BOOLEAN_PROPERTY(SpaceClipEditor, lock_selection)
	BOOLEAN_PROPERTY(SpaceClipEditor, lock_time_cursor)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_track_path)
	INT_PROPERTY(SpaceClipEditor, path_length)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_tiny_markers)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_bundles)
	BOOLEAN_PROPERTY(SpaceClipEditor, use_mute_footage)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_disabled)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_metadata)
	POINTER_PROPERTY(MovieClipScopes, SpaceClipEditor, scopes)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_names)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_grid)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_stable)
	BOOLEAN_PROPERTY(SpaceClipEditor, use_manual_calibration)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_annotation)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_filters)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_frames)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_tracks_motion)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_tracks_error)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_only_selected)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_graph_hidden)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_red_channel)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_green_channel)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_blue_channel)
	BOOLEAN_PROPERTY(SpaceClipEditor, use_grayscale_preview)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_seconds)
	ENUM_PROPERTY(annotation_source_enum, SpaceClipEditor, annotation_source)
	FLOAT_ARRAY_PROPERTY(SpaceClipEditor, 2, cursor_location)
	ENUM_PROPERTY(pivot_point_enum, SpaceClipEditor, pivot_point)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_gizmo)
	BOOLEAN_PROPERTY(SpaceClipEditor, show_gizmo_navigate)


	BOOLEAN_PROPERTY(SpaceSpreadsheet, show_region_footer)
	BOOLEAN_PROPERTY(SpaceSpreadsheet, show_region_toolbar)
	BOOLEAN_PROPERTY(SpaceSpreadsheet, show_region_channels)
	BOOLEAN_PROPERTY(SpaceSpreadsheet, show_region_ui)
	BOOLEAN_PROPERTY(SpaceSpreadsheet, is_pinned)
	BOOLEAN_PROPERTY(SpaceSpreadsheet, use_filter)
	BOOLEAN_PROPERTY(SpaceSpreadsheet, display_viewer_path_collapsed)
	POINTER_PROPERTY(ViewerPath, SpaceSpreadsheet, viewer_path)
	BOOLEAN_PROPERTY(SpaceSpreadsheet, show_only_selected)
	ENUM_PROPERTY(geometry_component_type_enum, SpaceSpreadsheet, geometry_component_type)
	ENUM_PROPERTY(attribute_domain_enum, SpaceSpreadsheet, attribute_domain)
	ENUM_PROPERTY(object_eval_state_enum, SpaceSpreadsheet, object_eval_state)




	POINTER_PROPERTY(Struct, SpreadsheetColumn, rna_type)
	ENUM_PROPERTY(data_type_enum, SpreadsheetColumn, data_type)
	POINTER_PROPERTY(SpreadsheetColumnID, SpreadsheetColumn, id)


	POINTER_PROPERTY(Struct, SpreadsheetColumnID, rna_type)
	STRING_PROPERTY(SpreadsheetColumnID, name)


	POINTER_PROPERTY(Struct, SpreadsheetRowFilter, rna_type)
	BOOLEAN_PROPERTY(SpreadsheetRowFilter, enabled)
	BOOLEAN_PROPERTY(SpreadsheetRowFilter, show_expanded)
	STRING_PROPERTY(SpreadsheetRowFilter, column_name)
	ENUM_PROPERTY(operation_enum, SpreadsheetRowFilter, operation)
	FLOAT_PROPERTY(SpreadsheetRowFilter, value_float)
	FLOAT_ARRAY_PROPERTY(SpreadsheetRowFilter, 2, value_float2)
	FLOAT_ARRAY_PROPERTY(SpreadsheetRowFilter, 3, value_float3)
	FLOAT_ARRAY_PROPERTY(SpreadsheetRowFilter, 4, value_color)
	STRING_PROPERTY(SpreadsheetRowFilter, value_string)
	FLOAT_PROPERTY(SpreadsheetRowFilter, threshold)
	INT_PROPERTY(SpreadsheetRowFilter, value_int)
	INT_PROPERTY(SpreadsheetRowFilter, value_int8)
	INT_ARRAY_PROPERTY(SpreadsheetRowFilter, 2, value_int2)
	BOOLEAN_PROPERTY(SpreadsheetRowFilter, value_boolean)


	BOOLEAN_PROPERTY(Speaker, muted)
	POINTER_PROPERTY(Sound, Speaker, sound)
	FLOAT_PROPERTY(Speaker, volume_max)
	FLOAT_PROPERTY(Speaker, volume_min)
	FLOAT_PROPERTY(Speaker, distance_max)
	FLOAT_PROPERTY(Speaker, distance_reference)
	FLOAT_PROPERTY(Speaker, attenuation)
	FLOAT_PROPERTY(Speaker, cone_angle_outer)
	FLOAT_PROPERTY(Speaker, cone_angle_inner)
	FLOAT_PROPERTY(Speaker, cone_volume_outer)
	FLOAT_PROPERTY(Speaker, volume)
	FLOAT_PROPERTY(Speaker, pitch)
	POINTER_PROPERTY(AnimData, Speaker, animation_data)


	POINTER_PROPERTY(Struct, TextLine, rna_type)
	STRING_PROPERTY(TextLine, body)


	STRING_PROPERTY(Text, filepath)
	BOOLEAN_PROPERTY(Text, is_dirty)
	BOOLEAN_PROPERTY(Text, is_modified)
	BOOLEAN_PROPERTY(Text, is_in_memory)
	BOOLEAN_PROPERTY(Text, use_module)
	ENUM_PROPERTY(indentation_enum, Text, indentation)

	POINTER_PROPERTY(TextLine, Text, current_line)
	INT_PROPERTY(Text, current_character)
	INT_PROPERTY(Text, current_line_index)
	POINTER_PROPERTY(TextLine, Text, select_end_line)
	INT_PROPERTY(Text, select_end_line_index)
	INT_PROPERTY(Text, select_end_character)

	inline void Text::clear() {
		Text_clear_func((::Text *) this->ptr.data);
	}

	inline void Text::write(const char * text) {
		Text_write_func((::Text *) this->ptr.data, text);
	}

	inline void Text::from_string(const char * text) {
		Text_from_string_func((::Text *) this->ptr.data, text);
	}

	inline void Text::as_string(int *text_len, const char * *text) {
		Text_as_string_func((::Text *) this->ptr.data, text_len, text);
	}

	inline bool Text::is_syntax_highlight_supported() {
		return Text_is_syntax_highlight_supported_func((::Text *) this->ptr.data);
	}

	inline void Text::select_set(int line_start, int char_start, int line_end, int char_end) {
		Text_select_set_func((::Text *) this->ptr.data, line_start, char_start, line_end, char_end);
	}

	inline void Text::cursor_set(int line, int character, bool select) {
		Text_cursor_set_func((::Text *) this->ptr.data, line, character, select);
	}


	POINTER_PROPERTY(Struct, TimelineMarker, rna_type)
	STRING_PROPERTY(TimelineMarker, name)
	INT_PROPERTY(TimelineMarker, frame)
	BOOLEAN_PROPERTY(TimelineMarker, select)
	POINTER_PROPERTY(Object, TimelineMarker, camera)


	STRING_PROPERTY(Sound, filepath)
	POINTER_PROPERTY(PackedFile, Sound, packed_file)
	BOOLEAN_PROPERTY(Sound, use_memory_cache)
	BOOLEAN_PROPERTY(Sound, use_mono)
	INT_PROPERTY(Sound, samplerate)
	ENUM_PROPERTY(channels_enum, Sound, channels)

	inline void Sound::pack(void *main) {
		Sound_pack_func((::bSound *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline void Sound::unpack(void *main, int method) {
		Sound_unpack_func((::bSound *) this->ptr.data, (::Main *) main, nullptr, method);
	}


	POINTER_PROPERTY(Struct, UILayout, rna_type)
	BOOLEAN_PROPERTY(UILayout, active)
	BOOLEAN_PROPERTY(UILayout, active_default)
	BOOLEAN_PROPERTY(UILayout, activate_init)
	ENUM_PROPERTY(operator_context_enum, UILayout, operator_context)
	BOOLEAN_PROPERTY(UILayout, enabled)
	BOOLEAN_PROPERTY(UILayout, alert)
	ENUM_PROPERTY(alignment_enum, UILayout, alignment)
	ENUM_PROPERTY(direction_enum, UILayout, direction)
	FLOAT_PROPERTY(UILayout, scale_x)
	FLOAT_PROPERTY(UILayout, scale_y)
	FLOAT_PROPERTY(UILayout, ui_units_x)
	FLOAT_PROPERTY(UILayout, ui_units_y)
	ENUM_PROPERTY(emboss_enum, UILayout, emboss)
	BOOLEAN_PROPERTY(UILayout, use_property_split)
	BOOLEAN_PROPERTY(UILayout, use_property_decorate)

	inline UILayout UILayout::row(bool align, const char * heading, const char * heading_ctxt, bool translate) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_row_func((::uiLayout *) this->ptr.data, align, heading, heading_ctxt, translate);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UILayout, retdata);
		return UILayout(result);
	}

	inline UILayout UILayout::column(bool align, const char * heading, const char * heading_ctxt, bool translate) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_column_func((::uiLayout *) this->ptr.data, align, heading, heading_ctxt, translate);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UILayout, retdata);
		return UILayout(result);
	}

	inline UILayout UILayout::column_flow(int columns, bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_column_flow_func((::uiLayout *) this->ptr.data, columns, align);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UILayout, retdata);
		return UILayout(result);
	}

	inline UILayout UILayout::grid_flow(bool row_major, int columns, bool even_columns, bool even_rows, bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_grid_flow_func((::uiLayout *) this->ptr.data, row_major, columns, even_columns, even_rows, align);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UILayout, retdata);
		return UILayout(result);
	}

	inline UILayout UILayout::box() {
		PointerRNA result;
		::uiLayout *retdata = UILayout_box_func((::uiLayout *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UILayout, retdata);
		return UILayout(result);
	}

	inline UILayout UILayout::split(float factor, bool align) {
		PointerRNA result;
		::uiLayout *retdata = UILayout_split_func((::uiLayout *) this->ptr.data, factor, align);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UILayout, retdata);
		return UILayout(result);
	}

	inline UILayout UILayout::menu_pie() {
		PointerRNA result;
		::uiLayout *retdata = UILayout_menu_pie_func((::uiLayout *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UILayout, retdata);
		return UILayout(result);
	}

	inline int UILayout::icon(Context C, AnyType& data) {
		return UILayout_icon_func((::bContext *) C.ptr.data, (::PointerRNA *) &data);
	}

	inline const char * UILayout::enum_item_name(Context C, AnyType& data, const char * property, const char * identifier) {
		return UILayout_enum_item_name_func((::bContext *) C.ptr.data, (::PointerRNA *) &data, property, identifier);
	}

	inline const char * UILayout::enum_item_description(Context C, AnyType& data, const char * property, const char * identifier) {
		return UILayout_enum_item_description_func((::bContext *) C.ptr.data, (::PointerRNA *) &data, property, identifier);
	}

	inline int UILayout::enum_item_icon(Context C, AnyType& data, const char * property, const char * identifier) {
		return UILayout_enum_item_icon_func((::bContext *) C.ptr.data, (::PointerRNA *) &data, property, identifier);
	}

	inline void UILayout::prop(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, const char * placeholder, bool expand, bool slider, int toggle, bool icon_only, bool event, bool full_event, bool emboss, int index, int icon_value, bool invert_checkbox) {
		UILayout_prop_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, text, text_ctxt, translate, icon, placeholder, expand, slider, toggle, icon_only, event, full_event, emboss, index, icon_value, invert_checkbox);
	}

	inline void UILayout::props_enum(AnyType& data, const char * property) {
		UILayout_props_enum_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::prop_menu_enum(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon) {
		UILayout_prop_menu_enum_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, text, text_ctxt, translate, icon);
	}

	inline void UILayout::prop_with_popover(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * panel) {
		UILayout_prop_with_popover_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, text, text_ctxt, translate, icon, icon_only, panel);
	}

	inline void UILayout::prop_with_menu(AnyType& data, const char * property, const char * text, const char * text_ctxt, bool translate, int icon, bool icon_only, const char * menu) {
		UILayout_prop_with_menu_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, text, text_ctxt, translate, icon, icon_only, menu);
	}

	inline void UILayout::prop_tabs_enum(Context C, AnyType& data, const char * property, AnyType& data_highlight, const char * property_highlight, bool icon_only) {
		UILayout_prop_tabs_enum_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &data_highlight, property_highlight, icon_only);
	}

	inline void UILayout::prop_enum(AnyType& data, const char * property, const char * value, const char * text, const char * text_ctxt, bool translate, int icon) {
		UILayout_prop_enum_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, value, text, text_ctxt, translate, icon);
	}

	inline void UILayout::prop_search(AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * text, const char * text_ctxt, bool translate, int icon, bool results_are_suggestions) {
		UILayout_prop_search_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &search_data, search_property, text, text_ctxt, translate, icon, results_are_suggestions);
	}

	inline void UILayout::prop_decorator(AnyType& data, const char * property, int index) {
		UILayout_prop_decorator_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, index);
	}

	inline OperatorProperties UILayout::operator_value(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value) {
		PointerRNA result;
		result = UILayout_operator_func((::uiLayout *) this->ptr.data, operator_value, text, text_ctxt, translate, icon, emboss, depress, icon_value);
		return OperatorProperties(result);
	}

	inline OperatorProperties UILayout::operator_menu_hold(const char * operator_value, const char * text, const char * text_ctxt, bool translate, int icon, bool emboss, bool depress, int icon_value, const char * menu) {
		PointerRNA result;
		result = UILayout_operator_menu_hold_func((::uiLayout *) this->ptr.data, operator_value, text, text_ctxt, translate, icon, emboss, depress, icon_value, menu);
		return OperatorProperties(result);
	}

	inline void UILayout::operator_enum(const char * operator_value, const char * property, bool icon_only) {
		UILayout_operator_enum_func((::uiLayout *) this->ptr.data, operator_value, property, icon_only);
	}

	inline OperatorProperties UILayout::operator_menu_enum(Context C, const char * operator_value, const char * property, const char * text, const char * text_ctxt, bool translate, int icon) {
		PointerRNA result;
		result = UILayout_operator_menu_enum_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, operator_value, property, text, text_ctxt, translate, icon);
		return OperatorProperties(result);
	}

	inline void UILayout::label(const char * text, const char * text_ctxt, bool translate, int icon, int icon_value) {
		UILayout_label_func((::uiLayout *) this->ptr.data, text, text_ctxt, translate, icon, icon_value);
	}

	inline void UILayout::menu(const char * menu, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value) {
		UILayout_menu_func((::uiLayout *) this->ptr.data, menu, text, text_ctxt, translate, icon, icon_value);
	}

	inline void UILayout::menu_contents(const char * menu) {
		UILayout_menu_contents_func((::uiLayout *) this->ptr.data, menu);
	}

	inline void UILayout::popover(Context C, const char * panel, const char * text, const char * text_ctxt, bool translate, int icon, int icon_value) {
		UILayout_popover_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, panel, text, text_ctxt, translate, icon, icon_value);
	}

	inline void UILayout::popover_group(Context C, int space_type, int region_type, const char * context, const char * category) {
		UILayout_popover_group_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, space_type, region_type, context, category);
	}

	inline void UILayout::separator(float factor) {
		UILayout_separator_func((::uiLayout *) this->ptr.data, factor);
	}

	inline void UILayout::separator_spacer() {
		UILayout_separator_spacer_func((::uiLayout *) this->ptr.data);
	}

	inline void UILayout::progress(const char * text, const char * text_ctxt, bool translate, float factor, int type) {
		UILayout_progress_func((::uiLayout *) this->ptr.data, text, text_ctxt, translate, factor, type);
	}

	inline void UILayout::context_pointer_set(const char * name, AnyType& data) {
		UILayout_context_pointer_set_func((::uiLayout *) this->ptr.data, name, (::PointerRNA *) &data);
	}

	inline void UILayout::template_header(Context C) {
		UILayout_template_header_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_ID(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int filter, bool live_icon, const char * text, const char * text_ctxt, bool translate) {
		UILayout_template_ID_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, create, open, unlink, filter, live_icon, text, text_ctxt, translate);
	}

	inline void UILayout::template_ID_preview(Context C, AnyType& data, const char * property, const char * create, const char * open, const char * unlink, int rows, int cols, int filter, bool hide_buttons) {
		UILayout_template_ID_preview_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, create, open, unlink, rows, cols, filter, hide_buttons);
	}

	inline void UILayout::template_any_ID(AnyType& data, const char * property, const char * type_property, const char * text, const char * text_ctxt, bool translate) {
		UILayout_template_any_ID_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, type_property, text, text_ctxt, translate);
	}

	inline void UILayout::template_ID_tabs(Context C, AnyType& data, const char * property, const char * create, const char * menu, int filter) {
		UILayout_template_ID_tabs_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, create, menu, filter);
	}

	inline void UILayout::template_search(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink) {
		UILayout_template_search_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &search_data, search_property, create, unlink);
	}

	inline void UILayout::template_search_preview(Context C, AnyType& data, const char * property, AnyType& search_data, const char * search_property, const char * create, const char * unlink, int rows, int cols) {
		UILayout_template_search_preview_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &search_data, search_property, create, unlink, rows, cols);
	}

	inline void UILayout::template_path_builder(AnyType& data, const char * property, ID& root, const char * text, const char * text_ctxt, bool translate) {
		UILayout_template_path_builder_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &root, text, text_ctxt, translate);
	}

	inline void UILayout::template_modifiers(Context C) {
		UILayout_template_modifiers_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_constraints(Context C, bool use_bone_constraints) {
		UILayout_template_constraints_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, use_bone_constraints);
	}

	inline void UILayout::template_grease_pencil_modifiers(Context C) {
		UILayout_template_grease_pencil_modifiers_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_shaderfx(Context C) {
		UILayout_template_shaderfx_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_greasepencil_color(Context C, AnyType& data, const char * property, int rows, int cols, float scale, int filter) {
		UILayout_template_greasepencil_color_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, rows, cols, scale, filter);
	}

	inline void UILayout::template_constraint_header(Constraint& data) {
		UILayout_template_constraint_header_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data);
	}

	inline void UILayout::template_preview(Context C, ID& id, bool show_buttons, ID& parent, TextureSlot& slot, const char * preview_id) {
		UILayout_template_preview_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::ID *) id.ptr.data, show_buttons, (::ID *) parent.ptr.data, (::MTex *) slot.ptr.data, preview_id);
	}

	inline void UILayout::template_curve_mapping(AnyType& data, const char * property, int type, bool levels, bool brush, bool use_negative_slope, bool show_tone) {
		UILayout_template_curve_mapping_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, type, levels, brush, use_negative_slope, show_tone);
	}

	inline void UILayout::template_curveprofile(AnyType& data, const char * property) {
		UILayout_template_curveprofile_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_color_ramp(AnyType& data, const char * property, bool expand) {
		UILayout_template_color_ramp_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, expand);
	}

	inline void UILayout::template_icon(int icon_value, float scale) {
		UILayout_template_icon_func((::uiLayout *) this->ptr.data, icon_value, scale);
	}

	inline void UILayout::template_icon_view(AnyType& data, const char * property, bool show_labels, float scale, float scale_popup) {
		UILayout_template_icon_view_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, show_labels, scale, scale_popup);
	}

	inline void UILayout::template_histogram(AnyType& data, const char * property) {
		UILayout_template_histogram_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_waveform(AnyType& data, const char * property) {
		UILayout_template_waveform_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_vectorscope(AnyType& data, const char * property) {
		UILayout_template_vectorscope_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_layers(AnyType& data, const char * property, AnyType& used_layers_data, const char * used_layers_property, int active_layer) {
		UILayout_template_layers_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &used_layers_data, used_layers_property, active_layer);
	}

	inline void UILayout::template_color_picker(AnyType& data, const char * property, bool value_slider, bool lock, bool lock_luminosity, bool cubic) {
		UILayout_template_color_picker_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, value_slider, lock, lock_luminosity, cubic);
	}

	inline void UILayout::template_palette(AnyType& data, const char * property, bool color) {
		UILayout_template_palette_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, color);
	}

	inline void UILayout::template_image_layers(Context C, Image& image, ImageUser& image_user) {
		UILayout_template_image_layers_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::Image *) image.ptr.data, (::ImageUser *) image_user.ptr.data);
	}

	inline void UILayout::template_image(Context C, AnyType& data, const char * property, ImageUser& image_user, bool compact, bool multiview) {
		UILayout_template_image_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &image_user, compact, multiview);
	}

	inline void UILayout::template_image_settings(ImageFormatSettings& image_settings, bool color_management) {
		UILayout_template_image_settings_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &image_settings, color_management);
	}

	inline void UILayout::template_image_stereo_3d(Stereo3dFormat& stereo_3d_format) {
		UILayout_template_image_stereo_3d_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &stereo_3d_format);
	}

	inline void UILayout::template_image_views(ImageFormatSettings& image_settings) {
		UILayout_template_image_views_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &image_settings);
	}

	inline void UILayout::template_movieclip(Context C, AnyType& data, const char * property, bool compact) {
		UILayout_template_movieclip_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property, compact);
	}

	inline void UILayout::template_track(AnyType& data, const char * property) {
		UILayout_template_track_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_marker(AnyType& data, const char * property, MovieClipUser& clip_user, MovieTrackingTrack& track, bool compact) {
		UILayout_template_marker_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &clip_user, (::PointerRNA *) &track, compact);
	}

	inline void UILayout::template_movieclip_information(AnyType& data, const char * property, MovieClipUser& clip_user) {
		UILayout_template_movieclip_information_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, (::PointerRNA *) &clip_user);
	}

	inline void UILayout::template_list(Context C, const char * listtype_name, const char * list_id, AnyType& dataptr, const char * propname, AnyType& active_dataptr, const char * active_propname, const char * item_dyntip_propname, int rows, int maxrows, int type, int columns, bool sort_reverse, bool sort_lock) {
		UILayout_template_list_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, listtype_name, list_id, (::PointerRNA *) &dataptr, propname, (::PointerRNA *) &active_dataptr, active_propname, item_dyntip_propname, rows, maxrows, type, columns, sort_reverse, sort_lock);
	}

	inline void UILayout::template_running_jobs(Context C) {
		UILayout_template_running_jobs_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_operator_search() {
		UILayout_template_operator_search_func((::uiLayout *) this->ptr.data);
	}

	inline void UILayout::template_menu_search() {
		UILayout_template_menu_search_func((::uiLayout *) this->ptr.data);
	}

	inline void UILayout::template_header_3D_mode(Context C) {
		UILayout_template_header_3D_mode_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_edit_mode_selection(Context C) {
		UILayout_template_edit_mode_selection_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_reports_banner(Context C) {
		UILayout_template_reports_banner_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_input_status(Context C) {
		UILayout_template_input_status_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_status_info(Context C) {
		UILayout_template_status_info_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_node_link(Context C, NodeTree& ntree, Node& node, NodeSocket& socket) {
		UILayout_template_node_link_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::bNodeTree *) ntree.ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}

	inline void UILayout::template_node_view(Context C, NodeTree& ntree, Node& node, NodeSocket& socket) {
		UILayout_template_node_view_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::bNodeTree *) ntree.ptr.data, (::bNode *) node.ptr.data, (::bNodeSocket *) socket.ptr.data);
	}

	inline void UILayout::template_node_asset_menu_items(Context C, const char * catalog_path) {
		UILayout_template_node_asset_menu_items_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, catalog_path);
	}

	inline void UILayout::template_modifier_asset_menu_items(Context C, const char * catalog_path) {
		UILayout_template_modifier_asset_menu_items_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, catalog_path);
	}

	inline void UILayout::template_node_operator_asset_menu_items(Context C, const char * catalog_path) {
		UILayout_template_node_operator_asset_menu_items_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, catalog_path);
	}

	inline void UILayout::template_node_operator_asset_root_items(Context C) {
		UILayout_template_node_operator_asset_root_items_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_texture_user(Context C) {
		UILayout_template_texture_user_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_keymap_item_properties(KeyMapItem& item) {
		UILayout_template_keymap_item_properties_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &item);
	}

	inline void UILayout::template_component_menu(AnyType& data, const char * property, const char * name) {
		UILayout_template_component_menu_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property, name);
	}

	inline void UILayout::template_colorspace_settings(AnyType& data, const char * property) {
		UILayout_template_colorspace_settings_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_colormanaged_view_settings(Context C, AnyType& data, const char * property) {
		UILayout_template_colormanaged_view_settings_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_node_socket(Context C, float color[4]) {
		UILayout_template_node_socket_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, color);
	}

	inline void UILayout::template_cache_file(Context C, AnyType& data, const char * property) {
		UILayout_template_cache_file_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_cache_file_velocity(AnyType& data, const char * property) {
		UILayout_template_cache_file_velocity_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_cache_file_procedural(Context C, AnyType& data, const char * property) {
		UILayout_template_cache_file_procedural_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_cache_file_time_settings(AnyType& data, const char * property) {
		UILayout_template_cache_file_time_settings_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_cache_file_layers(Context C, AnyType& data, const char * property) {
		UILayout_template_cache_file_layers_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::PointerRNA *) &data, property);
	}

	inline int UILayout::template_recent_files(int rows) {
		return UILayout_template_recent_files_func((::uiLayout *) this->ptr.data, rows);
	}

	inline void UILayout::template_file_select_path(Context C, FileSelectParams& params) {
		UILayout_template_file_select_path_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, (::FileSelectParams *) params.ptr.data);
	}

	inline void UILayout::template_event_from_keymap_item(KeyMapItem& item, const char * text, const char * text_ctxt, bool translate) {
		UILayout_template_event_from_keymap_item_func((::uiLayout *) this->ptr.data, (::wmKeyMapItem *) item.ptr.data, text, text_ctxt, translate);
	}

	inline void UILayout::template_asset_view(Context C, const char * list_id, AnyType& asset_library_dataptr, const char * asset_library_propname, AnyType& assets_dataptr, const char * assets_propname, AnyType& active_dataptr, const char * active_propname, int filter_id_types, int display_options, const char * activate_operator, OperatorProperties *activate_operator_properties, const char * drag_operator, OperatorProperties *drag_operator_properties) {
		UILayout_template_asset_view_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data, list_id, (::PointerRNA *) &asset_library_dataptr, asset_library_propname, (::PointerRNA *) &assets_dataptr, assets_propname, (::PointerRNA *) &active_dataptr, active_propname, filter_id_types, display_options, activate_operator, &activate_operator_properties->ptr, drag_operator, &drag_operator_properties->ptr);
	}

	inline void UILayout::template_light_linking_collection(UILayout& context_layout, AnyType& data, const char * property) {
		UILayout_template_light_linking_collection_func((::uiLayout *) this->ptr.data, (::uiLayout *) context_layout.ptr.data, (::PointerRNA *) &data, property);
	}

	inline void UILayout::template_grease_pencil_layer_tree(Context C) {
		UILayout_template_grease_pencil_layer_tree_func((::uiLayout *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void UILayout::template_node_tree_interface(NodeTreeInterface& interface) {
		UILayout_template_node_tree_interface_func((::uiLayout *) this->ptr.data, (::PointerRNA *) &interface);
	}


	POINTER_PROPERTY(Struct, Panel, rna_type)
	POINTER_PROPERTY(UILayout, Panel, layout)
	STRING_PROPERTY(Panel, text)
	POINTER_PROPERTY(Constraint, Panel, custom_data)
	STRING_PROPERTY(Panel, bl_idname)
	STRING_PROPERTY(Panel, bl_label)
	STRING_PROPERTY(Panel, bl_translation_context)
	STRING_PROPERTY(Panel, bl_description)
	STRING_PROPERTY(Panel, bl_category)
	STRING_PROPERTY(Panel, bl_owner_id)
	ENUM_PROPERTY(bl_space_type_enum, Panel, bl_space_type)
	ENUM_PROPERTY(bl_region_type_enum, Panel, bl_region_type)
	STRING_PROPERTY(Panel, bl_context)
	ENUM_PROPERTY(bl_options_enum, Panel, bl_options)
	STRING_PROPERTY(Panel, bl_parent_id)
	INT_PROPERTY(Panel, bl_ui_units_x)
	INT_PROPERTY(Panel, bl_order)
	BOOLEAN_PROPERTY(Panel, use_pin)
	BOOLEAN_PROPERTY(Panel, is_popover)


	POINTER_PROPERTY(Struct, UIList, rna_type)
	STRING_PROPERTY(UIList, bl_idname)
	STRING_PROPERTY(UIList, list_id)
	ENUM_PROPERTY(layout_type_enum, UIList, layout_type)
	BOOLEAN_PROPERTY(UIList, use_filter_show)
	STRING_PROPERTY(UIList, filter_name)
	BOOLEAN_PROPERTY(UIList, use_filter_invert)
	BOOLEAN_PROPERTY(UIList, use_filter_sort_alpha)
	BOOLEAN_PROPERTY(UIList, use_filter_sort_reverse)
	BOOLEAN_PROPERTY(UIList, use_filter_sort_lock)
	INT_PROPERTY(UIList, bitflag_filter_item)


	POINTER_PROPERTY(Struct, Header, rna_type)
	POINTER_PROPERTY(UILayout, Header, layout)
	STRING_PROPERTY(Header, bl_idname)
	ENUM_PROPERTY(bl_space_type_enum, Header, bl_space_type)
	ENUM_PROPERTY(bl_region_type_enum, Header, bl_region_type)


	POINTER_PROPERTY(Struct, Menu, rna_type)
	POINTER_PROPERTY(UILayout, Menu, layout)
	STRING_PROPERTY(Menu, bl_idname)
	STRING_PROPERTY(Menu, bl_label)
	STRING_PROPERTY(Menu, bl_translation_context)
	STRING_PROPERTY(Menu, bl_description)
	STRING_PROPERTY(Menu, bl_owner_id)
	ENUM_PROPERTY(bl_options_enum, Menu, bl_options)


	POINTER_PROPERTY(Struct, AssetShelf, rna_type)
	STRING_PROPERTY(AssetShelf, bl_idname)
	ENUM_PROPERTY(bl_space_type_enum, AssetShelf, bl_space_type)
	ENUM_PROPERTY(bl_options_enum, AssetShelf, bl_options)
	ENUM_PROPERTY(asset_library_reference_enum, AssetShelf, asset_library_reference)
	BOOLEAN_PROPERTY(AssetShelf, show_names)
	INT_PROPERTY(AssetShelf, preview_size)
	STRING_PROPERTY(AssetShelf, search_filter)


	POINTER_PROPERTY(Struct, USDHook, rna_type)
	STRING_PROPERTY(USDHook, bl_idname)
	STRING_PROPERTY(USDHook, bl_label)
	STRING_PROPERTY(USDHook, bl_description)


	POINTER_PROPERTY(Struct, ThemeFontStyle, rna_type)
	FLOAT_PROPERTY(ThemeFontStyle, points)
	INT_PROPERTY(ThemeFontStyle, character_weight)
	INT_PROPERTY(ThemeFontStyle, shadow)
	INT_PROPERTY(ThemeFontStyle, shadow_offset_x)
	INT_PROPERTY(ThemeFontStyle, shadow_offset_y)
	FLOAT_PROPERTY(ThemeFontStyle, shadow_alpha)
	FLOAT_PROPERTY(ThemeFontStyle, shadow_value)


	POINTER_PROPERTY(Struct, ThemeStyle, rna_type)
	POINTER_PROPERTY(ThemeFontStyle, ThemeStyle, panel_title)
	POINTER_PROPERTY(ThemeFontStyle, ThemeStyle, widget_label)
	POINTER_PROPERTY(ThemeFontStyle, ThemeStyle, widget)


	POINTER_PROPERTY(Struct, ThemeWidgetColors, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 4, outline)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 4, inner)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 4, inner_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 4, item)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 3, text)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetColors, 3, text_sel)
	BOOLEAN_PROPERTY(ThemeWidgetColors, show_shaded)
	INT_PROPERTY(ThemeWidgetColors, shadetop)
	INT_PROPERTY(ThemeWidgetColors, shadedown)
	FLOAT_PROPERTY(ThemeWidgetColors, roundness)


	POINTER_PROPERTY(Struct, ThemeWidgetStateColors, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_anim)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_anim_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_key)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_key_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_driven)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_driven_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_overridden)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_overridden_sel)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_changed)
	FLOAT_ARRAY_PROPERTY(ThemeWidgetStateColors, 3, inner_changed_sel)
	FLOAT_PROPERTY(ThemeWidgetStateColors, blend)


	POINTER_PROPERTY(Struct, ThemePanelColors, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemePanelColors, 4, header)
	FLOAT_ARRAY_PROPERTY(ThemePanelColors, 4, back)
	FLOAT_ARRAY_PROPERTY(ThemePanelColors, 4, sub_back)


	POINTER_PROPERTY(Struct, ThemeGradientColors, rna_type)
	ENUM_PROPERTY(background_type_enum, ThemeGradientColors, background_type)
	FLOAT_ARRAY_PROPERTY(ThemeGradientColors, 3, high_gradient)
	FLOAT_ARRAY_PROPERTY(ThemeGradientColors, 3, gradient)


	POINTER_PROPERTY(Struct, ThemeUserInterface, rna_type)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_regular)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_tool)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_toolbar_item)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_radio)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_text)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_option)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_toggle)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_num)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_numslider)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_box)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_menu)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_pulldown)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_menu_back)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_pie_menu)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_tooltip)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_menu_item)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_scroll)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_progress)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_list_item)
	POINTER_PROPERTY(ThemeWidgetStateColors, ThemeUserInterface, wcol_state)
	POINTER_PROPERTY(ThemeWidgetColors, ThemeUserInterface, wcol_tab)
	FLOAT_PROPERTY(ThemeUserInterface, menu_shadow_fac)
	INT_PROPERTY(ThemeUserInterface, menu_shadow_width)
	FLOAT_PROPERTY(ThemeUserInterface, icon_alpha)
	FLOAT_PROPERTY(ThemeUserInterface, icon_saturation)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, widget_emboss)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, editor_outline)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, widget_text_cursor)
	FLOAT_PROPERTY(ThemeUserInterface, panel_roundness)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, transparent_checker_primary)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, transparent_checker_secondary)
	INT_PROPERTY(ThemeUserInterface, transparent_checker_size)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, axis_x)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, axis_y)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, axis_z)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_hi)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_primary)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_secondary)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_view_align)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_a)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 3, gizmo_b)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_scene)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_collection)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_object)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_object_data)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_modifier)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_shading)
	FLOAT_ARRAY_PROPERTY(ThemeUserInterface, 4, icon_folder)
	FLOAT_PROPERTY(ThemeUserInterface, icon_border_intensity)


	POINTER_PROPERTY(Struct, ThemeSpaceGeneric, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, back)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, header)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, header_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, header_text_hi)
	POINTER_PROPERTY(ThemePanelColors, ThemeSpaceGeneric, panelcolors)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, button)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, button_title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, button_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, button_text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, navigation_bar)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, execution_buts)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, tab_active)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 3, tab_inactive)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, tab_back)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGeneric, 4, tab_outline)


	POINTER_PROPERTY(Struct, ThemeSpaceGradient, rna_type)
	POINTER_PROPERTY(ThemeGradientColors, ThemeSpaceGradient, gradients)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, header)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, header_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, header_text_hi)
	POINTER_PROPERTY(ThemePanelColors, ThemeSpaceGradient, panelcolors)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, button)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, button_title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, button_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, button_text_hi)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, navigation_bar)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, execution_buts)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, tab_active)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 3, tab_inactive)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, tab_back)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceGradient, 4, tab_outline)


	POINTER_PROPERTY(Struct, ThemeSpaceListGeneric, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list_title)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list_text)
	FLOAT_ARRAY_PROPERTY(ThemeSpaceListGeneric, 3, list_text_hi)


	POINTER_PROPERTY(Struct, ThemeAssetShelf, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeAssetShelf, 4, header_back)
	FLOAT_ARRAY_PROPERTY(ThemeAssetShelf, 4, back)


	POINTER_PROPERTY(Struct, ThemeView3D, rna_type)
	POINTER_PROPERTY(ThemeSpaceGradient, ThemeView3D, space)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, grid)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, clipping_border_3d)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, wire)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, wire_edit)
	INT_PROPERTY(ThemeView3D, edge_width)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, gp_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, gp_vertex_select)
	INT_PROPERTY(ThemeView3D, gp_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, text_grease_pencil)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, object_selected)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, object_active)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, text_keyframe)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, camera)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, empty)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, light)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, speaker)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_select)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_active)
	INT_PROPERTY(ThemeView3D, vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_unreferenced)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_select)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_mode_select)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_seam)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_sharp)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_crease)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, edge_facesel)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, freestyle_edge_mark)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face_select)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face_mode_select)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, face_dot)
	INT_PROPERTY(ThemeView3D, facedot_size)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, freestyle_face_mark)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face_retopology)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face_back)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, face_front)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_uline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_vline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_sel_uline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, nurb_sel_vline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, act_spline)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_vect)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_vect)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, lastsel_point)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_edge_len)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_edge_angle)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_face_angle)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, extra_face_area)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, editmesh_active)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, normal)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, vertex_normal)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, split_normal)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bone_pose)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bone_pose_active)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bone_solid)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, bone_locked_weight)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, bundle_solid)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, camera_path)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, camera_passepartout)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, skin_root)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, view_overlay)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, transform)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, paint_curve_handle)
	FLOAT_ARRAY_PROPERTY(ThemeView3D, 4, paint_curve_pivot)
	INT_PROPERTY(ThemeView3D, outline_width)
	INT_PROPERTY(ThemeView3D, object_origin_size)
	POINTER_PROPERTY(ThemeAssetShelf, ThemeView3D, asset_shelf)


	POINTER_PROPERTY(Struct, ThemeGraphEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeGraphEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeGraphEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 4, time_scrub_background)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 4, time_marker_line)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 4, time_marker_line_selected)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, window_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, channels_region)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, dopesheet_channel)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, dopesheet_subchannel)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, channel_group)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, active_channels_group)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 4, preview_range)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex_select)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex_active)
	INT_PROPERTY(ThemeGraphEditor, vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, vertex_unreferenced)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_vect)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_vect)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_sel_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, lastsel_point)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeGraphEditor, 3, handle_vertex_select)
	INT_PROPERTY(ThemeGraphEditor, handle_vertex_size)


	POINTER_PROPERTY(Struct, ThemeFileBrowser, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeFileBrowser, space)
	FLOAT_ARRAY_PROPERTY(ThemeFileBrowser, 3, selected_file)
	FLOAT_ARRAY_PROPERTY(ThemeFileBrowser, 4, row_alternate)


	POINTER_PROPERTY(Struct, ThemeNLAEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeNLAEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeNLAEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, view_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, dopesheet_channel)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, dopesheet_subchannel)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, nla_track)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, active_action)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, active_action_unset)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, preview_range)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, transition_strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, transition_strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, meta_strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, meta_strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, sound_strips)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, sound_strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, tweak)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, tweak_duplicate)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, keyframe_border)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, keyframe_border_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, time_scrub_background)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, time_marker_line)
	FLOAT_ARRAY_PROPERTY(ThemeNLAEditor, 4, time_marker_line_selected)


	POINTER_PROPERTY(Struct, ThemeDopeSheet, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeDopeSheet, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeDopeSheet, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, time_scrub_background)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, time_marker_line)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, time_marker_line_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, value_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, view_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, dopesheet_channel)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, dopesheet_subchannel)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, channels)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, channels_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, channel_group)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, active_channels_group)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, long_key)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, long_key_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_extreme)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_extreme_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_breakdown)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_breakdown_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_jitter)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_jitter_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_movehold)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 3, keyframe_movehold_selected)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, keyframe_border)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, keyframe_border_selected)
	FLOAT_PROPERTY(ThemeDopeSheet, keyframe_scale_factor)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, summary)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, preview_range)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, interpolation_line)
	FLOAT_ARRAY_PROPERTY(ThemeDopeSheet, 4, simulated_frames)


	POINTER_PROPERTY(Struct, ThemeImageEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeImageEditor, space)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, grid)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex_select)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex_active)
	INT_PROPERTY(ThemeImageEditor, vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex_bevel)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, vertex_unreferenced)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face_select)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face_mode_select)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, face_dot)
	INT_PROPERTY(ThemeImageEditor, facedot_size)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, freestyle_face_mark)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face_retopology)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face_back)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, face_front)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, editmesh_active)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, wire_edit)
	INT_PROPERTY(ThemeImageEditor, edge_width)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, edge_select)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, scope_back)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_face)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_edge)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_vert)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_stitchable)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_unstitchable)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, preview_stitch_active)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, uv_shadow)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, metadatabg)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, metadatatext)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_sel_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 3, handle_vertex_select)
	INT_PROPERTY(ThemeImageEditor, handle_vertex_size)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, paint_curve_handle)
	FLOAT_ARRAY_PROPERTY(ThemeImageEditor, 4, paint_curve_pivot)


	POINTER_PROPERTY(Struct, ThemeSequenceEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeSequenceEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeSequenceEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, window_sliders)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, movie_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, movieclip_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, image_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, scene_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, audio_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, effect_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, transition_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, color_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, meta_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, mask_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, text_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, active_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, selected_strip)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 4, time_scrub_background)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 4, time_marker_line)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 4, time_marker_line_selected)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, keyframe)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, keyframe_selected)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, keyframe_breakdown)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, keyframe_breakdown_selected)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, keyframe_movehold)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, keyframe_movehold_selected)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 4, keyframe_border)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 4, keyframe_border_selected)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, draw_action)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, preview_back)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, metadatabg)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 3, metadatatext)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 4, preview_range)
	FLOAT_ARRAY_PROPERTY(ThemeSequenceEditor, 4, row_alternate)


	POINTER_PROPERTY(Struct, ThemeProperties, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeProperties, 3, match)
	FLOAT_ARRAY_PROPERTY(ThemeProperties, 4, active_modifier)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeProperties, space)


	POINTER_PROPERTY(Struct, ThemeTextEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeTextEditor, space)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, line_numbers)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, line_numbers_background)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, selected_text)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, cursor)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_builtin)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_symbols)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_special)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_preprocessor)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_reserved)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_comment)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_string)
	FLOAT_ARRAY_PROPERTY(ThemeTextEditor, 3, syntax_numbers)


	POINTER_PROPERTY(Struct, ThemeNodeEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeNodeEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeNodeEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, grid)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, node_selected)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, node_active)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, wire)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, wire_inner)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, wire_select)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, selected_text)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, node_backdrop)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, converter_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, color_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, group_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, group_socket_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, frame_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, matte_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, distor_node)
	INT_PROPERTY(ThemeNodeEditor, noodle_curving)
	INT_PROPERTY(ThemeNodeEditor, grid_levels)
	FLOAT_PROPERTY(ThemeNodeEditor, dash_alpha)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, input_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, output_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, filter_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, vector_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, texture_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, shader_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, script_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, pattern_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, layout_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, geometry_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 3, attribute_node)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, simulation_zone)
	FLOAT_ARRAY_PROPERTY(ThemeNodeEditor, 4, repeat_zone)


	POINTER_PROPERTY(Struct, ThemeOutliner, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeOutliner, space)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 3, match)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 3, selected_highlight)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 3, active)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 3, selected_object)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 3, active_object)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 4, edited_object)
	FLOAT_ARRAY_PROPERTY(ThemeOutliner, 4, row_alternate)


	POINTER_PROPERTY(Struct, ThemeInfo, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeInfo, space)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_selected)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_selected_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 4, info_error)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_error_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 4, info_warning)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_warning_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 4, info_info)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_info_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 4, info_debug)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_debug_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 4, info_property)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_property_text)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 4, info_operator)
	FLOAT_ARRAY_PROPERTY(ThemeInfo, 3, info_operator_text)


	POINTER_PROPERTY(Struct, ThemePreferences, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemePreferences, space)


	POINTER_PROPERTY(Struct, ThemeConsole, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeConsole, space)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_output)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_input)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_info)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, line_error)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 3, cursor)
	FLOAT_ARRAY_PROPERTY(ThemeConsole, 4, select)


	POINTER_PROPERTY(Struct, ThemeClipEditor, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeClipEditor, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeClipEditor, space_list)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 4, grid)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, marker_outline)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, active_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, selected_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, disabled_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, locked_marker)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, path_before)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, path_after)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, path_keyframe_before)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, path_keyframe_after)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, frame_current)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 4, time_scrub_background)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 4, time_marker_line)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 4, time_marker_line_selected)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, strips)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, strips_selected)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, metadatabg)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, metadatatext)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_free)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_auto)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_align)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_free)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_auto)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_align)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_sel_auto_clamped)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_vertex)
	FLOAT_ARRAY_PROPERTY(ThemeClipEditor, 3, handle_vertex_select)
	INT_PROPERTY(ThemeClipEditor, handle_vertex_size)


	POINTER_PROPERTY(Struct, ThemeTopBar, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeTopBar, space)


	POINTER_PROPERTY(Struct, ThemeStatusBar, rna_type)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeStatusBar, space)


	POINTER_PROPERTY(Struct, ThemeSpreadsheet, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeSpreadsheet, 4, row_alternate)
	POINTER_PROPERTY(ThemeSpaceGeneric, ThemeSpreadsheet, space)
	POINTER_PROPERTY(ThemeSpaceListGeneric, ThemeSpreadsheet, space_list)


	POINTER_PROPERTY(Struct, ThemeBoneColorSet, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeBoneColorSet, 3, normal)
	FLOAT_ARRAY_PROPERTY(ThemeBoneColorSet, 3, select)
	FLOAT_ARRAY_PROPERTY(ThemeBoneColorSet, 3, active)
	BOOLEAN_PROPERTY(ThemeBoneColorSet, show_colored_constraints)


	POINTER_PROPERTY(Struct, ThemeCollectionColor, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeCollectionColor, 3, color)


	POINTER_PROPERTY(Struct, ThemeStripColor, rna_type)
	FLOAT_ARRAY_PROPERTY(ThemeStripColor, 3, color)


	POINTER_PROPERTY(Struct, Theme, rna_type)
	STRING_PROPERTY(Theme, name)
	ENUM_PROPERTY(theme_area_enum, Theme, theme_area)
	POINTER_PROPERTY(ThemeUserInterface, Theme, user_interface)
	POINTER_PROPERTY(ThemeView3D, Theme, view_3d)
	POINTER_PROPERTY(ThemeGraphEditor, Theme, graph_editor)
	POINTER_PROPERTY(ThemeFileBrowser, Theme, file_browser)
	POINTER_PROPERTY(ThemeNLAEditor, Theme, nla_editor)
	POINTER_PROPERTY(ThemeDopeSheet, Theme, dopesheet_editor)
	POINTER_PROPERTY(ThemeImageEditor, Theme, image_editor)
	POINTER_PROPERTY(ThemeSequenceEditor, Theme, sequence_editor)
	POINTER_PROPERTY(ThemeProperties, Theme, properties)
	POINTER_PROPERTY(ThemeTextEditor, Theme, text_editor)
	POINTER_PROPERTY(ThemeNodeEditor, Theme, node_editor)
	POINTER_PROPERTY(ThemeOutliner, Theme, outliner)
	POINTER_PROPERTY(ThemeInfo, Theme, info)
	POINTER_PROPERTY(ThemePreferences, Theme, preferences)
	POINTER_PROPERTY(ThemeConsole, Theme, console)
	POINTER_PROPERTY(ThemeClipEditor, Theme, clip_editor)
	POINTER_PROPERTY(ThemeTopBar, Theme, topbar)
	POINTER_PROPERTY(ThemeStatusBar, Theme, statusbar)
	POINTER_PROPERTY(ThemeSpreadsheet, Theme, spreadsheet)





	POINTER_PROPERTY(Struct, UserSolidLight, rna_type)
	BOOLEAN_PROPERTY(UserSolidLight, use)
	FLOAT_PROPERTY(UserSolidLight, smooth)
	FLOAT_ARRAY_PROPERTY(UserSolidLight, 3, direction)
	FLOAT_ARRAY_PROPERTY(UserSolidLight, 3, specular_color)
	FLOAT_ARRAY_PROPERTY(UserSolidLight, 3, diffuse_color)


	POINTER_PROPERTY(Struct, WalkNavigation, rna_type)
	FLOAT_PROPERTY(WalkNavigation, mouse_speed)
	FLOAT_PROPERTY(WalkNavigation, walk_speed)
	FLOAT_PROPERTY(WalkNavigation, walk_speed_factor)
	FLOAT_PROPERTY(WalkNavigation, view_height)
	FLOAT_PROPERTY(WalkNavigation, jump_height)
	FLOAT_PROPERTY(WalkNavigation, teleport_time)
	BOOLEAN_PROPERTY(WalkNavigation, use_gravity)
	BOOLEAN_PROPERTY(WalkNavigation, use_mouse_reverse)


	POINTER_PROPERTY(Struct, Preferences, rna_type)
	ENUM_PROPERTY(active_section_enum, Preferences, active_section)
	STRING_PROPERTY(Preferences, app_template)




	BOOLEAN_PROPERTY(Preferences, use_recent_searches)
	POINTER_PROPERTY(PreferencesView, Preferences, view)
	POINTER_PROPERTY(PreferencesEdit, Preferences, edit)
	POINTER_PROPERTY(PreferencesInput, Preferences, inputs)
	POINTER_PROPERTY(PreferencesKeymap, Preferences, keymap)
	POINTER_PROPERTY(PreferencesFilePaths, Preferences, filepaths)
	POINTER_PROPERTY(PreferencesSystem, Preferences, system)
	POINTER_PROPERTY(PreferencesApps, Preferences, apps)
	POINTER_PROPERTY(PreferencesExperimental, Preferences, experimental)
	INT_ARRAY_PROPERTY(Preferences, 3, version)

	BOOLEAN_PROPERTY(Preferences, use_preferences_save)
	BOOLEAN_PROPERTY(Preferences, is_dirty)


	POINTER_PROPERTY(Struct, Addons, rna_type)

	inline Addon Addons::create() {
		PointerRNA result;
		::bAddon *retdata = Addons_new_func();
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Addon, retdata);
		return Addon(result);
	}

	inline void Addons::remove(Addon& addon) {
		Addons_remove_func(nullptr, (::PointerRNA *) &addon.ptr);
	}


	POINTER_PROPERTY(Struct, PathCompareCollection, rna_type)

	inline PathCompare PathCompareCollection::create() {
		PointerRNA result;
		::bPathCompare *retdata = PathCompareCollection_new_func();
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_PathCompare, retdata);
		return PathCompare(result);
	}

	inline void PathCompareCollection::remove(PathCompare& pathcmp) {
		PathCompareCollection_remove_func(nullptr, (::PointerRNA *) &pathcmp.ptr);
	}


	POINTER_PROPERTY(Struct, PreferencesView, rna_type)
	FLOAT_PROPERTY(PreferencesView, ui_scale)
	ENUM_PROPERTY(ui_line_width_enum, PreferencesView, ui_line_width)
	BOOLEAN_PROPERTY(PreferencesView, show_tooltips)
	BOOLEAN_PROPERTY(PreferencesView, show_tooltips_python)
	BOOLEAN_PROPERTY(PreferencesView, show_developer_ui)
	BOOLEAN_PROPERTY(PreferencesView, show_object_info)
	BOOLEAN_PROPERTY(PreferencesView, show_view_name)
	BOOLEAN_PROPERTY(PreferencesView, show_splash)
	BOOLEAN_PROPERTY(PreferencesView, show_playback_fps)
	INT_PROPERTY(PreferencesView, playback_fps_samples)
	BOOLEAN_PROPERTY(PreferencesView, use_fresnel_edit)
	BOOLEAN_PROPERTY(PreferencesView, show_addons_enabled_only)
	ENUM_PROPERTY(factor_display_type_enum, PreferencesView, factor_display_type)
	BOOLEAN_PROPERTY(PreferencesView, use_weight_color_range)
	POINTER_PROPERTY(ColorRamp, PreferencesView, weight_color_range)
	BOOLEAN_PROPERTY(PreferencesView, show_navigate_ui)
	BOOLEAN_PROPERTY(PreferencesView, use_mouse_over_open)
	INT_PROPERTY(PreferencesView, open_toplevel_delay)
	INT_PROPERTY(PreferencesView, open_sublevel_delay)
	ENUM_PROPERTY(color_picker_type_enum, PreferencesView, color_picker_type)
	INT_PROPERTY(PreferencesView, pie_initial_timeout)
	INT_PROPERTY(PreferencesView, pie_tap_timeout)
	INT_PROPERTY(PreferencesView, pie_animation_timeout)
	INT_PROPERTY(PreferencesView, pie_menu_radius)
	INT_PROPERTY(PreferencesView, pie_menu_threshold)
	INT_PROPERTY(PreferencesView, pie_menu_confirm)
	BOOLEAN_PROPERTY(PreferencesView, use_save_prompt)
	BOOLEAN_PROPERTY(PreferencesView, show_column_layout)
	ENUM_PROPERTY(header_align_enum, PreferencesView, header_align)
	ENUM_PROPERTY(render_display_type_enum, PreferencesView, render_display_type)
	ENUM_PROPERTY(filebrowser_display_type_enum, PreferencesView, filebrowser_display_type)
	ENUM_PROPERTY(mini_axis_type_enum, PreferencesView, mini_axis_type)
	INT_PROPERTY(PreferencesView, mini_axis_size)
	INT_PROPERTY(PreferencesView, mini_axis_brightness)
	INT_PROPERTY(PreferencesView, smooth_view)
	FLOAT_PROPERTY(PreferencesView, rotation_angle)
	BOOLEAN_PROPERTY(PreferencesView, show_gizmo)
	INT_PROPERTY(PreferencesView, gizmo_size)
	INT_PROPERTY(PreferencesView, gizmo_size_navigate_v3d)
	INT_PROPERTY(PreferencesView, lookdev_sphere_size)
	INT_PROPERTY(PreferencesView, view2d_grid_spacing_min)
	ENUM_PROPERTY(timecode_style_enum, PreferencesView, timecode_style)
	ENUM_PROPERTY(view_frame_type_enum, PreferencesView, view_frame_type)
	INT_PROPERTY(PreferencesView, view_frame_keyframes)
	FLOAT_PROPERTY(PreferencesView, view_frame_seconds)
	BOOLEAN_PROPERTY(PreferencesView, use_text_antialiasing)
	BOOLEAN_PROPERTY(PreferencesView, use_text_render_subpixelaa)
	ENUM_PROPERTY(text_hinting_enum, PreferencesView, text_hinting)
	STRING_PROPERTY(PreferencesView, font_path_ui)
	STRING_PROPERTY(PreferencesView, font_path_ui_mono)
	ENUM_PROPERTY(language_enum, PreferencesView, language)
	BOOLEAN_PROPERTY(PreferencesView, use_translate_tooltips)
	BOOLEAN_PROPERTY(PreferencesView, use_translate_interface)
	BOOLEAN_PROPERTY(PreferencesView, use_translate_new_dataname)
	BOOLEAN_PROPERTY(PreferencesView, show_statusbar_memory)
	BOOLEAN_PROPERTY(PreferencesView, show_statusbar_vram)
	BOOLEAN_PROPERTY(PreferencesView, show_statusbar_version)
	BOOLEAN_PROPERTY(PreferencesView, show_statusbar_stats)
	BOOLEAN_PROPERTY(PreferencesView, show_statusbar_scene_duration)


	POINTER_PROPERTY(Struct, PreferencesEdit, rna_type)
	ENUM_PROPERTY(material_link_enum, PreferencesEdit, material_link)
	ENUM_PROPERTY(object_align_enum, PreferencesEdit, object_align)
	BOOLEAN_PROPERTY(PreferencesEdit, use_enter_edit_mode)
	FLOAT_PROPERTY(PreferencesEdit, collection_instance_empty_size)
	BOOLEAN_PROPERTY(PreferencesEdit, use_text_edit_auto_close)
	INT_PROPERTY(PreferencesEdit, undo_steps)
	INT_PROPERTY(PreferencesEdit, undo_memory_limit)
	BOOLEAN_PROPERTY(PreferencesEdit, use_global_undo)
	BOOLEAN_PROPERTY(PreferencesEdit, use_auto_keying)
	ENUM_PROPERTY(auto_keying_mode_enum, PreferencesEdit, auto_keying_mode)
	BOOLEAN_PROPERTY(PreferencesEdit, use_keyframe_insert_available)
	BOOLEAN_PROPERTY(PreferencesEdit, use_auto_keying_warning)
	BOOLEAN_PROPERTY(PreferencesEdit, use_keyframe_insert_needed)
	BOOLEAN_PROPERTY(PreferencesEdit, use_visual_keying)
	BOOLEAN_PROPERTY(PreferencesEdit, use_insertkey_xyz_to_rgb)
	BOOLEAN_PROPERTY(PreferencesEdit, use_anim_channel_group_colors)
	ENUM_PROPERTY(fcurve_new_auto_smoothing_enum, PreferencesEdit, fcurve_new_auto_smoothing)
	ENUM_PROPERTY(keyframe_new_interpolation_type_enum, PreferencesEdit, keyframe_new_interpolation_type)
	ENUM_PROPERTY(keyframe_new_handle_type_enum, PreferencesEdit, keyframe_new_handle_type)
	BOOLEAN_PROPERTY(PreferencesEdit, use_negative_frames)
	FLOAT_PROPERTY(PreferencesEdit, fcurve_unselected_alpha)
	BOOLEAN_PROPERTY(PreferencesEdit, show_only_selected_curve_keyframes)
	BOOLEAN_PROPERTY(PreferencesEdit, use_fcurve_high_quality_drawing)
	INT_PROPERTY(PreferencesEdit, grease_pencil_manhattan_distance)
	INT_PROPERTY(PreferencesEdit, grease_pencil_euclidean_distance)
	INT_PROPERTY(PreferencesEdit, grease_pencil_eraser_radius)
	FLOAT_ARRAY_PROPERTY(PreferencesEdit, 4, grease_pencil_default_color)
	FLOAT_ARRAY_PROPERTY(PreferencesEdit, 3, sculpt_paint_overlay_color)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_mesh)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_surface)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_curve)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_lattice)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_text)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_metaball)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_armature)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_camera)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_speaker)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_light)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_material)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_action)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_particle)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_lightprobe)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_grease_pencil)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_curves)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_pointcloud)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_volume)
	BOOLEAN_PROPERTY(PreferencesEdit, use_duplicate_node_tree)
	BOOLEAN_PROPERTY(PreferencesEdit, node_use_insert_offset)
	INT_PROPERTY(PreferencesEdit, node_margin)
	INT_PROPERTY(PreferencesEdit, node_preview_resolution)
	BOOLEAN_PROPERTY(PreferencesEdit, use_cursor_lock_adjust)
	BOOLEAN_PROPERTY(PreferencesEdit, use_mouse_depth_cursor)


	POINTER_PROPERTY(Struct, PreferencesInput, rna_type)
	ENUM_PROPERTY(view_zoom_method_enum, PreferencesInput, view_zoom_method)
	ENUM_PROPERTY(view_zoom_axis_enum, PreferencesInput, view_zoom_axis)
	BOOLEAN_PROPERTY(PreferencesInput, use_multitouch_gestures)
	BOOLEAN_PROPERTY(PreferencesInput, invert_mouse_zoom)
	BOOLEAN_PROPERTY(PreferencesInput, use_mouse_depth_navigate)
	BOOLEAN_PROPERTY(PreferencesInput, use_zoom_to_mouse)
	BOOLEAN_PROPERTY(PreferencesInput, use_auto_perspective)
	BOOLEAN_PROPERTY(PreferencesInput, use_rotate_around_active)
	ENUM_PROPERTY(view_rotate_method_enum, PreferencesInput, view_rotate_method)
	BOOLEAN_PROPERTY(PreferencesInput, use_mouse_continuous)
	BOOLEAN_PROPERTY(PreferencesInput, use_drag_immediately)
	BOOLEAN_PROPERTY(PreferencesInput, use_numeric_input_advanced)
	ENUM_PROPERTY(navigation_mode_enum, PreferencesInput, navigation_mode)
	POINTER_PROPERTY(WalkNavigation, PreferencesInput, walk_navigation)
	FLOAT_PROPERTY(PreferencesInput, view_rotate_sensitivity_turntable)
	FLOAT_PROPERTY(PreferencesInput, view_rotate_sensitivity_trackball)
	INT_PROPERTY(PreferencesInput, drag_threshold_mouse)
	INT_PROPERTY(PreferencesInput, drag_threshold_tablet)
	INT_PROPERTY(PreferencesInput, drag_threshold)
	INT_PROPERTY(PreferencesInput, move_threshold)
	FLOAT_PROPERTY(PreferencesInput, pressure_threshold_max)
	FLOAT_PROPERTY(PreferencesInput, pressure_softness)
	ENUM_PROPERTY(tablet_api_enum, PreferencesInput, tablet_api)
	FLOAT_PROPERTY(PreferencesInput, ndof_sensitivity)
	FLOAT_PROPERTY(PreferencesInput, ndof_orbit_sensitivity)
	FLOAT_PROPERTY(PreferencesInput, ndof_deadzone)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_pan_yz_swap_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_zoom_invert)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_show_guide)
	ENUM_PROPERTY(ndof_view_navigate_method_enum, PreferencesInput, ndof_view_navigate_method)
	ENUM_PROPERTY(ndof_view_rotate_method_enum, PreferencesInput, ndof_view_rotate_method)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_rotx_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_roty_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_rotz_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_panx_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_pany_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_panz_invert_axis)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_lock_horizon)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_fly_helicopter)
	BOOLEAN_PROPERTY(PreferencesInput, ndof_lock_camera_pan_zoom)
	INT_PROPERTY(PreferencesInput, mouse_double_click_time)
	BOOLEAN_PROPERTY(PreferencesInput, use_mouse_emulate_3_button)
	ENUM_PROPERTY(mouse_emulate_3_button_modifier_enum, PreferencesInput, mouse_emulate_3_button_modifier)
	BOOLEAN_PROPERTY(PreferencesInput, use_emulate_numpad)
	BOOLEAN_PROPERTY(PreferencesInput, invert_zoom_wheel)


	POINTER_PROPERTY(Struct, PreferencesKeymap, rna_type)
	BOOLEAN_PROPERTY(PreferencesKeymap, show_ui_keyconfig)
	STRING_PROPERTY(PreferencesKeymap, active_keyconfig)


	POINTER_PROPERTY(Struct, PreferencesFilePaths, rna_type)
	BOOLEAN_PROPERTY(PreferencesFilePaths, show_hidden_files_datablocks)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_filter_files)
	BOOLEAN_PROPERTY(PreferencesFilePaths, show_recent_locations)
	BOOLEAN_PROPERTY(PreferencesFilePaths, show_system_bookmarks)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_relative_paths)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_file_compression)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_load_ui)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_scripts_auto_execute)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_tabs_as_spaces)
	STRING_PROPERTY(PreferencesFilePaths, font_directory)
	STRING_PROPERTY(PreferencesFilePaths, texture_directory)
	STRING_PROPERTY(PreferencesFilePaths, render_output_directory)

	STRING_PROPERTY(PreferencesFilePaths, i18n_branches_directory)
	STRING_PROPERTY(PreferencesFilePaths, sound_directory)
	STRING_PROPERTY(PreferencesFilePaths, temporary_directory)
	STRING_PROPERTY(PreferencesFilePaths, render_cache_directory)
	STRING_PROPERTY(PreferencesFilePaths, image_editor)
	STRING_PROPERTY(PreferencesFilePaths, text_editor)
	STRING_PROPERTY(PreferencesFilePaths, text_editor_args)
	STRING_PROPERTY(PreferencesFilePaths, animation_player)
	ENUM_PROPERTY(animation_player_preset_enum, PreferencesFilePaths, animation_player_preset)
	INT_PROPERTY(PreferencesFilePaths, save_version)
	BOOLEAN_PROPERTY(PreferencesFilePaths, use_auto_save_temporary_files)
	INT_PROPERTY(PreferencesFilePaths, auto_save_time)
	INT_PROPERTY(PreferencesFilePaths, recent_files)
	ENUM_PROPERTY(file_preview_type_enum, PreferencesFilePaths, file_preview_type)

	INT_PROPERTY(PreferencesFilePaths, active_asset_library)

	INT_PROPERTY(PreferencesFilePaths, active_extension_repo)


	POINTER_PROPERTY(Struct, ScriptDirectory, rna_type)
	STRING_PROPERTY(ScriptDirectory, name)
	STRING_PROPERTY(ScriptDirectory, directory)


	POINTER_PROPERTY(Struct, ScriptDirectoryCollection, rna_type)

	inline ScriptDirectory ScriptDirectoryCollection::create() {
		PointerRNA result;
		::bUserScriptDirectory *retdata = ScriptDirectoryCollection_new_func();
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_ScriptDirectory, retdata);
		return ScriptDirectory(result);
	}

	inline void ScriptDirectoryCollection::remove(ScriptDirectory& script_directory) {
		ScriptDirectoryCollection_remove_func(nullptr, (::PointerRNA *) &script_directory.ptr);
	}


	POINTER_PROPERTY(Struct, UserAssetLibrary, rna_type)
	STRING_PROPERTY(UserAssetLibrary, name)
	STRING_PROPERTY(UserAssetLibrary, path)
	ENUM_PROPERTY(import_method_enum, UserAssetLibrary, import_method)
	BOOLEAN_PROPERTY(UserAssetLibrary, use_relative_path)


	POINTER_PROPERTY(Struct, UserExtensionRepo, rna_type)
	STRING_PROPERTY(UserExtensionRepo, name)
	STRING_PROPERTY(UserExtensionRepo, module)
	STRING_PROPERTY(UserExtensionRepo, directory)
	STRING_PROPERTY(UserExtensionRepo, remote_path)
	BOOLEAN_PROPERTY(UserExtensionRepo, use_cache)


	POINTER_PROPERTY(Struct, UserExtensionRepoCollection, rna_type)

	inline UserExtensionRepo UserExtensionRepoCollection::create(const char * name, const char * module, const char * directory, const char * remote_path) {
		PointerRNA result;
		::bUserExtensionRepo *retdata = UserExtensionRepoCollection_new_func(name, module, directory, remote_path);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_UserExtensionRepo, retdata);
		return UserExtensionRepo(result);
	}

	inline void UserExtensionRepoCollection::remove(UserExtensionRepo& repo) {
		UserExtensionRepoCollection_remove_func(nullptr, (::PointerRNA *) &repo.ptr);
	}


	POINTER_PROPERTY(Struct, PreferencesSystem, rna_type)
	FLOAT_PROPERTY(PreferencesSystem, ui_scale)
	FLOAT_PROPERTY(PreferencesSystem, ui_line_width)
	INT_PROPERTY(PreferencesSystem, dpi)
	FLOAT_PROPERTY(PreferencesSystem, pixel_size)
	INT_PROPERTY(PreferencesSystem, memory_cache_limit)
	BOOLEAN_PROPERTY(PreferencesSystem, use_sequencer_disk_cache)
	STRING_PROPERTY(PreferencesSystem, sequencer_disk_cache_dir)
	INT_PROPERTY(PreferencesSystem, sequencer_disk_cache_size_limit)
	ENUM_PROPERTY(sequencer_disk_cache_compression_enum, PreferencesSystem, sequencer_disk_cache_compression)
	ENUM_PROPERTY(sequencer_proxy_setup_enum, PreferencesSystem, sequencer_proxy_setup)
	INT_PROPERTY(PreferencesSystem, scrollback)
	BOOLEAN_PROPERTY(PreferencesSystem, use_overlay_smooth_wire)
	BOOLEAN_PROPERTY(PreferencesSystem, use_edit_mode_smooth_wire)
	BOOLEAN_PROPERTY(PreferencesSystem, use_region_overlap)
	ENUM_PROPERTY(viewport_aa_enum, PreferencesSystem, viewport_aa)

	FLOAT_ARRAY_PROPERTY(PreferencesSystem, 3, light_ambient)
	BOOLEAN_PROPERTY(PreferencesSystem, use_studio_light_edit)
	FLOAT_PROPERTY(PreferencesSystem, gl_clip_alpha)
	ENUM_PROPERTY(image_draw_method_enum, PreferencesSystem, image_draw_method)
	ENUM_PROPERTY(anisotropic_filter_enum, PreferencesSystem, anisotropic_filter)
	ENUM_PROPERTY(gl_texture_limit_enum, PreferencesSystem, gl_texture_limit)
	INT_PROPERTY(PreferencesSystem, texture_time_out)
	INT_PROPERTY(PreferencesSystem, texture_collection_rate)
	INT_PROPERTY(PreferencesSystem, vbo_time_out)
	INT_PROPERTY(PreferencesSystem, vbo_collection_rate)
	BOOLEAN_PROPERTY(PreferencesSystem, use_select_pick_depth)
	BOOLEAN_PROPERTY(PreferencesSystem, use_gpu_subdivision)
	ENUM_PROPERTY(gpu_backend_enum, PreferencesSystem, gpu_backend)
	ENUM_PROPERTY(audio_mixing_buffer_enum, PreferencesSystem, audio_mixing_buffer)
	ENUM_PROPERTY(audio_device_enum, PreferencesSystem, audio_device)
	ENUM_PROPERTY(audio_sample_rate_enum, PreferencesSystem, audio_sample_rate)
	ENUM_PROPERTY(audio_sample_format_enum, PreferencesSystem, audio_sample_format)
	ENUM_PROPERTY(audio_channels_enum, PreferencesSystem, audio_channels)
	INT_PROPERTY(PreferencesSystem, legacy_compute_device_type)
	BOOLEAN_PROPERTY(PreferencesSystem, register_all_users)
	BOOLEAN_PROPERTY(PreferencesSystem, is_microsoft_store_install)


	POINTER_PROPERTY(Struct, Addon, rna_type)
	STRING_PROPERTY(Addon, module)
	POINTER_PROPERTY(AddonPreferences, Addon, preferences)


	POINTER_PROPERTY(Struct, AddonPreferences, rna_type)
	STRING_PROPERTY(AddonPreferences, bl_idname)


	POINTER_PROPERTY(Struct, StudioLights, rna_type)

	inline StudioLight StudioLights::load(const char * path, int type) {
		PointerRNA result;
		::StudioLight *retdata = StudioLights_load_func((::UserDef *) this->ptr.data, path, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_StudioLight, retdata);
		return StudioLight(result);
	}

	inline StudioLight StudioLights::create(const char * path) {
		PointerRNA result;
		::StudioLight *retdata = StudioLights_new_func((::UserDef *) this->ptr.data, path);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_StudioLight, retdata);
		return StudioLight(result);
	}

	inline void StudioLights::remove(StudioLight& studio_light) {
		StudioLights_remove_func((::UserDef *) this->ptr.data, (::StudioLight *) studio_light.ptr.data);
	}

	inline void StudioLights::refresh() {
		StudioLights_refresh_func((::UserDef *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, StudioLight, rna_type)
	INT_PROPERTY(StudioLight, index)
	BOOLEAN_PROPERTY(StudioLight, is_user_defined)
	BOOLEAN_PROPERTY(StudioLight, has_specular_highlight_pass)
	ENUM_PROPERTY(type_enum, StudioLight, type)
	STRING_PROPERTY(StudioLight, name)
	STRING_PROPERTY(StudioLight, path)

	FLOAT_ARRAY_PROPERTY(StudioLight, 3, light_ambient)
	STRING_PROPERTY(StudioLight, path_irr_cache)
	STRING_PROPERTY(StudioLight, path_sh_cache)
	FLOAT_ARRAY_PROPERTY(StudioLight, 12, spherical_harmonics_coefficients)


	POINTER_PROPERTY(Struct, PathCompare, rna_type)
	STRING_PROPERTY(PathCompare, path)
	BOOLEAN_PROPERTY(PathCompare, use_glob)


	POINTER_PROPERTY(Struct, PreferencesApps, rna_type)
	BOOLEAN_PROPERTY(PreferencesApps, show_corner_split)
	BOOLEAN_PROPERTY(PreferencesApps, show_edge_resize)
	BOOLEAN_PROPERTY(PreferencesApps, show_regions_visibility_toggle)


	POINTER_PROPERTY(Struct, PreferencesExperimental, rna_type)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_undo_legacy)
	BOOLEAN_PROPERTY(PreferencesExperimental, override_auto_resync)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_new_point_cloud_type)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_experimental_compositors)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_new_curves_tools)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_cycles_debug)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_eevee_debug)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_sculpt_tools_tilt)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_sculpt_texture_paint)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_extended_asset_browser)
	BOOLEAN_PROPERTY(PreferencesExperimental, show_asset_debug_info)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_asset_indexing)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_override_templates)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_grease_pencil_version3)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_viewport_debug)
	BOOLEAN_PROPERTY(PreferencesExperimental, enable_overlay_next)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_all_linked_data_direct)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_new_volume_nodes)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_shader_node_previews)
	BOOLEAN_PROPERTY(PreferencesExperimental, use_extension_repos)


	STRING_PROPERTY(VectorFont, filepath)
	POINTER_PROPERTY(PackedFile, VectorFont, packed_file)

	inline void VectorFont::pack(void *main) {
		VectorFont_pack_func((::VFont *) this->ptr.data, (::Main *) main, nullptr);
	}

	inline void VectorFont::unpack(void *main, int method) {
		VectorFont_unpack_func((::VFont *) this->ptr.data, (::Main *) main, nullptr, method);
	}


	POINTER_PROPERTY(Struct, VolumeGrid, rna_type)
	STRING_PROPERTY(VolumeGrid, name)
	ENUM_PROPERTY(data_type_enum, VolumeGrid, data_type)
	INT_PROPERTY(VolumeGrid, channels)
	FLOAT_ARRAY_PROPERTY(VolumeGrid, 16, matrix_object)
	BOOLEAN_PROPERTY(VolumeGrid, is_loaded)

	inline bool VolumeGrid::load() {
		return VolumeGrid_load_func((::ID *) ptr.owner_id, (::VolumeGrid *) this->ptr.data);
	}

	inline void VolumeGrid::unload() {
		VolumeGrid_unload_func((::ID *) ptr.owner_id, (::VolumeGrid *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, VolumeDisplay, rna_type)
	FLOAT_PROPERTY(VolumeDisplay, density)
	ENUM_PROPERTY(wireframe_type_enum, VolumeDisplay, wireframe_type)
	ENUM_PROPERTY(wireframe_detail_enum, VolumeDisplay, wireframe_detail)
	ENUM_PROPERTY(interpolation_method_enum, VolumeDisplay, interpolation_method)
	BOOLEAN_PROPERTY(VolumeDisplay, use_slice)
	ENUM_PROPERTY(slice_axis_enum, VolumeDisplay, slice_axis)
	FLOAT_PROPERTY(VolumeDisplay, slice_depth)


	POINTER_PROPERTY(Struct, VolumeRender, rna_type)
	ENUM_PROPERTY(precision_enum, VolumeRender, precision)
	ENUM_PROPERTY(space_enum, VolumeRender, space)
	FLOAT_PROPERTY(VolumeRender, step_size)
	FLOAT_PROPERTY(VolumeRender, clipping)


	STRING_PROPERTY(Volume, filepath)
	POINTER_PROPERTY(PackedFile, Volume, packed_file)
	BOOLEAN_PROPERTY(Volume, is_sequence)
	INT_PROPERTY(Volume, frame_start)
	INT_PROPERTY(Volume, frame_duration)
	INT_PROPERTY(Volume, frame_offset)
	ENUM_PROPERTY(sequence_mode_enum, Volume, sequence_mode)


	POINTER_PROPERTY(VolumeDisplay, Volume, display)
	POINTER_PROPERTY(VolumeRender, Volume, render)
	STRING_PROPERTY(Volume, velocity_grid)
	ENUM_PROPERTY(velocity_unit_enum, Volume, velocity_unit)
	FLOAT_PROPERTY(Volume, velocity_scale)
	STRING_PROPERTY(Volume, velocity_x_grid)
	STRING_PROPERTY(Volume, velocity_y_grid)
	STRING_PROPERTY(Volume, velocity_z_grid)
	POINTER_PROPERTY(AnimData, Volume, animation_data)


	POINTER_PROPERTY(Struct, VolumeGrids, rna_type)
	INT_PROPERTY(VolumeGrids, active_index)
	STRING_PROPERTY(VolumeGrids, error_message)
	BOOLEAN_PROPERTY(VolumeGrids, is_loaded)
	INT_PROPERTY(VolumeGrids, frame)
	STRING_PROPERTY(VolumeGrids, frame_filepath)

	inline bool VolumeGrids::load(void *main) {
		return VolumeGrids_load_func((::Volume *) this->ptr.data, (::Main *) main);
	}

	inline void VolumeGrids::unload() {
		VolumeGrids_unload_func((::Volume *) this->ptr.data);
	}

	inline bool VolumeGrids::save(void *main, const char * filepath) {
		return VolumeGrids_save_func((::Volume *) this->ptr.data, (::Main *) main, nullptr, filepath);
	}


	POINTER_PROPERTY(Struct, Operator, rna_type)
	STRING_PROPERTY(Operator, name)
	POINTER_PROPERTY(OperatorProperties, Operator, properties)
	BOOLEAN_PROPERTY(Operator, has_reports)
	STRING_PROPERTY(Operator, bl_idname)
	STRING_PROPERTY(Operator, bl_label)
	STRING_PROPERTY(Operator, bl_translation_context)
	STRING_PROPERTY(Operator, bl_description)
	STRING_PROPERTY(Operator, bl_undo_group)
	ENUM_PROPERTY(bl_options_enum, Operator, bl_options)
	ENUM_PROPERTY(bl_cursor_pending_enum, Operator, bl_cursor_pending)
	POINTER_PROPERTY(UILayout, Operator, layout)
	POINTER_PROPERTY(OperatorOptions, Operator, options)


	inline void Operator::report(int type, const char * message) {
		Operator_report_func((::wmOperator *) this->ptr.data, type, message);
	}

	inline bool Operator::is_repeat(Context C) {
		return Operator_is_repeat_func((::wmOperator *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, OperatorProperties, rna_type)


	POINTER_PROPERTY(Struct, OperatorOptions, rna_type)
	BOOLEAN_PROPERTY(OperatorOptions, is_grab_cursor)
	BOOLEAN_PROPERTY(OperatorOptions, is_invoke)
	BOOLEAN_PROPERTY(OperatorOptions, is_repeat)
	BOOLEAN_PROPERTY(OperatorOptions, is_repeat_last)
	BOOLEAN_PROPERTY(OperatorOptions, use_cursor_region)






	POINTER_PROPERTY(Struct, Macro, rna_type)
	STRING_PROPERTY(Macro, name)
	POINTER_PROPERTY(OperatorProperties, Macro, properties)
	BOOLEAN_PROPERTY(Macro, has_reports)
	STRING_PROPERTY(Macro, bl_idname)
	STRING_PROPERTY(Macro, bl_label)
	STRING_PROPERTY(Macro, bl_translation_context)
	STRING_PROPERTY(Macro, bl_description)
	STRING_PROPERTY(Macro, bl_undo_group)
	ENUM_PROPERTY(bl_options_enum, Macro, bl_options)
	ENUM_PROPERTY(bl_cursor_pending_enum, Macro, bl_cursor_pending)

	inline void Macro::report(int type, const char * message) {
		Macro_report_func((::wmOperator *) this->ptr.data, type, message);
	}


	POINTER_PROPERTY(Struct, OperatorMacro, rna_type)
	POINTER_PROPERTY(OperatorProperties, OperatorMacro, properties)


	POINTER_PROPERTY(Struct, Event, rna_type)
	STRING_PROPERTY(Event, ascii)
	STRING_PROPERTY(Event, unicode)
	ENUM_PROPERTY(value_enum, Event, value)
	ENUM_PROPERTY(value_prev_enum, Event, value_prev)
	ENUM_PROPERTY(type_enum, Event, type)
	ENUM_PROPERTY(type_prev_enum, Event, type_prev)
	ENUM_PROPERTY(direction_enum, Event, direction)
	BOOLEAN_PROPERTY(Event, is_repeat)
	BOOLEAN_PROPERTY(Event, is_consecutive)
	INT_PROPERTY(Event, mouse_x)
	INT_PROPERTY(Event, mouse_y)
	INT_PROPERTY(Event, mouse_region_x)
	INT_PROPERTY(Event, mouse_region_y)
	INT_PROPERTY(Event, mouse_prev_x)
	INT_PROPERTY(Event, mouse_prev_y)
	INT_PROPERTY(Event, mouse_prev_press_x)
	INT_PROPERTY(Event, mouse_prev_press_y)
	FLOAT_PROPERTY(Event, pressure)
	FLOAT_ARRAY_PROPERTY(Event, 2, tilt)
	BOOLEAN_PROPERTY(Event, is_tablet)
	BOOLEAN_PROPERTY(Event, is_mouse_absolute)
	POINTER_PROPERTY(XrEventData, Event, xr)
	BOOLEAN_PROPERTY(Event, shift)
	BOOLEAN_PROPERTY(Event, ctrl)
	BOOLEAN_PROPERTY(Event, alt)
	BOOLEAN_PROPERTY(Event, oskey)


	POINTER_PROPERTY(Struct, Timer, rna_type)
	FLOAT_PROPERTY(Timer, time_step)
	FLOAT_PROPERTY(Timer, time_delta)
	FLOAT_PROPERTY(Timer, time_duration)


	POINTER_PROPERTY(Struct, UIPopupMenu, rna_type)
	POINTER_PROPERTY(UILayout, UIPopupMenu, layout)


	POINTER_PROPERTY(Struct, UIPopover, rna_type)
	POINTER_PROPERTY(UILayout, UIPopover, layout)


	POINTER_PROPERTY(Struct, UIPieMenu, rna_type)
	POINTER_PROPERTY(UILayout, UIPieMenu, layout)


	POINTER_PROPERTY(Struct, Window, rna_type)
	POINTER_PROPERTY(Window, Window, parent)
	POINTER_PROPERTY(Scene, Window, scene)
	POINTER_PROPERTY(WorkSpace, Window, workspace)
	POINTER_PROPERTY(Screen, Window, screen)
	POINTER_PROPERTY(ViewLayer, Window, view_layer)
	INT_PROPERTY(Window, x)
	INT_PROPERTY(Window, y)
	INT_PROPERTY(Window, width)
	INT_PROPERTY(Window, height)
	POINTER_PROPERTY(Stereo3dDisplay, Window, stereo_3d_display)

	inline void Window::cursor_warp(int x, int y) {
		Window_cursor_warp_func((::wmWindow *) this->ptr.data, x, y);
	}

	inline void Window::cursor_set(int cursor) {
		Window_cursor_set_func((::wmWindow *) this->ptr.data, cursor);
	}

	inline void Window::cursor_modal_set(int cursor) {
		Window_cursor_modal_set_func((::wmWindow *) this->ptr.data, cursor);
	}

	inline void Window::cursor_modal_restore() {
		Window_cursor_modal_restore_func((::wmWindow *) this->ptr.data);
	}

	inline Event Window::event_simulate(int type, int value, const char * unicode, int x, int y, bool shift, bool ctrl, bool alt, bool oskey) {
		PointerRNA result;
		::wmEvent *retdata = Window_event_simulate_func((::wmWindow *) this->ptr.data, nullptr, type, value, unicode, x, y, shift, ctrl, alt, oskey);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Event, retdata);
		return Event(result);
	}


	POINTER_PROPERTY(Struct, Stereo3dDisplay, rna_type)
	ENUM_PROPERTY(display_mode_enum, Stereo3dDisplay, display_mode)
	ENUM_PROPERTY(anaglyph_type_enum, Stereo3dDisplay, anaglyph_type)
	ENUM_PROPERTY(interlace_type_enum, Stereo3dDisplay, interlace_type)
	BOOLEAN_PROPERTY(Stereo3dDisplay, use_interlace_swap)
	BOOLEAN_PROPERTY(Stereo3dDisplay, use_sidebyside_crosseyed)





	POINTER_PROPERTY(XrSessionSettings, WindowManager, xr_session_settings)
	POINTER_PROPERTY(XrSessionState, WindowManager, xr_session_state)
	BOOLEAN_PROPERTY(WindowManager, is_interface_locked)

	inline void WindowManager::fileselect_add(Context C, Operator& operator_value) {
		WindowManager_fileselect_add_func((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data);
	}

	inline bool WindowManager::modal_handler_add(Context C, Operator& operator_value) {
		return WindowManager_modal_handler_add_func((::bContext *) C.ptr.data, nullptr, (::wmOperator *) operator_value.ptr.data);
	}

	inline Timer WindowManager::event_timer_add(float time_step, Window& window) {
		PointerRNA result;
		::wmTimer *retdata = WindowManager_event_timer_add_func((::wmWindowManager *) this->ptr.data, time_step, (::wmWindow *) window.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Timer, retdata);
		return Timer(result);
	}

	inline void WindowManager::event_timer_remove(Timer& timer) {
		WindowManager_event_timer_remove_func((::wmWindowManager *) this->ptr.data, (::wmTimer *) timer.ptr.data);
	}

	inline void WindowManager::gizmo_group_type_ensure(const char * identifier) {
		WindowManager_gizmo_group_type_ensure_func(nullptr, identifier);
	}

	inline void WindowManager::gizmo_group_type_unlink_delayed(const char * identifier) {
		WindowManager_gizmo_group_type_unlink_delayed_func(nullptr, identifier);
	}

	inline void WindowManager::progress_begin(float min, float max) {
		WindowManager_progress_begin_func((::wmWindowManager *) this->ptr.data, min, max);
	}

	inline void WindowManager::progress_update(float value) {
		WindowManager_progress_update_func((::wmWindowManager *) this->ptr.data, value);
	}

	inline void WindowManager::progress_end() {
		WindowManager_progress_end_func((::wmWindowManager *) this->ptr.data);
	}

	inline int WindowManager::invoke_props_popup(Context C, Operator& operator_value, Event& event) {
		return WindowManager_invoke_props_popup_func((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, (::wmEvent *) event.ptr.data);
	}

	inline int WindowManager::invoke_props_dialog(Context C, Operator& operator_value, int width) {
		return WindowManager_invoke_props_dialog_func((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, width);
	}

	inline void WindowManager::invoke_search_popup(Context C, Operator& operator_value) {
		WindowManager_invoke_search_popup_func((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data);
	}

	inline int WindowManager::invoke_popup(Context C, Operator& operator_value, int width) {
		return WindowManager_invoke_popup_func((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, width);
	}

	inline int WindowManager::invoke_confirm(Context C, Operator& operator_value, Event& event) {
		return WindowManager_invoke_confirm_func((::bContext *) C.ptr.data, (::wmOperator *) operator_value.ptr.data, (::wmEvent *) event.ptr.data);
	}

	inline UIPopupMenu WindowManager::popmenu_begin__internal(Context C, const char * title, int icon) {
		PointerRNA result;
		result = WindowManager_popmenu_begin__internal_func((::bContext *) C.ptr.data, title, icon);
		return UIPopupMenu(result);
	}

	inline void WindowManager::popmenu_end__internal(Context C, UIPopupMenu& menu) {
		WindowManager_popmenu_end__internal_func((::bContext *) C.ptr.data, (::PointerRNA *) &menu);
	}

	inline UIPopover WindowManager::popover_begin__internal(Context C, int ui_units_x, bool from_active_button) {
		PointerRNA result;
		result = WindowManager_popover_begin__internal_func((::bContext *) C.ptr.data, ui_units_x, from_active_button);
		return UIPopover(result);
	}

	inline void WindowManager::popover_end__internal(Context C, UIPopover& menu, KeyMap& keymap) {
		WindowManager_popover_end__internal_func((::bContext *) C.ptr.data, (::PointerRNA *) &menu, (::wmKeyMap *) keymap.ptr.data);
	}

	inline UIPieMenu WindowManager::piemenu_begin__internal(Context C, const char * title, int icon, Event& event) {
		PointerRNA result;
		result = WindowManager_piemenu_begin__internal_func((::bContext *) C.ptr.data, title, icon, (::PointerRNA *) &event);
		return UIPieMenu(result);
	}

	inline void WindowManager::piemenu_end__internal(Context C, UIPieMenu& menu) {
		WindowManager_piemenu_end__internal_func((::bContext *) C.ptr.data, (::PointerRNA *) &menu);
	}

	inline OperatorProperties WindowManager::operator_properties_last(const char * operator_value) {
		PointerRNA result;
		result = WindowManager_operator_properties_last_func(operator_value);
		return OperatorProperties(result);
	}

	inline void WindowManager::print_undo_steps() {
		WindowManager_print_undo_steps_func((::wmWindowManager *) this->ptr.data);
	}

	inline void WindowManager::tag_script_reload() {
		WindowManager_tag_script_reload_func();
	}


	POINTER_PROPERTY(Struct, KeyConfigurations, rna_type)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, active)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, default_value)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, addon)
	POINTER_PROPERTY(KeyConfig, KeyConfigurations, user)

	inline KeyConfig KeyConfigurations::create(const char * name) {
		PointerRNA result;
		::wmKeyConfig *retdata = KeyConfigurations_new_func((::wmWindowManager *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyConfig, retdata);
		return KeyConfig(result);
	}

	inline void KeyConfigurations::remove(KeyConfig& keyconfig) {
		KeyConfigurations_remove_func((::wmWindowManager *) this->ptr.data, nullptr, (::PointerRNA *) &keyconfig.ptr);
	}

	inline KeyMapItem KeyConfigurations::find_item_from_operator(Context C, const char * idname, int context, OperatorProperties& properties, int include, int exclude, KeyMap *keymap) {
		PointerRNA result;
		result = KeyConfigurations_find_item_from_operator_func((::wmWindowManager *) this->ptr.data, (::bContext *) C.ptr.data, idname, context, (::PointerRNA *) &properties, include, exclude, &keymap->ptr);
		return KeyMapItem(result);
	}

	inline void KeyConfigurations::update(bool keep_properties) {
		KeyConfigurations_update_func((::wmWindowManager *) this->ptr.data, keep_properties);
	}


	POINTER_PROPERTY(Struct, KeyConfigPreferences, rna_type)
	STRING_PROPERTY(KeyConfigPreferences, bl_idname)


	POINTER_PROPERTY(Struct, KeyConfig, rna_type)
	STRING_PROPERTY(KeyConfig, name)

	BOOLEAN_PROPERTY(KeyConfig, is_user_defined)
	POINTER_PROPERTY(KeyConfigPreferences, KeyConfig, preferences)


	POINTER_PROPERTY(Struct, KeyMaps, rna_type)

	inline KeyMap KeyMaps::create(const char * name, int space_type, int region_type, bool modal, bool tool) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMaps_new_func((::wmKeyConfig *) this->ptr.data, nullptr, name, space_type, region_type, modal, tool);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMap, retdata);
		return KeyMap(result);
	}

	inline void KeyMaps::remove(KeyMap& keymap) {
		KeyMaps_remove_func((::wmKeyConfig *) this->ptr.data, nullptr, (::PointerRNA *) &keymap.ptr);
	}

	inline void KeyMaps::clear() {
		KeyMaps_clear_func((::wmKeyConfig *) this->ptr.data);
	}

	inline KeyMap KeyMaps::find(const char * name, int space_type, int region_type) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMaps_find_func((::wmKeyConfig *) this->ptr.data, name, space_type, region_type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMap, retdata);
		return KeyMap(result);
	}

	inline KeyMap KeyMaps::find_modal(const char * name) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMaps_find_modal_func((::wmKeyConfig *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMap, retdata);
		return KeyMap(result);
	}


	POINTER_PROPERTY(Struct, KeyMap, rna_type)
	STRING_PROPERTY(KeyMap, name)
	STRING_PROPERTY(KeyMap, bl_owner_id)
	ENUM_PROPERTY(space_type_enum, KeyMap, space_type)
	ENUM_PROPERTY(region_type_enum, KeyMap, region_type)

	BOOLEAN_PROPERTY(KeyMap, is_user_modified)
	BOOLEAN_PROPERTY(KeyMap, is_modal)
	BOOLEAN_PROPERTY(KeyMap, show_expanded_items)
	BOOLEAN_PROPERTY(KeyMap, show_expanded_children)


	inline KeyMap KeyMap::active(Context C) {
		PointerRNA result;
		::wmKeyMap *retdata = KeyMap_active_func((::wmKeyMap *) this->ptr.data, (::bContext *) C.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMap, retdata);
		return KeyMap(result);
	}

	inline void KeyMap::restore_to_default(Context C) {
		KeyMap_restore_to_default_func((::wmKeyMap *) this->ptr.data, (::bContext *) C.ptr.data);
	}

	inline void KeyMap::restore_item_to_default(Context C, KeyMapItem& item) {
		KeyMap_restore_item_to_default_func((::wmKeyMap *) this->ptr.data, (::bContext *) C.ptr.data, (::wmKeyMapItem *) item.ptr.data);
	}


	POINTER_PROPERTY(Struct, KeyMapItems, rna_type)

	inline KeyMapItem KeyMapItems::create(const char * idname, int type, int value, bool any, int shift, int ctrl, int alt, int oskey, int key_modifier, int direction, bool repeat, bool head) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_new_func((::wmKeyMap *) this->ptr.data, nullptr, idname, type, value, any, shift, ctrl, alt, oskey, key_modifier, direction, repeat, head);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMapItem, retdata);
		return KeyMapItem(result);
	}

	inline KeyMapItem KeyMapItems::new_modal(const char * propvalue, int type, int value, bool any, int shift, int ctrl, int alt, int oskey, int key_modifier, int direction, bool repeat) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_new_modal_func((::wmKeyMap *) this->ptr.data, nullptr, propvalue, type, value, any, shift, ctrl, alt, oskey, key_modifier, direction, repeat);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMapItem, retdata);
		return KeyMapItem(result);
	}

	inline KeyMapItem KeyMapItems::new_from_item(KeyMapItem& item, bool head) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_new_from_item_func((::wmKeyMap *) this->ptr.data, nullptr, (::wmKeyMapItem *) item.ptr.data, head);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMapItem, retdata);
		return KeyMapItem(result);
	}

	inline void KeyMapItems::remove(KeyMapItem& item) {
		KeyMapItems_remove_func((::wmKeyMap *) this->ptr.data, nullptr, (::PointerRNA *) &item.ptr);
	}

	inline KeyMapItem KeyMapItems::from_id(int id) {
		PointerRNA result;
		::wmKeyMapItem *retdata = KeyMapItems_from_id_func((::wmKeyMap *) this->ptr.data, id);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_KeyMapItem, retdata);
		return KeyMapItem(result);
	}

	inline KeyMapItem KeyMapItems::find_from_operator(const char * idname, OperatorProperties& properties, int include, int exclude) {
		PointerRNA result;
		result = KeyMapItems_find_from_operator_func((::ID *) ptr.owner_id, (::wmKeyMap *) this->ptr.data, idname, (::PointerRNA *) &properties, include, exclude);
		return KeyMapItem(result);
	}

	inline KeyMapItem KeyMapItems::match_event(Context C, Event& event) {
		PointerRNA result;
		result = KeyMapItems_match_event_func((::ID *) ptr.owner_id, (::wmKeyMap *) this->ptr.data, (::bContext *) C.ptr.data, (::wmEvent *) event.ptr.data);
		return KeyMapItem(result);
	}


	POINTER_PROPERTY(Struct, KeyMapItem, rna_type)
	STRING_PROPERTY(KeyMapItem, idname)
	STRING_PROPERTY(KeyMapItem, name)
	POINTER_PROPERTY(OperatorProperties, KeyMapItem, properties)
	ENUM_PROPERTY(map_type_enum, KeyMapItem, map_type)
	ENUM_PROPERTY(type_enum, KeyMapItem, type)
	ENUM_PROPERTY(value_enum, KeyMapItem, value)
	ENUM_PROPERTY(direction_enum, KeyMapItem, direction)
	INT_PROPERTY(KeyMapItem, id)
	BOOLEAN_PROPERTY(KeyMapItem, any)
	INT_PROPERTY(KeyMapItem, shift)
	INT_PROPERTY(KeyMapItem, ctrl)
	INT_PROPERTY(KeyMapItem, alt)
	INT_PROPERTY(KeyMapItem, oskey)
	BOOLEAN_PROPERTY(KeyMapItem, shift_ui)
	BOOLEAN_PROPERTY(KeyMapItem, ctrl_ui)
	BOOLEAN_PROPERTY(KeyMapItem, alt_ui)
	BOOLEAN_PROPERTY(KeyMapItem, oskey_ui)
	ENUM_PROPERTY(key_modifier_enum, KeyMapItem, key_modifier)
	BOOLEAN_PROPERTY(KeyMapItem, repeat)
	BOOLEAN_PROPERTY(KeyMapItem, show_expanded)
	ENUM_PROPERTY(propvalue_enum, KeyMapItem, propvalue)
	BOOLEAN_PROPERTY(KeyMapItem, active)
	BOOLEAN_PROPERTY(KeyMapItem, is_user_modified)
	BOOLEAN_PROPERTY(KeyMapItem, is_user_defined)

	inline bool KeyMapItem::compare(KeyMapItem& item) {
		return KeyMapItem_compare_func((::wmKeyMapItem *) this->ptr.data, (::wmKeyMapItem *) item.ptr.data);
	}

	inline void KeyMapItem::to_string(bool compact, char * result) {
		KeyMapItem_to_string_func((::wmKeyMapItem *) this->ptr.data, compact, result);
	}


	POINTER_PROPERTY(Struct, GizmoGroup, rna_type)
	STRING_PROPERTY(GizmoGroup, bl_idname)
	STRING_PROPERTY(GizmoGroup, bl_label)
	ENUM_PROPERTY(bl_space_type_enum, GizmoGroup, bl_space_type)
	ENUM_PROPERTY(bl_region_type_enum, GizmoGroup, bl_region_type)
	STRING_PROPERTY(GizmoGroup, bl_owner_id)
	ENUM_PROPERTY(bl_options_enum, GizmoGroup, bl_options)
	STRING_PROPERTY(GizmoGroup, name)
	BOOLEAN_PROPERTY(GizmoGroup, has_reports)



	POINTER_PROPERTY(Struct, Gizmo, rna_type)
	POINTER_PROPERTY(GizmoProperties, Gizmo, properties)
	STRING_PROPERTY(Gizmo, bl_idname)
	POINTER_PROPERTY(GizmoGroup, Gizmo, group)
	FLOAT_ARRAY_PROPERTY(Gizmo, 3, color)
	FLOAT_PROPERTY(Gizmo, alpha)
	FLOAT_ARRAY_PROPERTY(Gizmo, 3, color_highlight)
	FLOAT_PROPERTY(Gizmo, alpha_highlight)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_space)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_basis)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_offset)
	FLOAT_ARRAY_PROPERTY(Gizmo, 16, matrix_world)
	FLOAT_PROPERTY(Gizmo, scale_basis)
	FLOAT_PROPERTY(Gizmo, line_width)
	FLOAT_PROPERTY(Gizmo, select_bias)
	BOOLEAN_PROPERTY(Gizmo, hide)
	BOOLEAN_PROPERTY(Gizmo, hide_select)
	BOOLEAN_PROPERTY(Gizmo, hide_keymap)
	BOOLEAN_PROPERTY(Gizmo, use_grab_cursor)
	BOOLEAN_PROPERTY(Gizmo, use_draw_hover)
	BOOLEAN_PROPERTY(Gizmo, use_draw_modal)
	BOOLEAN_PROPERTY(Gizmo, use_draw_value)
	BOOLEAN_PROPERTY(Gizmo, use_draw_offset_scale)
	BOOLEAN_PROPERTY(Gizmo, use_draw_scale)
	BOOLEAN_PROPERTY(Gizmo, use_select_background)
	BOOLEAN_PROPERTY(Gizmo, use_operator_tool_properties)
	BOOLEAN_PROPERTY(Gizmo, use_event_handle_all)
	BOOLEAN_PROPERTY(Gizmo, use_tooltip)
	BOOLEAN_PROPERTY(Gizmo, is_highlight)
	BOOLEAN_PROPERTY(Gizmo, is_modal)
	BOOLEAN_PROPERTY(Gizmo, select)

	inline void Gizmo::draw_preset_box(float matrix[16], int select_id) {
		Gizmo_draw_preset_box_func((::wmGizmo *) this->ptr.data, matrix, select_id);
	}

	inline void Gizmo::draw_preset_arrow(float matrix[16], int axis, int select_id) {
		Gizmo_draw_preset_arrow_func((::wmGizmo *) this->ptr.data, matrix, axis, select_id);
	}

	inline void Gizmo::draw_preset_circle(float matrix[16], int axis, int select_id) {
		Gizmo_draw_preset_circle_func((::wmGizmo *) this->ptr.data, matrix, axis, select_id);
	}

	inline void Gizmo::target_set_prop(const char * target, AnyType& data, const char * property, int index) {
		Gizmo_target_set_prop_func((::wmGizmo *) this->ptr.data, nullptr, target, (::PointerRNA *) &data, property, index);
	}

	inline OperatorProperties Gizmo::target_set_operator(const char * operator_value, int index) {
		PointerRNA result;
		result = Gizmo_target_set_operator_func((::wmGizmo *) this->ptr.data, nullptr, operator_value, index);
		return OperatorProperties(result);
	}

	inline bool Gizmo::target_is_valid(const char * property) {
		return Gizmo_target_is_valid_func((::wmGizmo *) this->ptr.data, nullptr, property);
	}


	POINTER_PROPERTY(Struct, GizmoProperties, rna_type)


	POINTER_PROPERTY(Struct, Gizmos, rna_type)

	inline Gizmo Gizmos::create(const char * type) {
		PointerRNA result;
		::wmGizmo *retdata = Gizmos_new_func((::wmGizmoGroup *) this->ptr.data, nullptr, type);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_Gizmo, retdata);
		return Gizmo(result);
	}

	inline void Gizmos::remove(Context C, Gizmo& gizmo) {
		Gizmos_remove_func((::wmGizmoGroup *) this->ptr.data, (::bContext *) C.ptr.data, (::wmGizmo *) gizmo.ptr.data);
	}

	inline void Gizmos::clear(Context C) {
		Gizmos_clear_func((::wmGizmoGroup *) this->ptr.data, (::bContext *) C.ptr.data);
	}


	POINTER_PROPERTY(Struct, GizmoGroupProperties, rna_type)


	POINTER_PROPERTY(Struct, wmOwnerID, rna_type)
	STRING_PROPERTY(wmOwnerID, name)


	POINTER_PROPERTY(Struct, WorkSpaceTool, rna_type)
	STRING_PROPERTY(WorkSpaceTool, idname)
	STRING_PROPERTY(WorkSpaceTool, idname_fallback)
	INT_PROPERTY(WorkSpaceTool, index)
	ENUM_PROPERTY(space_type_enum, WorkSpaceTool, space_type)
	ENUM_PROPERTY(mode_enum, WorkSpaceTool, mode)
	BOOLEAN_PROPERTY(WorkSpaceTool, use_paint_canvas)
	BOOLEAN_PROPERTY(WorkSpaceTool, has_datablock)
	STRING_PROPERTY(WorkSpaceTool, widget)

	inline void WorkSpaceTool::setup(Context C, const char * idname, int cursor, const char * keymap, const char * gizmo_group, const char * data_block, const char * operator_value, int index, int options, const char * idname_fallback, const char * keymap_fallback) {
		WorkSpaceTool_setup_func((::ID *) ptr.owner_id, (::bToolRef *) this->ptr.data, (::bContext *) C.ptr.data, idname, cursor, keymap, gizmo_group, data_block, operator_value, index, options, idname_fallback, keymap_fallback);
	}

	inline OperatorProperties WorkSpaceTool::operator_properties(const char * operator_value) {
		PointerRNA result;
		result = WorkSpaceTool_operator_properties_func((::bToolRef *) this->ptr.data, nullptr, operator_value);
		return OperatorProperties(result);
	}

	inline GizmoGroupProperties WorkSpaceTool::gizmo_group_properties(const char * group) {
		PointerRNA result;
		result = WorkSpaceTool_gizmo_group_properties_func((::bToolRef *) this->ptr.data, nullptr, group);
		return GizmoGroupProperties(result);
	}

	inline void WorkSpaceTool::refresh_from_context(void *main) {
		WorkSpaceTool_refresh_from_context_func((::ID *) ptr.owner_id, (::bToolRef *) this->ptr.data, (::Main *) main);
	}





	ENUM_PROPERTY(object_mode_enum, WorkSpace, object_mode)
	BOOLEAN_PROPERTY(WorkSpace, use_pin_scene)
	BOOLEAN_PROPERTY(WorkSpace, use_filter_by_owner)
	ENUM_PROPERTY(asset_library_reference_enum, WorkSpace, asset_library_reference)

	inline void WorkSpace::status_text_set_internal(Context C, const char * text) {
		WorkSpace_status_text_set_internal_func((::bContext *) C.ptr.data, text);
	}


	POINTER_PROPERTY(Struct, wmOwnerIDs, rna_type)

	inline wmOwnerID wmOwnerIDs::create(const char * name) {
		PointerRNA result;
		::wmOwnerID *retdata = wmOwnerIDs_new_func((::WorkSpace *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_wmOwnerID, retdata);
		return wmOwnerID(result);
	}

	inline void wmOwnerIDs::remove(wmOwnerID& owner_id) {
		wmOwnerIDs_remove_func((::WorkSpace *) this->ptr.data, nullptr, (::PointerRNA *) &owner_id.ptr);
	}

	inline void wmOwnerIDs::clear() {
		wmOwnerIDs_clear_func((::WorkSpace *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, wmTools, rna_type)

	inline WorkSpaceTool wmTools::from_space_view3d_mode(int mode, bool create) {
		PointerRNA result;
		::bToolRef *retdata = wmTools_from_space_view3d_mode_func((::WorkSpace *) this->ptr.data, mode, create);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_WorkSpaceTool, retdata);
		return WorkSpaceTool(result);
	}

	inline WorkSpaceTool wmTools::from_space_image_mode(int mode, bool create) {
		PointerRNA result;
		::bToolRef *retdata = wmTools_from_space_image_mode_func((::WorkSpace *) this->ptr.data, mode, create);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_WorkSpaceTool, retdata);
		return WorkSpaceTool(result);
	}

	inline WorkSpaceTool wmTools::from_space_node(bool create) {
		PointerRNA result;
		::bToolRef *retdata = wmTools_from_space_node_func((::WorkSpace *) this->ptr.data, create);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_WorkSpaceTool, retdata);
		return WorkSpaceTool(result);
	}

	inline WorkSpaceTool wmTools::from_space_sequencer(int mode, bool create) {
		PointerRNA result;
		::bToolRef *retdata = wmTools_from_space_sequencer_func((::WorkSpace *) this->ptr.data, mode, create);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_WorkSpaceTool, retdata);
		return WorkSpaceTool(result);
	}


	POINTER_PROPERTY(AnimData, World, animation_data)
	FLOAT_ARRAY_PROPERTY(World, 3, color)
	POINTER_PROPERTY(WorldLighting, World, light_settings)
	POINTER_PROPERTY(WorldMistSettings, World, mist_settings)
	POINTER_PROPERTY(NodeTree, World, node_tree)
	BOOLEAN_PROPERTY(World, use_nodes)
	STRING_PROPERTY(World, lightgroup)
	ENUM_PROPERTY(probe_resolution_enum, World, probe_resolution)


	POINTER_PROPERTY(Struct, WorldLighting, rna_type)
	FLOAT_PROPERTY(WorldLighting, ao_factor)
	FLOAT_PROPERTY(WorldLighting, distance)


	POINTER_PROPERTY(Struct, WorldMistSettings, rna_type)
	BOOLEAN_PROPERTY(WorldMistSettings, use_mist)
	FLOAT_PROPERTY(WorldMistSettings, intensity)
	FLOAT_PROPERTY(WorldMistSettings, start)
	FLOAT_PROPERTY(WorldMistSettings, depth)
	FLOAT_PROPERTY(WorldMistSettings, height)
	ENUM_PROPERTY(falloff_enum, WorldMistSettings, falloff)


	STRING_PROPERTY(MovieClip, filepath)
	POINTER_PROPERTY(MovieTracking, MovieClip, tracking)
	POINTER_PROPERTY(MovieClipProxy, MovieClip, proxy)
	BOOLEAN_PROPERTY(MovieClip, use_proxy)
	INT_ARRAY_PROPERTY(MovieClip, 2, size)
	FLOAT_ARRAY_PROPERTY(MovieClip, 2, display_aspect)
	ENUM_PROPERTY(source_enum, MovieClip, source)
	BOOLEAN_PROPERTY(MovieClip, use_proxy_custom_directory)
	POINTER_PROPERTY(GreasePencil, MovieClip, grease_pencil)
	INT_PROPERTY(MovieClip, frame_start)
	INT_PROPERTY(MovieClip, frame_offset)
	INT_PROPERTY(MovieClip, frame_duration)
	FLOAT_PROPERTY(MovieClip, fps)
	POINTER_PROPERTY(ColorManagedInputColorspaceSettings, MovieClip, colorspace_settings)
	POINTER_PROPERTY(AnimData, MovieClip, animation_data)

	inline IDPropertyWrapPtr MovieClip::metadata() {
		PointerRNA result;
		result = MovieClip_metadata_func((::MovieClip *) this->ptr.data);
		return IDPropertyWrapPtr(result);
	}


	POINTER_PROPERTY(Struct, MovieClipProxy, rna_type)
	BOOLEAN_PROPERTY(MovieClipProxy, build_25)
	BOOLEAN_PROPERTY(MovieClipProxy, build_50)
	BOOLEAN_PROPERTY(MovieClipProxy, build_75)
	BOOLEAN_PROPERTY(MovieClipProxy, build_100)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_25)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_50)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_75)
	BOOLEAN_PROPERTY(MovieClipProxy, build_undistorted_100)
	BOOLEAN_PROPERTY(MovieClipProxy, build_record_run)
	BOOLEAN_PROPERTY(MovieClipProxy, build_free_run)
	BOOLEAN_PROPERTY(MovieClipProxy, build_free_run_rec_date)
	INT_PROPERTY(MovieClipProxy, quality)
	ENUM_PROPERTY(timecode_enum, MovieClipProxy, timecode)
	STRING_PROPERTY(MovieClipProxy, directory)


	POINTER_PROPERTY(Struct, MovieClipUser, rna_type)
	INT_PROPERTY(MovieClipUser, frame_current)
	ENUM_PROPERTY(proxy_render_size_enum, MovieClipUser, proxy_render_size)
	BOOLEAN_PROPERTY(MovieClipUser, use_render_undistorted)


	POINTER_PROPERTY(Struct, MovieClipScopes, rna_type)


	POINTER_PROPERTY(Struct, MovieTrackingSettings, rna_type)
	ENUM_PROPERTY(speed_enum, MovieTrackingSettings, speed)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_keyframe_selection)
	BOOLEAN_PROPERTY(MovieTrackingSettings, refine_intrinsics_focal_length)
	BOOLEAN_PROPERTY(MovieTrackingSettings, refine_intrinsics_principal_point)
	BOOLEAN_PROPERTY(MovieTrackingSettings, refine_intrinsics_radial_distortion)
	BOOLEAN_PROPERTY(MovieTrackingSettings, refine_intrinsics_tangential_distortion)
	FLOAT_PROPERTY(MovieTrackingSettings, distance)
	INT_PROPERTY(MovieTrackingSettings, clean_frames)
	FLOAT_PROPERTY(MovieTrackingSettings, clean_error)
	ENUM_PROPERTY(clean_action_enum, MovieTrackingSettings, clean_action)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_tripod_solver)
	INT_PROPERTY(MovieTrackingSettings, default_frames_limit)
	ENUM_PROPERTY(default_pattern_match_enum, MovieTrackingSettings, default_pattern_match)
	INT_PROPERTY(MovieTrackingSettings, default_margin)
	ENUM_PROPERTY(default_motion_model_enum, MovieTrackingSettings, default_motion_model)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_brute)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_mask)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_normalization)
	FLOAT_PROPERTY(MovieTrackingSettings, default_correlation_min)
	INT_PROPERTY(MovieTrackingSettings, default_pattern_size)
	INT_PROPERTY(MovieTrackingSettings, default_search_size)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_red_channel)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_green_channel)
	BOOLEAN_PROPERTY(MovieTrackingSettings, use_default_blue_channel)
	FLOAT_PROPERTY(MovieTrackingSettings, default_weight)
	FLOAT_PROPERTY(MovieTrackingSettings, object_distance)


	POINTER_PROPERTY(Struct, MovieTrackingCamera, rna_type)
	ENUM_PROPERTY(distortion_model_enum, MovieTrackingCamera, distortion_model)
	FLOAT_PROPERTY(MovieTrackingCamera, sensor_width)
	FLOAT_PROPERTY(MovieTrackingCamera, focal_length)
	FLOAT_PROPERTY(MovieTrackingCamera, focal_length_pixels)
	ENUM_PROPERTY(units_enum, MovieTrackingCamera, units)
	FLOAT_ARRAY_PROPERTY(MovieTrackingCamera, 2, principal_point)
	FLOAT_ARRAY_PROPERTY(MovieTrackingCamera, 2, principal_point_pixels)
	FLOAT_PROPERTY(MovieTrackingCamera, k1)
	FLOAT_PROPERTY(MovieTrackingCamera, k2)
	FLOAT_PROPERTY(MovieTrackingCamera, k3)
	FLOAT_PROPERTY(MovieTrackingCamera, division_k1)
	FLOAT_PROPERTY(MovieTrackingCamera, division_k2)
	FLOAT_PROPERTY(MovieTrackingCamera, nuke_k1)
	FLOAT_PROPERTY(MovieTrackingCamera, nuke_k2)
	FLOAT_PROPERTY(MovieTrackingCamera, brown_k1)
	FLOAT_PROPERTY(MovieTrackingCamera, brown_k2)
	FLOAT_PROPERTY(MovieTrackingCamera, brown_k3)
	FLOAT_PROPERTY(MovieTrackingCamera, brown_k4)
	FLOAT_PROPERTY(MovieTrackingCamera, brown_p1)
	FLOAT_PROPERTY(MovieTrackingCamera, brown_p2)
	FLOAT_PROPERTY(MovieTrackingCamera, pixel_aspect)


	POINTER_PROPERTY(Struct, MovieTrackingMarker, rna_type)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 2, co)
	INT_PROPERTY(MovieTrackingMarker, frame)
	BOOLEAN_PROPERTY(MovieTrackingMarker, mute)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 8, pattern_corners)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 4, pattern_bound_box)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 2, search_min)
	FLOAT_ARRAY_PROPERTY(MovieTrackingMarker, 2, search_max)
	BOOLEAN_PROPERTY(MovieTrackingMarker, is_keyed)


	POINTER_PROPERTY(Struct, MovieTrackingTrack, rna_type)
	STRING_PROPERTY(MovieTrackingTrack, name)
	INT_PROPERTY(MovieTrackingTrack, frames_limit)
	ENUM_PROPERTY(pattern_match_enum, MovieTrackingTrack, pattern_match)
	INT_PROPERTY(MovieTrackingTrack, margin)
	ENUM_PROPERTY(motion_model_enum, MovieTrackingTrack, motion_model)
	FLOAT_PROPERTY(MovieTrackingTrack, correlation_min)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_brute)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_mask)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_normalization)

	BOOLEAN_PROPERTY(MovieTrackingTrack, use_red_channel)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_green_channel)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_blue_channel)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_grayscale_preview)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_alpha_preview)
	BOOLEAN_PROPERTY(MovieTrackingTrack, has_bundle)
	FLOAT_ARRAY_PROPERTY(MovieTrackingTrack, 3, bundle)
	BOOLEAN_PROPERTY(MovieTrackingTrack, hide)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select_anchor)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select_pattern)
	BOOLEAN_PROPERTY(MovieTrackingTrack, select_search)
	BOOLEAN_PROPERTY(MovieTrackingTrack, lock)
	BOOLEAN_PROPERTY(MovieTrackingTrack, use_custom_color)
	FLOAT_ARRAY_PROPERTY(MovieTrackingTrack, 3, color)
	FLOAT_PROPERTY(MovieTrackingTrack, average_error)
	POINTER_PROPERTY(GreasePencil, MovieTrackingTrack, grease_pencil)
	FLOAT_PROPERTY(MovieTrackingTrack, weight)
	FLOAT_PROPERTY(MovieTrackingTrack, weight_stab)
	FLOAT_ARRAY_PROPERTY(MovieTrackingTrack, 2, offset)


	POINTER_PROPERTY(Struct, MovieTrackingMarkers, rna_type)

	inline MovieTrackingMarker MovieTrackingMarkers::find_frame(int frame, bool exact) {
		PointerRNA result;
		::MovieTrackingMarker *retdata = MovieTrackingMarkers_find_frame_func((::MovieTrackingTrack *) this->ptr.data, frame, exact);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieTrackingMarker, retdata);
		return MovieTrackingMarker(result);
	}

	inline MovieTrackingMarker MovieTrackingMarkers::insert_frame(int frame, float co[2]) {
		PointerRNA result;
		::MovieTrackingMarker *retdata = MovieTrackingMarkers_insert_frame_func((::MovieTrackingTrack *) this->ptr.data, frame, co);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieTrackingMarker, retdata);
		return MovieTrackingMarker(result);
	}

	inline void MovieTrackingMarkers::delete_frame(int frame) {
		MovieTrackingMarkers_delete_frame_func((::MovieTrackingTrack *) this->ptr.data, frame);
	}


	POINTER_PROPERTY(Struct, MovieTrackingPlaneMarker, rna_type)
	INT_PROPERTY(MovieTrackingPlaneMarker, frame)
	FLOAT_ARRAY_PROPERTY(MovieTrackingPlaneMarker, 8, corners)
	BOOLEAN_PROPERTY(MovieTrackingPlaneMarker, mute)


	POINTER_PROPERTY(Struct, MovieTrackingPlaneTrack, rna_type)
	STRING_PROPERTY(MovieTrackingPlaneTrack, name)

	BOOLEAN_PROPERTY(MovieTrackingPlaneTrack, select)
	BOOLEAN_PROPERTY(MovieTrackingPlaneTrack, use_auto_keying)
	POINTER_PROPERTY(Image, MovieTrackingPlaneTrack, image)
	FLOAT_PROPERTY(MovieTrackingPlaneTrack, image_opacity)


	POINTER_PROPERTY(Struct, MovieTrackingPlaneMarkers, rna_type)

	inline MovieTrackingPlaneMarker MovieTrackingPlaneMarkers::find_frame(int frame, bool exact) {
		PointerRNA result;
		::MovieTrackingPlaneMarker *retdata = MovieTrackingPlaneMarkers_find_frame_func((::MovieTrackingPlaneTrack *) this->ptr.data, frame, exact);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieTrackingPlaneMarker, retdata);
		return MovieTrackingPlaneMarker(result);
	}

	inline MovieTrackingPlaneMarker MovieTrackingPlaneMarkers::insert_frame(int frame) {
		PointerRNA result;
		::MovieTrackingPlaneMarker *retdata = MovieTrackingPlaneMarkers_insert_frame_func((::MovieTrackingPlaneTrack *) this->ptr.data, frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieTrackingPlaneMarker, retdata);
		return MovieTrackingPlaneMarker(result);
	}

	inline void MovieTrackingPlaneMarkers::delete_frame(int frame) {
		MovieTrackingPlaneMarkers_delete_frame_func((::MovieTrackingPlaneTrack *) this->ptr.data, frame);
	}


	POINTER_PROPERTY(Struct, MovieTrackingTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingTrack, MovieTrackingTracks, active)

	inline MovieTrackingTrack MovieTrackingTracks::create(const char * name, int frame) {
		PointerRNA result;
		::MovieTrackingTrack *retdata = MovieTrackingTracks_new_func((::ID *) ptr.owner_id, (::MovieTracking *) this->ptr.data, name, frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieTrackingTrack, retdata);
		return MovieTrackingTrack(result);
	}


	POINTER_PROPERTY(Struct, MovieTrackingPlaneTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingPlaneTrack, MovieTrackingPlaneTracks, active)


	POINTER_PROPERTY(Struct, MovieTrackingObjectTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingTrack, MovieTrackingObjectTracks, active)

	inline MovieTrackingTrack MovieTrackingObjectTracks::create(const char * name, int frame) {
		PointerRNA result;
		::MovieTrackingTrack *retdata = MovieTrackingObjectTracks_new_func((::ID *) ptr.owner_id, (::MovieTrackingObject *) this->ptr.data, name, frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieTrackingTrack, retdata);
		return MovieTrackingTrack(result);
	}


	POINTER_PROPERTY(Struct, MovieTrackingObjectPlaneTracks, rna_type)
	POINTER_PROPERTY(MovieTrackingTrack, MovieTrackingObjectPlaneTracks, active)


	POINTER_PROPERTY(Struct, MovieTrackingStabilization, rna_type)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_2d_stabilization)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_stabilize_rotation)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_stabilize_scale)

	INT_PROPERTY(MovieTrackingStabilization, active_track_index)

	INT_PROPERTY(MovieTrackingStabilization, active_rotation_track_index)
	INT_PROPERTY(MovieTrackingStabilization, anchor_frame)
	FLOAT_ARRAY_PROPERTY(MovieTrackingStabilization, 2, target_position)
	FLOAT_PROPERTY(MovieTrackingStabilization, target_rotation)
	FLOAT_PROPERTY(MovieTrackingStabilization, target_scale)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, use_autoscale)
	FLOAT_PROPERTY(MovieTrackingStabilization, scale_max)
	FLOAT_PROPERTY(MovieTrackingStabilization, influence_location)
	FLOAT_PROPERTY(MovieTrackingStabilization, influence_scale)
	FLOAT_PROPERTY(MovieTrackingStabilization, influence_rotation)
	ENUM_PROPERTY(filter_type_enum, MovieTrackingStabilization, filter_type)
	BOOLEAN_PROPERTY(MovieTrackingStabilization, show_tracks_expanded)


	POINTER_PROPERTY(Struct, MovieTrackingReconstructedCameras, rna_type)

	inline MovieReconstructedCamera MovieTrackingReconstructedCameras::find_frame(int frame) {
		PointerRNA result;
		::MovieReconstructedCamera *retdata = MovieTrackingReconstructedCameras_find_frame_func((::ID *) ptr.owner_id, (::MovieTrackingReconstruction *) this->ptr.data, frame);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieReconstructedCamera, retdata);
		return MovieReconstructedCamera(result);
	}

	inline void MovieTrackingReconstructedCameras::matrix_from_frame(int frame, float matrix[16]) {
		MovieTrackingReconstructedCameras_matrix_from_frame_func((::ID *) ptr.owner_id, (::MovieTrackingReconstruction *) this->ptr.data, frame, matrix);
	}


	POINTER_PROPERTY(Struct, MovieReconstructedCamera, rna_type)
	INT_PROPERTY(MovieReconstructedCamera, frame)
	FLOAT_ARRAY_PROPERTY(MovieReconstructedCamera, 16, matrix)
	FLOAT_PROPERTY(MovieReconstructedCamera, average_error)


	POINTER_PROPERTY(Struct, MovieTrackingReconstruction, rna_type)
	BOOLEAN_PROPERTY(MovieTrackingReconstruction, is_valid)
	FLOAT_PROPERTY(MovieTrackingReconstruction, average_error)



	POINTER_PROPERTY(Struct, MovieTrackingObject, rna_type)
	STRING_PROPERTY(MovieTrackingObject, name)
	BOOLEAN_PROPERTY(MovieTrackingObject, is_camera)


	POINTER_PROPERTY(MovieTrackingReconstruction, MovieTrackingObject, reconstruction)
	FLOAT_PROPERTY(MovieTrackingObject, scale)
	INT_PROPERTY(MovieTrackingObject, keyframe_a)
	INT_PROPERTY(MovieTrackingObject, keyframe_b)


	POINTER_PROPERTY(Struct, MovieTrackingDopesheet, rna_type)
	ENUM_PROPERTY(sort_method_enum, MovieTrackingDopesheet, sort_method)
	BOOLEAN_PROPERTY(MovieTrackingDopesheet, use_invert_sort)
	BOOLEAN_PROPERTY(MovieTrackingDopesheet, show_only_selected)
	BOOLEAN_PROPERTY(MovieTrackingDopesheet, show_hidden)


	POINTER_PROPERTY(Struct, MovieTracking, rna_type)
	POINTER_PROPERTY(MovieTrackingSettings, MovieTracking, settings)
	POINTER_PROPERTY(MovieTrackingCamera, MovieTracking, camera)


	POINTER_PROPERTY(MovieTrackingStabilization, MovieTracking, stabilization)
	POINTER_PROPERTY(MovieTrackingReconstruction, MovieTracking, reconstruction)

	INT_PROPERTY(MovieTracking, active_object_index)
	POINTER_PROPERTY(MovieTrackingDopesheet, MovieTracking, dopesheet)


	POINTER_PROPERTY(Struct, MovieTrackingObjects, rna_type)
	POINTER_PROPERTY(MovieTrackingObject, MovieTrackingObjects, active)

	inline MovieTrackingObject MovieTrackingObjects::create(const char * name) {
		PointerRNA result;
		::MovieTrackingObject *retdata = MovieTrackingObjects_new_func((::MovieTracking *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MovieTrackingObject, retdata);
		return MovieTrackingObject(result);
	}

	inline void MovieTrackingObjects::remove(MovieTrackingObject& object) {
		MovieTrackingObjects_remove_func((::MovieTracking *) this->ptr.data, nullptr, (::PointerRNA *) &object.ptr);
	}


	POINTER_PROPERTY(Struct, MaskParent, rna_type)
	POINTER_PROPERTY(ID, MaskParent, id)
	ENUM_PROPERTY(id_type_enum, MaskParent, id_type)
	ENUM_PROPERTY(type_enum, MaskParent, type)
	STRING_PROPERTY(MaskParent, parent)
	STRING_PROPERTY(MaskParent, sub_parent)


	POINTER_PROPERTY(Struct, MaskSplinePointUW, rna_type)
	FLOAT_PROPERTY(MaskSplinePointUW, u)
	FLOAT_PROPERTY(MaskSplinePointUW, weight)
	BOOLEAN_PROPERTY(MaskSplinePointUW, select)


	POINTER_PROPERTY(Struct, MaskSplinePoint, rna_type)
	FLOAT_ARRAY_PROPERTY(MaskSplinePoint, 2, handle_left)
	FLOAT_ARRAY_PROPERTY(MaskSplinePoint, 2, co)
	FLOAT_ARRAY_PROPERTY(MaskSplinePoint, 2, handle_right)
	ENUM_PROPERTY(handle_type_enum, MaskSplinePoint, handle_type)
	ENUM_PROPERTY(handle_left_type_enum, MaskSplinePoint, handle_left_type)
	ENUM_PROPERTY(handle_right_type_enum, MaskSplinePoint, handle_right_type)
	FLOAT_PROPERTY(MaskSplinePoint, weight)
	BOOLEAN_PROPERTY(MaskSplinePoint, select)
	POINTER_PROPERTY(MaskParent, MaskSplinePoint, parent)



	POINTER_PROPERTY(Struct, MaskSpline, rna_type)
	ENUM_PROPERTY(offset_mode_enum, MaskSpline, offset_mode)
	ENUM_PROPERTY(weight_interpolation_enum, MaskSpline, weight_interpolation)
	BOOLEAN_PROPERTY(MaskSpline, use_cyclic)
	BOOLEAN_PROPERTY(MaskSpline, use_fill)
	BOOLEAN_PROPERTY(MaskSpline, use_self_intersection_check)



	POINTER_PROPERTY(Struct, MaskSplines, rna_type)
	POINTER_PROPERTY(MaskSpline, MaskSplines, active)
	POINTER_PROPERTY(MaskSplinePoint, MaskSplines, active_point)

	inline MaskSpline MaskSplines::create() {
		PointerRNA result;
		::MaskSpline *retdata = MaskSplines_new_func((::ID *) ptr.owner_id, (::MaskLayer *) this->ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MaskSpline, retdata);
		return MaskSpline(result);
	}

	inline void MaskSplines::remove(MaskSpline& spline) {
		MaskSplines_remove_func((::ID *) ptr.owner_id, (::MaskLayer *) this->ptr.data, nullptr, (::PointerRNA *) &spline.ptr);
	}


	POINTER_PROPERTY(Struct, MaskSplinePoints, rna_type)

	inline void MaskSplinePoints::add(int count) {
		MaskSplinePoints_add_func((::ID *) ptr.owner_id, (::MaskSpline *) this->ptr.data, count);
	}

	inline void MaskSplinePoints::remove(MaskSplinePoint& point) {
		MaskSplinePoints_remove_func((::ID *) ptr.owner_id, (::MaskSpline *) this->ptr.data, nullptr, (::PointerRNA *) &point.ptr);
	}


	POINTER_PROPERTY(Struct, MaskLayer, rna_type)
	STRING_PROPERTY(MaskLayer, name)

	BOOLEAN_PROPERTY(MaskLayer, hide)
	BOOLEAN_PROPERTY(MaskLayer, hide_select)
	BOOLEAN_PROPERTY(MaskLayer, hide_render)
	BOOLEAN_PROPERTY(MaskLayer, select)
	FLOAT_PROPERTY(MaskLayer, alpha)
	ENUM_PROPERTY(blend_enum, MaskLayer, blend)
	BOOLEAN_PROPERTY(MaskLayer, invert)
	ENUM_PROPERTY(falloff_enum, MaskLayer, falloff)
	BOOLEAN_PROPERTY(MaskLayer, use_fill_holes)
	BOOLEAN_PROPERTY(MaskLayer, use_fill_overlap)



	INT_PROPERTY(Mask, active_layer_index)
	INT_PROPERTY(Mask, frame_start)
	INT_PROPERTY(Mask, frame_end)
	POINTER_PROPERTY(AnimData, Mask, animation_data)


	POINTER_PROPERTY(Struct, MaskLayers, rna_type)
	POINTER_PROPERTY(MaskLayer, MaskLayers, active)

	inline MaskLayer MaskLayers::create(const char * name) {
		PointerRNA result;
		::MaskLayer *retdata = MaskLayers_new_func((::Mask *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_MaskLayer, retdata);
		return MaskLayer(result);
	}

	inline void MaskLayers::remove(MaskLayer& layer) {
		MaskLayers_remove_func((::Mask *) this->ptr.data, nullptr, (::PointerRNA *) &layer.ptr);
	}

	inline void MaskLayers::clear() {
		MaskLayers_clear_func((::Mask *) this->ptr.data);
	}


	POINTER_PROPERTY(Struct, XrActionMap, rna_type)
	STRING_PROPERTY(XrActionMap, name)

	INT_PROPERTY(XrActionMap, selected_item)


	POINTER_PROPERTY(Struct, XrActionMapItems, rna_type)

	inline XrActionMapItem XrActionMapItems::create(const char * name, bool replace_existing) {
		PointerRNA result;
		::XrActionMapItem *retdata = XrActionMapItems_new_func((::XrActionMap *) this->ptr.data, name, replace_existing);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMapItem, retdata);
		return XrActionMapItem(result);
	}

	inline XrActionMapItem XrActionMapItems::new_from_item(XrActionMapItem& item) {
		PointerRNA result;
		::XrActionMapItem *retdata = XrActionMapItems_new_from_item_func((::XrActionMap *) this->ptr.data, (::XrActionMapItem *) item.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMapItem, retdata);
		return XrActionMapItem(result);
	}

	inline void XrActionMapItems::remove(XrActionMapItem& item) {
		XrActionMapItems_remove_func((::XrActionMap *) this->ptr.data, nullptr, (::PointerRNA *) &item.ptr);
	}

	inline XrActionMapItem XrActionMapItems::find(const char * name) {
		PointerRNA result;
		::XrActionMapItem *retdata = XrActionMapItems_find_func((::XrActionMap *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMapItem, retdata);
		return XrActionMapItem(result);
	}


	POINTER_PROPERTY(Struct, XrUserPath, rna_type)
	STRING_PROPERTY(XrUserPath, path)


	POINTER_PROPERTY(Struct, XrActionMapItem, rna_type)
	STRING_PROPERTY(XrActionMapItem, name)
	ENUM_PROPERTY(type_enum, XrActionMapItem, type)

	STRING_PROPERTY(XrActionMapItem, op)
	STRING_PROPERTY(XrActionMapItem, op_name)
	POINTER_PROPERTY(OperatorProperties, XrActionMapItem, op_properties)
	ENUM_PROPERTY(op_mode_enum, XrActionMapItem, op_mode)
	BOOLEAN_PROPERTY(XrActionMapItem, bimanual)
	BOOLEAN_PROPERTY(XrActionMapItem, pose_is_controller_grip)
	BOOLEAN_PROPERTY(XrActionMapItem, pose_is_controller_aim)
	STRING_PROPERTY(XrActionMapItem, haptic_name)
	BOOLEAN_PROPERTY(XrActionMapItem, haptic_match_user_paths)
	FLOAT_PROPERTY(XrActionMapItem, haptic_duration)
	FLOAT_PROPERTY(XrActionMapItem, haptic_frequency)
	FLOAT_PROPERTY(XrActionMapItem, haptic_amplitude)
	ENUM_PROPERTY(haptic_mode_enum, XrActionMapItem, haptic_mode)

	INT_PROPERTY(XrActionMapItem, selected_binding)


	POINTER_PROPERTY(Struct, XrUserPaths, rna_type)

	inline XrUserPath XrUserPaths::create(const char * path) {
		PointerRNA result;
		::XrUserPath *retdata = XrUserPaths_new_func((::XrActionMapItem *) this->ptr.data, path);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrUserPath, retdata);
		return XrUserPath(result);
	}

	inline void XrUserPaths::remove(XrUserPath& user_path) {
		XrUserPaths_remove_func((::XrActionMapItem *) this->ptr.data, (::PointerRNA *) &user_path.ptr);
	}

	inline XrUserPath XrUserPaths::find(const char * path) {
		PointerRNA result;
		::XrUserPath *retdata = XrUserPaths_find_func((::XrActionMapItem *) this->ptr.data, path);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrUserPath, retdata);
		return XrUserPath(result);
	}


	POINTER_PROPERTY(Struct, XrActionMapBindings, rna_type)

	inline XrActionMapBinding XrActionMapBindings::create(const char * name, bool replace_existing) {
		PointerRNA result;
		::XrActionMapBinding *retdata = XrActionMapBindings_new_func((::XrActionMapItem *) this->ptr.data, name, replace_existing);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMapBinding, retdata);
		return XrActionMapBinding(result);
	}

	inline XrActionMapBinding XrActionMapBindings::new_from_binding(XrActionMapBinding& binding) {
		PointerRNA result;
		::XrActionMapBinding *retdata = XrActionMapBindings_new_from_binding_func((::XrActionMapItem *) this->ptr.data, (::XrActionMapBinding *) binding.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMapBinding, retdata);
		return XrActionMapBinding(result);
	}

	inline void XrActionMapBindings::remove(XrActionMapBinding& binding) {
		XrActionMapBindings_remove_func((::XrActionMapItem *) this->ptr.data, nullptr, (::PointerRNA *) &binding.ptr);
	}

	inline XrActionMapBinding XrActionMapBindings::find(const char * name) {
		PointerRNA result;
		::XrActionMapBinding *retdata = XrActionMapBindings_find_func((::XrActionMapItem *) this->ptr.data, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMapBinding, retdata);
		return XrActionMapBinding(result);
	}


	POINTER_PROPERTY(Struct, XrComponentPath, rna_type)
	STRING_PROPERTY(XrComponentPath, path)


	POINTER_PROPERTY(Struct, XrActionMapBinding, rna_type)
	STRING_PROPERTY(XrActionMapBinding, name)
	STRING_PROPERTY(XrActionMapBinding, profile)

	FLOAT_PROPERTY(XrActionMapBinding, threshold)
	ENUM_PROPERTY(axis0_region_enum, XrActionMapBinding, axis0_region)
	ENUM_PROPERTY(axis1_region_enum, XrActionMapBinding, axis1_region)
	FLOAT_ARRAY_PROPERTY(XrActionMapBinding, 3, pose_location)
	FLOAT_ARRAY_PROPERTY(XrActionMapBinding, 3, pose_rotation)


	POINTER_PROPERTY(Struct, XrComponentPaths, rna_type)

	inline XrComponentPath XrComponentPaths::create(const char * path) {
		PointerRNA result;
		::XrComponentPath *retdata = XrComponentPaths_new_func((::XrActionMapBinding *) this->ptr.data, path);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrComponentPath, retdata);
		return XrComponentPath(result);
	}

	inline void XrComponentPaths::remove(XrComponentPath& component_path) {
		XrComponentPaths_remove_func((::XrActionMapBinding *) this->ptr.data, (::PointerRNA *) &component_path.ptr);
	}

	inline XrComponentPath XrComponentPaths::find(const char * path) {
		PointerRNA result;
		::XrComponentPath *retdata = XrComponentPaths_find_func((::XrActionMapBinding *) this->ptr.data, path);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrComponentPath, retdata);
		return XrComponentPath(result);
	}


	POINTER_PROPERTY(Struct, XrSessionSettings, rna_type)
	POINTER_PROPERTY(View3DShading, XrSessionSettings, shading)
	ENUM_PROPERTY(base_pose_type_enum, XrSessionSettings, base_pose_type)
	POINTER_PROPERTY(Object, XrSessionSettings, base_pose_object)
	FLOAT_ARRAY_PROPERTY(XrSessionSettings, 3, base_pose_location)
	FLOAT_PROPERTY(XrSessionSettings, base_pose_angle)
	FLOAT_PROPERTY(XrSessionSettings, base_scale)
	BOOLEAN_PROPERTY(XrSessionSettings, show_floor)
	BOOLEAN_PROPERTY(XrSessionSettings, show_annotation)
	BOOLEAN_PROPERTY(XrSessionSettings, show_selection)
	BOOLEAN_PROPERTY(XrSessionSettings, show_controllers)
	BOOLEAN_PROPERTY(XrSessionSettings, show_custom_overlays)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_extras)
	ENUM_PROPERTY(controller_draw_style_enum, XrSessionSettings, controller_draw_style)
	FLOAT_PROPERTY(XrSessionSettings, clip_start)
	FLOAT_PROPERTY(XrSessionSettings, clip_end)
	BOOLEAN_PROPERTY(XrSessionSettings, use_positional_tracking)
	BOOLEAN_PROPERTY(XrSessionSettings, use_absolute_tracking)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_mesh)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_curve)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_surf)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_meta)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_font)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_curves)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_pointcloud)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_volume)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_armature)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_lattice)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_empty)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_grease_pencil)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_camera)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_light)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_speaker)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_viewport_light_probe)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_mesh)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_curve)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_surf)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_meta)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_font)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_curves)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_pointcloud)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_volume)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_armature)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_lattice)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_empty)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_grease_pencil)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_camera)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_light)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_speaker)
	BOOLEAN_PROPERTY(XrSessionSettings, show_object_select_light_probe)
	INT_PROPERTY(XrSessionSettings, icon_from_show_object_viewport)


	POINTER_PROPERTY(Struct, XrSessionState, rna_type)
	FLOAT_ARRAY_PROPERTY(XrSessionState, 3, viewer_pose_location)
	FLOAT_ARRAY_PROPERTY(XrSessionState, 4, viewer_pose_rotation)
	FLOAT_ARRAY_PROPERTY(XrSessionState, 3, navigation_location)
	FLOAT_ARRAY_PROPERTY(XrSessionState, 4, navigation_rotation)
	FLOAT_PROPERTY(XrSessionState, navigation_scale)

	INT_PROPERTY(XrSessionState, active_actionmap)
	INT_PROPERTY(XrSessionState, selected_actionmap)

	inline bool XrSessionState::is_running(Context& context) {
		return XrSessionState_is_running_func((::bContext *) context.ptr.data);
	}

	inline void XrSessionState::reset_to_base_pose(Context& context) {
		XrSessionState_reset_to_base_pose_func((::bContext *) context.ptr.data);
	}

	inline bool XrSessionState::action_set_create(Context& context, XrActionMap& actionmap) {
		return XrSessionState_action_set_create_func((::bContext *) context.ptr.data, (::XrActionMap *) actionmap.ptr.data);
	}

	inline bool XrSessionState::action_create(Context& context, XrActionMap& actionmap, XrActionMapItem& actionmap_item) {
		return XrSessionState_action_create_func((::bContext *) context.ptr.data, (::XrActionMap *) actionmap.ptr.data, (::XrActionMapItem *) actionmap_item.ptr.data);
	}

	inline bool XrSessionState::action_binding_create(Context& context, XrActionMap& actionmap, XrActionMapItem& actionmap_item, XrActionMapBinding& actionmap_binding) {
		return XrSessionState_action_binding_create_func((::bContext *) context.ptr.data, (::XrActionMap *) actionmap.ptr.data, (::XrActionMapItem *) actionmap_item.ptr.data, (::XrActionMapBinding *) actionmap_binding.ptr.data);
	}

	inline bool XrSessionState::active_action_set_set(Context& context, const char * action_set) {
		return XrSessionState_active_action_set_set_func((::bContext *) context.ptr.data, action_set);
	}

	inline bool XrSessionState::controller_pose_actions_set(Context& context, const char * action_set, const char * grip_action, const char * aim_action) {
		return XrSessionState_controller_pose_actions_set_func((::bContext *) context.ptr.data, action_set, grip_action, aim_action);
	}

	inline void XrSessionState::action_state_get(Context& context, const char * action_set_name, const char * action_name, const char * user_path, float state[2]) {
		XrSessionState_action_state_get_func((::bContext *) context.ptr.data, action_set_name, action_name, user_path, state);
	}

	inline bool XrSessionState::haptic_action_apply(Context& context, const char * action_set_name, const char * action_name, const char * user_path, float duration, float frequency, float amplitude) {
		return XrSessionState_haptic_action_apply_func((::bContext *) context.ptr.data, action_set_name, action_name, user_path, duration, frequency, amplitude);
	}

	inline void XrSessionState::haptic_action_stop(Context& context, const char * action_set_name, const char * action_name, const char * user_path) {
		XrSessionState_haptic_action_stop_func((::bContext *) context.ptr.data, action_set_name, action_name, user_path);
	}

	inline void XrSessionState::controller_grip_location_get(Context& context, int index, float location[3]) {
		XrSessionState_controller_grip_location_get_func((::bContext *) context.ptr.data, index, location);
	}

	inline void XrSessionState::controller_grip_rotation_get(Context& context, int index, float rotation[4]) {
		XrSessionState_controller_grip_rotation_get_func((::bContext *) context.ptr.data, index, rotation);
	}

	inline void XrSessionState::controller_aim_location_get(Context& context, int index, float location[3]) {
		XrSessionState_controller_aim_location_get_func((::bContext *) context.ptr.data, index, location);
	}

	inline void XrSessionState::controller_aim_rotation_get(Context& context, int index, float rotation[4]) {
		XrSessionState_controller_aim_rotation_get_func((::bContext *) context.ptr.data, index, rotation);
	}


	POINTER_PROPERTY(Struct, XrActionMaps, rna_type)

	inline XrActionMap XrActionMaps::create(XrSessionState& xr_session_state, const char * name, bool replace_existing) {
		PointerRNA result;
		::XrActionMap *retdata = XrActionMaps_new_func((::PointerRNA *) &xr_session_state, name, replace_existing);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMap, retdata);
		return XrActionMap(result);
	}

	inline XrActionMap XrActionMaps::new_from_actionmap(XrSessionState& xr_session_state, XrActionMap& actionmap) {
		PointerRNA result;
		::XrActionMap *retdata = XrActionMaps_new_from_actionmap_func((::PointerRNA *) &xr_session_state, (::XrActionMap *) actionmap.ptr.data);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMap, retdata);
		return XrActionMap(result);
	}

	inline void XrActionMaps::remove(XrSessionState& xr_session_state, XrActionMap& actionmap) {
		XrActionMaps_remove_func(nullptr, (::PointerRNA *) &xr_session_state, (::PointerRNA *) &actionmap.ptr);
	}

	inline XrActionMap XrActionMaps::find(XrSessionState& xr_session_state, const char * name) {
		PointerRNA result;
		::XrActionMap *retdata = XrActionMaps_find_func((::PointerRNA *) &xr_session_state, name);
		result = RNA_pointer_create((::ID *) ptr.owner_id, &RNA_XrActionMap, retdata);
		return XrActionMap(result);
	}


	POINTER_PROPERTY(Struct, XrEventData, rna_type)
	STRING_PROPERTY(XrEventData, action_set)
	STRING_PROPERTY(XrEventData, action)
	STRING_PROPERTY(XrEventData, user_path)
	STRING_PROPERTY(XrEventData, user_path_other)
	ENUM_PROPERTY(type_enum, XrEventData, type)
	FLOAT_ARRAY_PROPERTY(XrEventData, 2, state)
	FLOAT_ARRAY_PROPERTY(XrEventData, 2, state_other)
	FLOAT_PROPERTY(XrEventData, float_threshold)
	FLOAT_ARRAY_PROPERTY(XrEventData, 3, controller_location)
	FLOAT_ARRAY_PROPERTY(XrEventData, 4, controller_rotation)
	FLOAT_ARRAY_PROPERTY(XrEventData, 3, controller_location_other)
	FLOAT_ARRAY_PROPERTY(XrEventData, 4, controller_rotation_other)
	BOOLEAN_PROPERTY(XrEventData, bimanual)


}

#endif /* __RNA_BLENDER_CPP_H__ */

